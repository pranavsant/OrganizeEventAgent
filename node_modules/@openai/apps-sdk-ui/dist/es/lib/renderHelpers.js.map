{"version":3,"file":"renderHelpers.js","sourceRoot":"","sources":["../../../src/lib/renderHelpers.tsx"],"names":[],"mappings":";AAAA,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE,cAAc,EAAqC,MAAM,OAAO,CAAA;AAEjG,MAAM,gBAAgB,GAAG,CAAC,QAAmB,EAAe,EAAE;IAC5D,MAAM,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAA;IACxC,MAAM,MAAM,GAAgB,EAAE,CAAA;IAC9B,IAAI,MAAM,GAAG,EAAE,CAAA;IAEf,MAAM,KAAK,GAAG,GAAG,EAAE;QACjB,IAAI,MAAM,KAAK,EAAE,EAAE,CAAC;YAClB,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;YACnB,MAAM,GAAG,EAAE,CAAA;QACb,CAAC;IACH,CAAC,CAAA;IAED,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;QACzB,IAAI,IAAI,IAAI,IAAI,IAAI,OAAO,IAAI,KAAK,SAAS,EAAE,CAAC;YAC9C,SAAQ;QACV,CAAC;QAED,IAAI,OAAO,IAAI,KAAK,QAAQ,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE,CAAC;YACzD,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,CAAA;YACtB,SAAQ;QACV,CAAC;QAED,mEAAmE;QACnE,KAAK,EAAE,CAAA;QACP,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;IACnB,CAAC;IAED,KAAK,EAAE,CAAA;IACP,OAAO,MAAM,CAAA;AACf,CAAC,CAAA;AAED,gEAAgE;AAChE,+EAA+E;AAC/E,MAAM,CAAC,MAAM,oBAAoB,GAAG,CAAC,QAAmB,EAAa,EAAE;IACrE,MAAM,iBAAiB,GAAG,gBAAgB,CAAC,QAAQ,CAAC,CAAA;IACpD,MAAM,aAAa,GAAG,QAAQ,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAA;IAEvD,OAAO,QAAQ,CAAC,GAAG,CAAC,iBAAiB,EAAE,CAAC,KAAK,EAAE,EAAE;QAC/C,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE,CAAC;YAChD,mDAAmD;YACnD,IAAI,aAAa,IAAI,CAAC,EAAE,CAAC;gBACvB,OAAO,KAAK,CAAA;YACd,CAAC;YAED,qCAAqC;YACrC,OAAO,yBAAO,KAAK,GAAQ,CAAA;QAC7B,CAAC;QAED,qEAAqE;QACrE,IAAI,cAAc,CAAC,KAAK,CAAC,EAAE,CAAC;YAC1B,MAAM,OAAO,GAAG,KAA+C,CAAA;YAC/D,MAAM,EAAE,QAAQ,EAAE,aAAa,EAAE,GAAG,SAAS,EAAE,GAAG,OAAO,CAAC,KAAK,CAAA;YAE/D,IAAI,aAAa,IAAI,IAAI,EAAE,CAAC;gBAC1B,OAAO,YAAY,CAAC,OAAO,EAAE,SAAS,EAAE,oBAAoB,CAAC,aAAa,CAAC,CAAC,CAAA;YAC9E,CAAC;YAED,OAAO,OAAO,CAAA;QAChB,CAAC;QAED,OAAO,KAAK,CAAA;IACd,CAAC,CAAC,CAAA;AACJ,CAAC,CAAA","sourcesContent":["import { Children, cloneElement, isValidElement, type ReactElement, type ReactNode } from \"react\"\n\nconst flattenTextNodes = (children: ReactNode): ReactNode[] => {\n  const nodes = Children.toArray(children)\n  const result: ReactNode[] = []\n  let buffer = \"\"\n\n  const flush = () => {\n    if (buffer !== \"\") {\n      result.push(buffer)\n      buffer = \"\"\n    }\n  }\n\n  for (const node of nodes) {\n    if (node == null || typeof node === \"boolean\") {\n      continue\n    }\n\n    if (typeof node === \"string\" || typeof node === \"number\") {\n      buffer += String(node)\n      continue\n    }\n\n    // Boundary encountered: output any accumulated text, then the node\n    flush()\n    result.push(node)\n  }\n\n  flush()\n  return result\n}\n\n// Helper to wrap text node siblings of other elements in a tag,\n// which enables sibling selectors to behave as expected for certain conditions\nexport const wrapTextNodeSiblings = (children: ReactNode): ReactNode => {\n  const flattenedChildren = flattenTextNodes(children)\n  const childrenCount = Children.count(flattenedChildren)\n\n  return Children.map(flattenedChildren, (child) => {\n    if (typeof child === \"string\" && !!child.trim()) {\n      // Children with no siblings can immediately return\n      if (childrenCount <= 1) {\n        return child\n      }\n\n      // Wrap text nodes that have siblings\n      return <span>{child}</span>\n    }\n\n    // For valid elements, recursively render to capture wrapped children\n    if (isValidElement(child)) {\n      const element = child as ReactElement<{ children?: ReactNode }>\n      const { children: innerChildren, ...restProps } = element.props\n\n      if (innerChildren != null) {\n        return cloneElement(element, restProps, wrapTextNodeSiblings(innerChildren))\n      }\n\n      return element\n    }\n\n    return child\n  })\n}\n"]}