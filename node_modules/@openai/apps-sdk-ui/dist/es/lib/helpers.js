import {} from "react";
import { canUseDOM, hasDocument, hasWindow } from "./environment";
export const prefersReducedMotion = () => {
    if (!hasWindow || typeof window.matchMedia !== "function") {
        return false;
    }
    return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
};
export const handlePressableMouseEnter = (evt) => {
    const target = evt.currentTarget;
    // Safely coerce type to HTMLElement so TS is peaceful with `evt.target`
    if (!(target instanceof HTMLElement)) {
        return;
    }
    const elementWidth = target.offsetWidth;
    let scale = 0.985;
    if (elementWidth <= 80) {
        scale = 0.96;
    }
    else if (elementWidth <= 150) {
        scale = 0.97;
    }
    else if (elementWidth <= 220) {
        scale = 0.98;
    }
    else if (elementWidth > 600) {
        scale = 0.995;
    }
    target.style.setProperty("--scale", scale.toString());
};
export const waitForAnimationFrame = (cb, options) => {
    const runAfterTick = () => {
        const id = setTimeout(cb);
        return () => {
            clearTimeout(id);
        };
    };
    if (!canUseDOM || typeof window.requestAnimationFrame !== "function") {
        return runAfterTick();
    }
    const visibilityHidden = hasDocument && document.visibilityState === "hidden";
    if (visibilityHidden) {
        return runAfterTick();
    }
    let frames = options?.frames ?? 2;
    let animationFrame = window.requestAnimationFrame(function recurse() {
        frames -= 1;
        if (frames === 0) {
            cb();
        }
        else {
            animationFrame = window.requestAnimationFrame(recurse);
        }
    });
    return () => {
        if (typeof window.cancelAnimationFrame === "function") {
            window.cancelAnimationFrame(animationFrame);
        }
    };
};
export const toCssVariables = (variables) => {
    const formattedVariables = Object.keys(variables).reduce((acc, variable) => {
        // Ensure value is truthy
        const value = variables[variable];
        // Accept 0 as a valid value
        if (value || value === 0) {
            // Add the prefix if it wasn't already provided
            const prefix = variable.startsWith("--") ? "" : "--";
            const formattedValue = typeof value === "number" ? `${value}px` : value;
            acc[`${prefix}${variable}`] = formattedValue;
        }
        return acc;
    }, {});
    // Safe casting because we know we've formatted an object of CSS Variable strings
    return formattedVariables;
};
export const toAngle = (value) => typeof value === "number" ? `${value}deg` : value;
export const toOpacityProperty = (opacity) => String(opacity);
export const toMsDurationProperty = (duration) => `${duration}ms`;
export const toTransformProperty = ({ x, y, scale, rotate, skewX, skewY, } = {}) => {
    const transforms = [
        x == null ? null : `translateX(${x}px)`,
        y == null ? null : `translateY(${y}px)`,
        scale == null ? null : `scale(${scale})`,
        rotate == null ? null : `rotate(${toAngle(rotate)})`,
        skewX == null ? null : `skewX(${toAngle(skewX)})`,
        skewY == null ? null : `skewY(${toAngle(skewY)})`,
    ].filter(Boolean);
    return transforms.length ? transforms.join(" ") : "none";
};
export const toFilterProperty = ({ blur } = {}) => {
    // Maybe add more support in the future
    const filters = [blur == null ? null : `blur(${blur}px)`].filter(Boolean);
    return filters.length ? filters.join(" ") : "none";
};
export const preventDefaultHandler = (evt) => {
    evt.preventDefault();
};
/*
 * Intentionally simple selector string. Purposeful exclusions: (for now)
 * - select, because our selects are better recognized as button
 * - unused selectors like iframe, object, .etc.
 * - states like [inert]
 */
export const focusableElements = (element) => element.querySelectorAll('a[href], input:not([disabled]):not([type="hidden"]), textarea:not([disabled]), button:not([disabled]), [tabindex]:not([tabindex^="-"]), [contenteditable]');
export const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
/**
 * Group an array of objects by a property, preserving the *first-seen* order
 * of each group.
 *
 * @example
 * groupByOrdered(people, "team")
 * // => [ { team: "infra", items:[...] }, { team:"design", items:[...] }, ... ]
 */
export function groupByProperty(items, key, format = (raw) => raw) {
    const groups = [];
    const indexMap = new Map(); // maps group value -> index in groups array
    for (const item of items) {
        const value = format(item[key], item);
        // Add to existing group
        const existing = indexMap.get(value);
        if (existing !== undefined) {
            groups[existing].items.push(item);
            continue;
        }
        // Create new group
        const group = { [key]: value, items: [item] };
        indexMap.set(value, groups.length);
        groups.push(group);
    }
    return groups;
}
//# sourceMappingURL=helpers.js.map