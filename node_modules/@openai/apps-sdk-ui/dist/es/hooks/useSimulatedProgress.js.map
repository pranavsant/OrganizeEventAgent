{"version":3,"file":"useSimulatedProgress.js","sourceRoot":"","sources":["../../../src/hooks/useSimulatedProgress.tsx"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,OAAO,CAAA;AAChC,OAAO,EAAE,WAAW,EAAE,MAAM,aAAa,CAAA;AAEzC;;;;;;;GAOG;AACH,MAAM,UAAU,oBAAoB,CAAC,OAAe,EAAE,WAAmB;IACvE,aAAa;IACb,MAAM,KAAK,GAAG,IAAI,CAAA,CAAC,kDAAkD;IACrE,MAAM,EAAE,GAAG,EAAE,CAAA,CAAC,0CAA0C;IACxD,MAAM,WAAW,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,OAAO,CAAA,CAAC,8BAA8B;IACtE,MAAM,EAAE,GAAG,EAAE,GAAG,WAAW,CAAA,CAAC,gCAAgC;IAE5D,IAAI,UAAU,CAAA;IAEd,IAAI,WAAW,IAAI,EAAE,EAAE,CAAC;QACtB,4EAA4E;QAC5E,UAAU,GAAG,WAAW,GAAG,WAAW,CAAA;IACxC,CAAC;SAAM,CAAC;QACN,sDAAsD;QACtD,MAAM,CAAC,GAAG,CAAC,CAAA,CAAC,iDAAiD;QAC7D,MAAM,aAAa,GAAG,OAAO,GAAG,EAAE,CAAA;QAClC,MAAM,WAAW,GAAG,WAAW,GAAG,EAAE,CAAA;QACpC,MAAM,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC,WAAW,GAAG,aAAa,CAAC,CAAA;QACnD,UAAU,GAAG,EAAE,GAAG,CAAC,KAAK,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAA;IAC3D,CAAC;IAED,8CAA8C;IAC9C,OAAO,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC,CAAA;AACpC,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,CAAC,MAAM,oBAAoB,GAAG,CAAC,OAAe,EAAE,WAAmB,EAAE,SAAmB,EAAE,EAAE;IAChG,MAAM,gBAAgB,GAAG,CAAC,IAAI,IAAI,EAAE,GAAG,OAAO,CAAA;IAC9C,MAAM,CAAC,QAAQ,EAAE,WAAW,CAAC,GAAG,QAAQ,CAAC,oBAAoB,CAAC,WAAW,EAAE,gBAAgB,CAAC,CAAC,CAAA;IAE7F,MAAM,iBAAiB,GAAG,GAAG,EAAE;QAC7B,MAAM,WAAW,GAAG,CAAC,IAAI,IAAI,EAAE,GAAG,OAAO,CAAA;QACzC,MAAM,WAAW,GACf,WAAW,IAAI,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,oBAAoB,CAAC,WAAW,EAAE,WAAW,CAAC,CAAA;QACnF,WAAW,CAAC,WAAW,CAAC,CAAA;IAC1B,CAAC,CAAA;IAED,WAAW,CAAC,iBAAiB,EAAE,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,CAAA;IAEtD,OAAO,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAA;AACnC,CAAC,CAAA","sourcesContent":["import { useState } from \"react\"\nimport { useInterval } from \"usehooks-ts\"\n\n/**\n * Deterministically returns a progress value between 0 and 100 that decays as it approaches 100,\n * based on a maximum duration and the elapsed time.\n *\n * @param maxTime - The maximum duration (in ms) after which the progress will be 100\n * @param elapsedTime - The elapsed time (in ms) since the start time\n * @returns The simulated progress percentage\n */\nexport function getSimulatedProgress(maxTime: number, elapsedTime: number) {\n  // Parameters\n  const P_max = 99.9 // Maximum percentage to approach (less than 100%)\n  const P1 = 35 // Percentage at which the rate slows down\n  const initialRate = (3 * 100) / maxTime // Initial rate (% per second)\n  const t1 = P1 / initialRate // Time when progress reaches P1\n\n  let percentage\n\n  if (elapsedTime <= t1) {\n    // **Phase 1:** Linear increase at the start to show consistency in progress\n    percentage = initialRate * elapsedTime\n  } else {\n    // **Phase 2:** Progress slows down, approaching P_max\n    const k = 4 // Controls how quickly progress approaches P_max\n    const remainingTime = maxTime - t1\n    const timeSinceT1 = elapsedTime - t1\n    const exponent = -k * (timeSinceT1 / remainingTime)\n    percentage = P1 + (P_max - P1) * (1 - Math.exp(exponent))\n  }\n\n  // Ensure the percentage does not exceed P_max\n  return Math.min(percentage, P_max)\n}\n\n/**\n * Returns a number that will increase over time, decaying as it approaches 100,\n * withouth ever reaching the end.\n *\n * @param startAt - The time at which the progress started\n * @param maxDuration - The maximum duration (in ms) after which the progress will be 100\n * @param completed - Sets progress to 100% immediately\n */\nexport const useSimulatedProgress = (startAt: number, maxDuration: number, completed?: boolean) => {\n  const elapsedStartTime = +new Date() - startAt\n  const [progress, setProgress] = useState(getSimulatedProgress(maxDuration, elapsedStartTime))\n\n  const incrementProgress = () => {\n    const elapsedTime = +new Date() - startAt\n    const newProgress =\n      elapsedTime >= maxDuration ? 100 : getSimulatedProgress(maxDuration, elapsedTime)\n    setProgress(newProgress)\n  }\n\n  useInterval(incrementProgress, completed ? null : 100)\n\n  return completed ? 100 : progress\n}\n"]}