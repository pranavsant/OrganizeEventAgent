"use client";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import clsx from "clsx";
import { ToggleGroup } from "radix-ui";
import { useCallback, useLayoutEffect, useRef } from "react";
import { useResizeObserver } from "usehooks-ts";
import { handlePressableMouseEnter, waitForAnimationFrame } from "../../lib/helpers";
import {} from "../../types";
import s from "./SegmentedControl.module.css";
export const SegmentedControl = ({ value, onChange, children, block, pill = true, size = "md", gutterSize, className, onClick, ...restProps }) => {
    const rootRef = useRef(null);
    const thumbRef = useRef(null);
    const applyThumbSizing = useCallback((attemptScroll) => {
        const root = rootRef.current;
        const thumb = thumbRef.current;
        if (!root || !thumb) {
            return;
        }
        // Get selected node
        const activeNode = root?.querySelector('[data-state="on"]');
        // Impossible
        if (!activeNode) {
            return;
        }
        const rootWidth = root.clientWidth;
        let targetWidth = Math.floor(activeNode.clientWidth);
        const targetOffset = activeNode.offsetLeft;
        // Detect if the thumb is moving too far to the edge of the container.
        // This would most commonly be due to subpixel widths adding up to excessive distance.
        if (rootWidth - (targetWidth + targetOffset) < 2) {
            targetWidth = targetWidth - 1;
        }
        thumb.style.width = `${Math.floor(targetWidth)}px`;
        thumb.style.transform = `translateX(${targetOffset}px)`;
        // If the control is scrollable, ensure the active option is visible
        if (root.scrollWidth > rootWidth) {
            // Only scroll items near the edge, but not the inner 2/3.
            const buffer = rootWidth * 0.15;
            const scrollLeft = root.scrollLeft;
            const left = activeNode.offsetLeft;
            const right = left + targetWidth;
            if (left < scrollLeft + buffer || right > scrollLeft + rootWidth - buffer) {
                // Cheap trick to avoid unintentional scroll on mount - transition is set after mounting
                if (attemptScroll) {
                    activeNode.scrollIntoView({ block: "nearest", inline: "center", behavior: "smooth" });
                }
            }
        }
    }, []);
    useResizeObserver({
        // @ts-expect-error(2322) -- bug in types: https://github.com/juliencrn/usehooks-ts/issues/663
        ref: rootRef,
        onResize: () => {
            const thumb = thumbRef.current;
            if (!thumb) {
                return;
            }
            // Perform the size update instantly
            const currentTransition = thumb.style.transition;
            thumb.style.transition = "";
            applyThumbSizing(false);
            thumb.style.transition = currentTransition;
        },
    });
    useLayoutEffect(() => {
        const root = rootRef.current;
        const thumb = thumbRef.current;
        if (!root || !thumb) {
            return;
        }
        // Cheap trick to avoid unintentional scroll on mount - transition is set after mounting
        applyThumbSizing(!!thumb.style.transition);
        // Apply transition after initial calculation is set
        if (!thumb.style.transition) {
            waitForAnimationFrame(() => {
                thumb.style.transition =
                    "width 300ms var(--cubic-enter), transform 300ms var(--cubic-enter)";
            });
        }
    }, [applyThumbSizing, value, size, gutterSize, pill]);
    const handleValueChange = (nextValue) => {
        // Only trigger onChange when a value exists
        // Disallow toggling off enabled items
        if (nextValue && onChange)
            onChange(nextValue);
    };
    return (_jsxs(ToggleGroup.Root, { ref: rootRef, className: clsx(s.SegmentedControl, className), type: "single", value: value, loop: false, onValueChange: handleValueChange, onClick: onClick, "data-block": block ? "" : undefined, "data-pill": pill ? "" : undefined, "data-size": size, "data-gutter-size": gutterSize, ...restProps, children: [_jsx("div", { className: s.SegmentedControlThumb, ref: thumbRef }), children] }));
};
const Segment = ({ children, ...restProps }) => {
    return (_jsx(ToggleGroup.Item, { className: s.SegmentedControlOption, ...restProps, onPointerEnter: handlePressableMouseEnter, children: _jsx("span", { className: "relative", children: children }) }));
};
SegmentedControl.Option = Segment;
//# sourceMappingURL=SegmentedControl.js.map