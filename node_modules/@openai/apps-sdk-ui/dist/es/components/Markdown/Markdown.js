"use client";
import { jsx as _jsx } from "react/jsx-runtime";
import clsx from "clsx";
import { Children, useMemo } from "react";
import ReactMarkdown from "react-markdown";
import remarkBreaks from "remark-breaks";
import remarkDirective from "remark-directive";
import remarkGfm from "remark-gfm";
import { CodeBlock, CodeBlockBase } from "../CodeBlock/CodeBlock";
import { TextLink } from "../TextLink/TextLink";
import { reactMarkdownRemarkDirective } from "./directives";
import s from "./Markdown.module.css";
import { defaultUrlTransform } from "./urlTransform";
import { useMathPlugins } from "./useMathPlugins";
import { useParseMarkdownPre } from "./useParseMarkdownPre";
const supportsLookbehind = (() => {
    try {
        new RegExp("(?<=a)b");
        return true;
    }
    catch {
        return false;
    }
})();
export function Markdown({ children, directives, includeMath = false, breakNewLines = false, components: propsComponents, remarkPlugins, rehypePlugins, allowedElements, disallowedElements, skipHtml, urlTransform = defaultUrlTransform, className, copyableCodeBlocks = true, }) {
    const mathPlugins = useMathPlugins(includeMath);
    const baseComponents = {
        ...COMMON_COMPONENTS,
        ...(copyableCodeBlocks ? null : NON_COPYABLE_CODE_BLOCK_COMPONENTS),
        ...propsComponents,
    };
    const components = directives?.reduce((acc, directive) => {
        acc[directive.directiveName] = directive.render;
        return acc;
    }, baseComponents) ?? baseComponents;
    const mergedRemarkPlugins = useMemo(() => {
        const baseRemarkPlugins = [
            remarkDirective,
            reactMarkdownRemarkDirective,
            ...mathPlugins.remarkPlugins,
        ];
        if (breakNewLines) {
            baseRemarkPlugins.push(remarkBreaks);
        }
        // remark-gfm requires lookbehind support, which will throw in <= Safari 16.4
        // with no easily available polyfill.
        if (supportsLookbehind) {
            // Do not treat single tilde as strikethrough to allow for more
            // conversational use cases such as "~$20-$30"
            baseRemarkPlugins.push([remarkGfm, { singleTilde: false }]);
        }
        return [...baseRemarkPlugins, ...(remarkPlugins ?? [])];
    }, [mathPlugins.remarkPlugins, remarkPlugins, breakNewLines]);
    return (_jsx(ReactMarkdown, { className: clsx(s.MarkdownContent, className), remarkPlugins: mergedRemarkPlugins, rehypePlugins: [...(rehypePlugins ?? []), ...mathPlugins.rehypePlugins], components: components, allowedElements: allowedElements, disallowedElements: disallowedElements, skipHtml: skipHtml, urlTransform: urlTransform, children: children }));
}
const Pre = ({ children, className }) => {
    const { code, language } = useParseMarkdownPre(children);
    return (_jsx(CodeBlock, { language: language, className: className, children: code }));
};
const InlineCode = ({ children, className }) => (_jsx("code", { className: clsx(s.InlineCode, className), children: children }));
const Anchor = ({ children, node: _node, ...props }) => (_jsx(TextLink, { as: "a", ...props, children: children }));
// Sourced from ChatGPT
const TableCell = ({ node: _node, children, ...rest }) => {
    return (_jsx("td", { ...rest, children: Children.map(children, (child, i) => 
        // ReactMarkdown does not support <br> tags in tables without using
        // remark-html (which may not be safe), so we need to manually handle them
        child === "<br>" ? _jsx("br", {}, i) : child) }));
};
const COMMON_COMPONENTS = {
    code: InlineCode,
    pre: Pre,
    a: Anchor,
    td: TableCell,
};
const NonCopyableCodeBlock = ({ children, className }) => {
    const { code, language } = useParseMarkdownPre(children);
    return (_jsx(CodeBlockBase, { className: className, children: _jsx(CodeBlockBase.Code, { language: language, children: code }) }));
};
const NON_COPYABLE_CODE_BLOCK_COMPONENTS = {
    pre: NonCopyableCodeBlock,
};
//# sourceMappingURL=Markdown.js.map