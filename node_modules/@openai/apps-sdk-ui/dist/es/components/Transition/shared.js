import React, { Children, useCallback, useRef } from "react";
import { isDev, isTest } from "../../lib/constants";
export const NonNullChildren = (children) => Children.toArray(children).filter((child) => child !== null && child !== undefined);
export const ChildrenWithKeys = (children, shouldThrow = false, componentName = "TransitionGroup") => {
    const validChildren = [];
    Children.forEach(children, (child) => {
        if (child && typeof child === "object" && "key" in child && !!child.key) {
            // @ts-expect-error -- The above conditional is enough coercion that the component is valid
            validChildren.push(child);
        }
        else if (shouldThrow) {
            throw new Error(`Child elements of <${componentName} /> must include a \`key\``);
        }
    });
    return validChildren;
};
export const noop = () => { };
export const useChildCallback = (cb) => {
    const ref = useRef(cb);
    ref.current = cb;
    return useCallback((element) => ref.current(element), []);
};
export function computeNextRenderChildren(propChildrenArray, currentRenderChildren, createDefaultRenderChildProps, insertMethod) {
    const propChildKeyMap = propChildrenArray.reduce((acc, child) => ({ ...acc, [child.key]: 1 }), {});
    const currentRenderChildKeyMap = currentRenderChildren.reduce((acc, child) => ({ ...acc, [child.component.key]: 1 }), {});
    const newRenderChildren = propChildrenArray
        .filter((propChild) => !currentRenderChildKeyMap[propChild.key])
        .map(createDefaultRenderChildProps);
    const updatedCurrentChildren = currentRenderChildren.map((childProps) => ({
        ...childProps,
        component: propChildrenArray.find(({ key }) => key === childProps.component.key) || childProps.component,
        shouldRender: !!propChildKeyMap[childProps.component.key],
    }));
    return insertMethod === "append"
        ? updatedCurrentChildren.concat(newRenderChildren)
        : newRenderChildren.concat(updatedCurrentChildren);
}
export function assertSingleChildWhenRef(componentName, ref, childrenCount) {
    if ((isTest || isDev) && ref && childrenCount > 1) {
        throw new Error(`Cannot use forwardRef with multiple children in <${componentName} />`);
    }
}
//# sourceMappingURL=shared.js.map