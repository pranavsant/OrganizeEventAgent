"use client";
import { jsx as _jsx, Fragment as _Fragment } from "react/jsx-runtime";
import React, { Children, useCallback, useEffect, useLayoutEffect, useReducer, useRef, useState, } from "react";
import { mergeRefs } from "react-merge-refs";
import { waitForAnimationFrame } from "../../lib/helpers";
// (no-op) clsx removed: className is not managed at group-level for slotted children
import { useTimeout } from "usehooks-ts";
import getDisableAnimations from "./getDisableAnimations";
import { assertSingleChildWhenRef, ChildrenWithKeys, computeNextRenderChildren, noop, useChildCallback, } from "./shared";
import { getInitialTransitionState, transitionReducer } from "./transitionReducer";
const SlotTransitionGroupChildInner = ({ ref, component, preventMountTransition, shouldRender, enterDuration, exitDuration, removeChild, onEnter, onEnterActive, onEnterComplete, onExit, onExitActive, onExitComplete, }) => {
    const [state, dispatch] = useReducer(transitionReducer, getInitialTransitionState(preventMountTransition || false));
    const preventedMountTransition = useRef(false);
    const elementRef = useRef(null);
    const enterDurationRef = useRef(enterDuration);
    enterDurationRef.current = enterDuration;
    const exitDurationRef = useRef(exitDuration);
    exitDurationRef.current = exitDuration;
    const lastCallbackRef = useRef(null);
    const triggerCallback = useCallback((callbackType) => {
        const element = elementRef.current;
        if (!element || callbackType === lastCallbackRef.current) {
            return;
        }
        lastCallbackRef.current = callbackType;
        switch (callbackType) {
            case "enter":
                onEnter(element);
                break;
            case "enter-active":
                onEnterActive(element);
                break;
            case "enter-complete":
                onEnterComplete(element);
                break;
            case "exit":
                onExit(element);
                break;
            case "exit-active":
                onExitActive(element);
                break;
            case "exit-complete":
                onExitComplete(element);
                break;
            default:
                callbackType;
                break;
        }
    }, [onEnter, onEnterActive, onEnterComplete, onExit, onExitActive, onExitComplete]);
    /**
     * IMPORTANT: `useLayoutEffect()` is used here to avoid race conditions between new SlotTransitionGroupChild components.
     */
    useLayoutEffect(() => {
        // Exit transition
        if (!shouldRender) {
            let exitTimeout;
            dispatch({ type: "exit-before" });
            triggerCallback("exit");
            const cancelAnimationFrame = waitForAnimationFrame(() => {
                dispatch({ type: "exit-active" });
                triggerCallback("exit-active");
                exitTimeout = window.setTimeout(() => {
                    triggerCallback("exit-complete");
                    removeChild();
                }, exitDurationRef.current);
            });
            return () => {
                cancelAnimationFrame();
                if (exitTimeout !== undefined)
                    clearTimeout(exitTimeout);
            };
        }
        // Enter transition
        // Check if we need to prevent this specific entering cycle
        if (preventMountTransition && !preventedMountTransition.current) {
            // Mark initial transition as prevented and short-circuit.
            preventedMountTransition.current = true;
            return;
        }
        let enterTimeout;
        dispatch({ type: "enter-before" });
        triggerCallback("enter");
        const cancelAnimationFrame = waitForAnimationFrame(() => {
            dispatch({ type: "enter-active" });
            triggerCallback("enter-active");
            enterTimeout = window.setTimeout(() => {
                dispatch({ type: "done" });
                triggerCallback("enter-complete");
            }, enterDurationRef.current);
        });
        return () => {
            cancelAnimationFrame();
            if (enterTimeout !== undefined)
                clearTimeout(enterTimeout);
        };
    }, [
        shouldRender,
        // This value is immutable after <SlotTransitionGroup> is created, and does not change on re-renders.
        preventMountTransition,
        removeChild,
        triggerCallback,
    ]);
    useEffect(() => {
        // Required for <StrictMode>
        return () => {
            preventedMountTransition.current = false;
        };
    }, []);
    const original = component;
    const mergedRef = mergeRefs([
        elementRef,
        ref,
        (original.ref ?? null),
    ]);
    const nextProps = {
        "data-entering": state.enter ? "" : undefined,
        "data-entering-active": state.enterActive ? "" : undefined,
        "data-exiting": state.exit ? "" : undefined,
        "data-exiting-active": state.exitActive ? "" : undefined,
        "data-interrupted": state.interrupted ? "" : undefined,
        "ref": mergedRef,
    };
    return React.isValidElement(original) ? React.cloneElement(original, nextProps) : null;
};
const SlotTransitionGroupChild = (props) => {
    const { enterMountDelay, preventMountTransition } = props;
    const mountDelay = !preventMountTransition && enterMountDelay != null ? enterMountDelay : null;
    const [mounted, setMounted] = useState(mountDelay == null);
    useTimeout(() => setMounted(true), mounted ? null : mountDelay);
    return mounted ? _jsx(SlotTransitionGroupChildInner, { ...props }) : null;
};
export const SlotTransitionGroup = (props) => {
    const { ref, children, enterDuration = 0, exitDuration = 0, preventInitialTransition = true, enterMountDelay, insertMethod = "append", disableAnimations = getDisableAnimations(), } = props;
    // Create stable, mutable references for all callbacks
    const onEnter = useChildCallback(props.onEnter ?? noop);
    const onEnterActive = useChildCallback(props.onEnterActive ?? noop);
    const onEnterComplete = useChildCallback(props.onEnterComplete ?? noop);
    const onExit = useChildCallback(props.onExit ?? noop);
    const onExitActive = useChildCallback(props.onExitActive ?? noop);
    const onExitComplete = useChildCallback(props.onExitComplete ?? noop);
    // Ensure all children are provided with keys.
    Children.forEach(children, (child) => {
        // @ts-expect-error - We know `key` might not exist on certain types, that's why we're checking
        if (child && !child.key) {
            throw new Error("Child elements of <SlotTransitionGroup /> must include a `key`");
        }
    });
    const createDefaultRenderChildProps = useCallback((child) => ({
        component: child,
        shouldRender: true,
        removeChild: () => {
            setRenderChildren((currentRenderChildren) => currentRenderChildren.filter((c) => child.key !== c.component.key));
        },
        onEnter,
        onEnterActive,
        onEnterComplete,
        onExit,
        onExitActive,
        onExitComplete,
    }), [onEnter, onEnterActive, onEnterComplete, onExit, onExitActive, onExitComplete]);
    const [renderChildren, setRenderChildren] = useState(() => {
        return ChildrenWithKeys(children).map((child) => ({
            ...createDefaultRenderChildProps(child),
            // Lock this value to whatever the value was on initial render of the group.
            preventMountTransition: preventInitialTransition,
        }));
    });
    // IMPORTANT: useLayoutEffect is required to satisfy render timings for prop updates to input elements
    useLayoutEffect(() => {
        setRenderChildren((currentRenderChildren) => {
            const propChildrenArray = ChildrenWithKeys(children, false, "SlotTransitionGroup");
            return computeNextRenderChildren(propChildrenArray, currentRenderChildren, createDefaultRenderChildProps, insertMethod);
        });
    }, [children, insertMethod, createDefaultRenderChildProps]);
    // Prevent mistakes with forwardRef() by ensuring single child usage within the group.
    assertSingleChildWhenRef("SlotTransitionGroup", ref, Children.count(children));
    if (disableAnimations) {
        // Fast path: when animations are disabled and no ref is provided, render children as-is.
        if (!ref) {
            return _jsx(_Fragment, { children: children });
        }
        // If a ref is provided, attach it to the (single) child by cloning.
        return (_jsx(_Fragment, { children: Children.map(children, (child) => {
                if (!React.isValidElement(child))
                    return child;
                const original = child;
                const merged = mergeRefs([
                    ref,
                    (original.ref ??
                        null),
                ]);
                const nextProps = { ref: merged };
                return React.cloneElement(original, nextProps);
            }) }));
    }
    return (_jsx(_Fragment, { children: renderChildren.map(({ component, ...restProps }) => (_jsx(SlotTransitionGroupChild, { ...restProps, component: component, enterDuration: enterDuration, exitDuration: exitDuration, enterMountDelay: enterMountDelay, ref: ref }, component.key))) }));
};
//# sourceMappingURL=SlotTransitionGroup.js.map