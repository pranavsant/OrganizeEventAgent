"use client";
import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import clsx from "clsx";
import { useMemo } from "react";
import { getMonthStartAndEnd, isBefore, isSameDay } from "../../lib/dateUtils";
import { Button } from "../Button";
import { Calendar, ChevronLeft, ChevronRight } from "../Icon";
import { SelectControl } from "../SelectControl";
import s from "./Trigger.module.css";
import { useDateRangeContext } from "./context";
import {} from "./types";
export const DateRangeTrigger = (props) => {
    const { value, min, max, disabled, variant, pill, size, block, triggerStepperUnit, triggerClassName, clearable, dropdownIconType, triggerShowIcon, onChangeRef, } = useDateRangeContext();
    const isStepperView = useMemo(() => rangeMatchesStepperUnit(value, triggerStepperUnit, {
        min,
        max,
    }), [value, triggerStepperUnit, min, max]);
    const handleClearClick = () => {
        onChangeRef.current(null);
    };
    return (_jsx(SelectControl, { className: clsx(isStepperView && s.StepperControl, triggerClassName), selected: !!value, variant: variant, pill: pill, block: block, size: size, disabled: disabled, StartIcon: triggerShowIcon && !isStepperView ? Calendar : undefined, dropdownIconType: !isStepperView ? dropdownIconType : "none", onClearClick: clearable && !isStepperView ? handleClearClick : undefined, ...props, children: isStepperView ? _jsx(TriggerStepperView, {}) : _jsx(TriggerDisplayView, {}) }));
};
const TriggerStepperView = () => {
    const { value, min, max, disabled, onChangeRef } = useDateRangeContext();
    if (!value) {
        return null;
    }
    const [startDate, endDate] = value;
    const canGoBack = !min || isBefore(min, startDate.startOf("month"));
    const canGoForward = !max || isBefore(endDate.endOf("month"), max);
    return (_jsxs("span", { className: "flex", children: [_jsx(Button, { className: s.StepperPrevious, color: "secondary", variant: "ghost", disabled: disabled || !canGoBack, size: "3xs", uniform: true, pill: true, onPointerDown: (evt) => {
                    evt.stopPropagation();
                    onChangeRef.current(getMonthStartAndEnd(startDate.minus({ months: 1 }), { min, max }));
                }, children: _jsx(ChevronLeft, {}) }), " ", _jsxs("span", { className: clsx(s.TriggerText, "min-w-[120px] text-center"), children: [startDate.monthLong, " ", startDate.year] }), _jsx(Button, { className: s.StepperNext, color: "secondary", variant: "ghost", disabled: disabled || !canGoForward, size: "3xs", uniform: true, pill: true, onPointerDown: (evt) => {
                    evt.stopPropagation();
                    onChangeRef.current(getMonthStartAndEnd(startDate.plus({ months: 1 }), { min, max }));
                }, children: _jsx(ChevronRight, {}) })] }));
};
const TriggerDisplayView = () => {
    const { placeholder, value, triggerDateFormat, shortcuts } = useDateRangeContext();
    const activeShortcut = useMemo(() => {
        if (!value || !shortcuts?.length) {
            return undefined;
        }
        return shortcuts.find((sc) => {
            const [start, end] = sc.getDateRange();
            return isSameDay(start, value[0]) && isSameDay(end, value[1]);
        });
    }, [value, shortcuts]);
    return (_jsx(_Fragment, { children: activeShortcut ? (_jsx("span", { className: "inline-block", children: activeShortcut.label })) : value && isSameDay(value[0], value[1]) ? (_jsx("span", { className: "inline-block tabular-nums", children: value[0].toFormat(triggerDateFormat) })) : value ? (_jsxs("span", { className: "inline-block tabular-nums", children: [value[0].toFormat(triggerDateFormat), _jsx("span", { className: s.RangeTextSeparator, children: "-" }), value[1].toFormat(triggerDateFormat)] })) : (placeholder) }));
};
const rangeMatchesStepperUnit = (range, stepperUnit, { min, max } = {}) => {
    // Allows method to be called lazily
    if (!range || !stepperUnit) {
        return false;
    }
    const [startDate, endDate] = range;
    const [startDateCompare, endDateCompare] = getMonthStartAndEnd(startDate, {
        min,
        max,
    });
    return isSameDay(startDateCompare, startDate) && isSameDay(endDateCompare, endDate);
};
//# sourceMappingURL=Trigger.js.map