"use client";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import clsx from "clsx";
import { useCallback, } from "react";
import { handlePressableMouseEnter } from "../../lib/helpers";
import { wrapTextNodeSiblings } from "../../lib/renderHelpers";
import {} from "../../types";
import { useLinkComponent } from "../AppsSDKUIProvider/internal";
import { LoadingIndicator } from "../Indicator";
import { TransitionGroup } from "../Transition/TransitionGroup";
import s from "./Button.module.css";
export const Button = (props) => {
    const { type = "button", color = "primary", variant = "solid", pill = true, uniform = false, size = "md", iconSize, gutterSize, loading, selected, block, opticallyAlign, children, className, onClick, disabled, disabledTone, 
    // Defaults to `loading` state
    inert = loading, ...restProps } = props;
    const isInert = disabled || inert;
    const handleClick = useCallback((e) => {
        if (disabled) {
            return;
        }
        onClick?.(e);
    }, [onClick, disabled]);
    return (_jsxs("button", { type: type, className: clsx(s.Button, className), "data-color": color, "data-variant": variant, "data-pill": pill ? "" : undefined, "data-uniform": uniform ? "" : undefined, "data-size": size, "data-gutter-size": gutterSize, "data-icon-size": iconSize, "data-loading": loading ? "" : undefined, "data-selected": selected ? "" : undefined, "data-block": block ? "" : undefined, "data-optically-align": opticallyAlign, onPointerEnter: handlePressableMouseEnter, 
        // Non-visual, accessible disablement
        // NOTE: Do not use literal `inert` because that is incorrect semantically
        disabled: isInert, "aria-disabled": isInert, tabIndex: isInert ? -1 : undefined, "data-disabled": disabled ? "" : undefined, "data-disabled-tone": disabled ? disabledTone : undefined, onClick: handleClick, ...restProps, children: [_jsx(TransitionGroup, { className: s.ButtonLoader, enterDuration: 250, exitDuration: 150, children: loading && _jsx(LoadingIndicator, {}, "loader") }), _jsx("span", { className: s.ButtonInner, children: wrapTextNodeSiblings(children) })] }));
};
export const ButtonLink = ((props) => {
    const { color = "primary", variant = "solid", pill = true, size = "md", gutterSize, iconSize, external, block, opticallyAlign, children, className, disabled, disabledTone, onClick, onPointerEnter, as: OverrideComponent, href, to, ...restProps } = props;
    const isExternal = external ?? /^https?:\/\//.test(href ?? to ?? "");
    const DefaultComponent = useLinkComponent();
    const LinkComponent = OverrideComponent || (isExternal ? "a" : DefaultComponent);
    const sharedProps = {
        "className": clsx(s.Button, className),
        disabled,
        "aria-disabled": disabled,
        "tabIndex": disabled ? -1 : undefined,
        // Visual disablement (inert not supported in links, always applied)
        "data-disabled": disabled ? "" : undefined,
        "data-disabled-tone": disabled ? disabledTone : undefined,
        "data-color": color,
        "data-variant": variant,
        "data-pill": pill ? "" : undefined,
        "data-block": block ? "" : undefined,
        "data-optically-align": opticallyAlign,
        "data-size": size,
        "data-gutter-size": gutterSize,
        "data-icon-size": iconSize,
        "onClick": disabled ? undefined : onClick,
        "onPointerEnter": (evt) => {
            handlePressableMouseEnter(evt);
            onPointerEnter?.(evt);
        },
    };
    if (disabled) {
        // Don't thread down stuff that isn't valid for a span - just keep the event handlers
        const eventProps = Object.fromEntries(Object.entries(restProps).filter(([key, value]) => key.startsWith("on") && typeof value === "function"));
        return (_jsx("span", { role: "link", ...sharedProps, ...eventProps, children: _jsx("span", { className: s.ButtonInner, children: wrapTextNodeSiblings(children) }) }));
    }
    const linkProps = {
        ...(isExternal
            ? { target: "_blank", rel: "noopener noreferrer", href: href ?? to }
            : { href, to }),
        ...sharedProps,
        ...restProps,
    };
    return (_jsx(LinkComponent, { ...linkProps, children: _jsx("span", { className: s.ButtonInner, children: wrapTextNodeSiblings(children) }) }));
});
//# sourceMappingURL=Button.js.map