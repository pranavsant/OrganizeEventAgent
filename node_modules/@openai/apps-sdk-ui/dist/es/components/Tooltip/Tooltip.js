"use client";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import clsx from "clsx";
import { Tooltip as RadixTooltip, Slot } from "radix-ui";
import { useState } from "react";
import { useTimeout } from "usehooks-ts";
import { useEscCloseStack } from "../../hooks/useEscCloseStack";
import { preventDefaultHandler } from "../../lib/helpers";
import s from "./Tooltip.module.css";
export const Tooltip = (props) => {
    const { ref: forwardedRef, children, content, forceOpen = content === null ? false : undefined, maxWidth = 300, openDelay = 150, interactive = false, compact = false, preventUnintentionalClickToClose, align, alignOffset = 0, side, sideOffset = 5, gutterSize = "md", contentClassName, onPointerDown, onClick, ...restProps } = props;
    const [visible, setVisible] = useState(false);
    const [temporarilyPreventClickToClose, setTemporarilyPreventClickToClose] = useState(false);
    useTimeout(() => setTemporarilyPreventClickToClose(false), temporarilyPreventClickToClose ? 400 : null);
    const open = forceOpen ?? visible;
    const handleOpenChange = (nextState) => {
        // When forceOpen is passed, don't manage internal state
        if (typeof forceOpen === "boolean")
            return;
        setVisible(nextState);
        if (preventUnintentionalClickToClose) {
            setTemporarilyPreventClickToClose(nextState);
        }
    };
    const maybePreventClickClose = (evt) => {
        if (preventUnintentionalClickToClose && temporarilyPreventClickToClose) {
            // Prevents tooltip listeners from closing
            evt.preventDefault();
            evt.stopPropagation();
        }
    };
    return (_jsxs(Root, { open: open, delayDuration: openDelay, onOpenChange: handleOpenChange, disableHoverableContent: !interactive, children: [_jsx(RadixTooltip.Trigger, { asChild: true, children: _jsx(Slot.Root, { ...restProps, ref: forwardedRef, onPointerDown: (evt) => {
                        maybePreventClickClose(evt);
                        onPointerDown?.(evt);
                    }, onClick: (evt) => {
                        maybePreventClickClose(evt);
                        onClick?.(evt);
                    }, children: children }) }), _jsx(Content, { maxWidth: maxWidth, compact: compact, align: align, alignOffset: alignOffset, side: side, sideOffset: sideOffset, gutterSize: gutterSize, className: contentClassName, children: content })] }));
};
const Root = ({ children, open, onOpenChange, ...restProps }) => {
    useEscCloseStack(open, () => {
        onOpenChange(false);
    });
    return (_jsx(RadixTooltip.Provider, { children: _jsx(RadixTooltip.Root, { open: open, onOpenChange: onOpenChange, ...restProps, children: children }) }));
};
export const Content = ({ children, maxWidth = 300, compact = false, clickable = undefined, alignOffset = 0, sideOffset = 5, gutterSize = "md", className, style, ...restProps }) => {
    return (_jsx(RadixTooltip.Portal, { children: _jsx(RadixTooltip.Content, { ...restProps, className: clsx(s.Tooltip, className), "data-compact": compact, "data-clickable": clickable, "data-gutter-size": gutterSize, alignOffset: alignOffset, sideOffset: sideOffset, collisionPadding: 15, hideWhenDetached: true, style: {
                ...style,
                maxWidth,
            }, onEscapeKeyDown: preventDefaultHandler, children: children }) }));
};
export const Trigger = ({ children, asChild = true, ...restProps }) => {
    return (_jsx(RadixTooltip.Trigger, { asChild: asChild, ...restProps, children: children }));
};
// Optional wrapper for tooltip trigger, if the visual content isn't already accessible or with built-in visual indications
export const TriggerDecorator = (props) => {
    const { children, className, focusable = true, ref, ...restProps } = props;
    const isPlainText = typeof children === "string";
    return (_jsx(Slot.Root, { ref: ref, ...restProps, className: clsx(s.TriggerDecorator, className), tabIndex: focusable ? 0 : undefined, children: isPlainText ? _jsx("span", { children: children }) : children }));
};
// Building advanced tooltip behaviors can be achieved by using the
// composed components, and wiring up bespoke behaviors.
Tooltip.Root = Root;
Tooltip.Content = Content;
Tooltip.Trigger = Trigger;
// Basic <Tooltip> usage can be done with the component directly,
// without requiring controlled component composition.
// <TriggerDecorator> is a helper component that creates an accessible trigger with a visual effect
Tooltip.TriggerDecorator = TriggerDecorator;
//# sourceMappingURL=Tooltip.js.map