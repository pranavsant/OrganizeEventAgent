"use client";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { DropdownMenu } from "radix-ui";
import React, { createContext, useCallback, useContext, useMemo, useRef, useState, } from "react";
import clsx from "clsx";
import { useEscCloseStack } from "../../hooks/useEscCloseStack";
import { useLatestValue } from "../../hooks/useLatestValue";
import { preventDefaultHandler, toCssVariables } from "../../lib/helpers";
import { useLinkComponent } from "../AppsSDKUIProvider/internal";
import { Button } from "../Button";
import { Check, ChevronRight } from "../Icon";
import { TransitionGroup } from "../Transition";
import s from "./Menu.module.css";
const MenuContext = createContext(null);
const useMenuContext = () => {
    const context = useContext(MenuContext);
    if (!context) {
        throw new Error("Menu components must be wrapped in <Menu />");
    }
    return context;
};
export const Menu = ({ children, forceOpen, onOpen, onClose, modal = false }) => {
    const [open, setOpen] = useState(false);
    const isOpen = forceOpen ?? open;
    const latestOnOpen = useLatestValue(onOpen);
    const latestOnClose = useLatestValue(onClose);
    const handleOpenChange = useCallback((nextState) => {
        setOpen(nextState);
        if (nextState) {
            latestOnOpen.current?.();
        }
        else {
            latestOnClose.current?.();
        }
    }, [latestOnOpen, latestOnClose]);
    useEscCloseStack(open, () => {
        handleOpenChange(false);
    });
    const store = useMemo(() => ({
        open: isOpen,
        setOpen: handleOpenChange,
    }), [isOpen, handleOpenChange]);
    return (_jsx(MenuContext.Provider, { value: store, children: _jsx(DropdownMenu.Root, { open: isOpen, onOpenChange: handleOpenChange, modal: modal, children: children }) }));
};
const Item = ({ className, children, disabled, onSelect, onClick }) => {
    const { open } = useMenuContext();
    // This handler patches over focus races with core Radix primitives
    // https://github.com/radix-ui/primitives/blob/main/packages/react/menu/src/Menu.tsx#L712-L734
    const handlePreventAfterClose = (evt) => {
        // Prevent default behavior when we're always known to be closing
        if (!open) {
            evt.preventDefault();
        }
    };
    // Custom click handlers
    if (onSelect) {
        return (_jsx(DropdownMenu.Item, { className: clsx(s.MenuItem, className), onSelect: onSelect, onClick: onClick, disabled: disabled, onPointerMove: handlePreventAfterClose, onPointerLeave: handlePreventAfterClose, children: _jsx("div", { className: s.PressableInner, children: children }) }));
    }
    // Read-only content - will not appear interactive.
    return _jsx("div", { className: clsx(s.MenuItemContent, className), children: children });
};
const ItemActions = ({ className, children }) => {
    return _jsx("div", { className: clsx(s.ItemActions, className), children: children });
};
const ItemAction = ({ children, onClick, }) => {
    const { setOpen } = useMenuContext();
    return (_jsx(Button, { className: "rounded-sm", color: "secondary", size: "xs", uniform: true, iconSize: "sm", variant: "ghost", onClick: (evt) => {
            evt.stopPropagation();
            setOpen(false);
            onClick(evt);
        }, children: children }));
};
const Link = ((props) => {
    const { className, children, href, to, disabled, as: OverrideComponent, ...restProps } = props;
    const { open } = useMenuContext();
    const propPath = href || to;
    // When a path is not provided, default to an anchor
    const isExternal = propPath ? /^https?:\/\//.test(propPath) : true;
    const DefaultComponent = useLinkComponent();
    const Component = OverrideComponent || (isExternal ? "a" : DefaultComponent);
    // This handler patches over focus races with core Radix primitives
    // https://github.com/radix-ui/primitives/blob/main/packages/react/menu/src/Menu.tsx#L712-L734
    const handlePreventAfterClose = (evt) => {
        // Prevent default behavior when we're always known to be closing
        if (!open) {
            evt.preventDefault();
        }
    };
    const linkProps = isExternal
        ? { target: "_blank", rel: "noopener noreferrer", href: href ?? to }
        : { href, to };
    return (_jsx(DropdownMenu.Item, { asChild: true, className: clsx(s.MenuItem, className), disabled: disabled, onPointerMove: isExternal ? undefined : handlePreventAfterClose, onPointerLeave: isExternal ? undefined : handlePreventAfterClose, children: _jsx(Component, { ...linkProps, ...restProps, children: _jsx("span", { className: s.PressableInner, children: children }) }) }));
});
const Separator = ({ className }) => {
    return _jsx(DropdownMenu.Separator, { className: clsx(s.Separator, className), role: "separator" });
};
const Content = ({ children, side, sideOffset = 5, align, alignOffset, width, minWidth, maxHeight, }) => {
    const { open } = useMenuContext();
    return (_jsx(DropdownMenu.Portal, { forceMount: true, children: _jsx(TransitionGroup, { className: s.Menu, enterDuration: 350, exitDuration: 200, disableAnimations: true, children: open && (_jsx(DropdownMenu.Content, { forceMount: true, className: s.MenuList, side: side, sideOffset: sideOffset, align: align, alignOffset: alignOffset ?? (align === "center" ? 0 : -5), avoidCollisions: true, collisionPadding: { bottom: 30, top: 30, left: 12, right: 12 }, onEscapeKeyDown: preventDefaultHandler, style: toCssVariables({
                    "menu-width": width,
                    "menu-min-width": minWidth,
                    "menu-max-height": maxHeight,
                }), children: children }, "dropdown")) }) }));
};
const Trigger = ({ children, disabled }) => {
    return (_jsx(DropdownMenu.Trigger, { asChild: true, disabled: disabled, children: children }));
};
const SubmenuContext = createContext(null);
const useSubmenuContext = () => {
    const context = useContext(SubmenuContext);
    if (!context) {
        throw new Error("Submenu components must be wrapped in <Sub />");
    }
    return context;
};
const Sub = ({ children, forceOpen, onOpen, onClose }) => {
    const [open, setOpen] = useState(false);
    const triggerRef = useRef(null);
    const isOpen = forceOpen ?? open;
    const latestOnOpen = useLatestValue(onOpen);
    const latestOnClose = useLatestValue(onClose);
    const handleOpenChange = useCallback((nextState) => {
        setOpen(nextState);
        if (nextState) {
            latestOnOpen.current?.();
        }
        else {
            latestOnClose.current?.();
        }
    }, [latestOnOpen, latestOnClose]);
    useEscCloseStack(open, () => {
        handleOpenChange(false);
        // Ensure trigger is focused
        triggerRef.current?.focus();
    });
    const store = useMemo(() => ({
        open: isOpen,
        setOpen: handleOpenChange,
        triggerRef,
    }), [isOpen, handleOpenChange]);
    return (_jsx(SubmenuContext.Provider, { value: store, children: _jsx(DropdownMenu.Sub, { open: isOpen, onOpenChange: handleOpenChange, children: children }) }));
};
const SubTrigger = ({ className, children, disabled, }) => {
    const { open } = useMenuContext();
    const { triggerRef } = useSubmenuContext();
    // This handler patches over focus races with core Radix primitives
    // https://github.com/radix-ui/primitives/blob/main/packages/react/menu/src/Menu.tsx#L712-L734
    const handlePreventAfterClose = (evt) => {
        // Prevent default behavior when we know the outer menu is closing
        if (!open) {
            evt.preventDefault();
        }
    };
    return (_jsx(DropdownMenu.SubTrigger, { ref: triggerRef, className: clsx(s.MenuItem, s.SubMenuItem, className), disabled: disabled, onPointerMove: handlePreventAfterClose, onPointerLeave: handlePreventAfterClose, children: _jsxs("div", { className: s.PressableInner, children: [children, _jsx(ChevronRight, { width: "16", height: "16", className: s.SubTriggerIcon })] }) }));
};
const SubContent = ({ children, sideOffset = 4, alignOffset = -6, width = "auto", minWidth = "auto", maxHeight, }) => {
    const { open } = useSubmenuContext();
    return (_jsx(DropdownMenu.Portal, { forceMount: true, children: _jsx(TransitionGroup, { className: s.Menu, enterDuration: 350, exitDuration: 200, disableAnimations: true, children: open && (_jsx(DropdownMenu.SubContent, { className: s.MenuList, sideOffset: sideOffset, alignOffset: alignOffset, avoidCollisions: true, collisionPadding: { bottom: 30, top: 30, left: 12, right: 12 }, onEscapeKeyDown: preventDefaultHandler, style: toCssVariables({
                    "menu-width": width,
                    "menu-min-width": minWidth,
                    "menu-max-height": maxHeight,
                }), children: children }, "submenu")) }) }));
};
const RadioGroup = ({ children, value, onChange, indicatorPosition = "end", ...props }) => (_jsx(DropdownMenu.RadioGroup, { ...props, value: value, onValueChange: (v) => onChange(v), "data-indicator-position": indicatorPosition, children: children }));
const RadioItem = ({ className, children, ...props }) => (_jsx(DropdownMenu.RadioItem, { className: clsx(s.MenuItem, s.RadioItem, className), ...props, children: _jsxs("div", { className: s.PressableInner, children: [_jsx("div", { className: s.RadioIndicator, children: _jsx(DropdownMenu.ItemIndicator, { className: s.RadioIndicatorActive }) }), children] }) }));
const CheckboxItem = ({ className, children, indicatorPosition = "end", indicatorVariant = "solid", ...props }) => (_jsx(DropdownMenu.CheckboxItem, { className: clsx(s.MenuItem, s.CheckboxItem, className), ...props, "data-indicator-position": indicatorPosition, "data-indicator-variant": indicatorVariant, children: _jsxs("div", { className: s.PressableInner, children: [_jsx("div", { className: s.CheckboxIndicator, children: _jsx(DropdownMenu.ItemIndicator, { children: indicatorVariant === "ghost" ? (_jsx(Check, { className: "size-4" })) : (_jsx("div", { className: s.CheckboxCircle, children: _jsx(Check, { className: "size-4" }) })) }) }), children] }) }));
Menu.Content = Content;
Menu.Item = Item;
Menu.ItemActions = ItemActions;
Menu.ItemAction = ItemAction;
Menu.Link = Link;
Menu.Separator = Separator;
Menu.Trigger = Trigger;
Menu.Sub = Sub;
Menu.SubTrigger = SubTrigger;
Menu.SubContent = SubContent;
Menu.CheckboxItem = CheckboxItem;
Menu.RadioGroup = RadioGroup;
Menu.RadioItem = RadioItem;
//# sourceMappingURL=Menu.js.map