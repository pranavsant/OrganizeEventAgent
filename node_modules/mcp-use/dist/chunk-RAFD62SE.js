import {
  fsHelpers,
  getCwd,
  isDeno,
  pathHelpers
} from "./chunk-MTHLLDCX.js";
import {
  __name
} from "./chunk-3GQAWCBQ.js";

// src/server/widgets/mcp-ui-adapter.ts
import { createUIResource } from "@mcp-ui/server";
function buildWidgetUrl(widget, props, config) {
  const slugifiedWidget = slugifyWidgetName(widget);
  const url = new URL(
    `/mcp-use/widgets/${slugifiedWidget}`,
    `${config.baseUrl}:${config.port}`
  );
  if (props && Object.keys(props).length > 0) {
    url.searchParams.set("props", JSON.stringify(props));
  }
  return url.toString();
}
__name(buildWidgetUrl, "buildWidgetUrl");
async function createExternalUrlResource(uri, iframeUrl, encoding = "text", adapters, metadata) {
  return await createUIResource({
    uri,
    content: { type: "externalUrl", iframeUrl },
    encoding,
    adapters,
    metadata
  });
}
__name(createExternalUrlResource, "createExternalUrlResource");
async function createRawHtmlResource(uri, htmlString, encoding = "text", adapters, metadata) {
  return await createUIResource({
    uri,
    content: { type: "rawHtml", htmlString },
    encoding,
    adapters,
    metadata
  });
}
__name(createRawHtmlResource, "createRawHtmlResource");
async function createRemoteDomResource(uri, script, framework = "react", encoding = "text", _adapters, _metadata) {
  const resource = {
    uri,
    mimeType: `application/vnd.mcp-ui.remote-dom+${framework}`
  };
  if (encoding === "blob") {
    resource.blob = Buffer.from(script).toString("base64");
  } else {
    resource.text = script;
  }
  return { type: "resource", resource };
}
__name(createRemoteDomResource, "createRemoteDomResource");
function createAppsSdkResource(uri, htmlTemplate, metadata) {
  const resource = {
    uri,
    mimeType: "text/html+skybridge",
    text: htmlTemplate
  };
  if (metadata && Object.keys(metadata).length > 0) {
    resource._meta = metadata;
  }
  return {
    type: "resource",
    resource
  };
}
__name(createAppsSdkResource, "createAppsSdkResource");
function createMcpAppsResource(uri, htmlTemplate, metadata) {
  const resource = {
    uri,
    mimeType: "text/html;profile=mcp-app",
    text: htmlTemplate
  };
  if (metadata && Object.keys(metadata).length > 0) {
    const uiMeta = {};
    if (metadata.csp && Object.keys(metadata.csp).length > 0) {
      uiMeta.csp = metadata.csp;
    }
    if (metadata.prefersBorder !== void 0) {
      uiMeta.prefersBorder = metadata.prefersBorder;
    }
    if (metadata.domain) {
      uiMeta.domain = metadata.domain;
    }
    if (Object.keys(uiMeta).length > 0) {
      resource._meta = { ui: uiMeta };
    }
  }
  return {
    type: "resource",
    resource
  };
}
__name(createMcpAppsResource, "createMcpAppsResource");
async function createUIResourceFromDefinition(definition, params, config) {
  const buildIdPart = config.buildId ? `-${config.buildId}` : "";
  const uri = definition.type === "appsSdk" || definition.type === "mcpApps" ? `ui://widget/${definition.name}${buildIdPart}.html` : `ui://widget/${definition.name}${buildIdPart}`;
  const encoding = definition.encoding || "text";
  switch (definition.type) {
    case "externalUrl": {
      const widgetUrl = buildWidgetUrl(definition.widget, params, config);
      return await createExternalUrlResource(
        uri,
        widgetUrl,
        encoding,
        definition.adapters,
        definition.appsSdkMetadata
      );
    }
    case "rawHtml": {
      return await createRawHtmlResource(
        uri,
        definition.htmlContent,
        encoding,
        definition.adapters,
        definition.appsSdkMetadata
      );
    }
    case "remoteDom": {
      const framework = definition.framework || "react";
      return await createRemoteDomResource(
        uri,
        definition.script,
        framework,
        encoding,
        definition.adapters,
        definition.appsSdkMetadata
      );
    }
    case "appsSdk": {
      return createAppsSdkResource(
        uri,
        definition.htmlTemplate,
        definition.appsSdkMetadata
      );
    }
    case "mcpApps": {
      return createMcpAppsResource(
        uri,
        definition.htmlTemplate,
        definition.metadata
      );
    }
    default: {
      const _exhaustive = definition;
      throw new Error(`Unknown UI resource type: ${_exhaustive.type}`);
    }
  }
}
__name(createUIResourceFromDefinition, "createUIResourceFromDefinition");

// src/server/widgets/widget-helpers.ts
function slugifyWidgetName(name) {
  const MAX_LENGTH = 300;
  if (name.length > MAX_LENGTH) {
    name = name.substring(0, MAX_LENGTH);
  }
  return name.toLowerCase().replace(/[^a-z0-9-_.]/g, "-").replace(/-+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
}
__name(slugifyWidgetName, "slugifyWidgetName");
function generateWidgetUri(widgetName, buildId, extension = "", suffix = "") {
  const slugifiedName = slugifyWidgetName(widgetName);
  const parts = [slugifiedName];
  if (buildId) {
    parts.push(buildId);
  }
  if (suffix) {
    parts.push(suffix);
  }
  return `ui://widget/${parts.join("-")}${extension}`;
}
__name(generateWidgetUri, "generateWidgetUri");
function convertPropsToInputs(props) {
  if (!props) return [];
  return Object.entries(props).map(([name, prop]) => ({
    name,
    type: prop.type,
    description: prop.description,
    required: prop.required,
    default: prop.default
  }));
}
__name(convertPropsToInputs, "convertPropsToInputs");
function applyDefaultProps(props) {
  if (!props) return {};
  const defaults = {};
  for (const [key, prop] of Object.entries(props)) {
    if (prop.default !== void 0) {
      defaults[key] = prop.default;
    }
  }
  return defaults;
}
__name(applyDefaultProps, "applyDefaultProps");
async function readBuildManifest() {
  try {
    const manifestPath = pathHelpers.join(
      isDeno ? "." : getCwd(),
      "dist",
      "mcp-use.json"
    );
    const content = await fsHelpers.readFileSync(manifestPath, "utf8");
    return JSON.parse(content);
  } catch {
    return null;
  }
}
__name(readBuildManifest, "readBuildManifest");
function getContentType(filename) {
  const ext = filename.split(".").pop()?.toLowerCase();
  switch (ext) {
    case "js":
      return "application/javascript";
    case "css":
      return "text/css";
    case "png":
      return "image/png";
    case "jpg":
    case "jpeg":
      return "image/jpeg";
    case "svg":
      return "image/svg+xml";
    case "gif":
      return "image/gif";
    case "webp":
      return "image/webp";
    case "ico":
      return "image/x-icon";
    case "woff":
      return "font/woff";
    case "woff2":
      return "font/woff2";
    case "ttf":
      return "font/ttf";
    case "otf":
      return "font/otf";
    case "json":
      return "application/json";
    case "pdf":
      return "application/pdf";
    default:
      return "application/octet-stream";
  }
}
__name(getContentType, "getContentType");
function processWidgetHtml(html, widgetName, baseUrl) {
  let processedHtml = html;
  if (baseUrl && processedHtml) {
    let htmlWithoutComments = processedHtml;
    let prevHtmlWithoutComments;
    do {
      prevHtmlWithoutComments = htmlWithoutComments;
      htmlWithoutComments = htmlWithoutComments.replace(/<!--[\s\S]*?-->/g, "");
    } while (prevHtmlWithoutComments !== htmlWithoutComments);
    const baseTagRegex = /<base\s+[^>]*\/?>/i;
    if (baseTagRegex.test(htmlWithoutComments)) {
      const actualBaseTagMatch = processedHtml.match(/<base\s+[^>]*\/?>/i);
      if (actualBaseTagMatch) {
        processedHtml = processedHtml.replace(
          actualBaseTagMatch[0],
          `<base href="${baseUrl}" />`
        );
      }
    } else {
      const headTagRegex = /<head[^>]*>/i;
      if (headTagRegex.test(processedHtml)) {
        processedHtml = processedHtml.replace(
          headTagRegex,
          (match) => `${match}
    <base href="${baseUrl}" />`
        );
      }
    }
    processedHtml = processedHtml.replace(
      /src="\/mcp-use\/widgets\/([^"]+)"/g,
      `src="${baseUrl}/mcp-use/widgets/$1"`
    );
    processedHtml = processedHtml.replace(
      /href="\/mcp-use\/widgets\/([^"]+)"/g,
      `href="${baseUrl}/mcp-use/widgets/$1"`
    );
    const slugifiedName = slugifyWidgetName(widgetName);
    processedHtml = processedHtml.replace(
      /<head[^>]*>/i,
      `<head>
    <script>window.__getFile = (filename) => { return "${baseUrl}/mcp-use/widgets/${slugifiedName}/"+filename }; window.__mcpPublicUrl = "${baseUrl}/mcp-use/public";</script>`
    );
  }
  return processedHtml;
}
__name(processWidgetHtml, "processWidgetHtml");
function createWidgetRegistration(widgetName, metadata, html, serverConfig, isDev = false) {
  const props = metadata.props || metadata.inputs || metadata.schema || {};
  const description = metadata.description || `Widget: ${widgetName}`;
  const title = metadata.title || widgetName;
  const exposeAsTool = metadata.exposeAsTool !== void 0 ? metadata.exposeAsTool : false;
  const widgetType = metadata.appsSdkMetadata && !metadata.metadata ? "appsSdk" : "mcpApps";
  const mcp_connect_domain = serverConfig.serverBaseUrl ? new URL(serverConfig.serverBaseUrl || "").origin : null;
  const slugifiedName = slugifyWidgetName(widgetName);
  const baseRegistration = {
    name: widgetName,
    title,
    description,
    type: widgetType,
    props,
    _meta: {
      "mcp-use/widget": {
        name: widgetName,
        slugifiedName,
        title,
        description,
        type: widgetType,
        props,
        html,
        dev: isDev,
        exposeAsTool
      },
      ui: {},
      // mcp-use private extension: props schema for inspector PropsConfigDialog.
      // Not part of SEP-1865; other hosts will ignore this key.
      ...props && Object.keys(props).length > 0 ? { "mcp-use/propsSchema": props } : {},
      ...metadata._meta || {}
    },
    htmlTemplate: html
  };
  if (widgetType === "appsSdk") {
    return {
      ...baseRegistration,
      type: "appsSdk",
      appsSdkMetadata: {
        "openai/widgetDescription": description,
        "openai/toolInvocation/invoking": `Loading ${widgetName}...`,
        "openai/toolInvocation/invoked": `${widgetName} ready`,
        "openai/widgetAccessible": true,
        "openai/resultCanProduceWidget": true,
        "openai/widgetDomain": "https://chatgpt.com",
        // Default domain (required for app submission)
        ...metadata.appsSdkMetadata || {},
        "openai/widgetCSP": {
          connect_domains: [
            // always also add the base url of the server
            ...mcp_connect_domain ? [mcp_connect_domain] : [],
            ...metadata.appsSdkMetadata?.["openai/widgetCSP"]?.connect_domains || []
          ],
          resource_domains: [
            "https://*.oaistatic.com",
            "https://*.oaiusercontent.com",
            ...isDev ? [] : ["https://*.openai.com"],
            // always also add the base url of the server
            ...mcp_connect_domain ? [mcp_connect_domain] : [],
            // add additional CSP URLs from environment variable
            ...serverConfig.cspUrls,
            ...metadata.appsSdkMetadata?.["openai/widgetCSP"]?.resource_domains || []
          ],
          // frame_domains for iframe embeds (optional per OpenAI spec)
          ...metadata.appsSdkMetadata?.["openai/widgetCSP"]?.frame_domains ? {
            frame_domains: metadata.appsSdkMetadata?.["openai/widgetCSP"]?.frame_domains
          } : {},
          // redirect_domains for openExternal redirects (optional per OpenAI spec)
          ...metadata.appsSdkMetadata?.["openai/widgetCSP"]?.redirect_domains ? {
            redirect_domains: metadata.appsSdkMetadata?.["openai/widgetCSP"]?.redirect_domains
          } : {}
        }
      }
    };
  } else {
    return {
      ...baseRegistration,
      type: "mcpApps",
      metadata: {
        description,
        invoking: `Loading ${widgetName}...`,
        invoked: `${widgetName} ready`,
        ...metadata.metadata || {}
      },
      // Include appsSdkMetadata if provided for advanced ChatGPT features
      ...metadata.appsSdkMetadata ? { appsSdkMetadata: metadata.appsSdkMetadata } : {}
    };
  }
}
__name(createWidgetRegistration, "createWidgetRegistration");
async function createWidgetUIResource(definition, params, serverConfig) {
  let configBaseUrl = `http://${serverConfig.serverHost}`;
  let configPort = serverConfig.serverPort || 3e3;
  if (serverConfig.serverBaseUrl) {
    try {
      const url = new URL(serverConfig.serverBaseUrl);
      configBaseUrl = `${url.protocol}//${url.hostname}`;
      configPort = url.port || (url.protocol === "https:" ? 443 : 80);
    } catch (e) {
      console.warn("Failed to parse baseUrl, falling back to host:port", e);
    }
  }
  const urlConfig = {
    baseUrl: configBaseUrl,
    port: configPort,
    buildId: serverConfig.buildId
  };
  const uiResource = await createUIResourceFromDefinition(
    definition,
    params,
    urlConfig
  );
  if (definition._meta && Object.keys(definition._meta).length > 0) {
    const resourceMeta = uiResource.resource._meta ?? {};
    const defMeta = definition._meta;
    const specUiKeys = /* @__PURE__ */ new Set([
      "csp",
      "prefersBorder",
      "domain",
      "permissions"
    ]);
    const defUiFiltered = defMeta.ui ? Object.fromEntries(
      Object.entries(defMeta.ui).filter(([k]) => specUiKeys.has(k))
    ) : void 0;
    const mergedUi = resourceMeta.ui || defUiFiltered ? {
      ...resourceMeta.ui || {},
      ...defUiFiltered || {}
    } : void 0;
    const defMetaPublic = Object.fromEntries(
      Object.entries(defMeta).filter(
        ([k]) => k !== "ui" && k !== "mcp-use/widget"
      )
    );
    uiResource.resource._meta = {
      ...resourceMeta,
      ...defMetaPublic,
      ...mergedUi !== void 0 ? { ui: mergedUi } : {}
    };
  }
  return uiResource;
}
__name(createWidgetUIResource, "createWidgetUIResource");
function ensureWidgetMetadata(metadata, widgetName, widgetDescription) {
  const result = { ...metadata };
  if (!result.description) {
    result.description = widgetDescription || `Widget: ${widgetName}`;
  }
  return result;
}
__name(ensureWidgetMetadata, "ensureWidgetMetadata");
async function readWidgetHtml(filePath, widgetName) {
  try {
    return await fsHelpers.readFileSync(filePath, "utf8");
  } catch (error) {
    console.error(
      `[WIDGET] Failed to read html template for widget ${widgetName}:`,
      error
    );
    return "";
  }
}
__name(readWidgetHtml, "readWidgetHtml");
async function registerWidgetFromTemplate(widgetName, htmlPath, metadata, serverConfig, registerWidget, isDev = false) {
  let html = await readWidgetHtml(htmlPath, widgetName);
  if (!html) {
    return;
  }
  html = processWidgetHtml(html, widgetName, serverConfig.serverBaseUrl);
  const processedMetadata = ensureWidgetMetadata(metadata, widgetName);
  const widgetRegistration = createWidgetRegistration(
    widgetName,
    processedMetadata,
    html,
    serverConfig,
    isDev
  );
  registerWidget(widgetRegistration);
}
__name(registerWidgetFromTemplate, "registerWidgetFromTemplate");
function setupPublicRoutes(app, useDistDirectory = false) {
  app.get("/mcp-use/public/*", async (c) => {
    const filePath = c.req.path.replace("/mcp-use/public/", "");
    const basePath = useDistDirectory ? "dist/public" : "public";
    const fullPath = pathHelpers.join(getCwd(), basePath, filePath);
    try {
      if (await fsHelpers.existsSync(fullPath)) {
        const content = await fsHelpers.readFile(fullPath);
        const contentType = getContentType(filePath);
        return new Response(content, {
          status: 200,
          headers: { "Content-Type": contentType }
        });
      }
      return c.notFound();
    } catch {
      return c.notFound();
    }
  });
}
__name(setupPublicRoutes, "setupPublicRoutes");
function setupFaviconRoute(app, faviconPath, useDistDirectory = false) {
  if (!faviconPath) {
    return;
  }
  app.get("/favicon.ico", async (c) => {
    const basePath = useDistDirectory ? "dist/public" : "public";
    const fullPath = pathHelpers.join(getCwd(), basePath, faviconPath);
    try {
      if (await fsHelpers.existsSync(fullPath)) {
        const content = await fsHelpers.readFile(fullPath);
        const contentType = getContentType(faviconPath);
        return new Response(content, {
          status: 200,
          headers: {
            "Content-Type": contentType,
            "Cache-Control": "public, max-age=31536000"
            // Cache for 1 year
          }
        });
      }
      return c.notFound();
    } catch {
      return c.notFound();
    }
  });
}
__name(setupFaviconRoute, "setupFaviconRoute");

export {
  buildWidgetUrl,
  createExternalUrlResource,
  createRawHtmlResource,
  createRemoteDomResource,
  createMcpAppsResource,
  createUIResourceFromDefinition,
  slugifyWidgetName,
  generateWidgetUri,
  convertPropsToInputs,
  applyDefaultProps,
  readBuildManifest,
  getContentType,
  processWidgetHtml,
  createWidgetRegistration,
  createWidgetUIResource,
  ensureWidgetMetadata,
  readWidgetHtml,
  registerWidgetFromTemplate,
  setupPublicRoutes,
  setupFaviconRoute
};
