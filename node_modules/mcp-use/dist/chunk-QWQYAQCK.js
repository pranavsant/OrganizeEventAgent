import {
  __name
} from "./chunk-3GQAWCBQ.js";

// src/logging.ts
var DEFAULT_LOGGER_NAME = "mcp-use";
function resolveLevel(env) {
  const envValue = typeof process !== "undefined" && process.env ? env : void 0;
  switch (envValue?.trim()) {
    case "2":
      return "debug";
    case "1":
      return "info";
    default:
      return "info";
  }
}
__name(resolveLevel, "resolveLevel");
function formatArgs(args) {
  if (args.length === 0) return "";
  return args.map((arg) => {
    if (typeof arg === "string") return arg;
    try {
      return JSON.stringify(arg);
    } catch {
      return String(arg);
    }
  }).join(" ");
}
__name(formatArgs, "formatArgs");
var SimpleConsoleLogger = class {
  static {
    __name(this, "SimpleConsoleLogger");
  }
  _level;
  name;
  format;
  constructor(name = DEFAULT_LOGGER_NAME, level = "info", format = "minimal") {
    this.name = name;
    this._level = level;
    this.format = format;
  }
  shouldLog(level) {
    if (this._level === "silent") return false;
    const levels = [
      "silent",
      "error",
      "warn",
      "info",
      "http",
      "verbose",
      "debug",
      "silly"
    ];
    const currentIndex = levels.indexOf(this._level);
    const messageIndex = levels.indexOf(level);
    return messageIndex <= currentIndex;
  }
  formatMessage(level, message, args) {
    const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", { hour12: false });
    const extraArgs = formatArgs(args);
    const fullMessage = extraArgs ? `${message} ${extraArgs}` : message;
    switch (this.format) {
      case "detailed":
        return `${timestamp} [${this.name}] ${level.toUpperCase()}: ${fullMessage}`;
      case "emoji": {
        const emojiMap = {
          silent: "",
          error: "\u274C",
          warn: "\u26A0\uFE0F",
          info: "\u2139\uFE0F",
          http: "\u{1F310}",
          verbose: "\u{1F4DD}",
          debug: "\u{1F50D}",
          silly: "\u{1F92A}"
        };
        return `${timestamp} [${this.name}] ${emojiMap[level] || ""} ${level.toUpperCase()}: ${fullMessage}`;
      }
      case "minimal":
      default:
        return `${timestamp} [${this.name}] ${level}: ${fullMessage}`;
    }
  }
  error(message, ...args) {
    if (this.shouldLog("error")) {
      console.error(this.formatMessage("error", message, args));
    }
  }
  warn(message, ...args) {
    if (this.shouldLog("warn")) {
      console.warn(this.formatMessage("warn", message, args));
    }
  }
  info(message, ...args) {
    if (this.shouldLog("info")) {
      console.info(this.formatMessage("info", message, args));
    }
  }
  debug(message, ...args) {
    if (this.shouldLog("debug")) {
      console.debug(this.formatMessage("debug", message, args));
    }
  }
  http(message, ...args) {
    if (this.shouldLog("http")) {
      console.log(this.formatMessage("http", message, args));
    }
  }
  verbose(message, ...args) {
    if (this.shouldLog("verbose")) {
      console.log(this.formatMessage("verbose", message, args));
    }
  }
  silly(message, ...args) {
    if (this.shouldLog("silly")) {
      console.log(this.formatMessage("silly", message, args));
    }
  }
  get level() {
    return this._level;
  }
  set level(newLevel) {
    this._level = newLevel;
  }
  setFormat(format) {
    this.format = format;
  }
};
var Logger = class {
  static {
    __name(this, "Logger");
  }
  static instances = {};
  static currentFormat = "minimal";
  static get(name = DEFAULT_LOGGER_NAME) {
    if (!this.instances[name]) {
      const debugEnv = typeof process !== "undefined" && process.env?.DEBUG || void 0;
      this.instances[name] = new SimpleConsoleLogger(
        name,
        resolveLevel(debugEnv),
        this.currentFormat
      );
    }
    return this.instances[name];
  }
  static configure(options = {}) {
    const { level, format = "minimal" } = options;
    const debugEnv = typeof process !== "undefined" && process.env?.DEBUG || void 0;
    const resolvedLevel = level ?? resolveLevel(debugEnv);
    this.currentFormat = format;
    Object.values(this.instances).forEach((logger2) => {
      logger2.level = resolvedLevel;
      logger2.setFormat(format);
    });
  }
  static setDebug(enabled) {
    let level;
    if (enabled === 2 || enabled === true) level = "debug";
    else if (enabled === 1) level = "info";
    else level = "info";
    Object.values(this.instances).forEach((logger2) => {
      logger2.level = level;
    });
    if (typeof process !== "undefined" && process.env) {
      process.env.DEBUG = enabled ? enabled === true ? "2" : String(enabled) : "0";
    }
  }
  static setFormat(format) {
    this.currentFormat = format;
    this.configure({ format });
  }
};
var logger = Logger.get();

export {
  Logger,
  logger
};
