import {
  ConnectionManager
} from "./chunk-GKPKUKD6.js";
import {
  BaseConnector
} from "./chunk-ZAA33UB5.js";
import {
  Tel,
  getPackageVersion
} from "./chunk-YEK7642C.js";
import {
  logger
} from "./chunk-QWQYAQCK.js";
import {
  __name,
  __require
} from "./chunk-3GQAWCBQ.js";

// src/session.ts
var MCPSession = class {
  static {
    __name(this, "MCPSession");
  }
  /**
   * The underlying connector managing the transport layer.
   * This is the Stdio, HTTP, or WebSocket connector handling actual communication.
   */
  connector;
  /**
   * Whether to automatically connect when initializing.
   * @internal
   */
  autoConnect;
  /**
   * Creates a new MCP session.
   *
   * @param connector - The connector to use for communication (Stdio, HTTP, WebSocket)
   * @param autoConnect - Whether to automatically connect during initialization (default: true)
   *
   * @example
   * ```typescript
   * const connector = new HttpConnector({ url: 'http://localhost:3000/mcp' });
   * const session = new MCPSession(connector);
   * await session.initialize(); // Auto-connects and initializes
   * ```
   *
   * @example
   * ```typescript
   * // Manual connection control
   * const session = new MCPSession(connector, false);
   * await session.connect();
   * await session.initialize();
   * ```
   */
  constructor(connector, autoConnect = true) {
    this.connector = connector;
    this.autoConnect = autoConnect;
  }
  /**
   * Establishes the connection to the MCP server.
   *
   * This method starts the underlying transport (spawns process for Stdio,
   * opens WebSocket, etc.) but does not perform the MCP initialization
   * handshake. Call {@link initialize} after connecting.
   *
   * @returns Promise that resolves when connected
   *
   * @example
   * ```typescript
   * await session.connect();
   * await session.initialize();
   * ```
   *
   * @see {@link initialize} for performing the MCP handshake
   * @see {@link disconnect} for closing the connection
   */
  async connect() {
    await this.connector.connect();
  }
  /**
   * Closes the connection to the MCP server.
   *
   * This method gracefully shuts down the transport and cleans up resources.
   * After disconnecting, the session cannot be used until reconnected.
   *
   * @returns Promise that resolves when disconnected
   *
   * @example
   * ```typescript
   * await session.disconnect();
   * console.log('Session closed');
   * ```
   *
   * @see {@link connect} for establishing connections
   */
  async disconnect() {
    await this.connector.disconnect();
  }
  /**
   * Initializes the MCP session with the server.
   *
   * This method performs the MCP initialization handshake, exchanging
   * capabilities and metadata with the server. If `autoConnect` is true
   * and the session is not yet connected, it will connect first.
   *
   * After initialization, you can list and call tools, read resources, etc.
   *
   * @returns Promise that resolves when initialized
   *
   * @example
   * ```typescript
   * const session = await client.createSession('my-server', false);
   * await session.connect();
   * await session.initialize();
   * // Now ready to use
   * const tools = await session.listTools();
   * ```
   *
   * @see {@link connect} for establishing the connection first
   */
  async initialize() {
    if (!this.isConnected && this.autoConnect) {
      await this.connect();
    }
    await this.connector.initialize();
  }
  /**
   * Checks if the session is currently connected to the server.
   *
   * @returns True if connected, false otherwise
   *
   * @example
   * ```typescript
   * if (session.isConnected) {
   *   const tools = await session.listTools();
   * }
   * ```
   */
  get isConnected() {
    return this.connector && this.connector.isClientConnected;
  }
  /**
   * Register an event handler for session events
   *
   * @param event - The event type to listen for
   * @param handler - The handler function to call when the event occurs
   *
   * @example
   * ```typescript
   * session.on("notification", async (notification) => {
   *   console.log(`Received: ${notification.method}`, notification.params);
   *
   *   if (notification.method === "notifications/tools/list_changed") {
   *     // Refresh tools list
   *   }
   * });
   * ```
   */
  on(event, handler) {
    if (event === "notification") {
      this.connector.onNotification(handler);
    }
  }
  /**
   * Set roots and notify the server.
   * Roots represent directories or files that the client has access to.
   *
   * @param roots - Array of Root objects with `uri` (must start with "file://") and optional `name`
   *
   * @example
   * ```typescript
   * await session.setRoots([
   *   { uri: "file:///home/user/project", name: "My Project" },
   *   { uri: "file:///home/user/data" }
   * ]);
   * ```
   */
  async setRoots(roots) {
    return this.connector.setRoots(roots);
  }
  /**
   * Gets the current roots advertised to the server.
   *
   * Roots represent directories or files that the client has provided access to.
   * The server may use this information to scope its operations.
   *
   * @returns Array of Root objects
   *
   * @example
   * ```typescript
   * const roots = session.getRoots();
   * console.log(`Current roots: ${roots.map(r => r.uri).join(', ')}`);
   * ```
   *
   * @see {@link setRoots} for updating roots
   */
  getRoots() {
    return this.connector.getRoots();
  }
  /**
   * Get the cached list of tools from the server.
   *
   * @returns Array of available tools
   *
   * @example
   * ```typescript
   * const tools = session.tools;
   * console.log(`Available tools: ${tools.map(t => t.name).join(", ")}`);
   * ```
   */
  get tools() {
    return this.connector.tools;
  }
  /**
   * List all available tools from the MCP server.
   * This method fetches fresh tools from the server, unlike the `tools` getter which returns cached tools.
   *
   * @param options - Optional request options
   * @returns Array of available tools
   *
   * @example
   * ```typescript
   * const tools = await session.listTools();
   * console.log(`Available tools: ${tools.map(t => t.name).join(", ")}`);
   * ```
   */
  async listTools(options) {
    return this.connector.listTools(options);
  }
  /**
   * Get the server capabilities advertised during initialization.
   *
   * @returns Server capabilities object
   */
  get serverCapabilities() {
    return this.connector.serverCapabilities;
  }
  /**
   * Get the server information (name and version).
   *
   * @returns Server info object or null if not available
   */
  get serverInfo() {
    return this.connector.serverInfo;
  }
  /**
   * Call a tool on the server.
   *
   * @param name - Name of the tool to call
   * @param args - Arguments to pass to the tool (defaults to empty object)
   * @param options - Optional request options (timeout, progress handlers, etc.)
   * @returns Result from the tool execution
   *
   * @example
   * ```typescript
   * const result = await session.callTool("add", { a: 5, b: 3 });
   * console.log(`Result: ${result.content[0].text}`);
   * ```
   */
  async callTool(name, args = {}, options) {
    return this.connector.callTool(name, args, options);
  }
  /**
   * List resources from the server with optional pagination.
   *
   * @param cursor - Optional cursor for pagination
   * @param options - Request options
   * @returns Resource list with optional nextCursor for pagination
   *
   * @example
   * ```typescript
   * const result = await session.listResources();
   * console.log(`Found ${result.resources.length} resources`);
   * ```
   */
  async listResources(cursor, options) {
    return this.connector.listResources(cursor, options);
  }
  /**
   * List all resources from the server, automatically handling pagination.
   *
   * @param options - Request options
   * @returns Complete list of all resources
   *
   * @example
   * ```typescript
   * const result = await session.listAllResources();
   * console.log(`Total resources: ${result.resources.length}`);
   * ```
   */
  async listAllResources(options) {
    return this.connector.listAllResources(options);
  }
  /**
   * List resource templates from the server.
   *
   * @param options - Request options
   * @returns List of available resource templates
   *
   * @example
   * ```typescript
   * const result = await session.listResourceTemplates();
   * console.log(`Available templates: ${result.resourceTemplates.length}`);
   * ```
   */
  async listResourceTemplates(options) {
    return this.connector.listResourceTemplates(options);
  }
  /**
   * Read a resource by URI.
   *
   * @param uri - URI of the resource to read
   * @param options - Request options
   * @returns Resource content
   *
   * @example
   * ```typescript
   * const resource = await session.readResource("file:///path/to/file.txt");
   * console.log(resource.contents);
   * ```
   */
  async readResource(uri, options) {
    return this.connector.readResource(uri, options);
  }
  /**
   * Subscribe to resource updates.
   *
   * @param uri - URI of the resource to subscribe to
   * @param options - Request options
   *
   * @example
   * ```typescript
   * await session.subscribeToResource("file:///path/to/file.txt");
   * // Now you'll receive notifications when this resource changes
   * ```
   */
  async subscribeToResource(uri, options) {
    return this.connector.subscribeToResource(uri, options);
  }
  /**
   * Unsubscribe from resource updates.
   *
   * @param uri - URI of the resource to unsubscribe from
   * @param options - Request options
   *
   * @example
   * ```typescript
   * await session.unsubscribeFromResource("file:///path/to/file.txt");
   * ```
   */
  async unsubscribeFromResource(uri, options) {
    return this.connector.unsubscribeFromResource(uri, options);
  }
  /**
   * List available prompts from the server.
   *
   * @returns List of available prompts
   *
   * @example
   * ```typescript
   * const result = await session.listPrompts();
   * console.log(`Available prompts: ${result.prompts.length}`);
   * ```
   */
  async listPrompts() {
    return this.connector.listPrompts();
  }
  /**
   * Get a specific prompt with arguments.
   *
   * @param name - Name of the prompt to get
   * @param args - Arguments for the prompt
   * @returns Prompt result
   *
   * @example
   * ```typescript
   * const prompt = await session.getPrompt("greeting", { name: "Alice" });
   * console.log(prompt.messages);
   * ```
   */
  async getPrompt(name, args) {
    return this.connector.getPrompt(name, args);
  }
  /**
   * Send a raw request through the client.
   *
   * @param method - MCP method name
   * @param params - Request parameters
   * @param options - Request options
   * @returns Response from the server
   *
   * @example
   * ```typescript
   * const result = await session.request("custom/method", { key: "value" });
   * ```
   */
  async request(method, params = null, options) {
    return this.connector.request(method, params, options);
  }
};

// src/client/base.ts
var BaseMCPClient = class {
  static {
    __name(this, "BaseMCPClient");
  }
  /**
   * Internal configuration object containing MCP server definitions.
   * @protected
   */
  config = {};
  /**
   * Map of server names to their active sessions.
   * @protected
   */
  sessions = {};
  /**
   * List of server names that have active sessions.
   * This array is kept in sync with the sessions map and can be used
   * to iterate over active connections.
   *
   * @example
   * ```typescript
   * console.log(`Active servers: ${client.activeSessions.join(', ')}`);
   * ```
   */
  activeSessions = [];
  /**
   * Creates a new BaseMCPClient instance.
   *
   * @param config - Optional configuration object with MCP server definitions
   *
   * @example
   * ```typescript
   * const client = new MCPClient({
   *   mcpServers: {
   *     'example': {
   *       command: 'node',
   *       args: ['server.js']
   *     }
   *   }
   * });
   * ```
   */
  constructor(config) {
    if (config) {
      this.config = config;
    }
  }
  /**
   * Creates a client instance from a configuration dictionary.
   *
   * This static factory method must be implemented by concrete subclasses
   * to provide proper type information and platform-specific initialization.
   *
   * @param _cfg - Configuration dictionary
   * @returns Client instance
   * @throws {Error} If called on the base class instead of a concrete implementation
   *
   * @example
   * ```typescript
   * const client = MCPClient.fromDict({
   *   mcpServers: {
   *     'my-server': { command: 'node', args: ['server.js'] }
   *   }
   * });
   * ```
   */
  static fromDict(_cfg) {
    throw new Error("fromDict must be implemented by concrete class");
  }
  /**
   * Adds a new MCP server configuration to the client.
   *
   * This method adds or updates a server configuration dynamically without
   * needing to restart the client. The server can then be used to create
   * new sessions.
   *
   * @param name - Unique name for the server
   * @param serverConfig - Server configuration object (connector type, command, args, etc.)
   *
   * @example
   * ```typescript
   * client.addServer('new-server', {
   *   command: 'python',
   *   args: ['server.py']
   * });
   *
   * // Now you can create a session
   * const session = await client.createSession('new-server');
   * ```
   *
   * @see {@link removeServer} for removing servers
   * @see {@link getServerConfig} for retrieving configurations
   */
  addServer(name, serverConfig) {
    this.config.mcpServers = this.config.mcpServers || {};
    this.config.mcpServers[name] = serverConfig;
    Tel.getInstance().trackClientAddServer(name, serverConfig);
  }
  /**
   * Removes an MCP server configuration from the client.
   *
   * This method removes a server configuration and cleans up any active
   * sessions associated with that server. If there's an active session,
   * it will be removed from the active sessions list.
   *
   * @param name - Name of the server to remove
   *
   * @example
   * ```typescript
   * // Remove a server configuration
   * client.removeServer('old-server');
   *
   * // The server name will no longer appear in getServerNames()
   * console.log(client.getServerNames()); // 'old-server' is gone
   * ```
   *
   * @see {@link addServer} for adding servers
   * @see {@link closeSession} for properly closing sessions before removal
   */
  removeServer(name) {
    if (this.config.mcpServers?.[name]) {
      delete this.config.mcpServers[name];
      this.activeSessions = this.activeSessions.filter((n) => n !== name);
      Tel.getInstance().trackClientRemoveServer(name);
    }
  }
  /**
   * Gets the names of all configured MCP servers.
   *
   * @returns Array of server names defined in the configuration
   *
   * @example
   * ```typescript
   * const serverNames = client.getServerNames();
   * console.log(`Configured servers: ${serverNames.join(', ')}`);
   *
   * // Create sessions for all servers
   * for (const name of serverNames) {
   *   await client.createSession(name);
   * }
   * ```
   *
   * @see {@link activeSessions} for servers with active sessions
   */
  getServerNames() {
    return Object.keys(this.config.mcpServers ?? {});
  }
  /**
   * Gets the configuration for a specific MCP server.
   *
   * @param name - Name of the server
   * @returns Server configuration object, or undefined if not found
   *
   * @example
   * ```typescript
   * const config = client.getServerConfig('my-server');
   * if (config) {
   *   console.log(`Command: ${config.command}`);
   *   console.log(`Args: ${config.args.join(' ')}`);
   * }
   * ```
   *
   * @see {@link getConfig} for retrieving the entire configuration
   */
  getServerConfig(name) {
    return this.config.mcpServers?.[name];
  }
  /**
   * Gets the complete client configuration.
   *
   * @returns Complete configuration object including all server definitions
   *
   * @example
   * ```typescript
   * const config = client.getConfig();
   * console.log(`Total servers: ${Object.keys(config.mcpServers).length}`);
   * ```
   *
   * @see {@link getServerConfig} for retrieving individual server configurations
   */
  getConfig() {
    return this.config ?? {};
  }
  /**
   * Creates a new session for connecting to an MCP server.
   *
   * This method initializes a connection to the specified server using the
   * configuration provided during client construction. Sessions manage the
   * lifecycle of connections and provide methods for calling tools, listing
   * resources, and more.
   *
   * If a session already exists for the server, it will be replaced with a new one.
   *
   * @param serverName - The name of the server as defined in the client configuration
   * @param autoInitialize - Whether to automatically initialize the session (default: true)
   * @returns A promise that resolves to the created MCPSession instance
   * @throws {Error} If the server is not found in the configuration
   *
   * @example
   * ```typescript
   * // Create and initialize a session
   * const session = await client.createSession('my-server');
   * const tools = await session.listTools();
   *
   * // Create without auto-initialization
   * const session = await client.createSession('my-server', false);
   * await session.connect();
   * await session.initialize();
   * ```
   *
   * @see {@link MCPSession} for session management methods
   * @see {@link closeSession} for closing sessions
   * @see {@link getSession} for retrieving existing sessions
   */
  async createSession(serverName, autoInitialize = true) {
    const servers = this.config.mcpServers ?? {};
    if (Object.keys(servers).length === 0) {
      logger.warn("No MCP servers defined in config");
    }
    if (!servers[serverName]) {
      throw new Error(`Server '${serverName}' not found in config`);
    }
    const connector = await Promise.resolve(
      this.createConnectorFromConfig(servers[serverName])
    );
    const session = new MCPSession(connector);
    if (autoInitialize) {
      await session.initialize();
    }
    this.sessions[serverName] = session;
    if (!this.activeSessions.includes(serverName)) {
      this.activeSessions.push(serverName);
    }
    return session;
  }
  /**
   * Creates sessions for all configured MCP servers.
   *
   * This is a convenience method that iterates through all servers in the
   * configuration and creates a session for each one. Sessions are created
   * sequentially to avoid overwhelming the system.
   *
   * @param autoInitialize - Whether to automatically initialize each session (default: true)
   * @returns A promise that resolves to a map of server names to sessions
   *
   * @example
   * ```typescript
   * // Create sessions for all configured servers
   * const sessions = await client.createAllSessions();
   * console.log(`Created ${Object.keys(sessions).length} sessions`);
   *
   * // List tools from all servers
   * for (const [name, session] of Object.entries(sessions)) {
   *   const tools = await session.listTools();
   *   console.log(`${name}: ${tools.length} tools`);
   * }
   * ```
   *
   * @see {@link createSession} for creating individual sessions
   * @see {@link closeAllSessions} for closing all sessions
   */
  async createAllSessions(autoInitialize = true) {
    const servers = this.config.mcpServers ?? {};
    if (Object.keys(servers).length === 0) {
      logger.warn("No MCP servers defined in config");
    }
    for (const name of Object.keys(servers)) {
      await this.createSession(name, autoInitialize);
    }
    return this.sessions;
  }
  /**
   * Retrieves an existing session by server name.
   *
   * This method returns null if no session exists, making it safe for
   * checking session existence without throwing errors.
   *
   * @param serverName - Name of the server
   * @returns The session instance or null if not found
   *
   * @example
   * ```typescript
   * const session = client.getSession('my-server');
   * if (session) {
   *   const tools = await session.listTools();
   * } else {
   *   console.log('Session not found, creating...');
   *   await client.createSession('my-server');
   * }
   * ```
   *
   * @see {@link requireSession} for getting a session that throws if not found
   * @see {@link createSession} for creating sessions
   */
  getSession(serverName) {
    const session = this.sessions[serverName];
    if (!session) {
      return null;
    }
    return session;
  }
  /**
   * Retrieves an existing session by server name, throwing if not found.
   *
   * This method is useful when you need to ensure a session exists before
   * proceeding. It throws a descriptive error if the session is not found.
   *
   * @param serverName - Name of the server
   * @returns The session instance
   * @throws {Error} If the session is not found
   *
   * @example
   * ```typescript
   * try {
   *   const session = client.requireSession('my-server');
   *   const tools = await session.listTools();
   * } catch (error) {
   *   console.error('Session not found:', error.message);
   * }
   * ```
   *
   * @see {@link getSession} for a null-returning alternative
   * @see {@link createSession} for creating sessions
   */
  requireSession(serverName) {
    const session = this.sessions[serverName];
    if (!session) {
      throw new Error(
        `Session '${serverName}' not found. Available sessions: ${this.activeSessions.join(", ") || "none"}`
      );
    }
    return session;
  }
  /**
   * Gets all active sessions as a map of server names to sessions.
   *
   * @returns Map of server names to their active sessions
   *
   * @example
   * ```typescript
   * const sessions = client.getAllActiveSessions();
   *
   * // Iterate over all active sessions
   * for (const [name, session] of Object.entries(sessions)) {
   *   console.log(`Server: ${name}`);
   *   const tools = await session.listTools();
   *   console.log(`  Tools: ${tools.length}`);
   * }
   * ```
   *
   * @see {@link activeSessions} for just the list of server names
   * @see {@link getSession} for retrieving individual sessions
   */
  getAllActiveSessions() {
    return Object.fromEntries(
      this.activeSessions.map((n) => [n, this.sessions[n]])
    );
  }
  /**
   * Closes a session and cleans up its resources.
   *
   * This method gracefully disconnects from the server and removes the
   * session from the active sessions list. It's safe to call even if
   * the session doesn't exist.
   *
   * @param serverName - Name of the server whose session should be closed
   *
   * @example
   * ```typescript
   * // Close a specific session
   * await client.closeSession('my-server');
   *
   * // Verify it's closed
   * console.log(client.activeSessions.includes('my-server')); // false
   * ```
   *
   * @see {@link closeAllSessions} for closing all sessions at once
   * @see {@link createSession} for creating new sessions
   */
  async closeSession(serverName) {
    const session = this.sessions[serverName];
    if (!session) {
      logger.warn(
        `No session exists for server ${serverName}, nothing to close`
      );
      return;
    }
    try {
      logger.debug(`Closing session for server ${serverName}`);
      await session.disconnect();
    } catch (e) {
      logger.error(`Error closing session for server '${serverName}': ${e}`);
    } finally {
      delete this.sessions[serverName];
      this.activeSessions = this.activeSessions.filter((n) => n !== serverName);
    }
  }
  /**
   * Closes all active sessions and cleans up their resources.
   *
   * This method iterates through all sessions and attempts to close each one
   * gracefully. If any session fails to close, the error is logged but the
   * method continues to close remaining sessions.
   *
   * This is particularly useful for cleanup on application shutdown.
   *
   * @example
   * ```typescript
   * // Clean shutdown
   * try {
   *   await client.closeAllSessions();
   *   console.log('All sessions closed successfully');
   * } catch (error) {
   *   console.error('Error during cleanup:', error);
   * }
   * ```
   *
   * @example
   * ```typescript
   * // Use in application shutdown handler
   * process.on('SIGINT', async () => {
   *   console.log('Shutting down...');
   *   await client.closeAllSessions();
   *   process.exit(0);
   * });
   * ```
   *
   * @see {@link closeSession} for closing individual sessions
   * @see {@link createAllSessions} for creating sessions
   */
  async closeAllSessions() {
    const serverNames = Object.keys(this.sessions);
    const errors = [];
    for (const serverName of serverNames) {
      try {
        logger.debug(`Closing session for server ${serverName}`);
        await this.closeSession(serverName);
      } catch (e) {
        const errorMsg = `Failed to close session for server '${serverName}': ${e}`;
        logger.error(errorMsg);
        errors.push(errorMsg);
      }
    }
    if (errors.length) {
      logger.error(
        `Encountered ${errors.length} errors while closing sessions`
      );
    } else {
      logger.debug("All sessions closed successfully");
    }
  }
};

// src/connectors/http.ts
import {
  Client
} from "@modelcontextprotocol/sdk/client/index.js";
import {
  StreamableHTTPClientTransport,
  StreamableHTTPError
} from "@modelcontextprotocol/sdk/client/streamableHttp.js";

// src/task_managers/sse.ts
import { SSEClientTransport } from "@modelcontextprotocol/sdk/client/sse.js";
var SseConnectionManager = class extends ConnectionManager {
  static {
    __name(this, "SseConnectionManager");
  }
  url;
  opts;
  _transport = null;
  reinitializing = false;
  /**
   * Create an SSE connection manager.
   *
   * @param url  The SSE endpoint URL.
   * @param opts Optional transport options (auth, headers, etc.).
   */
  constructor(url, opts) {
    super();
    this.url = typeof url === "string" ? new URL(url) : url;
    this.opts = opts;
  }
  /**
   * Spawn a new `SSEClientTransport` and wrap it with 404 handling.
   * Per MCP spec, clients MUST re-initialize when receiving 404 for stale sessions.
   */
  async establishConnection() {
    const transport = new SSEClientTransport(this.url, this.opts);
    const originalSend = transport.send.bind(transport);
    transport.send = async (message) => {
      const sendMessage = /* @__PURE__ */ __name(async (msg) => {
        if (Array.isArray(msg)) {
          for (const singleMsg of msg) {
            await originalSend(singleMsg);
          }
        } else {
          await originalSend(msg);
        }
      }, "sendMessage");
      try {
        await sendMessage(message);
      } catch (error) {
        if (error?.code === 404 && transport.sessionId && !this.reinitializing) {
          logger.warn(
            `[SSE] Session not found (404), re-initializing per MCP spec...`
          );
          this.reinitializing = true;
          try {
            transport.sessionId = void 0;
            await this.reinitialize(transport);
            logger.info(`[SSE] Re-initialization successful, retrying request`);
            await sendMessage(message);
          } finally {
            this.reinitializing = false;
          }
        } else {
          throw error;
        }
      }
    };
    this._transport = transport;
    logger.debug(`${this.constructor.name} connected successfully`);
    return transport;
  }
  /**
   * Re-initialize the transport with a new session
   * This is called when the server returns 404 for a stale session
   */
  async reinitialize(transport) {
    logger.debug(`[SSE] Re-initialization triggered`);
  }
  /**
   * Close the underlying transport and clean up resources.
   */
  async closeConnection(_connection) {
    if (this._transport) {
      try {
        await this._transport.close();
      } catch (e) {
        logger.warn(`Error closing SSE transport: ${e}`);
      } finally {
        this._transport = null;
      }
    }
  }
};

// src/connectors/http.ts
var HttpConnector = class extends BaseConnector {
  static {
    __name(this, "HttpConnector");
  }
  baseUrl;
  headers;
  timeout;
  sseReadTimeout;
  customFetch;
  clientInfo;
  preferSse;
  disableSseFallback;
  gatewayUrl;
  serverId;
  transportType = null;
  streamableTransport = null;
  constructor(baseUrl, opts = {}) {
    super(opts);
    const originalUrl = baseUrl.replace(/\/$/, "");
    this.gatewayUrl = opts.gatewayUrl;
    this.serverId = opts.serverId;
    if (this.gatewayUrl) {
      this.baseUrl = this.gatewayUrl.replace(/\/$/, "");
      this.headers = { ...opts.headers ?? {} };
      this.headers["X-Target-URL"] = originalUrl;
      if (this.serverId) {
        this.headers["X-Server-Id"] = this.serverId;
      }
    } else {
      this.baseUrl = originalUrl;
      this.headers = { ...opts.headers ?? {} };
    }
    if (opts.authToken) {
      this.headers.Authorization = `Bearer ${opts.authToken}`;
    }
    this.timeout = opts.timeout ?? 1e4;
    this.sseReadTimeout = opts.sseReadTimeout ?? 3e5;
    this.customFetch = opts.fetch;
    this.clientInfo = opts.clientInfo ?? {
      name: "http-connector",
      version: "1.0.0"
    };
    this.preferSse = opts.preferSse ?? false;
    this.disableSseFallback = opts.disableSseFallback ?? false;
  }
  buildClientOptions() {
    return {
      ...this.opts.clientOptions || {},
      capabilities: {
        ...this.opts.clientOptions?.capabilities || {},
        roots: { listChanged: true },
        ...this.opts.onSampling ? { sampling: {} } : {},
        ...this.opts.onElicitation ?? this.opts.elicitationCallback ? { elicitation: { form: {}, url: {} } } : {}
      }
    };
  }
  unwrapStreamableError(err) {
    if (err instanceof StreamableHTTPError) {
      return err;
    }
    if (err instanceof Error && err.cause instanceof StreamableHTTPError) {
      return err.cause;
    }
    return null;
  }
  classifyStreamableHttpFailure(err) {
    let fallbackReason = "Unknown error";
    let is401Error = false;
    let httpStatusCode;
    const streamableErr = this.unwrapStreamableError(err);
    if (streamableErr) {
      is401Error = streamableErr.code === 401;
      httpStatusCode = streamableErr.code;
      if (streamableErr.code === 400 && streamableErr.message.includes("Missing session ID")) {
        fallbackReason = "Server requires session ID (FastMCP compatibility) - using SSE transport";
        logger.warn(`\u26A0\uFE0F  ${fallbackReason}`);
      } else if (streamableErr.code === 404 || streamableErr.code === 405) {
        fallbackReason = `Server returned ${streamableErr.code} - server likely doesn't support streamable HTTP`;
        logger.debug(fallbackReason);
      } else {
        fallbackReason = `Server returned ${streamableErr.code}: ${streamableErr.message}`;
        logger.debug(fallbackReason);
      }
      return { fallbackReason, is401Error, httpStatusCode };
    }
    if (err instanceof Error) {
      const errorStr = err.toString();
      const errorMsg = err.message || "";
      is401Error = errorStr.includes("401") || errorMsg.includes("Unauthorized");
      if (errorStr.includes("Missing session ID") || errorStr.includes("Bad Request: Missing session ID") || errorMsg.includes("FastMCP session ID error")) {
        fallbackReason = "Server requires session ID (FastMCP compatibility) - using SSE transport";
        logger.warn(`\u26A0\uFE0F  ${fallbackReason}`);
      } else if (errorStr.includes("405 Method Not Allowed") || errorStr.includes("404 Not Found")) {
        fallbackReason = "Server doesn't support streamable HTTP (405/404)";
        logger.debug(fallbackReason);
      } else {
        fallbackReason = `Streamable HTTP failed: ${err.message}`;
        logger.debug(fallbackReason);
      }
    }
    return { fallbackReason, is401Error, httpStatusCode };
  }
  /** Establish connection to the MCP implementation via HTTP (streamable or SSE). */
  async connect() {
    if (this.connected) {
      logger.debug("Already connected to MCP implementation");
      return;
    }
    const baseUrl = this.baseUrl;
    if (this.preferSse) {
      logger.debug(`Connecting to MCP implementation via HTTP/SSE: ${baseUrl}`);
      await this.connectWithSse(baseUrl);
      return;
    }
    logger.debug(`Connecting to MCP implementation via HTTP: ${baseUrl}`);
    try {
      logger.info("\u{1F504} Attempting streamable HTTP transport...");
      await this.connectWithStreamableHttp(baseUrl);
      logger.info("\u2705 Successfully connected via streamable HTTP");
    } catch (err) {
      logger.debug("Streamable HTTP connect failed", err);
      const { fallbackReason, is401Error, httpStatusCode } = this.classifyStreamableHttpFailure(err);
      if (is401Error) {
        logger.info("Authentication required - skipping SSE fallback");
        await this.cleanupResources();
        const authError = new Error("Authentication required");
        authError.code = 401;
        throw authError;
      }
      if (this.disableSseFallback) {
        logger.info("SSE fallback disabled - failing connection");
        await this.cleanupResources();
        throw new Error(`Streamable HTTP connection failed: ${fallbackReason}`);
      }
      logger.info("\u{1F504} Falling back to SSE transport...");
      try {
        await this.connectWithSse(baseUrl);
      } catch (sseErr) {
        logger.error("Failed to connect with both transports:");
        logger.error(`  Streamable HTTP: ${fallbackReason}`);
        logger.error(`  SSE: ${sseErr}`);
        await this.cleanupResources();
        const sseIs401 = sseErr?.message?.includes("401") || sseErr?.message?.includes("Unauthorized");
        if (sseIs401) {
          const authError = new Error("Authentication required");
          authError.code = 401;
          throw authError;
        }
        const finalError = new Error(
          `Could not connect to server with any available transport. Streamable HTTP: ${fallbackReason}`
        );
        if (httpStatusCode !== void 0) {
          Object.defineProperty(finalError, "code", {
            value: httpStatusCode,
            writable: false,
            enumerable: true,
            configurable: true
          });
          logger.debug(
            `Preserving HTTP status code ${httpStatusCode} in error for proxy fallback detection`
          );
        }
        throw finalError;
      }
    }
  }
  async connectWithStreamableHttp(baseUrl) {
    try {
      logger.debug("[HttpConnector] Connecting with Streamable HTTP", {
        baseUrl,
        originalUrl: this.baseUrl,
        gatewayUrl: this.gatewayUrl || "none",
        authProviderUrl: this.opts.authProvider?.serverUrl || "none",
        headers: this.headers
      });
      const streamableTransport = new StreamableHTTPClientTransport(
        new URL(baseUrl),
        {
          authProvider: this.opts.authProvider,
          // ← Pass OAuth provider to SDK
          fetch: this.customFetch,
          requestInit: {
            headers: this.headers
          },
          // Pass through reconnection options
          reconnectionOptions: {
            maxReconnectionDelay: 3e4,
            initialReconnectionDelay: 1e3,
            reconnectionDelayGrowFactor: 1.5,
            maxRetries: 2
            // Disable automatic reconnection - let higher-level logic handle it
          }
          // Don't pass sessionId - let the SDK generate it automatically during connect()
        }
      );
      let transport = streamableTransport;
      if (this.opts.wrapTransport) {
        const serverId = this.baseUrl;
        transport = this.opts.wrapTransport(
          transport,
          serverId
        );
      }
      const clientOptions = this.buildClientOptions();
      logger.debug(
        `Creating Client with capabilities:`,
        JSON.stringify(clientOptions.capabilities, null, 2)
      );
      this.client = new Client(this.clientInfo, clientOptions);
      this.setupRootsHandler();
      logger.debug("Roots handler registered before connect");
      try {
        await this.client.connect(transport, {
          timeout: this.timeout
        });
        const sessionId = streamableTransport.sessionId;
        if (sessionId) {
          logger.debug(`Session ID obtained: ${sessionId}`);
        } else {
          logger.warn(
            "Session ID not available after connect - this may cause issues with SSE stream"
          );
        }
      } catch (connectErr) {
        if (connectErr instanceof Error) {
          const errMsg = connectErr.message || connectErr.toString();
          if (errMsg.includes("Missing session ID") || errMsg.includes("Bad Request: Missing session ID") || errMsg.includes("Mcp-Session-Id header is required")) {
            const wrappedError = new Error(
              `Session ID error: ${errMsg}. The SDK should automatically extract session ID from initialize response.`
            );
            wrappedError.cause = connectErr;
            throw wrappedError;
          }
        }
        throw connectErr;
      }
      this.streamableTransport = streamableTransport;
      this.connectionManager = {
        stop: /* @__PURE__ */ __name(async () => {
          if (this.streamableTransport) {
            try {
              await this.streamableTransport.terminateSession();
              await this.streamableTransport.close();
            } catch (e) {
              logger.warn(`Error closing Streamable HTTP transport: ${e}`);
            } finally {
              this.streamableTransport = null;
            }
          }
        }, "stop")
      };
      this.connected = true;
      this.transportType = "streamable-http";
      this.setupNotificationHandler();
      this.setupSamplingHandler();
      this.setupElicitationHandler();
      logger.debug(
        `Successfully connected to MCP implementation via streamable HTTP: ${baseUrl}`
      );
      this.trackConnectorInit({
        serverUrl: this.baseUrl,
        publicIdentifier: `${this.baseUrl} (streamable-http)`
      });
    } catch (err) {
      await this.cleanupResources();
      throw err;
    }
  }
  async connectWithSse(baseUrl) {
    try {
      this.connectionManager = new SseConnectionManager(baseUrl, {
        authProvider: this.opts.authProvider,
        // ← Pass OAuth provider to SDK (same as streamable HTTP)
        requestInit: {
          headers: this.headers
        }
      });
      let transport = await this.connectionManager.start();
      if (this.opts.wrapTransport) {
        const serverId = this.baseUrl;
        transport = this.opts.wrapTransport(transport, serverId);
      }
      const clientOptions = this.buildClientOptions();
      logger.debug(
        `Creating Client with capabilities (SSE):`,
        JSON.stringify(clientOptions.capabilities, null, 2)
      );
      this.client = new Client(this.clientInfo, clientOptions);
      this.setupRootsHandler();
      logger.debug("Roots handler registered before connect (SSE)");
      await this.client.connect(transport);
      this.connected = true;
      this.transportType = "sse";
      this.setupNotificationHandler();
      this.setupSamplingHandler();
      this.setupElicitationHandler();
      logger.debug(
        `Successfully connected to MCP implementation via HTTP/SSE: ${baseUrl}`
      );
      this.trackConnectorInit({
        serverUrl: this.baseUrl,
        publicIdentifier: `${this.baseUrl} (sse)`
      });
    } catch (err) {
      await this.cleanupResources();
      throw err;
    }
  }
  get publicIdentifier() {
    return {
      type: "http",
      url: this.baseUrl,
      transport: this.transportType || "unknown"
    };
  }
  /**
   * Get the transport type being used (streamable-http or sse)
   */
  getTransportType() {
    return this.transportType;
  }
};

// src/config.ts
function resolveCallbacks(perServer, globalDefaults) {
  const pickSampling = perServer?.onSampling ?? perServer?.samplingCallback ?? globalDefaults?.onSampling ?? globalDefaults?.samplingCallback;
  const pickElicitation = perServer?.onElicitation ?? perServer?.elicitationCallback ?? globalDefaults?.onElicitation ?? globalDefaults?.elicitationCallback;
  const pickNotification = perServer?.onNotification ?? globalDefaults?.onNotification;
  return {
    onSampling: pickSampling,
    onElicitation: pickElicitation,
    onNotification: pickNotification
  };
}
__name(resolveCallbacks, "resolveCallbacks");
function getDefaultClientInfo() {
  return {
    name: "mcp-use",
    title: "mcp-use",
    version: getPackageVersion(),
    description: "mcp-use is a complete TypeScript framework for building and using MCP",
    icons: [
      {
        src: "https://mcp-use.com/logo.png"
      }
    ],
    websiteUrl: "https://mcp-use.com"
  };
}
__name(getDefaultClientInfo, "getDefaultClientInfo");
function normalizeClientInfo(input) {
  const fallback = getDefaultClientInfo();
  if (!input || typeof input !== "object") return fallback;
  const ci = input;
  if (!ci.name || !ci.version) return fallback;
  return { ...fallback, ...ci };
}
__name(normalizeClientInfo, "normalizeClientInfo");
function loadConfigFile(filepath) {
  const { readFileSync } = __require("fs");
  const raw = readFileSync(filepath, "utf-8");
  return JSON.parse(raw);
}
__name(loadConfigFile, "loadConfigFile");
function createConnectorFromConfig(serverConfig, connectorOptions) {
  const clientInfo = normalizeClientInfo(serverConfig.clientInfo);
  if ("command" in serverConfig && "args" in serverConfig) {
    throw new Error(
      "Stdio connector is not supported in this environment. Stdio connections require Node.js and are only available in the Node.js MCPClient."
    );
  }
  if ("url" in serverConfig) {
    const transport = serverConfig.transport || "http";
    return new HttpConnector(serverConfig.url, {
      headers: serverConfig.headers,
      fetch: serverConfig.fetch,
      authToken: serverConfig.auth_token || serverConfig.authToken,
      authProvider: serverConfig.authProvider,
      // Only force SSE if explicitly requested
      preferSse: serverConfig.preferSse || transport === "sse",
      // Disable SSE fallback if explicitly disabled in config
      disableSseFallback: serverConfig.disableSseFallback,
      clientInfo,
      ...connectorOptions
    });
  }
  throw new Error("Cannot determine connector type from config");
}
__name(createConnectorFromConfig, "createConnectorFromConfig");

export {
  MCPSession,
  BaseMCPClient,
  HttpConnector,
  resolveCallbacks,
  normalizeClientInfo,
  loadConfigFile,
  createConnectorFromConfig
};
