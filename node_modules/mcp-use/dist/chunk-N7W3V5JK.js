import {
  __name
} from "./chunk-3GQAWCBQ.js";

// src/server/utils/tool-registry-generator.ts
import { writeFile, mkdir, readFile } from "fs/promises";
import { join } from "path";

// src/server/utils/zod-to-ts.ts
function zodToTypeString(schema) {
  const schemaAny = schema;
  const def = schemaAny._def || schemaAny.def || {};
  let typeName = def.typeName || def.type || schemaAny.type || (schemaAny._type ? `Zod${schemaAny._type.charAt(0).toUpperCase()}${schemaAny._type.slice(1)}` : void 0);
  let hasShape = false;
  try {
    hasShape = !!(def.shape || schemaAny.shape);
  } catch {
  }
  if (!typeName && hasShape) {
    typeName = "ZodObject";
  }
  const normalizedType = typeName?.startsWith?.("Zod") ? typeName : typeName ? `Zod${typeName.charAt(0).toUpperCase()}${typeName.slice(1)}` : void 0;
  if (!normalizedType) {
    console.warn(
      `[zod-to-ts] Could not determine type for schema. typeName=${typeName}, hasShape=${hasShape}`
    );
    return "unknown";
  }
  switch (normalizedType) {
    case "ZodString":
      return "string";
    case "ZodNumber":
      return "number";
    case "ZodBoolean":
      return "boolean";
    case "ZodNull":
      return "null";
    case "ZodUndefined":
      return "undefined";
    case "ZodAny":
      return "any";
    case "ZodUnknown":
      return "unknown";
    case "ZodVoid":
      return "void";
    case "ZodNever":
      return "never";
    case "ZodDate":
      return "Date";
    case "ZodBigInt":
      return "bigint";
    case "ZodLiteral": {
      const value = def.value;
      if (typeof value === "string") {
        return `"${value.replace(/"/g, '\\"')}"`;
      }
      if (typeof value === "number") {
        return String(value);
      }
      if (typeof value === "boolean") {
        return String(value);
      }
      return "unknown";
    }
    case "ZodEnum": {
      const values = def.values;
      return values.map((v) => `"${v.replace(/"/g, '\\"')}"`).join(" | ");
    }
    case "ZodNativeEnum": {
      return "string | number";
    }
    case "ZodOptional": {
      const innerType = zodToTypeString(def.innerType);
      return `${innerType} | undefined`;
    }
    case "ZodNullable": {
      const innerType = zodToTypeString(def.innerType);
      return `${innerType} | null`;
    }
    case "ZodDefault": {
      return zodToTypeString(def.innerType);
    }
    case "ZodArray": {
      const itemSchema = def.element || def.type || def.items;
      if (itemSchema) {
        const itemType = zodToTypeString(itemSchema);
        return `Array<${itemType}>`;
      }
      return "Array<unknown>";
    }
    case "ZodObject": {
      const shape = typeof def.shape === "function" ? def.shape() : def.shape;
      const entries = [];
      for (const [key, value] of Object.entries(shape || {})) {
        const valueSchema = value;
        const valueDef = valueSchema._def || valueSchema.def || {};
        const valueType = valueDef.typeName || valueSchema.type || valueDef.type;
        const normalizedValueType = valueType?.startsWith?.("Zod") ? valueType : `Zod${valueType?.charAt?.(0)?.toUpperCase?.()}${valueType?.slice?.(1)}`;
        const isOptional = normalizedValueType === "ZodOptional";
        const typeStr = zodToTypeString(valueSchema);
        const optionalMarker = isOptional ? "?" : "";
        entries.push(`${JSON.stringify(key)}${optionalMarker}: ${typeStr}`);
      }
      if (entries.length === 0) {
        return "Record<string, never>";
      }
      return `{ ${entries.join("; ")} }`;
    }
    case "ZodRecord": {
      const keyType = def.keyType ? zodToTypeString(def.keyType) : "string";
      const valueType = zodToTypeString(def.valueType);
      return `Record<${keyType}, ${valueType}>`;
    }
    case "ZodUnion": {
      const options = def.options;
      const typeStrings = options.map(zodToTypeString);
      return typeStrings.join(" | ");
    }
    case "ZodDiscriminatedUnion": {
      const options = Array.from(def.optionsMap.values());
      const typeStrings = options.map(zodToTypeString);
      return typeStrings.join(" | ");
    }
    case "ZodIntersection": {
      const left = zodToTypeString(def.left);
      const right = zodToTypeString(def.right);
      return `(${left}) & (${right})`;
    }
    case "ZodTuple": {
      const items = def.items;
      const typeStrings = items.map(zodToTypeString);
      return `[${typeStrings.join(", ")}]`;
    }
    case "ZodEffects": {
      return zodToTypeString(def.schema);
    }
    case "ZodBranded": {
      return zodToTypeString(def.type);
    }
    case "ZodCatch": {
      return zodToTypeString(def.innerType);
    }
    case "ZodPipeline": {
      return zodToTypeString(def.out);
    }
    case "ZodLazy": {
      return "unknown";
    }
    case "ZodPromise": {
      const innerType = zodToTypeString(def.type);
      return `Promise<${innerType}>`;
    }
    case "ZodFunction": {
      return "Function";
    }
    case "ZodMap": {
      const keyType = zodToTypeString(def.keyType);
      const valueType = zodToTypeString(def.valueType);
      return `Map<${keyType}, ${valueType}>`;
    }
    case "ZodSet": {
      const itemType = zodToTypeString(def.valueType);
      return `Set<${itemType}>`;
    }
    default:
      console.warn(`[zod-to-ts] Unknown Zod type: ${typeName}`);
      return "unknown";
  }
}
__name(zodToTypeString, "zodToTypeString");

// src/server/utils/tool-registry-generator.ts
var TOOL_REGISTRY_FILENAME = "tool-registry.d.ts";
var MCP_USE_DIR = ".mcp-use";
async function generateToolRegistryTypes(registrations, projectRoot = process.cwd()) {
  if (process.env.NODE_ENV === "production") {
    return;
  }
  try {
    const toolEntries = [];
    const toolsArray = Array.from(registrations?.entries() || []);
    const sortedTools = toolsArray.sort(([a], [b]) => a.localeCompare(b));
    for (const [toolName, { config }] of sortedTools) {
      const inputType = config.schema ? zodToTypeString(config.schema) : "null";
      const outputType = config.outputSchema ? zodToTypeString(config.outputSchema) : "Record<string, unknown>";
      toolEntries.push(
        `    ${JSON.stringify(toolName)}: {
      input: ${inputType};
      output: ${outputType};
    };`
      );
    }
    const content = `// Auto-generated tool registry types - DO NOT EDIT MANUALLY
// This file is regenerated whenever tools are added, removed, or updated during development
// Generated at: ${(/* @__PURE__ */ new Date()).toISOString()}

declare module "mcp-use/react" {
  interface ToolRegistry {
` + (toolEntries.length > 0 ? toolEntries.join("\n") + "\n" : "    // No tools registered yet\n") + `  }
}

export {};
`;
    const mcpUseDir = join(projectRoot, MCP_USE_DIR);
    const outputPath = join(mcpUseDir, TOOL_REGISTRY_FILENAME);
    let shouldWrite = true;
    try {
      const existingContent = await readFile(outputPath, "utf-8");
      const existingLines = existingContent.split("\n");
      const newLines = content.split("\n");
      const existingWithoutTimestamp = existingLines.filter((_, i) => i !== 2).join("\n");
      const newWithoutTimestamp = newLines.filter((_, i) => i !== 2).join("\n");
      if (existingWithoutTimestamp === newWithoutTimestamp) {
        shouldWrite = false;
      }
    } catch {
      shouldWrite = true;
    }
    if (shouldWrite) {
      await mkdir(mcpUseDir, { recursive: true });
      await writeFile(outputPath, content, "utf-8");
      console.log(
        `[TypeGen] Generated ${TOOL_REGISTRY_FILENAME} with ${sortedTools.length} tool(s)`
      );
    }
  } catch (error) {
    console.warn(
      "[TypeGen] Failed to generate tool registry types:",
      error instanceof Error ? error.message : String(error)
    );
  }
}
__name(generateToolRegistryTypes, "generateToolRegistryTypes");

export {
  generateToolRegistryTypes
};
