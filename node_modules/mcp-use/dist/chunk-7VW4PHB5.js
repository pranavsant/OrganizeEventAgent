import {
  CodeModeConnector
} from "./chunk-MJ5Q62O7.js";
import {
  JSONSchemaToZod
} from "./chunk-RPN2XO5I.js";
import {
  BaseMCPClient,
  MCPSession,
  createConnectorFromConfig,
  loadConfigFile,
  normalizeClientInfo,
  resolveCallbacks
} from "./chunk-MOIY46VI.js";
import {
  Tel,
  getPackageVersion
} from "./chunk-YEK7642C.js";
import {
  logger
} from "./chunk-QWQYAQCK.js";
import {
  __name,
  __require
} from "./chunk-3GQAWCBQ.js";

// src/client.ts
import fs from "fs";
import path from "path";

// src/client/executors/base.ts
var BaseCodeExecutor = class {
  static {
    __name(this, "BaseCodeExecutor");
  }
  client;
  _connecting = false;
  constructor(client) {
    this.client = client;
  }
  /**
   * Ensure all configured MCP servers are connected before execution.
   * Prevents race conditions with a connection lock.
   */
  async ensureServersConnected() {
    const configuredServers = this.client.getServerNames();
    const activeSessions = Object.keys(this.client.getAllActiveSessions());
    const missingServers = configuredServers.filter(
      (s) => !activeSessions.includes(s)
    );
    if (missingServers.length > 0 && !this._connecting) {
      this._connecting = true;
      try {
        logger.debug(
          `Connecting to configured servers for code execution: ${missingServers.join(", ")}`
        );
        await this.client.createAllSessions();
      } finally {
        this._connecting = false;
      }
    } else if (missingServers.length > 0 && this._connecting) {
      logger.debug("Waiting for ongoing server connection...");
      const startWait = Date.now();
      while (this._connecting && Date.now() - startWait < 5e3) {
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
    }
  }
  /**
   * Get tool namespace information from all active MCP sessions.
   * Filters out the internal code_mode server.
   */
  getToolNamespaces() {
    const namespaces = [];
    const activeSessions = this.client.getAllActiveSessions();
    for (const [serverName, session] of Object.entries(activeSessions)) {
      if (serverName === "code_mode") continue;
      try {
        const connector = session.connector;
        let tools;
        try {
          tools = connector.tools;
        } catch (e) {
          logger.warn(`Tools not available for server ${serverName}: ${e}`);
          continue;
        }
        if (!tools || tools.length === 0) continue;
        namespaces.push({ serverName, tools, session });
      } catch (e) {
        logger.warn(`Failed to load tools for server ${serverName}: ${e}`);
      }
    }
    return namespaces;
  }
  /**
   * Create a search function for discovering available MCP tools.
   * Used by code execution environments to find tools at runtime.
   */
  createSearchToolsFunction() {
    return async (query = "", detailLevel = "full") => {
      const allTools = [];
      const allNamespaces = /* @__PURE__ */ new Set();
      const queryLower = query.toLowerCase();
      const activeSessions = this.client.getAllActiveSessions();
      for (const [serverName, session] of Object.entries(activeSessions)) {
        if (serverName === "code_mode") continue;
        try {
          const tools = session.connector.tools;
          if (tools && tools.length > 0) {
            allNamespaces.add(serverName);
          }
          for (const tool of tools) {
            if (detailLevel === "names") {
              allTools.push({ name: tool.name, server: serverName });
            } else if (detailLevel === "descriptions") {
              allTools.push({
                name: tool.name,
                server: serverName,
                description: tool.description
              });
            } else {
              allTools.push({
                name: tool.name,
                server: serverName,
                description: tool.description,
                input_schema: tool.inputSchema
              });
            }
          }
        } catch (e) {
          logger.warn(`Failed to search tools in server ${serverName}: ${e}`);
        }
      }
      let filteredTools = allTools;
      if (query) {
        filteredTools = allTools.filter((tool) => {
          const nameMatch = tool.name.toLowerCase().includes(queryLower);
          const descMatch = tool.description?.toLowerCase().includes(queryLower);
          const serverMatch = tool.server.toLowerCase().includes(queryLower);
          return nameMatch || descMatch || serverMatch;
        });
      }
      return {
        meta: {
          total_tools: allTools.length,
          namespaces: Array.from(allNamespaces).sort(),
          result_count: filteredTools.length
        },
        results: filteredTools
      };
    };
  }
};

// src/client/executors/e2b.ts
var E2BCodeExecutor = class extends BaseCodeExecutor {
  static {
    __name(this, "E2BCodeExecutor");
  }
  e2bApiKey;
  codeExecSandbox = null;
  SandboxClass = null;
  timeoutMs;
  constructor(client, options) {
    super(client);
    this.e2bApiKey = options.apiKey;
    this.timeoutMs = options.timeoutMs ?? 3e5;
  }
  /**
   * Lazy load E2B Sandbox class.
   * This allows the library to work without E2B installed.
   */
  async ensureSandboxClass() {
    if (this.SandboxClass) return;
    try {
      const e2b = await import("@e2b/code-interpreter");
      this.SandboxClass = e2b.Sandbox;
    } catch (error) {
      throw new Error(
        "@e2b/code-interpreter is not installed. The E2B code executor requires this optional dependency. Install it with: yarn add @e2b/code-interpreter"
      );
    }
  }
  /**
   * Get or create a dedicated sandbox for code execution.
   */
  async getOrCreateCodeExecSandbox() {
    if (this.codeExecSandbox) return this.codeExecSandbox;
    await this.ensureSandboxClass();
    logger.debug("Starting E2B sandbox for code execution...");
    this.codeExecSandbox = await this.SandboxClass.create("base", {
      apiKey: this.e2bApiKey,
      timeoutMs: this.timeoutMs
    });
    return this.codeExecSandbox;
  }
  /**
   * Generate the shim code that exposes tools to the sandbox environment.
   * Creates a bridge that intercepts tool calls and sends them back to host.
   */
  generateShim(tools) {
    let shim = `
// MCP Bridge Shim
global.__callMcpTool = async (server, tool, args) => {
    const id = Math.random().toString(36).substring(7);
    console.log(JSON.stringify({
        type: '__MCP_TOOL_CALL__',
        id,
        server,
        tool,
        args
    }));
    
    const resultPath = \`/tmp/mcp_result_\${id}.json\`;
    const fs = require('fs');
    
    // Poll for result file
    let attempts = 0;
    while (attempts < 300) { // 30 seconds timeout
        if (fs.existsSync(resultPath)) {
            const content = fs.readFileSync(resultPath, 'utf8');
            const result = JSON.parse(content);
            fs.unlinkSync(resultPath); // Clean up
            
            if (result.error) {
                throw new Error(result.error);
            }
            return result.data;
        }
        await new Promise(resolve => setTimeout(resolve, 100));
        attempts++;
    }
    throw new Error('Tool execution timed out');
};

// Global search_tools helper
global.search_tools = async (query, detailLevel = 'full') => {
    const allTools = ${JSON.stringify(
      Object.entries(tools).flatMap(
        ([server, serverTools]) => serverTools.map((tool) => ({
          name: tool.name,
          description: tool.description,
          server,
          input_schema: tool.inputSchema
        }))
      )
    )};
    
    const filtered = allTools.filter(tool => {
        if (!query) return true;
        const q = query.toLowerCase();
        return tool.name.toLowerCase().includes(q) || 
               (tool.description && tool.description.toLowerCase().includes(q));
    });
    
    if (detailLevel === 'names') {
        return filtered.map(t => ({ name: t.name, server: t.server }));
    } else if (detailLevel === 'descriptions') {
        return filtered.map(t => ({ name: t.name, server: t.server, description: t.description }));
    }
    return filtered;
};
`;
    for (const [serverName, serverTools] of Object.entries(tools)) {
      if (!serverTools || serverTools.length === 0) continue;
      const safeServerName = serverName.replace(/[^a-zA-Z0-9_]/g, "_");
      shim += `
global['${serverName}'] = {`;
      for (const tool of serverTools) {
        shim += `
    '${tool.name}': async (args) => await global.__callMcpTool('${serverName}', '${tool.name}', args),`;
      }
      shim += `
};

// Also expose as safe name if different
if ('${safeServerName}' !== '${serverName}') {
    global['${safeServerName}'] = global['${serverName}'];
}
`;
    }
    return shim;
  }
  /**
   * Build the tool catalog for the shim.
   * Returns a map of server names to their available tools.
   */
  buildToolCatalog() {
    const catalog = {};
    const namespaces = this.getToolNamespaces();
    for (const { serverName, tools } of namespaces) {
      catalog[serverName] = tools;
    }
    return catalog;
  }
  /**
   * Execute JavaScript/TypeScript code in an E2B sandbox with MCP tool access.
   * Tool calls are proxied back to the host via the bridge pattern.
   *
   * @param code - Code to execute
   * @param timeout - Execution timeout in milliseconds (default: 30000)
   */
  async execute(code, timeout = 3e4) {
    const startTime = Date.now();
    let result = null;
    let error = null;
    let logs = [];
    try {
      await this.ensureServersConnected();
      const sandbox = await this.getOrCreateCodeExecSandbox();
      const toolCatalog = this.buildToolCatalog();
      const shim = this.generateShim(toolCatalog);
      const wrappedCode = `
${shim}

(async () => {
    try {
        const func = async () => {
            ${code}
        };
        const result = await func();
        console.log('__MCP_RESULT_START__');
        console.log(JSON.stringify(result));
        console.log('__MCP_RESULT_END__');
    } catch (e) {
        console.error(e);
        process.exit(1);
    }
})();
`;
      const filename = `exec_${Date.now()}.js`;
      await sandbox.files.write(filename, wrappedCode);
      const execution = await sandbox.commands.run(`node ${filename}`, {
        timeoutMs: timeout,
        onStdout: /* @__PURE__ */ __name(async (data) => {
          try {
            const lines = data.split("\n");
            for (const line of lines) {
              if (line.trim().startsWith('{"type":"__MCP_TOOL_CALL__"')) {
                const call = JSON.parse(line);
                if (call.type === "__MCP_TOOL_CALL__") {
                  try {
                    logger.debug(
                      `[E2B Bridge] Calling tool ${call.server}.${call.tool}`
                    );
                    const activeSessions = this.client.getAllActiveSessions();
                    const session = activeSessions[call.server];
                    if (!session) {
                      throw new Error(`Server ${call.server} not found`);
                    }
                    const toolResult = await session.connector.callTool(
                      call.tool,
                      call.args
                    );
                    let extractedResult = toolResult;
                    if (toolResult.content && toolResult.content.length > 0) {
                      const item = toolResult.content[0];
                      if (item.type === "text") {
                        try {
                          extractedResult = JSON.parse(item.text);
                        } catch {
                          extractedResult = item.text;
                        }
                      } else {
                        extractedResult = item;
                      }
                    }
                    const resultPath = `/tmp/mcp_result_${call.id}.json`;
                    await sandbox.files.write(
                      resultPath,
                      JSON.stringify({ data: extractedResult })
                    );
                  } catch (err) {
                    logger.error(
                      `[E2B Bridge] Tool execution failed: ${err.message}`
                    );
                    const resultPath = `/tmp/mcp_result_${call.id}.json`;
                    await sandbox.files.write(
                      resultPath,
                      JSON.stringify({
                        error: err.message || String(err)
                      })
                    );
                  }
                }
              }
            }
          } catch (e) {
          }
        }, "onStdout")
      });
      logs = [execution.stdout, execution.stderr].filter(Boolean);
      if (execution.exitCode !== 0) {
        error = execution.stderr || "Execution failed";
      } else {
        const stdout = execution.stdout;
        const startMarker = "__MCP_RESULT_START__";
        const endMarker = "__MCP_RESULT_END__";
        const startIndex = stdout.indexOf(startMarker);
        const endIndex = stdout.indexOf(endMarker);
        if (startIndex !== -1 && endIndex !== -1) {
          const jsonStr = stdout.substring(startIndex + startMarker.length, endIndex).trim();
          try {
            result = JSON.parse(jsonStr);
          } catch (e) {
            result = jsonStr;
          }
          logs = logs.map((log) => {
            let cleaned = log.replace(
              new RegExp(startMarker + "[\\s\\S]*?" + endMarker),
              "[Result captured]"
            );
            cleaned = cleaned.split("\n").filter((l) => !l.includes("__MCP_TOOL_CALL__")).join("\n");
            return cleaned;
          });
        }
      }
    } catch (e) {
      error = e.message || String(e);
      if (error && (error.includes("timeout") || error.includes("timed out"))) {
        error = "Script execution timed out";
      }
    }
    return {
      result,
      logs,
      error,
      execution_time: (Date.now() - startTime) / 1e3
    };
  }
  /**
   * Clean up the E2B sandbox.
   * Should be called when the executor is no longer needed.
   */
  async cleanup() {
    if (this.codeExecSandbox) {
      try {
        await this.codeExecSandbox.kill();
        this.codeExecSandbox = null;
        logger.debug("E2B code execution sandbox stopped");
      } catch (error) {
        logger.error("Failed to stop E2B code execution sandbox:", error);
      }
    }
  }
};

// src/client/executors/vm.ts
var vm = null;
var vmCheckAttempted = false;
function getVMModuleName() {
  return ["node", "vm"].join(":");
}
__name(getVMModuleName, "getVMModuleName");
function tryLoadVM() {
  if (vmCheckAttempted) {
    return vm !== null;
  }
  vmCheckAttempted = true;
  try {
    const nodeRequire = typeof __require !== "undefined" ? __require : null;
    if (nodeRequire) {
      vm = nodeRequire(getVMModuleName());
      return true;
    }
  } catch (error) {
    logger.debug("node:vm module not available via require");
  }
  return false;
}
__name(tryLoadVM, "tryLoadVM");
async function tryLoadVMAsync() {
  if (vm !== null) {
    return true;
  }
  if (!vmCheckAttempted) {
    if (tryLoadVM()) {
      return true;
    }
  }
  try {
    vm = await import(
      /* @vite-ignore */
      getVMModuleName()
    );
    return true;
  } catch (error) {
    logger.debug(
      "node:vm module not available in this environment (e.g., Deno)"
    );
    return false;
  }
}
__name(tryLoadVMAsync, "tryLoadVMAsync");
function isVMAvailable() {
  tryLoadVM();
  return vm !== null;
}
__name(isVMAvailable, "isVMAvailable");
var VMCodeExecutor = class extends BaseCodeExecutor {
  static {
    __name(this, "VMCodeExecutor");
  }
  defaultTimeout;
  memoryLimitMb;
  constructor(client, options) {
    super(client);
    this.defaultTimeout = options?.timeoutMs ?? 3e4;
    this.memoryLimitMb = options?.memoryLimitMb;
    tryLoadVM();
  }
  /**
   * Ensure VM module is loaded before execution
   */
  async ensureVMLoaded() {
    if (vm !== null) {
      return;
    }
    const loaded = await tryLoadVMAsync();
    if (!loaded) {
      throw new Error(
        "node:vm module is not available in this environment. Please use E2B executor instead or run in a Node.js environment."
      );
    }
  }
  /**
   * Execute JavaScript/TypeScript code with access to MCP tools.
   *
   * @param code - Code to execute
   * @param timeout - Execution timeout in milliseconds (default: configured timeout or 30000)
   */
  async execute(code, timeout) {
    const effectiveTimeout = timeout ?? this.defaultTimeout;
    await this.ensureVMLoaded();
    await this.ensureServersConnected();
    const logs = [];
    const startTime = Date.now();
    let result = null;
    let error = null;
    try {
      const context = await this._buildContext(logs);
      const wrappedCode = `
        (async () => {
          try {
            ${code}
          } catch (e) {
            throw e;
          }
        })()
      `;
      const script = new vm.Script(wrappedCode, {
        filename: "agent_code.js"
      });
      const promise = script.runInNewContext(context, {
        timeout: effectiveTimeout,
        displayErrors: true
      });
      result = await promise;
    } catch (e) {
      error = e.message || String(e);
      if (e.code === "ERR_SCRIPT_EXECUTION_TIMEOUT" || e.message === "Script execution timed out." || typeof error === "string" && (error.includes("timed out") || error.includes("timeout"))) {
        error = "Script execution timed out";
      }
      if (e.stack) {
        logger.debug(`Code execution error stack: ${e.stack}`);
      }
    }
    const executionTime = (Date.now() - startTime) / 1e3;
    return {
      result,
      logs,
      error,
      execution_time: executionTime
    };
  }
  /**
   * Build the VM execution context with MCP tools and standard globals.
   *
   * @param logs - Array to capture console output
   */
  async _buildContext(logs) {
    const logHandler = /* @__PURE__ */ __name((...args) => {
      logs.push(
        args.map(
          (arg) => typeof arg === "object" ? JSON.stringify(arg, null, 2) : String(arg)
        ).join(" ")
      );
    }, "logHandler");
    const sandbox = {
      console: {
        log: logHandler,
        error: /* @__PURE__ */ __name((...args) => {
          logHandler("[ERROR]", ...args);
        }, "error"),
        warn: /* @__PURE__ */ __name((...args) => {
          logHandler("[WARN]", ...args);
        }, "warn"),
        info: logHandler,
        debug: logHandler
      },
      // Standard globals
      Object,
      Array,
      String,
      Number,
      Boolean,
      Date,
      Math,
      JSON,
      RegExp,
      Map,
      Set,
      Promise,
      parseInt,
      parseFloat,
      isNaN,
      isFinite,
      encodeURI,
      decodeURI,
      encodeURIComponent,
      decodeURIComponent,
      setTimeout,
      clearTimeout,
      // Helper for tools
      search_tools: this.createSearchToolsFunction(),
      __tool_namespaces: []
    };
    const toolNamespaces = {};
    const namespaceInfos = this.getToolNamespaces();
    for (const { serverName, tools, session } of namespaceInfos) {
      const serverNamespace = {};
      for (const tool of tools) {
        const toolName = tool.name;
        serverNamespace[toolName] = async (args) => {
          const result = await session.connector.callTool(toolName, args || {});
          if (result.content && result.content.length > 0) {
            const item = result.content[0];
            if (item.type === "text") {
              try {
                return JSON.parse(item.text);
              } catch {
                return item.text;
              }
            }
            return item;
          }
          return result;
        };
      }
      sandbox[serverName] = serverNamespace;
      toolNamespaces[serverName] = true;
    }
    sandbox.__tool_namespaces = Object.keys(toolNamespaces);
    return vm.createContext(sandbox);
  }
  /**
   * Clean up resources.
   * VM executor doesn't need cleanup, but method kept for interface consistency.
   */
  async cleanup() {
  }
};

// src/client/elicitation-helpers.ts
function hasRequestedSchema(params) {
  return "requestedSchema" in params && params.requestedSchema != null;
}
__name(hasRequestedSchema, "hasRequestedSchema");
function getDefaults(params) {
  const content = {};
  if (!hasRequestedSchema(params)) return content;
  const schema = params.requestedSchema;
  const properties = schema.properties ?? {};
  for (const [fieldName, fieldSchema] of Object.entries(properties)) {
    const field = fieldSchema;
    if ("default" in field) {
      const v = field.default;
      if (typeof v === "string" || typeof v === "number" || typeof v === "boolean" || Array.isArray(v) && v.every((x) => typeof x === "string")) {
        content[fieldName] = v;
      }
    }
  }
  return content;
}
__name(getDefaults, "getDefaults");
function applyDefaults(params, partial) {
  const defaults = getDefaults(params);
  if (partial == null) return defaults;
  return { ...defaults, ...partial };
}
__name(applyDefaults, "applyDefaults");
function acceptWithDefaults(params) {
  return { action: "accept", content: getDefaults(params) };
}
__name(acceptWithDefaults, "acceptWithDefaults");
function accept(content) {
  return { action: "accept", content };
}
__name(accept, "accept");
function decline(_reason) {
  return { action: "decline" };
}
__name(decline, "decline");
function cancel() {
  return { action: "cancel" };
}
__name(cancel, "cancel");
function reject(reason) {
  return decline(reason);
}
__name(reject, "reject");
function validate(params, content) {
  if (!hasRequestedSchema(params)) {
    return { valid: true };
  }
  try {
    const zodSchema = JSONSchemaToZod.convert(
      params.requestedSchema
    );
    const result = zodSchema.safeParse(content);
    if (result.success) {
      return { valid: true };
    }
    const messages = result.error.issues.map(
      (i) => i.path.length > 0 ? `${i.path.join(".")}: ${i.message}` : i.message
    );
    return { valid: false, errors: messages };
  } catch {
    return { valid: false, errors: ["Unsupported or invalid schema"] };
  }
}
__name(validate, "validate");

// src/client.ts
var MCPClient = class _MCPClient extends BaseMCPClient {
  static {
    __name(this, "MCPClient");
  }
  /**
   * Gets the mcp-use package version.
   *
   * This static method returns the version string of the installed mcp-use package,
   * which is useful for debugging and compatibility checks.
   *
   * @returns The package version string (e.g., "1.13.2")
   *
   * @example
   * ```typescript
   * console.log(`mcp-use version: ${MCPClient.getPackageVersion()}`);
   * ```
   */
  static getPackageVersion() {
    return getPackageVersion();
  }
  /**
   * Indicates whether code execution mode is enabled.
   *
   * When true, the client provides special tools for executing code dynamically
   * through the {@link executeCode} and {@link searchTools} methods.
   *
   * @example
   * ```typescript
   * if (client.codeMode) {
   *   const result = await client.executeCode('return 2 + 2');
   *   console.log(result.output); // "4"
   * }
   * ```
   */
  codeMode = false;
  _codeExecutor = null;
  _customCodeExecutor = null;
  _codeExecutorConfig = "vm";
  _executorOptions;
  _globalCallbacks;
  /**
   * Creates a new MCPClient instance.
   *
   * The client can be initialized with either a configuration object, a path to
   * a configuration file, or no configuration at all (servers can be added later
   * using {@link addServer}).
   *
   * @param config - Configuration object or path to JSON config file. If omitted,
   *                 starts with empty configuration
   * @param options - Optional client behavior configuration
   * @param options.codeMode - Enable code execution mode (boolean or advanced config)
   * @param options.onSampling - Callback for handling sampling requests from servers
   * @param options.elicitationCallback - Callback for handling elicitation requests
   *
   * @example
   * ```typescript
   * // From config file
   * const client = new MCPClient('./mcp-config.json');
   * ```
   *
   * @example
   * ```typescript
   * // From inline config
   * const client = new MCPClient({
   *   mcpServers: {
   *     'my-server': {
   *       command: 'node',
   *       args: ['server.js']
   *     }
   *   }
   * });
   * ```
   *
   * @example
   * ```typescript
   * // With code mode enabled
   * const client = new MCPClient('./config.json', {
   *   codeMode: true
   * });
   * ```
   *
   * @example
   * ```typescript
   * // With sampling callback
   * const client = new MCPClient('./config.json', {
   *   onSampling: async (params) => {
   *     // Call your LLM here
   *     return anthropic.messages.create(params);
   *   }
   * });
   * ```
   *
   * @see {@link fromDict} for creating from config object (alternative syntax)
   * @see {@link fromConfigFile} for creating from file (alternative syntax)
   */
  constructor(config, options) {
    if (config) {
      if (typeof config === "string") {
        super(loadConfigFile(config));
      } else {
        super(config);
      }
    } else {
      super();
    }
    let codeModeEnabled = false;
    let executorConfig = "vm";
    let executorOptions;
    if (options?.codeMode) {
      if (typeof options.codeMode === "boolean") {
        codeModeEnabled = options.codeMode;
      } else {
        codeModeEnabled = options.codeMode.enabled;
        executorConfig = options.codeMode.executor ?? "vm";
        executorOptions = options.codeMode.executorOptions;
      }
    }
    this.codeMode = codeModeEnabled;
    this._codeExecutorConfig = executorConfig;
    this._executorOptions = executorOptions;
    const configRoot = this.config;
    this._globalCallbacks = {
      onSampling: options?.onSampling ?? options?.samplingCallback ?? configRoot?.onSampling ?? configRoot?.samplingCallback,
      samplingCallback: options?.samplingCallback ?? configRoot?.samplingCallback,
      onElicitation: options?.onElicitation ?? options?.elicitationCallback ?? configRoot?.onElicitation ?? configRoot?.elicitationCallback,
      elicitationCallback: options?.elicitationCallback ?? configRoot?.elicitationCallback,
      onNotification: options?.onNotification ?? configRoot?.onNotification
    };
    if (options?.samplingCallback && !options?.onSampling) {
      console.warn(
        '[MCPClient] The "samplingCallback" option is deprecated. Use "onSampling" instead.'
      );
    }
    if (options?.elicitationCallback && !options?.onElicitation) {
      console.warn(
        '[MCPClient] The "elicitationCallback" option is deprecated. Use "onElicitation" instead.'
      );
    }
    if (this.codeMode) {
      this._setupCodeModeConnector();
    }
    this._trackClientInit();
  }
  _trackClientInit() {
    const servers = Object.keys(this.config.mcpServers ?? {});
    const hasSamplingCallback = !!(this._globalCallbacks.onSampling ?? this._globalCallbacks.samplingCallback);
    const hasElicitationCallback = !!(this._globalCallbacks.onElicitation ?? this._globalCallbacks.elicitationCallback);
    Tel.getInstance().trackMCPClientInit({
      codeMode: this.codeMode,
      sandbox: false,
      // Sandbox not supported in TS yet
      allCallbacks: hasSamplingCallback && hasElicitationCallback,
      verify: false,
      // No verify option in TS client
      servers,
      numServers: servers.length,
      isBrowser: false
      // Node.js MCPClient
    }).catch((e) => logger.debug(`Failed to track MCPClient init: ${e}`));
  }
  /**
   * Creates a client instance from a configuration dictionary.
   *
   * This static factory method provides an alternative syntax for creating
   * a client from an inline configuration object.
   *
   * @param cfg - Configuration dictionary with server definitions
   * @param options - Optional client behavior configuration
   * @returns New MCPClient instance
   *
   * @example
   * ```typescript
   * const client = MCPClient.fromDict({
   *   mcpServers: {
   *     'filesystem': {
   *       command: 'npx',
   *       args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp']
   *     }
   *   }
   * });
   * ```
   *
   * @see {@link constructor} for direct instantiation
   * @see {@link fromConfigFile} for loading from file
   */
  static fromDict(cfg, options) {
    return new _MCPClient(cfg, options);
  }
  /**
   * Creates a client instance from a configuration file.
   *
   * This static factory method loads MCP server configurations from a JSON
   * file and creates a new client instance.
   *
   * @param path - Path to the JSON configuration file
   * @param options - Optional client behavior configuration
   * @returns New MCPClient instance
   * @throws {Error} If the file cannot be read or parsed
   *
   * @example
   * ```typescript
   * const client = MCPClient.fromConfigFile('./mcp-config.json');
   * await client.createAllSessions();
   * ```
   *
   * @example
   * ```typescript
   * // With code mode
   * const client = MCPClient.fromConfigFile('./config.json', {
   *   codeMode: true
   * });
   * ```
   *
   * @see {@link constructor} for direct instantiation
   * @see {@link fromDict} for inline configuration
   */
  static fromConfigFile(path2, options) {
    return new _MCPClient(loadConfigFile(path2), options);
  }
  /**
   * Saves the current configuration to a file.
   *
   * This Node.js-specific method writes the client's current configuration
   * (including all server definitions) to a JSON file. The directory will be
   * created if it doesn't exist.
   *
   * @param filepath - Path where the configuration file should be saved
   *
   * @example
   * ```typescript
   * const client = new MCPClient();
   * client.addServer('my-server', {
   *   command: 'node',
   *   args: ['server.js']
   * });
   *
   * // Save configuration for later use
   * client.saveConfig('./mcp-config.json');
   * ```
   *
   * @see {@link fromConfigFile} for loading configurations
   */
  saveConfig(filepath) {
    const dir = path.dirname(filepath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(filepath, JSON.stringify(this.config, null, 2), "utf-8");
  }
  /**
   * Create a connector from server configuration (Node.js version)
   * Supports all connector types including StdioConnector (lazy-loaded to avoid pulling Node-only code into browser bundles).
   */
  async createConnectorFromConfig(serverConfig) {
    const resolved = resolveCallbacks(
      serverConfig,
      this._globalCallbacks
    );
    const merged = {
      ...serverConfig,
      clientInfo: serverConfig.clientInfo ?? this.config.clientInfo
    };
    if ("command" in merged && "args" in merged) {
      const { StdioConnector } = await import("./stdio-ZKXAJGR6.js");
      const stdioConfig = merged;
      return new StdioConnector({
        command: stdioConfig.command,
        args: stdioConfig.args,
        env: stdioConfig.env,
        clientInfo: normalizeClientInfo(merged.clientInfo),
        onSampling: resolved.onSampling,
        onElicitation: resolved.onElicitation,
        onNotification: resolved.onNotification
      });
    }
    return createConnectorFromConfig(merged, {
      onSampling: resolved.onSampling,
      onElicitation: resolved.onElicitation,
      onNotification: resolved.onNotification
    });
  }
  _setupCodeModeConnector() {
    logger.debug("Code mode connector initialized as internal meta server");
    const connector = new CodeModeConnector(this);
    const session = new MCPSession(connector);
    this.sessions["code_mode"] = session;
    this.activeSessions.push("code_mode");
  }
  _ensureCodeExecutor() {
    if (!this._codeExecutor) {
      const config = this._codeExecutorConfig;
      if (config instanceof BaseCodeExecutor) {
        this._codeExecutor = config;
      } else if (typeof config === "function") {
        this._customCodeExecutor = config;
        throw new Error(
          "Custom executor function should be handled in executeCode"
        );
      } else if (config === "e2b") {
        const opts = this._executorOptions;
        if (!opts?.apiKey) {
          logger.warn("E2B executor requires apiKey. Falling back to VM.");
          try {
            this._codeExecutor = new VMCodeExecutor(
              this,
              this._executorOptions
            );
          } catch (error) {
            throw new Error(
              "VM executor is not available in this environment and E2B API key is not provided. Please provide an E2B API key or run in a Node.js environment."
            );
          }
        } else {
          this._codeExecutor = new E2BCodeExecutor(this, opts);
        }
      } else {
        try {
          this._codeExecutor = new VMCodeExecutor(
            this,
            this._executorOptions
          );
        } catch (error) {
          const e2bOpts = this._executorOptions;
          const e2bApiKey = e2bOpts?.apiKey || process.env.E2B_API_KEY;
          if (e2bApiKey) {
            logger.info(
              "VM executor not available in this environment. Falling back to E2B."
            );
            this._codeExecutor = new E2BCodeExecutor(this, {
              ...e2bOpts,
              apiKey: e2bApiKey
            });
          } else {
            throw new Error(
              "VM executor is not available in this environment. Please provide an E2B API key via executorOptions or E2B_API_KEY environment variable, or run in a Node.js environment."
            );
          }
        }
      }
    }
    return this._codeExecutor;
  }
  /**
   * Executes JavaScript/TypeScript code in a sandboxed environment.
   *
   * This method is only available when code mode is enabled. It executes the
   * provided code in an isolated environment (VM or E2B sandbox) and returns
   * the results including stdout, stderr, and return value.
   *
   * @param code - JavaScript/TypeScript code to execute
   * @param timeout - Optional execution timeout in milliseconds
   * @returns Execution result with output, errors, and return value
   * @throws {Error} If code mode is not enabled
   *
   * @example
   * ```typescript
   * const client = new MCPClient('./config.json', { codeMode: true });
   *
   * const result = await client.executeCode(`
   *   console.log('Hello, world!');
   *   return 2 + 2;
   * `);
   *
   * console.log(result.stdout);      // "Hello, world!\n"
   * console.log(result.returnValue); // 4
   * ```
   *
   * @example
   * ```typescript
   * // With timeout
   * try {
   *   const result = await client.executeCode('while(true) {}', 1000);
   * } catch (error) {
   *   console.log('Execution timed out');
   * }
   * ```
   *
   * @see {@link searchTools} for discovering available tools in code mode
   */
  async executeCode(code, timeout) {
    if (!this.codeMode) {
      throw new Error("Code execution mode is not enabled");
    }
    if (this._customCodeExecutor) {
      return this._customCodeExecutor(code, timeout);
    }
    return this._ensureCodeExecutor().execute(code, timeout);
  }
  /**
   * Searches for available tools across all MCP servers.
   *
   * This method is only available when code mode is enabled. It searches
   * through tools from all active servers and returns matching tools based
   * on the query and detail level.
   *
   * @param query - Optional search query to filter tools (defaults to empty string for all tools)
   * @param detailLevel - Level of detail to return: "names", "descriptions", or "full"
   * @returns Tool search results with matching tools
   * @throws {Error} If code mode is not enabled
   *
   * @example
   * ```typescript
   * const client = new MCPClient('./config.json', { codeMode: true });
   * await client.createAllSessions();
   *
   * // Search for all tools
   * const allTools = await client.searchTools();
   * console.log(`Found ${allTools.tools.length} tools`);
   *
   * // Search for specific tools
   * const fileTools = await client.searchTools('file', 'descriptions');
   * ```
   *
   * @see {@link executeCode} for executing code in code mode
   */
  async searchTools(query = "", detailLevel = "full") {
    if (!this.codeMode) {
      throw new Error("Code execution mode is not enabled");
    }
    return this._ensureCodeExecutor().createSearchToolsFunction()(
      query,
      detailLevel
    );
  }
  /**
   * Gets the names of all configured MCP servers (excluding internal servers).
   *
   * This method overrides the base implementation to filter out internal
   * meta-servers like the code mode server, which is an implementation detail
   * not intended for direct user interaction.
   *
   * @returns Array of user-configured server names
   *
   * @example
   * ```typescript
   * const names = client.getServerNames();
   * console.log(`User servers: ${names.join(', ')}`);
   * // Note: 'code_mode' is excluded even if code mode is enabled
   * ```
   *
   * @see {@link activeSessions} for servers with active sessions
   */
  getServerNames() {
    const isCodeModeEnabled = this.codeMode;
    return super.getServerNames().filter((name) => {
      return !isCodeModeEnabled || name !== "code_mode";
    });
  }
  /**
   * Closes the client and cleans up all resources.
   *
   * This method performs a complete cleanup by:
   * 1. Shutting down code executors (VM or E2B sandboxes)
   * 2. Closing all active MCP sessions
   * 3. Releasing any other held resources
   *
   * Always call this method when you're done with the client to ensure
   * proper resource cleanup, especially when using E2B sandboxes which
   * have associated costs.
   *
   * @example
   * ```typescript
   * const client = new MCPClient('./config.json', { codeMode: true });
   * await client.createAllSessions();
   *
   * // Do work...
   *
   * // Clean up
   * await client.close();
   * ```
   *
   * @example
   * ```typescript
   * // Use in shutdown handler
   * process.on('SIGINT', async () => {
   *   console.log('Shutting down...');
   *   await client.close();
   *   process.exit(0);
   * });
   * ```
   *
   * @see {@link closeAllSessions} for closing just the sessions
   */
  async close() {
    if (this._codeExecutor) {
      await this._codeExecutor.cleanup();
      this._codeExecutor = null;
    }
    await this.closeAllSessions();
  }
};

export {
  BaseCodeExecutor,
  E2BCodeExecutor,
  isVMAvailable,
  VMCodeExecutor,
  getDefaults,
  applyDefaults,
  acceptWithDefaults,
  accept,
  decline,
  cancel,
  reject,
  validate,
  MCPClient
};
