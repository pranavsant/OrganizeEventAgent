import {
  createNotification,
  createRequest
} from "./chunk-K4JZBXZM.js";
import {
  applyProxyConfig,
  detectFavicon
} from "./chunk-RYMNQ23J.js";
import {
  BrowserMCPClient
} from "./chunk-QCAOYQX6.js";
import {
  Tel,
  getPackageVersion
} from "./chunk-YEK7642C.js";
import {
  Logger,
  logger
} from "./chunk-QWQYAQCK.js";
import {
  probeAuthParams
} from "./chunk-MXENOGA5.js";
import {
  BrowserOAuthClientProvider,
  sanitizeUrl
} from "./chunk-6KHHFWTB.js";
import {
  __name
} from "./chunk-3GQAWCBQ.js";

// src/react/useMcp.ts
import { auth } from "@modelcontextprotocol/sdk/client/auth.js";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";

// src/utils/assert.ts
function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
__name(assert, "assert");

// src/react/useMcp-helpers.ts
var USE_MCP_SERVER_NAME = "inspector-server";
function deriveOAuthClientConfigFromClientInfo(clientInfo) {
  return {
    name: clientInfo.name,
    version: clientInfo.version,
    uri: clientInfo.websiteUrl,
    logo_uri: clientInfo.icons?.[0]?.src
  };
}
__name(deriveOAuthClientConfigFromClientInfo, "deriveOAuthClientConfigFromClientInfo");
function isOAuthDiscoveryFailure(error) {
  const errorMessage = error instanceof Error ? error.message : String(error);
  const msg = errorMessage.toLowerCase();
  return msg.includes("oauth discovery failed") || msg.includes("oauth-authorization-server") || msg.includes("not valid json") || msg.includes("404") && (msg.includes("openid-configuration") || msg.includes("oauth-protected-resources") || msg.includes("oauth-authorization-url") || msg.includes("register")) || msg.includes("invalid oauth error response") && msg.includes("not found");
}
__name(isOAuthDiscoveryFailure, "isOAuthDiscoveryFailure");
function deriveOAuthProxyUrl(gatewayUrl) {
  if (!gatewayUrl) {
    return void 0;
  }
  const gatewayUrlObj = new URL(gatewayUrl);
  const basePath = gatewayUrlObj.pathname.replace(/\/proxy\/?$/, "");
  return `${gatewayUrlObj.origin}${basePath}/oauth`;
}
__name(deriveOAuthProxyUrl, "deriveOAuthProxyUrl");
function createBrowserOAuthProvider(params) {
  const oauthProxyUrl = deriveOAuthProxyUrl(params.gatewayUrl);
  const provider = new BrowserOAuthClientProvider(params.effectiveOAuthUrl, {
    storageKeyPrefix: params.storageKeyPrefix,
    clientName: params.oauthClientConfig.name,
    clientUri: params.oauthClientConfig.uri,
    logoUri: params.oauthClientConfig.logo_uri || "https://mcp-use.com/logo.png",
    callbackUrl: params.callbackUrl,
    preventAutoAuth: params.preventAutoAuth,
    useRedirectFlow: params.useRedirectFlow,
    oauthProxyUrl,
    connectionUrl: params.gatewayUrl,
    onPopupWindow: params.onPopupWindow
  });
  if (oauthProxyUrl && params.installFetchInterceptor) {
    provider.installFetchInterceptor();
  }
  return { provider, oauthProxyUrl };
}
__name(createBrowserOAuthProvider, "createBrowserOAuthProvider");
function startConnectionHealthMonitoring(params) {
  let healthCheckInterval = null;
  let lastSuccessfulCheck = Date.now();
  const healthCheckIntervalMs = params.healthCheckIntervalMs ?? 1e4;
  const healthCheckTimeoutMs = params.healthCheckTimeoutMs ?? 3e4;
  const checkConnectionHealth = /* @__PURE__ */ __name(async () => {
    if (!params.isMountedRef.current || params.stateRef.current !== "ready") {
      if (healthCheckInterval) {
        clearInterval(healthCheckInterval);
        healthCheckInterval = null;
      }
      return;
    }
    try {
      const healthCheckUrl = params.gatewayUrl || params.url;
      if (!healthCheckUrl) {
        return;
      }
      const authHeaders = params.getAuthHeaders ? await params.getAuthHeaders() : {};
      const response = await fetch(healthCheckUrl, {
        method: "HEAD",
        headers: { ...params.allHeaders, ...authHeaders },
        signal: AbortSignal.timeout(5e3)
      });
      if (response.ok || response.status < 500) {
        lastSuccessfulCheck = Date.now();
      } else {
        throw new Error(`Server returned ${response.status}`);
      }
    } catch {
      const timeSinceLastSuccess = Date.now() - lastSuccessfulCheck;
      if (timeSinceLastSuccess > healthCheckTimeoutMs) {
        params.addLog(
          "warn",
          `Connection appears to be broken (no response for ${Math.round(timeSinceLastSuccess / 1e3)}s), attempting to reconnect...`
        );
        if (healthCheckInterval) {
          clearInterval(healthCheckInterval);
          healthCheckInterval = null;
        }
        if (params.autoReconnectRef.current && params.isMountedRef.current) {
          params.setState("discovering");
          params.addLog("info", "Auto-reconnecting to MCP server...");
          setTimeout(
            () => {
              if (params.isMountedRef.current && params.stateRef.current === "discovering") {
                params.connect();
              }
            },
            typeof params.autoReconnectRef.current === "number" ? params.autoReconnectRef.current : params.defaultReconnectDelay
          );
        }
      }
    }
  }, "checkConnectionHealth");
  healthCheckInterval = setInterval(
    checkConnectionHealth,
    healthCheckIntervalMs
  );
  return () => {
    if (healthCheckInterval) {
      clearInterval(healthCheckInterval);
      healthCheckInterval = null;
    }
  };
}
__name(startConnectionHealthMonitoring, "startConnectionHealthMonitoring");

// src/react/useMcp.ts
var DEFAULT_RECONNECT_DELAY = 3e3;
var DEFAULT_RETRY_DELAY = 5e3;
function useMcp(options) {
  const {
    url,
    enabled = true,
    callbackUrl = typeof window !== "undefined" ? sanitizeUrl(
      new URL("/oauth/callback", window.location.origin).toString()
    ) : "/oauth/callback",
    storageKeyPrefix = "mcp:auth",
    clientConfig = {},
    authProvider: providedAuthProvider,
    headers: headersOption,
    customHeaders: customHeadersOption,
    proxyConfig,
    autoProxyFallback = true,
    debug: _debug = false,
    logLevel: logLevelOption,
    autoRetry = false,
    autoReconnect = DEFAULT_RECONNECT_DELAY,
    transportType = "auto",
    preventAutoAuth = true,
    // Default to true - require explicit user action for OAuth
    useRedirectFlow = false,
    // Default to false for backward compatibility (use popup)
    onPopupWindow,
    timeout = 3e4,
    // 30 seconds default for connection timeout
    sseReadTimeout = 3e5,
    // 5 minutes default for SSE read timeout
    wrapTransport,
    fetch: customFetch,
    clientOptions,
    onNotification,
    onSampling: onSamplingOption,
    samplingCallback: samplingCallbackOption,
    onElicitation: onElicitationOption,
    elicitationCallback: elicitationCallbackOption
  } = options;
  const instanceLogger = useMemo(() => {
    const name = `useMcp:${url || "no-url"}`;
    const inst = Logger.get(name);
    if (logLevelOption) {
      inst.level = logLevelOption;
    } else if (_debug) {
      inst.level = "debug";
    }
    return inst;
  }, [url, logLevelOption, _debug]);
  const headers = headersOption ?? customHeadersOption ?? {};
  if (customHeadersOption && !headersOption) {
    instanceLogger.warn(
      '[useMcp] The "customHeaders" option is deprecated. Use "headers" instead.'
    );
  }
  const onSampling = onSamplingOption ?? samplingCallbackOption;
  if (samplingCallbackOption && !onSamplingOption) {
    instanceLogger.warn(
      '[useMcp] The "samplingCallback" option is deprecated. Use "onSampling" instead.'
    );
  }
  const onElicitation = onElicitationOption ?? elicitationCallbackOption;
  if (elicitationCallbackOption && !onElicitationOption) {
    logger.warn(
      '[useMcp] The "elicitationCallback" option is deprecated. Use "onElicitation" instead.'
    );
  }
  const defaultClientInfo = useMemo(
    () => ({
      name: "mcp-use",
      title: "mcp-use",
      version: getPackageVersion(),
      description: "mcp-use is a complete TypeScript framework for building and using MCP",
      icons: [
        {
          src: "https://mcp-use.com/logo.png"
        }
      ],
      websiteUrl: "https://mcp-use.com"
    }),
    []
  );
  const mergedClientInfo = useMemo(
    () => options.clientInfo ? { ...defaultClientInfo, ...options.clientInfo } : defaultClientInfo,
    [options.clientInfo, defaultClientInfo]
  );
  const derivedOAuthClientConfig = useMemo(
    () => deriveOAuthClientConfigFromClientInfo(mergedClientInfo),
    [mergedClientInfo]
  );
  const oauthClientConfig = useMemo(() => {
    if (clientConfig && Object.keys(clientConfig).length > 0) {
      instanceLogger.warn(
        "[useMcp] The 'clientConfig' option is deprecated and will be removed in a future version. Use 'clientInfo' instead. The clientConfig will be automatically derived from clientInfo."
      );
      return { ...derivedOAuthClientConfig, ...clientConfig };
    }
    return derivedOAuthClientConfig;
  }, [clientConfig, derivedOAuthClientConfig]);
  const autoProxyFallbackConfig = useMemo(() => {
    if (!autoProxyFallback) {
      return { enabled: false, proxyAddress: void 0 };
    }
    if (typeof autoProxyFallback === "boolean") {
      return {
        enabled: autoProxyFallback,
        proxyAddress: "https://inspector.mcp-use.com/inspector/api/proxy"
      };
    }
    return {
      enabled: autoProxyFallback.enabled !== false,
      proxyAddress: autoProxyFallback.proxyAddress || "https://inspector.mcp-use.com/inspector/api/proxy"
    };
  }, [autoProxyFallback]);
  const hasTriedProxyFallbackRef = useRef(false);
  const [effectiveProxyConfig, setEffectiveProxyConfig] = useState(proxyConfig);
  useEffect(() => {
    setEffectiveProxyConfig(proxyConfig);
  }, [proxyConfig]);
  const { gatewayUrl, proxyHeaders } = useMemo(() => {
    const result = applyProxyConfig(url || "", proxyConfig);
    return {
      gatewayUrl: proxyConfig?.proxyAddress,
      proxyHeaders: result.headers
    };
  }, [url, proxyConfig]);
  const effectiveOAuthUrl = useMemo(() => {
    return url || "";
  }, [url]);
  const allHeaders = useMemo(
    () => ({ ...proxyHeaders, ...headers }),
    [proxyHeaders, headers]
  );
  const [state, setState] = useState("discovering");
  const [tools, setTools] = useState([]);
  const [resources, setResources] = useState([]);
  const [resourceTemplates, setResourceTemplates] = useState([]);
  const [prompts, setPrompts] = useState([]);
  const [serverInfo, setServerInfo] = useState(
    // Only use cached metadata if it has at least a name
    options._initialServerInfo?.name ? options._initialServerInfo : void 0
  );
  const [capabilities, setCapabilities] = useState();
  const [error, setError] = useState(void 0);
  const [log, setLog] = useState([]);
  const [authUrl, setAuthUrl] = useState(void 0);
  const [authTokens, setAuthTokens] = useState(void 0);
  const clientRef = useRef(null);
  const authProviderRef = useRef(
    providedAuthProvider ?? null
  );
  const iconLoadingPromiseRef = useRef(null);
  const connectingRef = useRef(false);
  const isMountedRef = useRef(true);
  const connectAttemptRef = useRef(0);
  const authTimeoutRef = useRef(null);
  const retryScheduledRef = useRef(false);
  const stateRef = useRef(state);
  const autoReconnectRef = useRef(autoReconnect);
  const successfulTransportRef = useRef(null);
  const connectRef = useRef(null);
  const failConnectionRef = useRef(null);
  useEffect(() => {
    stateRef.current = state;
    autoReconnectRef.current = autoReconnect;
  }, [state, autoReconnect]);
  useEffect(() => {
    authProviderRef.current = providedAuthProvider ?? null;
  }, [providedAuthProvider]);
  const addLog = useCallback(
    (level, message, ...args) => {
      const fullMessage = args.length > 0 ? `${message} ${args.map((arg) => JSON.stringify(arg)).join(" ")}` : message;
      const logMsg = `[useMcp] ${fullMessage}`;
      switch (level) {
        case "error":
          instanceLogger.error(logMsg);
          break;
        case "warn":
          instanceLogger.warn(logMsg);
          break;
        case "info":
          instanceLogger.info(logMsg);
          break;
        case "debug":
          instanceLogger.debug(logMsg);
          break;
        default:
          instanceLogger.info(logMsg);
      }
      if (isMountedRef.current) {
        setLog((prevLog) => [
          ...prevLog.slice(-100),
          { level, message: fullMessage, timestamp: Date.now() }
        ]);
      }
    },
    [instanceLogger]
  );
  const disconnect = useCallback(
    async (quiet = false) => {
      if (!quiet) addLog("info", "Disconnecting...");
      connectingRef.current = false;
      if (authTimeoutRef.current) clearTimeout(authTimeoutRef.current);
      authTimeoutRef.current = null;
      if (clientRef.current) {
        try {
          const serverName = USE_MCP_SERVER_NAME;
          const session = clientRef.current.getSession(serverName);
          if (session && session._healthCheckCleanup) {
            session._healthCheckCleanup();
            session._healthCheckCleanup = null;
          }
          if (session) {
            await clientRef.current.closeSession(serverName);
          }
        } catch (err) {
          if (!quiet) addLog("warn", "Error closing session:", err);
        }
      }
      clientRef.current = null;
      if (isMountedRef.current && !quiet) {
        setState("discovering");
        setTools([]);
        setResources([]);
        setResourceTemplates([]);
        setPrompts([]);
        setError(void 0);
        setAuthUrl(void 0);
      }
    },
    [addLog]
  );
  const failConnection = useCallback(
    (errorMessage, connectionError) => {
      addLog("error", errorMessage, connectionError ?? "");
      const errorCode = connectionError && "code" in connectionError ? connectionError.code : void 0;
      const shouldTryProxyFallback = autoProxyFallbackConfig.enabled && !effectiveProxyConfig?.proxyAddress;
      const isCorsError = errorMessage.includes("CORS") || errorMessage.includes("blocked by CORS policy") || errorMessage.includes("Failed to fetch");
      const is400Error = errorCode === 400;
      const hasOther4xxError = typeof errorCode === "number" && errorCode >= 404 && errorCode < 500;
      const isAuthError = errorCode === 401 || errorCode === 403;
      const shouldFallback = shouldTryProxyFallback && (isCorsError || is400Error || hasOther4xxError) && !isAuthError;
      if (shouldFallback) {
        const errorType = isCorsError ? "CORS error" : is400Error ? "HTTP 400 (Bad Request)" : "HTTP 4xx error";
        addLog(
          "info",
          `Direct connection failed with ${errorType}. Trying with proxy...`
        );
        clientRef.current = null;
        if (!providedAuthProvider) {
          authProviderRef.current = null;
        }
        addLog("debug", "Cleared client and auth provider for proxy fallback");
        setEffectiveProxyConfig({
          proxyAddress: autoProxyFallbackConfig.proxyAddress
        });
        if (isMountedRef.current) {
          setState("discovering");
        }
        setTimeout(() => {
          if (isMountedRef.current) {
            connectRef.current?.();
          }
        }, 1e3);
        return true;
      }
      if (isMountedRef.current) {
        addLog("info", "Setting state to FAILED:", errorMessage);
        setState("failed");
        setError(errorMessage);
        const manualUrl = authProviderRef.current?.getLastAttemptedAuthUrl?.();
        if (manualUrl) {
          setAuthUrl(manualUrl);
          addLog(
            "info",
            "Manual authentication URL may be available.",
            manualUrl
          );
        }
      }
      connectingRef.current = false;
      if (url) {
        Tel.getInstance().trackUseMcpConnection({
          url,
          transportType,
          success: false,
          errorType: connectionError?.name || "UnknownError",
          hasOAuth: !!authProviderRef.current,
          hasSampling: !!onSampling,
          hasElicitation: !!onElicitation
        }).catch(() => {
        });
      }
      return false;
    },
    [
      addLog,
      url,
      transportType,
      onSampling,
      onElicitation,
      autoProxyFallbackConfig,
      effectiveProxyConfig,
      providedAuthProvider
    ]
  );
  const connect = useCallback(async () => {
    if (!enabled || !url) {
      addLog(
        "debug",
        enabled ? "No server URL provided, skipping connection." : "Connection disabled via enabled flag."
      );
      return;
    }
    if (connectingRef.current) {
      addLog("debug", "Connection attempt already in progress.");
      return;
    }
    if (!isMountedRef.current) {
      addLog("debug", "Connect called after unmount, aborting.");
      return;
    }
    connectingRef.current = true;
    connectAttemptRef.current += 1;
    setError(void 0);
    setAuthUrl(void 0);
    successfulTransportRef.current = null;
    setState("discovering");
    addLog(
      "info",
      `Connecting attempt #${connectAttemptRef.current} to ${url}...`
    );
    if (!authProviderRef.current) {
      const { provider, oauthProxyUrl } = createBrowserOAuthProvider({
        effectiveOAuthUrl,
        storageKeyPrefix,
        oauthClientConfig,
        callbackUrl,
        preventAutoAuth,
        useRedirectFlow,
        gatewayUrl,
        onPopupWindow,
        installFetchInterceptor: true
      });
      authProviderRef.current = provider;
      if (oauthProxyUrl) {
        addLog(
          "debug",
          `OAuth proxy URL derived from gateway: ${oauthProxyUrl}`
        );
      }
      addLog(
        "debug",
        `BrowserOAuthClientProvider initialized with URL: ${effectiveOAuthUrl}, proxy: ${oauthProxyUrl ? "enabled" : "disabled"}, gateway: ${gatewayUrl ? "enabled" : "disabled"}`
      );
    }
    if (!clientRef.current) {
      clientRef.current = new BrowserMCPClient();
      addLog("debug", "BrowserMCPClient initialized in connect.");
    } else {
      addLog("debug", "BrowserMCPClient already exists, reusing.");
    }
    const tryConnectWithTransport = /* @__PURE__ */ __name(async (transportTypeParam) => {
      if (!isMountedRef.current) {
        addLog("debug", "Connection attempt aborted - component unmounted");
        return "failed";
      }
      addLog(
        "info",
        `Attempting connection with transport: ${transportTypeParam}`
      );
      addLog(
        "debug",
        `Client ref status at start of tryConnectWithTransport: ${clientRef.current ? "initialized" : "NULL"}`
      );
      try {
        const serverName = USE_MCP_SERVER_NAME;
        const serverConfig = {
          url,
          // Use original URL, not transformed proxy URL
          transport: transportTypeParam === "sse" ? "http" : transportTypeParam,
          // Only disable SSE fallback when user explicitly set transportType: "http"
          // Don't disable it when we're in auto mode and just trying HTTP first
          disableSseFallback: transportType === "http",
          // Use SSE transport when explicitly requested
          preferSse: transportTypeParam === "sse",
          clientInfo: mergedClientInfo,
          // Pass custom fetch if provided (e.g., OAuth retry fetch for scope-step-up)
          ...customFetch && { fetch: customFetch },
          // Pass clientOptions for custom capabilities (e.g., MCP Apps extension)
          ...clientOptions && { clientOptions }
        };
        if (gatewayUrl) {
          serverConfig.gatewayUrl = gatewayUrl;
          addLog(
            "debug",
            `Using proxy gateway: ${gatewayUrl} for target: ${url}`
          );
        }
        if (allHeaders && Object.keys(allHeaders).length > 0) {
          serverConfig.headers = allHeaders;
        }
        if (!clientRef.current) {
          if (!isMountedRef.current) {
            addLog(
              "debug",
              "Connection aborted - component unmounted, client cleaned up"
            );
            return "failed";
          }
          const initError = new Error(
            "Client not initialized - this is a bug in the connection flow"
          );
          addLog(
            "error",
            "Client ref is null in tryConnectWithTransport but component is still mounted"
          );
          throw initError;
        }
        clientRef.current.addServer(serverName, {
          ...serverConfig,
          authProvider: authProviderRef.current,
          onSampling,
          onElicitation,
          wrapTransport: wrapTransport ? (transport) => {
            addLog(
              "debug",
              "Applying transport wrapper for server:",
              serverName,
              "url:",
              url
            );
            return wrapTransport(transport, url);
          } : void 0
        });
        const session = await clientRef.current.createSession(
          serverName,
          false
        );
        if (!isMountedRef.current) {
          addLog(
            "debug",
            "Connection aborted after session creation - component unmounted"
          );
          return "failed";
        }
        session.on("notification", (notification) => {
          addLog(
            "debug",
            "Notification received:",
            notification.method,
            notification
          );
          onNotification?.(notification);
          if (notification.method === "notifications/tools/list_changed") {
            addLog("info", "Tools list changed, auto-refreshing...");
            refreshTools().catch((err) => {
              addLog("warn", "Auto-refresh tools failed:", err);
            });
          } else if (notification.method === "notifications/resources/list_changed") {
            addLog("info", "Resources list changed, auto-refreshing...");
            refreshResources().catch(
              (err) => addLog("warn", "Auto-refresh resources failed:", err)
            );
          } else if (notification.method === "notifications/prompts/list_changed") {
            addLog("info", "Prompts list changed, auto-refreshing...");
            refreshPrompts().catch(
              (err) => addLog("warn", "Auto-refresh prompts failed:", err)
            );
          }
        });
        await session.initialize();
        if (!isMountedRef.current) {
          addLog(
            "debug",
            "Connection completed but component unmounted, aborting"
          );
          return "failed";
        }
        addLog("info", "\u2705 Successfully connected to MCP server");
        addLog("info", "Server info:", session.connector.serverInfo);
        addLog(
          "info",
          "Server capabilities:",
          session.connector.serverCapabilities
        );
        if (!isMountedRef.current) {
          addLog("debug", "Skipping state update - component unmounted");
          return "failed";
        }
        setState("ready");
        successfulTransportRef.current = transportTypeParam;
        if (autoReconnect) {
          const cleanup = startConnectionHealthMonitoring({
            gatewayUrl,
            url,
            allHeaders,
            getAuthHeaders: /* @__PURE__ */ __name(async () => {
              try {
                const tokens = await authProviderRef.current?.tokens?.();
                if (tokens?.access_token) {
                  const tokenType = tokens.token_type || "bearer";
                  return {
                    Authorization: `${tokenType.charAt(0).toUpperCase() + tokenType.slice(1)} ${tokens.access_token}`
                  };
                }
              } catch {
              }
              return {};
            }, "getAuthHeaders"),
            isMountedRef,
            stateRef,
            autoReconnectRef,
            setState,
            addLog,
            connect,
            defaultReconnectDelay: DEFAULT_RECONNECT_DELAY
          });
          session._healthCheckCleanup = cleanup;
        }
        Tel.getInstance().trackUseMcpConnection({
          url,
          transportType: transportTypeParam,
          success: true,
          hasOAuth: !!authProviderRef.current,
          hasSampling: !!onSampling,
          hasElicitation: !!onElicitation
        }).catch(() => {
        });
        setTools(session.connector.tools || []);
        const resourcesResult = await session.connector.listAllResources();
        if (!isMountedRef.current) {
          addLog(
            "debug",
            "Connection aborted after listing resources - component unmounted"
          );
          return "failed";
        }
        setResources(resourcesResult.resources || []);
        const promptsResult = await session.connector.listPrompts();
        if (!isMountedRef.current) {
          addLog(
            "debug",
            "Connection aborted after listing prompts - component unmounted"
          );
          return "failed";
        }
        setPrompts(promptsResult.prompts || []);
        const serverInfo2 = session.connector.serverInfo;
        const capabilities2 = session.connector.serverCapabilities;
        if (serverInfo2) {
          addLog("debug", "Server info:", serverInfo2);
          if (!isMountedRef.current) {
            addLog("debug", "Skipping state update - component unmounted");
            return "failed";
          }
          setServerInfo(serverInfo2);
          const loadIconPromise = (async () => {
            try {
              const serverIcons = serverInfo2.icons;
              if (serverIcons && Array.isArray(serverIcons) && serverIcons.length > 0) {
                const iconUrl = serverIcons[0].src || serverIcons[0].url;
                if (iconUrl) {
                  addLog("info", "Server provided icon:", iconUrl);
                  const res = await fetch(iconUrl);
                  const blob = await res.blob();
                  const base64 = await new Promise(
                    (resolve, reject) => {
                      const reader = new FileReader();
                      reader.onloadend = () => resolve(reader.result);
                      reader.onerror = reject;
                      reader.readAsDataURL(blob);
                    }
                  );
                  if (isMountedRef.current) {
                    setServerInfo(
                      (prev) => prev ? { ...prev, icon: base64 } : void 0
                    );
                    addLog("debug", "Server icon converted to base64");
                  }
                  return base64;
                }
              }
              if (url) {
                const faviconBase64 = await detectFavicon(url);
                if (!isMountedRef.current) {
                  addLog(
                    "debug",
                    "Connection aborted after favicon detection - component unmounted"
                  );
                  return null;
                }
                if (faviconBase64) {
                  setServerInfo(
                    (prev) => prev ? { ...prev, icon: faviconBase64 } : void 0
                  );
                  addLog("debug", "Favicon detected and added to serverInfo");
                  return faviconBase64;
                }
              }
              return null;
            } catch (err) {
              addLog("debug", "Icon loading failed (non-critical):", err);
              return null;
            }
          })();
          iconLoadingPromiseRef.current = loadIconPromise;
        }
        if (capabilities2) {
          addLog("debug", "Server capabilities:", capabilities2);
          if (!isMountedRef.current) {
            addLog("debug", "Skipping state update - component unmounted");
            return "failed";
          }
          setCapabilities(capabilities2);
        }
        if (authProviderRef.current) {
          const tokens = await authProviderRef.current.tokens?.();
          if (!isMountedRef.current) {
            addLog(
              "debug",
              "Connection aborted after token fetch for auth tokens - component unmounted"
            );
            return "failed";
          }
          if (tokens?.access_token) {
            const expiresAt = tokens.expires_in ? Date.now() + tokens.expires_in * 1e3 : void 0;
            if (!isMountedRef.current) {
              addLog("debug", "Skipping state update - component unmounted");
              return "failed";
            }
            setAuthTokens({
              access_token: tokens.access_token,
              token_type: tokens.token_type || "Bearer",
              expires_at: expiresAt,
              refresh_token: tokens.refresh_token,
              scope: tokens.scope
            });
          }
        }
        return "success";
      } catch (err) {
        const error2 = err;
        const errorMessage = error2?.message || String(err);
        const oauthDiscoveryFailed = isOAuthDiscoveryFailure(err);
        const is401Error = error2.code === 401 || errorMessage.includes("401") || errorMessage.includes("Unauthorized");
        if (oauthDiscoveryFailed && headers && Object.keys(headers).length > 0) {
          failConnection(
            "Authentication failed (HTTP 401). Server does not support OAuth. Check your Authorization header value is correct."
          );
          return "failed";
        }
        if (oauthDiscoveryFailed && (!headers || Object.keys(headers).length === 0)) {
          failConnection(
            "Authentication required (HTTP 401). Server does not support OAuth. Add an Authorization header in the Custom Headers section (e.g., Authorization: Bearer YOUR_API_KEY)."
          );
          return "failed";
        }
        if (is401Error) {
          if (oauthDiscoveryFailed) {
            failConnection(
              "Authentication required (HTTP 401). Server does not support OAuth. Add an Authorization header in the Custom Headers section (e.g., Authorization: Bearer YOUR_API_KEY)."
            );
            return "failed";
          }
          if (authProviderRef.current) {
            addLog(
              "info",
              "Authentication required. OAuth provider available."
            );
            if (preventAutoAuth) {
              addLog(
                "info",
                "Waiting for user to initiate authentication flow..."
              );
              if (isMountedRef.current) {
                setState("pending_auth");
                const storedAuthUrl = authProviderRef.current?.getLastAttemptedAuthUrl?.();
                if (storedAuthUrl) {
                  setAuthUrl(storedAuthUrl);
                  addLog(
                    "info",
                    "Retrieved stored auth URL for manual authentication"
                  );
                }
              }
              connectingRef.current = false;
              return "auth_redirect";
            } else {
              addLog(
                "info",
                "Triggering automatic OAuth authentication flow..."
              );
              try {
                const { resourceMetadataUrl, scope } = await probeAuthParams(url);
                const authResult = await auth(authProviderRef.current, {
                  serverUrl: url,
                  ...resourceMetadataUrl && { resourceMetadataUrl },
                  ...scope && { scope }
                });
                if (authResult === "REDIRECT") {
                  const authCode = await authProviderRef.current.getAuthorizationCode?.();
                  if (!authCode) {
                    throw new Error(
                      "Authorization code not captured by headless provider"
                    );
                  }
                  await auth(authProviderRef.current, {
                    serverUrl: url,
                    ...resourceMetadataUrl && { resourceMetadataUrl },
                    ...scope && { scope },
                    authorizationCode: authCode
                  });
                }
                addLog("info", "OAuth flow completed, reconnecting...");
                return await tryConnectWithTransport(transportTypeParam);
              } catch (authError) {
                const authErrorMessage = authError instanceof Error ? authError.message : String(authError);
                failConnection(
                  `Automatic OAuth authentication failed: ${authErrorMessage}`,
                  authError instanceof Error ? authError : new Error(String(authError))
                );
                return "failed";
              }
            }
          }
          if (headers && Object.keys(headers).length > 0) {
            failConnection(
              "Authentication failed: Server returned 401 Unauthorized. Check your Authorization header value is correct."
            );
            return "failed";
          }
          failConnection(
            "Authentication required: Server returned 401 Unauthorized. Add an Authorization header in the Custom Headers section (e.g., Authorization: Bearer YOUR_API_KEY)."
          );
          return "failed";
        }
        const isRetryingWithProxy = failConnection(
          errorMessage,
          error2 instanceof Error ? error2 : new Error(String(error2))
        );
        return isRetryingWithProxy ? "auth_redirect" : "failed";
      }
    }, "tryConnectWithTransport");
    let finalStatus = "failed";
    if (transportType === "sse") {
      addLog("debug", "Using SSE-only transport mode");
      finalStatus = await tryConnectWithTransport("sse");
    } else if (transportType === "http") {
      addLog("debug", "Using HTTP-only transport mode");
      finalStatus = await tryConnectWithTransport("http");
    } else {
      addLog("debug", "Using auto transport mode (HTTP with SSE fallback)");
      const httpResult = await tryConnectWithTransport("http");
      if (httpResult === "fallback" && isMountedRef.current && stateRef.current !== "authenticating") {
        addLog("info", "HTTP failed, attempting SSE fallback...");
        const sseResult = await tryConnectWithTransport("sse");
        finalStatus = sseResult;
      } else {
        finalStatus = httpResult;
      }
    }
    if (finalStatus === "success" || finalStatus === "failed" || finalStatus === "auth_redirect") {
      connectingRef.current = false;
    }
    addLog("debug", `Connection sequence finished with status: ${finalStatus}`);
  }, [
    addLog,
    failConnection,
    disconnect,
    url,
    storageKeyPrefix,
    callbackUrl,
    oauthClientConfig.name,
    oauthClientConfig.version,
    oauthClientConfig.uri,
    oauthClientConfig.logo_uri,
    headers,
    transportType,
    preventAutoAuth,
    useRedirectFlow,
    onPopupWindow,
    enabled,
    timeout,
    sseReadTimeout,
    mergedClientInfo,
    // IMPORTANT: Include proxy-related dependencies so connect() uses updated values after fallback
    gatewayUrl,
    allHeaders,
    effectiveOAuthUrl
  ]);
  useEffect(() => {
    connectRef.current = connect;
    failConnectionRef.current = failConnection;
  }, [connect, failConnection]);
  const callTool = useCallback(
    async (name, args, options2) => {
      if (stateRef.current !== "ready" || !clientRef.current) {
        throw new Error(
          `MCP client is not ready (current state: ${state}). Cannot call tool "${name}".`
        );
      }
      addLog("info", `Calling tool: ${name}`, args);
      const startTime = Date.now();
      try {
        const serverName = USE_MCP_SERVER_NAME;
        const session = clientRef.current.getSession(serverName);
        if (!session) {
          throw new Error("No active session found");
        }
        const result = await session.connector.callTool(
          name,
          args || {},
          options2
        );
        addLog("info", `Tool "${name}" call successful:`, result);
        Tel.getInstance().trackUseMcpToolCall({
          toolName: name,
          success: true,
          executionTimeMs: Date.now() - startTime
        }).catch(() => {
        });
        return result;
      } catch (err) {
        addLog("error", `Tool "${name}" call failed:`, err);
        Tel.getInstance().trackUseMcpToolCall({
          toolName: name,
          success: false,
          errorType: err instanceof Error ? err.name : "UnknownError",
          executionTimeMs: Date.now() - startTime
        }).catch(() => {
        });
        throw err;
      }
    },
    [state]
  );
  const retry = useCallback(() => {
    if (stateRef.current === "failed") {
      addLog("info", "Retry requested...");
      connectRef.current?.();
    } else {
      addLog(
        "warn",
        `Retry called but state is not 'failed' (state: ${stateRef.current}). Ignoring.`
      );
    }
  }, [addLog]);
  const authenticate = useCallback(async () => {
    addLog("info", "Manual authentication requested...");
    const currentState = stateRef.current;
    if (currentState === "failed") {
      addLog("info", "Attempting to reconnect and authenticate via retry...");
      retry();
    } else if (currentState === "pending_auth") {
      addLog("info", "Proceeding with authentication from pending state...");
      try {
        assert(
          authProviderRef.current,
          "Auth Provider not available for manual auth"
        );
        assert(url, "Server URL is required for authentication");
        if (providedAuthProvider) {
          addLog(
            "info",
            "Using provided authProvider for manual authentication"
          );
          const baseUrl2 = new URL(url).origin;
          await auth(authProviderRef.current, {
            serverUrl: baseUrl2
          });
          connectRef.current?.();
          return;
        }
        const clearedCount = authProviderRef.current.clearStorage?.() ?? 0;
        addLog(
          "info",
          `Cleared ${clearedCount} OAuth storage item(s) for fresh authentication`
        );
        setState("authenticating");
        const { provider: freshAuthProvider, oauthProxyUrl } = createBrowserOAuthProvider({
          effectiveOAuthUrl,
          storageKeyPrefix,
          oauthClientConfig,
          callbackUrl,
          preventAutoAuth: false,
          useRedirectFlow,
          gatewayUrl,
          onPopupWindow,
          installFetchInterceptor: !gatewayUrl
        });
        if (oauthProxyUrl && !gatewayUrl) {
          addLog("info", "Installed OAuth fetch interceptor for manual auth");
        } else if (oauthProxyUrl && gatewayUrl) {
          addLog(
            "info",
            "Using MCP gateway proxy for OAuth (no fetch interceptor needed)"
          );
        }
        authProviderRef.current = freshAuthProvider;
        addLog("info", "Triggering fresh OAuth authorization...");
        const baseUrl = new URL(url).origin;
        try {
          await auth(freshAuthProvider, {
            serverUrl: baseUrl
          });
          addLog("info", "OAuth flow completed (tokens obtained)");
        } catch (err) {
          addLog(
            "info",
            "OAuth flow initiated (popup/redirect):",
            err instanceof Error ? err.message : "Redirecting..."
          );
        }
        const newAuthUrl = freshAuthProvider.getLastAttemptedAuthUrl?.();
        if (newAuthUrl) {
          setAuthUrl(newAuthUrl);
          addLog("info", "Updated auth URL for fallback:", newAuthUrl);
        }
      } catch (authError) {
        if (!isMountedRef.current) return;
        setState("pending_auth");
        addLog(
          "error",
          `Manual authentication failed: ${authError instanceof Error ? authError.message : String(authError)}`
        );
      }
    } else if (currentState === "authenticating") {
      addLog(
        "warn",
        "Already attempting authentication. Check for blocked popups or wait for timeout."
      );
      const manualUrl = authProviderRef.current?.getLastAttemptedAuthUrl?.();
      if (manualUrl && !authUrl) {
        setAuthUrl(manualUrl);
        addLog("info", "Manual authentication URL retrieved:", manualUrl);
      }
    } else {
      addLog(
        "info",
        `Client not in a state requiring manual authentication trigger (state: ${currentState}). If needed, try disconnecting and reconnecting.`
      );
    }
  }, [
    addLog,
    retry,
    authUrl,
    url,
    useRedirectFlow,
    onPopupWindow,
    storageKeyPrefix,
    oauthClientConfig.name,
    oauthClientConfig.uri,
    oauthClientConfig.logo_uri,
    callbackUrl,
    mergedClientInfo,
    providedAuthProvider
  ]);
  const clearStorage = useCallback(() => {
    if (authProviderRef.current?.clearStorage) {
      const count = authProviderRef.current.clearStorage();
      addLog("info", `Cleared ${count} item(s) from localStorage for ${url}.`);
      setAuthUrl(void 0);
      disconnect();
    } else {
      addLog("warn", "Auth provider not initialized, cannot clear storage.");
    }
  }, [url, addLog, disconnect]);
  const listResources = useCallback(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      throw new Error(
        `MCP client is not ready (current state: ${state}). Cannot list resources.`
      );
    }
    addLog("info", "Listing resources");
    try {
      const serverName = USE_MCP_SERVER_NAME;
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        throw new Error("No active session found");
      }
      const resourcesResult = await session.connector.listAllResources();
      setResources(resourcesResult.resources || []);
      addLog("info", "Resources listed successfully");
    } catch (err) {
      addLog("error", "List resources failed:", err);
      throw err;
    }
  }, [state]);
  const readResource = useCallback(
    async (uri) => {
      if (stateRef.current !== "ready" || !clientRef.current) {
        throw new Error(
          `MCP client is not ready (current state: ${state}). Cannot read resource.`
        );
      }
      addLog("info", `Reading resource: ${uri}`);
      try {
        const serverName = USE_MCP_SERVER_NAME;
        const session = clientRef.current.getSession(serverName);
        if (!session) {
          throw new Error("No active session found");
        }
        const result = await session.connector.readResource(uri);
        addLog("info", "Resource read successful:", result);
        Tel.getInstance().trackUseMcpResourceRead({
          resourceUri: uri,
          success: true
        }).catch(() => {
        });
        return result;
      } catch (err) {
        addLog("error", "Resource read failed:", err);
        Tel.getInstance().trackUseMcpResourceRead({
          resourceUri: uri,
          success: false,
          errorType: err instanceof Error ? err.name : "UnknownError"
        }).catch(() => {
        });
        throw err;
      }
    },
    [state]
  );
  const listPrompts = useCallback(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      throw new Error(
        `MCP client is not ready (current state: ${state}). Cannot list prompts.`
      );
    }
    addLog("info", "Listing prompts");
    try {
      const serverName = USE_MCP_SERVER_NAME;
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        throw new Error("No active session found");
      }
      const promptsResult = await session.connector.listPrompts();
      setPrompts(promptsResult.prompts || []);
      addLog("info", "Prompts listed successfully");
    } catch (err) {
      addLog("error", "List prompts failed:", err);
      throw err;
    }
  }, [state]);
  const refreshTools = useCallback(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      addLog(
        "debug",
        "Cannot refresh tools - client not ready. State:",
        stateRef.current
      );
      return;
    }
    addLog("debug", "Refreshing tools list");
    try {
      const serverName = USE_MCP_SERVER_NAME;
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        addLog("warn", "No active session found for tools refresh");
        return;
      }
      addLog("debug", "Calling listTools...");
      const toolsResult = await session.connector.listTools();
      addLog("debug", "listTools returned:", toolsResult?.length, "tools");
      setTools(toolsResult || []);
      addLog("info", "Tools list refreshed successfully");
    } catch (err) {
      addLog("error", "Failed to refresh tools:", err);
    }
  }, [addLog]);
  const refreshResources = useCallback(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      addLog("debug", "Cannot refresh resources - client not ready");
      return;
    }
    addLog("debug", "Refreshing resources list");
    try {
      const serverName = USE_MCP_SERVER_NAME;
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        addLog("warn", "No active session found for resources refresh");
        return;
      }
      const resourcesResult = await session.connector.listAllResources();
      setResources(resourcesResult.resources || []);
      addLog("info", "Resources list refreshed successfully");
    } catch (err) {
      addLog("warn", "Failed to refresh resources:", err);
    }
  }, [addLog]);
  const refreshPrompts = useCallback(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      addLog("debug", "Cannot refresh prompts - client not ready");
      return;
    }
    addLog("debug", "Refreshing prompts list");
    try {
      const serverName = USE_MCP_SERVER_NAME;
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        addLog("warn", "No active session found for prompts refresh");
        return;
      }
      const promptsResult = await session.connector.listPrompts();
      setPrompts(promptsResult.prompts || []);
      addLog("info", "Prompts list refreshed successfully");
    } catch (err) {
      addLog("warn", "Failed to refresh prompts:", err);
    }
  }, [addLog]);
  const refreshAll = useCallback(async () => {
    addLog("info", "Refreshing all lists (tools, resources, prompts)");
    await Promise.all([refreshTools(), refreshResources(), refreshPrompts()]);
  }, [refreshTools, refreshResources, refreshPrompts, addLog]);
  const getPrompt = useCallback(
    async (name, args) => {
      if (stateRef.current !== "ready" || !clientRef.current) {
        throw new Error(
          `MCP client is not ready (current state: ${state}). Cannot get prompt.`
        );
      }
      addLog("info", `Getting prompt: ${name}`, args);
      try {
        const serverName = USE_MCP_SERVER_NAME;
        const session = clientRef.current.getSession(serverName);
        if (!session) {
          throw new Error("No active session found");
        }
        const result = await session.connector.getPrompt(name, args || {});
        addLog("info", `Prompt "${name}" retrieved successfully:`, result);
        return result;
      } catch (err) {
        addLog("error", `Prompt "${name}" retrieval failed:`, err);
        throw err;
      }
    },
    [state]
  );
  useEffect(() => {
    const messageHandler = /* @__PURE__ */ __name((event) => {
      if (event.origin !== window.location.origin) return;
      if (event.data?.type === "mcp_auth_callback") {
        addLog("info", "Received auth callback message.", event.data);
        if (authTimeoutRef.current) clearTimeout(authTimeoutRef.current);
        authTimeoutRef.current = null;
        if (event.data.success) {
          addLog(
            "info",
            "Authentication successful via popup. Reconnecting client..."
          );
          if (connectingRef.current) {
            addLog(
              "debug",
              "Connection attempt already in progress, resetting flag to allow reconnection."
            );
          }
          connectingRef.current = false;
          setTimeout(() => {
            if (isMountedRef.current) {
              addLog(
                "debug",
                "Initiating reconnection after successful auth callback."
              );
              connectRef.current?.();
            }
          }, 100);
        } else {
          failConnectionRef.current?.(
            `Authentication failed in callback: ${event.data.error || "Unknown reason."}`
          );
        }
      }
    }, "messageHandler");
    window.addEventListener("message", messageHandler);
    addLog("debug", "Auth callback message listener added.");
    return () => {
      window.removeEventListener("message", messageHandler);
      addLog("debug", "Auth callback message listener removed.");
      if (authTimeoutRef.current) clearTimeout(authTimeoutRef.current);
    };
  }, [addLog]);
  useEffect(() => {
    hasTriedProxyFallbackRef.current = false;
    setEffectiveProxyConfig(proxyConfig);
  }, [url, proxyConfig]);
  useEffect(() => {
    isMountedRef.current = true;
    if (!enabled || !url) {
      addLog(
        "debug",
        enabled ? "No server URL provided, skipping connection." : "Connection disabled via enabled flag."
      );
      setState("discovering");
      return () => {
        isMountedRef.current = false;
      };
    }
    addLog("debug", "useMcp mounted, initiating connection.");
    connectAttemptRef.current = 0;
    if (providedAuthProvider) {
      authProviderRef.current = providedAuthProvider;
      addLog("debug", "Using externally provided authProvider");
    } else if (!authProviderRef.current || authProviderRef.current.serverUrl !== effectiveOAuthUrl) {
      const { provider, oauthProxyUrl } = createBrowserOAuthProvider({
        effectiveOAuthUrl,
        storageKeyPrefix,
        oauthClientConfig,
        callbackUrl,
        preventAutoAuth,
        useRedirectFlow,
        gatewayUrl,
        onPopupWindow,
        installFetchInterceptor: true
      });
      authProviderRef.current = provider;
      if (oauthProxyUrl) {
        addLog(
          "debug",
          `OAuth proxy URL derived from gateway: ${oauthProxyUrl}`
        );
      }
      addLog(
        "debug",
        `BrowserOAuthClientProvider initialized/updated with URL: ${effectiveOAuthUrl}, proxy: ${oauthProxyUrl ? "enabled" : "disabled"}, gateway: ${gatewayUrl ? "enabled" : "disabled"}`
      );
    }
    connect();
    return () => {
      isMountedRef.current = false;
      addLog("debug", "useMcp unmounting, disconnecting.");
      if ((stateRef.current === "authenticating" || stateRef.current === "pending_auth") && authProviderRef.current) {
        try {
          const count = authProviderRef.current.clearStorage?.() ?? 0;
          if (count > 0) {
            addLog(
              "debug",
              `Cleared ${count} OAuth state item(s) during unmount to prevent corruption`
            );
          }
        } catch (err) {
          addLog("debug", "Error clearing OAuth state during unmount:", err);
        }
      }
      disconnect(true);
    };
  }, [
    url,
    enabled,
    storageKeyPrefix,
    callbackUrl,
    oauthClientConfig.name,
    oauthClientConfig.version,
    oauthClientConfig.uri,
    oauthClientConfig.logo_uri,
    useRedirectFlow,
    mergedClientInfo,
    effectiveOAuthUrl,
    // Triggers reconnection when proxy fallback changes OAuth URL
    proxyConfig,
    // Triggers reconnection when proxy config (including headers) changes
    providedAuthProvider
  ]);
  const retryRef = useRef(retry);
  const addLogRef = useRef(addLog);
  useEffect(() => {
    retryRef.current = retry;
    addLogRef.current = addLog;
  }, [retry, addLog]);
  useEffect(() => {
    let retryTimeoutId = null;
    if (state === "failed" && autoRetry && connectAttemptRef.current > 0) {
      if (!retryScheduledRef.current) {
        retryScheduledRef.current = true;
        const delay = typeof autoRetry === "number" ? autoRetry : DEFAULT_RETRY_DELAY;
        addLogRef.current(
          "info",
          `Connection failed, auto-retrying in ${delay}ms...`
        );
        retryTimeoutId = setTimeout(() => {
          retryScheduledRef.current = false;
          if (isMountedRef.current && stateRef.current === "failed") {
            retryRef.current();
          }
        }, delay);
      }
    } else if (state !== "failed") {
      retryScheduledRef.current = false;
    }
    return () => {
      if (retryTimeoutId) {
        clearTimeout(retryTimeoutId);
        retryScheduledRef.current = false;
      }
    };
  }, [state, autoRetry]);
  const ensureIconLoaded = useCallback(async () => {
    if (stateRef.current !== "ready") {
      addLog("warn", "Cannot ensure icon loaded - not connected");
      return null;
    }
    if (serverInfo?.icon) {
      return serverInfo.icon;
    }
    if (iconLoadingPromiseRef.current) {
      addLog("debug", "Waiting for icon to finish loading...");
      const icon = await iconLoadingPromiseRef.current;
      return icon;
    }
    addLog("debug", "No icon available and no loading in progress");
    return null;
  }, [serverInfo, addLog]);
  return {
    state,
    name: serverInfo?.name || url || "",
    tools,
    resources,
    resourceTemplates,
    prompts,
    serverInfo,
    capabilities,
    error,
    log,
    authUrl,
    authTokens,
    client: clientRef.current,
    callTool,
    readResource,
    listResources,
    listPrompts,
    getPrompt,
    refreshTools,
    refreshResources,
    refreshPrompts,
    refreshAll,
    retry,
    disconnect,
    authenticate,
    clearStorage,
    ensureIconLoaded
  };
}
__name(useMcp, "useMcp");

// src/react/ErrorBoundary.tsx
import React from "react";
var logger2 = Logger.get("ErrorBoundary");
var ErrorBoundary = class extends React.Component {
  static {
    __name(this, "ErrorBoundary");
  }
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidCatch(error, errorInfo) {
    logger2.error("Widget Error:", error, errorInfo);
  }
  render() {
    if (this.state.hasError) {
      return /* @__PURE__ */ React.createElement("div", { className: "p-4 border border-red-500 bg-red-50 text-red-900 rounded-md dark:bg-red-900/20 dark:text-red-100" }, /* @__PURE__ */ React.createElement("h3", { className: "font-bold mb-2" }, "Widget Error"), /* @__PURE__ */ React.createElement("pre", { className: "text-sm whitespace-pre-wrap" }, this.state.error?.message));
    }
    return this.props.children;
  }
};

// src/react/Image.tsx
import React2 from "react";
var Image = /* @__PURE__ */ __name(({ src, ...props }) => {
  const publicUrl = typeof window !== "undefined" ? window.__mcpPublicAssetsUrl || window.__mcpPublicUrl || "" : "";
  const getFinalSrc = /* @__PURE__ */ __name((source) => {
    if (!source) return source;
    if (source.startsWith("http://") || source.startsWith("https://") || source.startsWith("data:")) {
      return source;
    }
    if (!publicUrl) {
      return source;
    }
    const cleanSrc = source.startsWith("/") ? source.slice(1) : source;
    return `${publicUrl}/${cleanSrc}`;
  }, "getFinalSrc");
  const finalSrc = getFinalSrc(src);
  return /* @__PURE__ */ React2.createElement("img", { src: finalSrc, ...props });
}, "Image");

// src/react/ThemeProvider.tsx
import React3, { useEffect as useEffect3, useLayoutEffect, useState as useState3 } from "react";

// src/react/useWidget.ts
import {
  useCallback as useCallback2,
  useEffect as useEffect2,
  useMemo as useMemo2,
  useState as useState2,
  useSyncExternalStore
} from "react";

// src/react/constants.ts
var WIDGET_DEFAULTS = {
  /** Polling interval for checking window.openai availability (ms) */
  POLL_INTERVAL: 100,
  /** Maximum timeout for window.openai availability check (ms) */
  MAX_TIMEOUT: 5e3,
  /** Default maximum height for widgets */
  MAX_HEIGHT: 600,
  /** Default locale */
  LOCALE: "en"
};
var MCP_APPS_BRIDGE_CONFIG = {
  /** Request timeout (ms) */
  REQUEST_TIMEOUT: 3e4,
  /** App name for identification */
  APP_NAME: "mcp-use-widget",
  /** App version */
  APP_VERSION: "1.0.0",
  /** MCP Apps protocol version */
  PROTOCOL_VERSION: "2025-06-18"
};

// src/react/mcp-apps-bridge.ts
var McpAppsBridge = class {
  static {
    __name(this, "McpAppsBridge");
  }
  connected = false;
  connectPromise = null;
  requestId = 1;
  pendingRequests = /* @__PURE__ */ new Map();
  listeners = /* @__PURE__ */ new Set();
  // State
  toolInput = null;
  partialToolInput = null;
  toolOutput = null;
  toolResponseMetadata = null;
  hostContext = null;
  initialized = false;
  // Event handlers
  toolInputHandlers = /* @__PURE__ */ new Set();
  toolInputPartialHandlers = /* @__PURE__ */ new Set();
  toolResultHandlers = /* @__PURE__ */ new Set();
  hostContextHandlers = /* @__PURE__ */ new Set();
  constructor() {
    if (typeof window === "undefined") return;
    const handleMessage = /* @__PURE__ */ __name((event) => {
      const message = event.data;
      if (!message || message.jsonrpc !== "2.0") return;
      if ("result" in message || "error" in message) {
        const response = message;
        if (response.id !== null && response.id !== void 0) {
          const pending = this.pendingRequests.get(response.id);
          if (pending) {
            this.pendingRequests.delete(response.id);
            if ("error" in response && response.error) {
              pending.reject(new Error(response.error.message));
            } else {
              pending.resolve(response.result);
            }
          }
        }
        return;
      }
      if ("method" in message && !("id" in message)) {
        this.handleNotification(message);
      }
    }, "handleMessage");
    window.addEventListener("message", handleMessage);
    this.listeners.add(handleMessage);
    this.interceptConsole();
  }
  /**
   * Intercept console methods and proxy to MCP Apps host
   */
  interceptConsole() {
    if (typeof window === "undefined" || typeof console === "undefined") return;
    const originalConsole = {
      log: console.log.bind(console),
      warn: console.warn.bind(console),
      error: console.error.bind(console),
      info: console.info.bind(console),
      debug: console.debug.bind(console)
    };
    const consoleLevelToRfc5424 = {
      log: "info",
      warn: "warning",
      error: "error",
      info: "info",
      debug: "debug"
    };
    const serializeForPostMessage = /* @__PURE__ */ __name((value, seen = /* @__PURE__ */ new WeakSet()) => {
      if (value === null || value === void 0) return value;
      if (typeof value !== "object") return value;
      if (seen.has(value)) return "[Circular]";
      if (value instanceof Response) {
        return {
          __type: "Response",
          status: value.status,
          statusText: value.statusText,
          ok: value.ok,
          url: value.url,
          headers: Object.fromEntries(value.headers.entries())
        };
      }
      if (value instanceof Request) {
        return {
          __type: "Request",
          method: value.method,
          url: value.url,
          headers: Object.fromEntries(value.headers.entries())
        };
      }
      if (value instanceof Error) {
        return {
          __type: "Error",
          name: value.name,
          message: value.message,
          stack: value.stack
        };
      }
      if (value instanceof Event) {
        return {
          __type: "Event",
          type: value.type,
          target: value.target?.constructor?.name
        };
      }
      if (typeof HTMLElement !== "undefined" && value instanceof HTMLElement) {
        return {
          __type: "HTMLElement",
          tagName: value.tagName,
          id: value.id,
          className: value.className
        };
      }
      if (typeof value === "function") {
        return `[Function: ${value.name || "anonymous"}]`;
      }
      if (Array.isArray(value)) {
        seen.add(value);
        return value.map((item) => serializeForPostMessage(item, seen));
      }
      try {
        seen.add(value);
        const serialized = {};
        for (const key in value) {
          if (Object.prototype.hasOwnProperty.call(value, key)) {
            try {
              serialized[key] = serializeForPostMessage(value[key], seen);
            } catch {
              serialized[key] = "[Unserializable]";
            }
          }
        }
        return serialized;
      } catch {
        return "[Object]";
      }
    }, "serializeForPostMessage");
    const sendLog = /* @__PURE__ */ __name((level, args) => {
      try {
        const serializedArgs = args.map((arg) => serializeForPostMessage(arg));
        this.sendNotification("notifications/message", {
          level: consoleLevelToRfc5424[level] || "info",
          logger: "console",
          data: serializedArgs.length === 1 ? serializedArgs[0] : serializedArgs
        });
      } catch (error) {
        originalConsole.warn(
          "[MCP Apps Bridge] Failed to forward console message:",
          error
        );
      }
    }, "sendLog");
    console.log = (...args) => {
      sendLog("log", args);
      originalConsole.log(...args);
    };
    console.warn = (...args) => {
      sendLog("warn", args);
      originalConsole.warn(...args);
    };
    console.error = (...args) => {
      sendLog("error", args);
      originalConsole.error(...args);
    };
    console.info = (...args) => {
      sendLog("info", args);
      originalConsole.info(...args);
    };
    console.debug = (...args) => {
      sendLog("debug", args);
      originalConsole.debug(...args);
    };
  }
  handleNotification(notification) {
    console.log(
      "[MCP Apps Bridge] Received notification:",
      notification.method,
      notification.params
    );
    switch (notification.method) {
      case "ui/notifications/tool-input": {
        const params = notification.params;
        console.log("[MCP Apps Bridge] Tool input received:", params.arguments);
        this.toolInput = params.arguments;
        this.toolInputHandlers.forEach((handler) => handler(params.arguments));
        break;
      }
      case "ui/notifications/tool-input-partial": {
        const params = notification.params;
        console.log(
          "[MCP Apps Bridge] Partial tool input received:",
          params.arguments
        );
        this.partialToolInput = params.arguments;
        this.toolInputPartialHandlers.forEach(
          (handler) => handler(params.arguments)
        );
        break;
      }
      case "ui/notifications/tool-result": {
        const params = notification.params;
        const output = params.structuredContent || this.parseTextContent(params);
        const meta = params._meta || null;
        this.toolOutput = output;
        this.toolResponseMetadata = meta;
        this.partialToolInput = null;
        this.toolResultHandlers.forEach((handler) => handler(output));
        break;
      }
      case "ui/notifications/host-context-changed": {
        const context = notification.params;
        console.log("[MCP Apps Bridge] Host context changed:", context);
        this.hostContext = { ...this.hostContext, ...context };
        console.log("[MCP Apps Bridge] Merged hostContext:", this.hostContext);
        console.log(
          "[MCP Apps Bridge] Calling handlers:",
          this.hostContextHandlers.size
        );
        this.hostContextHandlers.forEach(
          (handler) => handler(this.hostContext)
        );
        break;
      }
      case "ui/notifications/initialized": {
        this.initialized = true;
        break;
      }
      default:
        break;
    }
  }
  parseTextContent(result) {
    if (result.content && Array.isArray(result.content)) {
      for (const block of result.content) {
        if (block.type === "text" && block.text) {
          try {
            const parsed = JSON.parse(block.text);
            if (parsed && typeof parsed === "object" && !Array.isArray(parsed)) {
              return parsed;
            }
          } catch {
          }
        }
      }
    }
    return {};
  }
  sendRequest(method, params) {
    if (typeof window === "undefined" || !window.parent) {
      return Promise.reject(new Error("Not in iframe context"));
    }
    const id = this.requestId++;
    const message = createRequest(
      id,
      method,
      params
    );
    return new Promise((resolve, reject) => {
      this.pendingRequests.set(id, { resolve, reject });
      window.parent.postMessage(message, "*");
      setTimeout(() => {
        if (this.pendingRequests.has(id)) {
          this.pendingRequests.delete(id);
          reject(new Error(`Request timeout: ${method}`));
        }
      }, MCP_APPS_BRIDGE_CONFIG.REQUEST_TIMEOUT);
    });
  }
  sendNotification(method, params) {
    if (typeof window === "undefined" || !window.parent) return;
    const message = createNotification(
      method,
      params
    );
    window.parent.postMessage(message, "*");
  }
  /**
   * Initialize connection with MCP Apps host.
   * Concurrent calls share the same in-flight connection attempt so that
   * React StrictMode double-invocations and multiple useWidget() hooks
   * only produce a single ui/initialize request.
   */
  async connect() {
    if (this.connected) return;
    if (typeof window === "undefined" || window === window.parent) {
      console.log("[MCP Apps Bridge] Not in iframe, skipping connection");
      return;
    }
    if (!this.connectPromise) {
      this.connectPromise = this.doConnect();
      this.connectPromise.catch(() => {
        this.connectPromise = null;
      });
    }
    return this.connectPromise;
  }
  async doConnect() {
    console.log("[MCP Apps Bridge] Connecting to MCP Apps host...");
    try {
      const result = await this.sendRequest("ui/initialize", {
        appCapabilities: {},
        appInfo: {
          name: MCP_APPS_BRIDGE_CONFIG.APP_NAME,
          version: MCP_APPS_BRIDGE_CONFIG.APP_VERSION
        },
        protocolVersion: MCP_APPS_BRIDGE_CONFIG.PROTOCOL_VERSION
      });
      console.log("[MCP Apps Bridge] Initialize result:", result);
      if (result.hostContext) {
        this.hostContext = result.hostContext;
        console.log("[MCP Apps Bridge] Host context:", this.hostContext);
      }
      this.sendNotification("ui/notifications/initialized", {});
      this.connected = true;
      console.log("[MCP Apps Bridge] Successfully connected");
    } catch (error) {
      console.error("[MCP Apps Bridge] Failed to connect:", error);
      throw error;
    }
  }
  /**
   * Check if connected to MCP Apps host
   */
  isConnected() {
    return this.connected;
  }
  /**
   * Get current tool input (props)
   */
  getToolInput() {
    return this.toolInput;
  }
  /**
   * Get current partial/streaming tool input
   */
  getPartialToolInput() {
    return this.partialToolInput;
  }
  /**
   * Get current tool output (structuredContent from tool result)
   */
  getToolOutput() {
    return this.toolOutput;
  }
  /**
   * Get tool response metadata (_meta from tool result)
   */
  getToolResponseMetadata() {
    return this.toolResponseMetadata;
  }
  /**
   * Get host context
   */
  getHostContext() {
    return this.hostContext;
  }
  /**
   * Subscribe to tool input changes
   */
  onToolInput(handler) {
    this.toolInputHandlers.add(handler);
    return () => this.toolInputHandlers.delete(handler);
  }
  /**
   * Subscribe to partial/streaming tool input changes
   */
  onToolInputPartial(handler) {
    this.toolInputPartialHandlers.add(handler);
    return () => this.toolInputPartialHandlers.delete(handler);
  }
  /**
   * Subscribe to tool result changes
   */
  onToolResult(handler) {
    this.toolResultHandlers.add(handler);
    return () => this.toolResultHandlers.delete(handler);
  }
  /**
   * Subscribe to host context changes
   */
  onHostContextChange(handler) {
    this.hostContextHandlers.add(handler);
    return () => this.hostContextHandlers.delete(handler);
  }
  /**
   * Call a tool on the server
   */
  async callTool(name, args) {
    return this.sendRequest("tools/call", { name, arguments: args });
  }
  /**
   * Send a message to the conversation
   */
  async sendMessage(content) {
    const contentArray = Array.isArray(content) ? content : [content];
    await this.sendRequest("ui/message", {
      role: "user",
      content: contentArray
    });
  }
  /**
   * Open an external link
   */
  async openLink(url) {
    await this.sendRequest("ui/open-link", { url });
  }
  /**
   * Request display mode change
   */
  async requestDisplayMode(mode) {
    const result = await this.sendRequest("ui/request-display-mode", { mode });
    return result;
  }
  /**
   * Update the host's model context (SEP-1865 ui/update-model-context).
   * The host will include this data in the model's context on future turns.
   * Each call overwrites the previous context.
   */
  async updateModelContext(params) {
    await this.sendRequest("ui/update-model-context", params);
  }
  /**
   * Notify host about size changes for auto-sizing
   * Sends ui/notifications/size-changed notification per SEP-1865
   */
  sendSizeChanged(params) {
    this.sendNotification("ui/notifications/size-changed", params);
  }
  /**
   * Cleanup
   */
  disconnect() {
    this.listeners.forEach((listener) => {
      if (typeof window !== "undefined") {
        window.removeEventListener("message", listener);
      }
    });
    this.listeners.clear();
    this.pendingRequests.clear();
    this.toolInputHandlers.clear();
    this.toolInputPartialHandlers.clear();
    this.toolResultHandlers.clear();
    this.hostContextHandlers.clear();
    this.connected = false;
    this.connectPromise = null;
  }
};
var bridgeInstance = null;
function getMcpAppsBridge() {
  if (!bridgeInstance) {
    bridgeInstance = new McpAppsBridge();
  }
  return bridgeInstance;
}
__name(getMcpAppsBridge, "getMcpAppsBridge");

// src/react/widget-utils.ts
function normalizeCallToolResponse(raw) {
  if (raw && typeof raw === "object" && "result" in raw) {
    return raw;
  }
  const content = raw?.content || [];
  const structuredContent = raw?.structuredContent || {};
  const result = content.filter((block) => block.type === "text" && block.text).map((block) => block.text).join("\n");
  const isError = raw?.isError ?? false;
  const _meta = raw?._meta;
  return {
    content,
    structuredContent,
    isError,
    result,
    _meta
  };
}
__name(normalizeCallToolResponse, "normalizeCallToolResponse");

// src/react/widget-types.ts
var SET_GLOBALS_EVENT_TYPE = "openai:set_globals";

// src/react/useWidget.ts
function useOpenAiGlobal(key) {
  return useSyncExternalStore(
    (onChange) => {
      let lastValue = typeof window !== "undefined" && window.openai ? window.openai[key] : void 0;
      const handleSetGlobal = /* @__PURE__ */ __name((event) => {
        const customEvent = event;
        const value = customEvent.detail.globals[key];
        if (value === void 0) {
          return;
        }
        if (value === lastValue) return;
        lastValue = value;
        onChange();
      }, "handleSetGlobal");
      if (typeof window !== "undefined") {
        window.addEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobal);
      }
      return () => {
        if (typeof window !== "undefined") {
          window.removeEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobal);
        }
      };
    },
    () => typeof window !== "undefined" && window.openai ? window.openai[key] : void 0
  );
}
__name(useOpenAiGlobal, "useOpenAiGlobal");
function useWidget(defaultProps) {
  const [isOpenAiAvailable, setIsOpenAiAvailable] = useState2(
    () => typeof window !== "undefined" && !!window.openai
  );
  const [isMcpAppsConnected, setIsMcpAppsConnected] = useState2(false);
  const [mcpAppsToolInput, setMcpAppsToolInput] = useState2(null);
  const [mcpAppsToolOutput, setMcpAppsToolOutput] = useState2(null);
  const [mcpAppsResponseMetadata, setMcpAppsResponseMetadata] = useState2(null);
  const [mcpAppsPartialToolInput, setMcpAppsPartialToolInput] = useState2(null);
  const [mcpAppsHostContext, setMcpAppsHostContext] = useState2(null);
  useEffect2(() => {
    if (typeof window !== "undefined" && window.openai) {
      setIsOpenAiAvailable(true);
      return;
    }
    const checkInterval = setInterval(() => {
      if (typeof window !== "undefined" && window.openai) {
        setIsOpenAiAvailable(true);
        clearInterval(checkInterval);
      }
    }, 100);
    const handleSetGlobals = /* @__PURE__ */ __name(() => {
      if (typeof window !== "undefined" && window.openai) {
        setIsOpenAiAvailable(true);
        clearInterval(checkInterval);
      }
    }, "handleSetGlobals");
    if (typeof window !== "undefined") {
      window.addEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobals);
    }
    const timeout = setTimeout(() => {
      clearInterval(checkInterval);
      if (typeof window !== "undefined") {
        window.removeEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobals);
      }
    }, 5e3);
    return () => {
      clearInterval(checkInterval);
      clearTimeout(timeout);
      if (typeof window !== "undefined") {
        window.removeEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobals);
      }
    };
  }, []);
  useEffect2(() => {
    if (typeof window === "undefined" || window.openai || window === window.parent) {
      return;
    }
    const bridge = getMcpAppsBridge();
    bridge.connect().then(() => {
      setIsMcpAppsConnected(true);
      const toolInput2 = bridge.getToolInput();
      const toolOutput2 = bridge.getToolOutput();
      const responseMeta = bridge.getToolResponseMetadata();
      const hostContext = bridge.getHostContext();
      const partialToolInput2 = bridge.getPartialToolInput();
      if (toolInput2) setMcpAppsToolInput(toolInput2);
      if (toolOutput2) setMcpAppsToolOutput(toolOutput2);
      if (responseMeta) setMcpAppsResponseMetadata(responseMeta);
      if (partialToolInput2) setMcpAppsPartialToolInput(partialToolInput2);
      if (hostContext) setMcpAppsHostContext(hostContext);
    }).catch((error) => {
      console.warn("[useWidget] Failed to connect to MCP Apps host:", error);
    });
    const unsubToolInput = bridge.onToolInput((input) => {
      setMcpAppsToolInput(input);
    });
    const unsubToolInputPartial = bridge.onToolInputPartial((input) => {
      setMcpAppsPartialToolInput(input);
    });
    const unsubToolResult = bridge.onToolResult((result) => {
      setMcpAppsToolOutput(result);
      setMcpAppsResponseMetadata(bridge.getToolResponseMetadata());
      setMcpAppsPartialToolInput(null);
    });
    const unsubHostContext = bridge.onHostContextChange((context) => {
      console.log("[useWidget] Host context change received:", context);
      setMcpAppsHostContext(context);
    });
    return () => {
      unsubToolInput();
      unsubToolInputPartial();
      unsubToolResult();
      unsubHostContext();
    };
  }, []);
  const provider = useMemo2(() => {
    if (isOpenAiAvailable) return "openai";
    if (isMcpAppsConnected) return "mcp-apps";
    return "mcp-ui";
  }, [isOpenAiAvailable, isMcpAppsConnected]);
  const searchString = typeof window !== "undefined" ? window.location.search : "";
  const urlParams = useMemo2(() => {
    const urlParams2 = new URLSearchParams(searchString);
    if (urlParams2.has("mcpUseParams")) {
      return JSON.parse(urlParams2.get("mcpUseParams"));
    }
    return {
      toolInput: {},
      toolOutput: {},
      toolId: ""
    };
  }, [searchString]);
  const openaiToolInput = useOpenAiGlobal("toolInput");
  const openaiToolOutput = useOpenAiGlobal("toolOutput");
  const toolResponseMetadata = useOpenAiGlobal("toolResponseMetadata");
  const widgetState = useOpenAiGlobal("widgetState");
  const openaiTheme = useOpenAiGlobal("theme");
  const openaiDisplayMode = useOpenAiGlobal("displayMode");
  const openaiSafeArea = useOpenAiGlobal("safeArea");
  const openaiMaxHeight = useOpenAiGlobal("maxHeight");
  const openaiUserAgent = useOpenAiGlobal("userAgent");
  const openaiLocale = useOpenAiGlobal("locale");
  const toolInput = useMemo2(() => {
    if (provider === "openai") return openaiToolInput;
    if (provider === "mcp-apps")
      return mcpAppsToolInput;
    return urlParams.toolInput;
  }, [provider, openaiToolInput, mcpAppsToolInput, urlParams.toolInput]);
  const toolOutput = useMemo2(() => {
    if (provider === "openai") {
      const raw = openaiToolOutput;
      if (raw && raw.structuredContent && typeof raw.structuredContent === "object") {
        return raw.structuredContent;
      }
      return openaiToolOutput;
    }
    if (provider === "mcp-apps")
      return mcpAppsToolOutput;
    return urlParams.toolOutput;
  }, [provider, openaiToolOutput, mcpAppsToolOutput, urlParams.toolOutput]);
  const widgetProps = useMemo2(() => {
    const ti = toolInput || {};
    const base = defaultProps || {};
    let structuredContent;
    if (provider === "openai" && openaiToolOutput) {
      const raw = openaiToolOutput;
      if (raw.structuredContent && typeof raw.structuredContent === "object") {
        structuredContent = raw.structuredContent;
      } else {
        structuredContent = raw;
      }
    } else if (provider === "mcp-apps" && mcpAppsToolOutput) {
      structuredContent = mcpAppsToolOutput;
    } else if (provider === "mcp-ui" && urlParams.toolOutput) {
      structuredContent = urlParams.toolOutput;
    }
    const merged = { ...base, ...ti, ...structuredContent || {} };
    return merged;
  }, [
    provider,
    toolInput,
    openaiToolOutput,
    mcpAppsToolOutput,
    urlParams.toolOutput,
    defaultProps
  ]);
  const theme = useMemo2(() => {
    if (provider === "openai") return openaiTheme;
    if (provider === "mcp-apps" && mcpAppsHostContext) {
      return mcpAppsHostContext.theme;
    }
    return void 0;
  }, [provider, openaiTheme, mcpAppsHostContext]);
  const displayMode = useMemo2(() => {
    if (provider === "openai") return openaiDisplayMode;
    if (provider === "mcp-apps" && mcpAppsHostContext) {
      return mcpAppsHostContext.displayMode;
    }
    return void 0;
  }, [provider, openaiDisplayMode, mcpAppsHostContext]);
  const safeArea = useMemo2(() => {
    if (provider === "openai") return openaiSafeArea;
    if (provider === "mcp-apps" && mcpAppsHostContext?.safeAreaInsets) {
      return {
        insets: mcpAppsHostContext.safeAreaInsets
      };
    }
    return void 0;
  }, [provider, openaiSafeArea, mcpAppsHostContext]);
  const maxHeight = useMemo2(() => {
    if (provider === "openai") return openaiMaxHeight;
    if (provider === "mcp-apps" && mcpAppsHostContext?.containerDimensions) {
      return mcpAppsHostContext.containerDimensions.maxHeight;
    }
    return void 0;
  }, [provider, openaiMaxHeight, mcpAppsHostContext]);
  const maxWidth = useMemo2(() => {
    if (provider === "openai") {
      return void 0;
    }
    if (provider === "mcp-apps" && mcpAppsHostContext?.containerDimensions) {
      return mcpAppsHostContext.containerDimensions.maxWidth;
    }
    return void 0;
  }, [provider, mcpAppsHostContext]);
  const userAgent = useMemo2(() => {
    if (provider === "openai") return openaiUserAgent;
    if (provider === "mcp-apps" && mcpAppsHostContext) {
      return {
        device: {
          type: mcpAppsHostContext.platform === "mobile" ? "mobile" : "desktop"
        },
        capabilities: {
          hover: mcpAppsHostContext.deviceCapabilities?.hover ?? false,
          touch: mcpAppsHostContext.deviceCapabilities?.touch ?? false
        }
      };
    }
    return void 0;
  }, [provider, openaiUserAgent, mcpAppsHostContext]);
  const locale = useMemo2(() => {
    if (provider === "openai") return openaiLocale;
    if (provider === "mcp-apps" && mcpAppsHostContext) {
      return mcpAppsHostContext.locale;
    }
    return void 0;
  }, [provider, openaiLocale, mcpAppsHostContext]);
  const timeZone = useMemo2(() => {
    if (provider === "openai") {
      return typeof window !== "undefined" ? Intl.DateTimeFormat().resolvedOptions().timeZone : void 0;
    }
    if (provider === "mcp-apps" && mcpAppsHostContext) {
      return mcpAppsHostContext.timeZone;
    }
    return void 0;
  }, [provider, mcpAppsHostContext]);
  const mcp_url = useMemo2(() => {
    if (typeof window !== "undefined" && window.__mcpPublicUrl) {
      return window.__mcpPublicUrl.replace(/\/mcp-use\/public$/, "");
    }
    return "";
  }, []);
  const [localWidgetState, setLocalWidgetState] = useState2(null);
  useEffect2(() => {
    if (widgetState !== void 0) {
      setLocalWidgetState(widgetState);
    }
  }, [widgetState]);
  const callTool = useCallback2(
    async (name, args) => {
      if (provider === "mcp-apps") {
        const bridge = getMcpAppsBridge();
        const raw2 = await bridge.callTool(name, args);
        return normalizeCallToolResponse(raw2);
      }
      if (!window.openai?.callTool) {
        throw new Error("window.openai.callTool is not available");
      }
      const raw = await window.openai.callTool(name, args);
      return normalizeCallToolResponse(raw);
    },
    [provider]
  );
  const sendFollowUpMessage = useCallback2(
    async (prompt) => {
      if (provider === "mcp-apps") {
        const bridge = getMcpAppsBridge();
        await bridge.sendMessage({ type: "text", text: prompt });
        return;
      }
      if (!window.openai?.sendFollowUpMessage) {
        throw new Error("window.openai.sendFollowUpMessage is not available");
      }
      return window.openai.sendFollowUpMessage({ prompt });
    },
    [provider]
  );
  const openExternal = useCallback2(
    (href) => {
      if (provider === "mcp-apps") {
        const bridge = getMcpAppsBridge();
        bridge.openLink(href).catch((error) => {
          console.error("Failed to open link:", error);
        });
        return;
      }
      if (!window.openai?.openExternal) {
        throw new Error("window.openai.openExternal is not available");
      }
      window.openai.openExternal({ href });
    },
    [provider]
  );
  const requestDisplayMode = useCallback2(
    async (mode) => {
      if (provider === "mcp-apps") {
        const bridge = getMcpAppsBridge();
        return await bridge.requestDisplayMode(mode);
      }
      if (!window.openai?.requestDisplayMode) {
        throw new Error("window.openai.requestDisplayMode is not available");
      }
      return window.openai.requestDisplayMode({ mode });
    },
    [provider]
  );
  const setState = useCallback2(
    async (state) => {
      if (provider === "mcp-apps") {
        const currentState2 = localWidgetState;
        const newState2 = typeof state === "function" ? state(currentState2) : state;
        setLocalWidgetState(newState2);
        const bridge = getMcpAppsBridge();
        bridge.updateModelContext({
          structuredContent: newState2,
          content: [{ type: "text", text: JSON.stringify(newState2) }]
        }).catch((err) => {
          console.warn("[useWidget] Failed to update model context:", err);
        });
        return;
      }
      if (!window.openai?.setWidgetState) {
        throw new Error("window.openai.setWidgetState is not available");
      }
      const currentState = widgetState !== void 0 ? widgetState : localWidgetState;
      const newState = typeof state === "function" ? state(currentState) : state;
      setLocalWidgetState(newState);
      return window.openai.setWidgetState(newState);
    },
    [provider, widgetState, localWidgetState]
  );
  const isPending = useMemo2(() => {
    if (provider === "openai") {
      return openaiToolOutput === null && toolResponseMetadata === null;
    }
    if (provider === "mcp-apps") {
      return mcpAppsToolOutput === null;
    }
    if (provider === "mcp-ui") {
      if (typeof window !== "undefined" && window !== window.parent && !urlParams.toolId) {
        return true;
      }
      return toolOutput === null || toolOutput === void 0;
    }
    return false;
  }, [
    provider,
    openaiToolOutput,
    toolResponseMetadata,
    mcpAppsToolOutput,
    toolOutput,
    urlParams.toolId
  ]);
  const partialToolInput = useMemo2(() => {
    if (provider === "mcp-apps" && mcpAppsPartialToolInput) {
      return mcpAppsPartialToolInput;
    }
    return null;
  }, [provider, mcpAppsPartialToolInput]);
  const isStreaming = useMemo2(() => {
    if (provider === "mcp-apps") {
      return mcpAppsPartialToolInput !== null;
    }
    return false;
  }, [provider, mcpAppsPartialToolInput]);
  return {
    // Props and state (with defaults)
    props: widgetProps,
    toolInput: toolInput || {},
    output: toolOutput ?? null,
    metadata: provider === "mcp-apps" ? mcpAppsResponseMetadata ?? null : toolResponseMetadata ?? null,
    state: localWidgetState,
    setState,
    // Layout and theme (with safe defaults)
    theme: theme || "light",
    displayMode: displayMode || "inline",
    safeArea: safeArea || { insets: { top: 0, bottom: 0, left: 0, right: 0 } },
    maxHeight: maxHeight || 600,
    maxWidth,
    userAgent: userAgent || {
      device: { type: "desktop" },
      capabilities: { hover: true, touch: false }
    },
    locale: locale || WIDGET_DEFAULTS.LOCALE,
    timeZone: timeZone || (typeof window !== "undefined" ? Intl.DateTimeFormat().resolvedOptions().timeZone : "UTC"),
    mcp_url,
    // Actions
    callTool,
    sendFollowUpMessage,
    openExternal,
    requestDisplayMode,
    // Availability
    isAvailable: isOpenAiAvailable || isMcpAppsConnected,
    isPending,
    // Streaming
    partialToolInput,
    isStreaming
  };
}
__name(useWidget, "useWidget");
function useWidgetProps(defaultProps) {
  const { props } = useWidget(defaultProps);
  return props;
}
__name(useWidgetProps, "useWidgetProps");
function useWidgetTheme() {
  const { theme } = useWidget();
  return theme;
}
__name(useWidgetTheme, "useWidgetTheme");
function useWidgetState(defaultState) {
  const { state, setState } = useWidget();
  useEffect2(() => {
    if (state === null && defaultState !== void 0 && window.openai?.setWidgetState) {
      setState(defaultState);
    }
  }, []);
  return [state, setState];
}
__name(useWidgetState, "useWidgetState");

// src/react/ThemeProvider.tsx
var ThemeProvider = /* @__PURE__ */ __name(({
  children
}) => {
  const { theme, isAvailable } = useWidget();
  const [systemPreference, setSystemPreference] = useState3(
    () => {
      if (typeof window === "undefined") return "light";
      return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
  );
  useEffect3(() => {
    if (typeof window === "undefined") return;
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    const handleChange = /* @__PURE__ */ __name((e) => {
      setSystemPreference(e.matches ? "dark" : "light");
    }, "handleChange");
    mediaQuery.addEventListener("change", handleChange);
    return () => mediaQuery.removeEventListener("change", handleChange);
  }, []);
  const effectiveTheme = isAvailable ? theme : systemPreference;
  useLayoutEffect(() => {
    if (typeof document === "undefined") return;
    const root = document.documentElement;
    root.classList.remove("light", "dark");
    root.classList.add(effectiveTheme === "dark" ? "dark" : "light");
    root.setAttribute(
      "data-theme",
      effectiveTheme === "dark" ? "dark" : "light"
    );
    root.style.colorScheme = effectiveTheme === "dark" ? "dark" : "light";
  }, [effectiveTheme]);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, children);
}, "ThemeProvider");

// src/react/WidgetControls.tsx
import React4, { useEffect as useEffect4, useRef as useRef2, useState as useState4 } from "react";
function WidgetControls({
  children,
  className = "",
  position = "top-right",
  attachTo,
  showLabels = true,
  debugger: enableDebugger = false,
  viewControls = false
}) {
  const {
    props,
    output,
    metadata,
    state,
    theme,
    displayMode,
    safeArea,
    maxHeight,
    userAgent,
    locale,
    isAvailable,
    callTool,
    sendFollowUpMessage,
    openExternal,
    requestDisplayMode,
    setState
  } = useWidget();
  const [isHovered, setIsHovered] = useState4(false);
  const [isOverlayOpen, setIsOverlayOpen] = useState4(false);
  const containerRef = useRef2(null);
  const overlayRef = useRef2(null);
  const [windowOpenAiKeys, setWindowOpenAiKeys] = useState4([]);
  const [actionResult, setActionResult] = useState4("");
  const [toolName, setToolName] = useState4("get-my-city");
  const [toolArgs, setToolArgs] = useState4("{}");
  const [followUpMessage, setFollowUpMessage] = useState4(
    "Test follow-up message"
  );
  const [externalUrl, setExternalUrl] = useState4(
    "https://mcp-use.com/docs"
  );
  const isFullscreen = displayMode === "fullscreen" && isAvailable;
  const isPip = displayMode === "pip" && isAvailable;
  const isInInspector = typeof window !== "undefined" && window.location.pathname.includes("/inspector/api/");
  useEffect4(() => {
    const timeoutId = setTimeout(() => {
      if (typeof window !== "undefined" && window.openai) {
        try {
          const keys = Object.keys(window.openai);
          setWindowOpenAiKeys(keys);
        } catch (e) {
          setWindowOpenAiKeys([]);
        }
      } else {
        setWindowOpenAiKeys([]);
      }
    }, 100);
    return () => {
      clearTimeout(timeoutId);
    };
  }, []);
  const isDark = theme === "dark";
  const getPositionClasses = /* @__PURE__ */ __name(() => {
    const baseClasses = [
      "absolute",
      "z-[1000]",
      "flex",
      "gap-2",
      "transition-opacity",
      "duration-200",
      "ease-in-out",
      isHovered ? "opacity-100" : "opacity-0",
      isHovered ? "pointer-events-auto" : "pointer-events-none"
    ];
    switch (position) {
      case "top-left":
        return [...baseClasses, "top-4", "left-4"];
      case "top-center":
        return [...baseClasses, "top-4", "left-1/2", "-translate-x-1/2"];
      case "top-right":
        return [...baseClasses, "top-4", "right-4"];
      case "center-left":
        return [...baseClasses, "top-1/2", "left-4", "-translate-y-1/2"];
      case "center-right":
        return [...baseClasses, "top-1/2", "right-4", "-translate-y-1/2"];
      case "bottom-left":
        return [...baseClasses, "bottom-4", "left-4"];
      case "bottom-center":
        return [...baseClasses, "bottom-4", "left-1/2", "-translate-x-1/2"];
      case "bottom-right":
        return [...baseClasses, "bottom-4", "right-4"];
      default:
        return [...baseClasses, "top-4", "right-4"];
    }
  }, "getPositionClasses");
  const getPositionOffsetStyles = /* @__PURE__ */ __name(() => {
    const baseOffset = 16;
    const topOffset = safeArea?.insets?.top ? Math.max(baseOffset, safeArea.insets.top + 8) : baseOffset;
    const rightOffset = safeArea?.insets?.right ? Math.max(baseOffset, safeArea.insets.right + 8) : baseOffset;
    const bottomOffset = safeArea?.insets?.bottom ? Math.max(baseOffset, safeArea.insets.bottom + 8) : baseOffset;
    const leftOffset = safeArea?.insets?.left ? Math.max(baseOffset, safeArea.insets.left + 8) : baseOffset;
    const styles = {};
    switch (position) {
      case "top-left":
        styles.top = `${topOffset}px`;
        styles.left = `${leftOffset}px`;
        break;
      case "top-center":
        styles.top = `${topOffset}px`;
        break;
      case "top-right":
        styles.top = `${topOffset}px`;
        styles.right = `${rightOffset}px`;
        break;
      case "center-left":
        styles.left = `${leftOffset}px`;
        break;
      case "center-right":
        styles.right = `${rightOffset}px`;
        break;
      case "bottom-left":
        styles.bottom = `${bottomOffset}px`;
        styles.left = `${leftOffset}px`;
        break;
      case "bottom-center":
        styles.bottom = `${bottomOffset}px`;
        break;
      case "bottom-right":
        styles.bottom = `${bottomOffset}px`;
        styles.right = `${rightOffset}px`;
        break;
      default:
        styles.top = `${topOffset}px`;
        styles.right = `${rightOffset}px`;
        break;
    }
    return styles;
  }, "getPositionOffsetStyles");
  useEffect4(() => {
    if (!attachTo) return;
    const handleMouseEnter = /* @__PURE__ */ __name(() => setIsHovered(true), "handleMouseEnter");
    const handleMouseLeave = /* @__PURE__ */ __name(() => setIsHovered(false), "handleMouseLeave");
    attachTo.addEventListener("mouseenter", handleMouseEnter);
    attachTo.addEventListener("mouseleave", handleMouseLeave);
    return () => {
      attachTo.removeEventListener("mouseenter", handleMouseEnter);
      attachTo.removeEventListener("mouseleave", handleMouseLeave);
    };
  }, [attachTo]);
  useEffect4(() => {
    if (!isOverlayOpen) return;
    const handleClickOutside = /* @__PURE__ */ __name((event) => {
      if (overlayRef.current && !overlayRef.current.contains(event.target)) {
        setIsOverlayOpen(false);
      }
    }, "handleClickOutside");
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [isOverlayOpen]);
  useEffect4(() => {
    if (isOverlayOpen) {
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = "";
    }
    return () => {
      document.body.style.overflow = "";
    };
  }, [isOverlayOpen]);
  const handleToggleOverlay = /* @__PURE__ */ __name(() => {
    setIsOverlayOpen(!isOverlayOpen);
  }, "handleToggleOverlay");
  const handleCallTool = /* @__PURE__ */ __name(async () => {
    try {
      setActionResult("Calling tool...");
      const args = toolArgs.trim() ? JSON.parse(toolArgs) : {};
      const result = await callTool(toolName, args);
      setActionResult(`Success: ${JSON.stringify(result, null, 2)}`);
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleCallTool");
  const handleSendFollowUpMessage = /* @__PURE__ */ __name(async () => {
    try {
      setActionResult("Sending follow-up message...");
      await sendFollowUpMessage(followUpMessage);
      setActionResult("Follow-up message sent successfully");
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleSendFollowUpMessage");
  const handleOpenExternal = /* @__PURE__ */ __name(() => {
    try {
      openExternal(externalUrl);
      setActionResult(`Opened external link: ${externalUrl}`);
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleOpenExternal");
  const handleRequestDisplayMode = /* @__PURE__ */ __name(async (mode) => {
    try {
      setActionResult(`Requesting display mode: ${mode}...`);
      const result = await requestDisplayMode(mode);
      setActionResult(`Display mode granted: ${result.mode}`);
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleRequestDisplayMode");
  const handleSetState = /* @__PURE__ */ __name(async () => {
    try {
      const newState = state ? { ...state, debugTimestamp: (/* @__PURE__ */ new Date()).toISOString() } : { debugTimestamp: (/* @__PURE__ */ new Date()).toISOString() };
      setActionResult("Setting state...");
      await setState(newState);
      setActionResult(`State updated: ${JSON.stringify(newState, null, 2)}`);
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleSetState");
  const handleFullscreen = /* @__PURE__ */ __name(async () => {
    try {
      await requestDisplayMode("fullscreen");
    } catch (error) {
      console.error("Failed to go fullscreen:", error);
    }
  }, "handleFullscreen");
  const handlePip = /* @__PURE__ */ __name(async () => {
    try {
      await requestDisplayMode("pip");
    } catch (error) {
      console.error("Failed to go pip:", error);
    }
  }, "handlePip");
  const getTooltipClasses = /* @__PURE__ */ __name(() => {
    const baseClasses = [
      "absolute",
      "px-2",
      "py-1",
      "bg-black/90",
      "text-white",
      "rounded",
      "text-xs",
      "whitespace-nowrap",
      "pointer-events-none",
      "transition-opacity",
      "duration-200",
      "ease-in-out"
    ];
    switch (position) {
      case "top-right":
        return [...baseClasses, "top-full", "right-0", "mt-2"];
      case "top-left":
        return [...baseClasses, "top-full", "left-0", "mt-2"];
      case "top-center":
        return [
          ...baseClasses,
          "top-full",
          "left-1/2",
          "-translate-x-1/2",
          "mt-2"
        ];
      case "bottom-right":
        return [...baseClasses, "bottom-full", "right-0", "mb-2"];
      case "bottom-left":
        return [...baseClasses, "bottom-full", "left-0", "mb-2"];
      case "bottom-center":
        return [
          ...baseClasses,
          "bottom-full",
          "left-1/2",
          "-translate-x-1/2",
          "mb-2"
        ];
      case "center-left":
        return [
          ...baseClasses,
          "left-full",
          "top-1/2",
          "-translate-y-1/2",
          "ml-2"
        ];
      case "center-right":
        return [
          ...baseClasses,
          "right-full",
          "top-1/2",
          "-translate-y-1/2",
          "mr-2"
        ];
      default:
        return [...baseClasses, "top-full", "right-0", "mt-2"];
    }
  }, "getTooltipClasses");
  const IconButton = /* @__PURE__ */ __name(({
    onClick,
    label,
    children: icon
  }) => {
    const [isButtonHovered, setIsButtonHovered] = useState4(false);
    const tooltipClasses = getTooltipClasses();
    return /* @__PURE__ */ React4.createElement(
      "button",
      {
        className: `p-2 ${isDark ? "bg-white/10 hover:bg-white/20" : "bg-black/70 hover:bg-black/90"} text-white border-none rounded-lg cursor-pointer flex items-center justify-center w-8 h-8 transition-colors duration-200 backdrop-blur-md ${isDark ? "shadow-[0_2px_8px_rgba(0,0,0,0.3)]" : "shadow-[0_2px_8px_rgba(0,0,0,0.2)]"} relative`,
        onMouseEnter: () => setIsButtonHovered(true),
        onMouseLeave: () => setIsButtonHovered(false),
        onClick,
        "aria-label": label
      },
      /* @__PURE__ */ React4.createElement(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          width: "16",
          height: "16",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          className: "block"
        },
        icon
      ),
      showLabels && /* @__PURE__ */ React4.createElement(
        "span",
        {
          className: `${tooltipClasses.join(" ")} ${isButtonHovered ? "opacity-100" : "opacity-0"}`
        },
        label
      )
    );
  }, "IconButton");
  const formatValue = /* @__PURE__ */ __name((value) => {
    if (value === null) return "null";
    if (value === void 0) return "undefined";
    if (typeof value === "object") {
      try {
        return JSON.stringify(value, null, 2);
      } catch {
        return String(value);
      }
    }
    return String(value);
  }, "formatValue");
  const formatUserAgent = /* @__PURE__ */ __name((ua) => {
    if (!ua) return "N/A";
    return `${ua.device?.type || "unknown"}`;
  }, "formatUserAgent");
  const formatSafeArea = /* @__PURE__ */ __name((sa) => {
    if (!sa?.insets) return "N/A";
    const { top, bottom, left, right } = sa.insets;
    return `T:${top} B:${bottom} L:${left} R:${right}`;
  }, "formatSafeArea");
  return /* @__PURE__ */ React4.createElement(React4.Fragment, null, /* @__PURE__ */ React4.createElement(
    "div",
    {
      ref: containerRef,
      className: `${className} relative h-fit`,
      onMouseEnter: () => !attachTo && setIsHovered(true),
      onMouseLeave: () => !attachTo && setIsHovered(false)
    },
    /* @__PURE__ */ React4.createElement(
      "div",
      {
        className: getPositionClasses().join(" "),
        style: getPositionOffsetStyles()
      },
      !isInInspector && /* @__PURE__ */ React4.createElement(React4.Fragment, null, !isFullscreen && !isPip && /* @__PURE__ */ React4.createElement(React4.Fragment, null, (viewControls === true || viewControls === "fullscreen") && /* @__PURE__ */ React4.createElement(IconButton, { onClick: handleFullscreen, label: "Fullscreen" }, /* @__PURE__ */ React4.createElement("path", { d: "M15 3h6v6" }), /* @__PURE__ */ React4.createElement("path", { d: "m21 3-7 7" }), /* @__PURE__ */ React4.createElement("path", { d: "m3 21 7-7" }), /* @__PURE__ */ React4.createElement("path", { d: "M9 21H3v-6" })), (viewControls === true || viewControls === "pip") && /* @__PURE__ */ React4.createElement(IconButton, { onClick: handlePip, label: "Picture in Picture" }, /* @__PURE__ */ React4.createElement("path", { d: "M21 9V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v10c0 1.1.9 2 2 2h4" }), /* @__PURE__ */ React4.createElement("rect", { width: "10", height: "7", x: "12", y: "13", rx: "2" }))), enableDebugger && /* @__PURE__ */ React4.createElement(IconButton, { onClick: handleToggleOverlay, label: "Debug Info" }, /* @__PURE__ */ React4.createElement("path", { d: "M12 20v-9" }), /* @__PURE__ */ React4.createElement("path", { d: "M14 7a4 4 0 0 1 4 4v3a6 6 0 0 1-12 0v-3a4 4 0 0 1 4-4z" }), /* @__PURE__ */ React4.createElement("path", { d: "M14.12 3.88 16 2" }), /* @__PURE__ */ React4.createElement("path", { d: "M21 21a4 4 0 0 0-3.81-4" }), /* @__PURE__ */ React4.createElement("path", { d: "M21 5a4 4 0 0 1-3.55 3.97" }), /* @__PURE__ */ React4.createElement("path", { d: "M22 13h-4" }), /* @__PURE__ */ React4.createElement("path", { d: "M3 21a4 4 0 0 1 3.81-4" }), /* @__PURE__ */ React4.createElement("path", { d: "M3 5a4 4 0 0 0 3.55 3.97" }), /* @__PURE__ */ React4.createElement("path", { d: "M6 13H2" }), /* @__PURE__ */ React4.createElement("path", { d: "m8 2 1.88 1.88" }), /* @__PURE__ */ React4.createElement("path", { d: "M9 7.13V6a3 3 0 1 1 6 0v1.13" })))
    ),
    children
  ), isOverlayOpen && enableDebugger && /* @__PURE__ */ React4.createElement(
    "div",
    {
      ref: overlayRef,
      className: "fixed inset-0 bg-black text-white font-mono text-xs z-[10000] overflow-auto p-4",
      onClick: (e) => {
        if (e.target === overlayRef.current) {
          setIsOverlayOpen(false);
        }
      }
    },
    /* @__PURE__ */ React4.createElement(
      "button",
      {
        onClick: () => setIsOverlayOpen(false),
        className: "absolute top-4 right-4 bg-white/10 text-white border-none rounded w-8 h-8 cursor-pointer flex items-center justify-center text-lg leading-none",
        "aria-label": "Close"
      },
      "\xD7"
    ),
    /* @__PURE__ */ React4.createElement("div", { className: "max-w-[1200px] mx-auto pt-10" }, /* @__PURE__ */ React4.createElement("h1", { className: "text-lg font-bold mb-4 border-b border-gray-700 pb-2" }, "Debug Info"), /* @__PURE__ */ React4.createElement("table", { className: "w-full border-collapse border-spacing-0" }, /* @__PURE__ */ React4.createElement("tbody", null, /* @__PURE__ */ React4.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ React4.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Props"), /* @__PURE__ */ React4.createElement("td", { className: "p-2 whitespace-pre-wrap break-all" }, formatValue(props))), /* @__PURE__ */ React4.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ React4.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Output"), /* @__PURE__ */ React4.createElement("td", { className: "p-2 whitespace-pre-wrap break-all" }, formatValue(output))), /* @__PURE__ */ React4.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ React4.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Metadata"), /* @__PURE__ */ React4.createElement("td", { className: "p-2 whitespace-pre-wrap break-all" }, formatValue(metadata))), /* @__PURE__ */ React4.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ React4.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "State"), /* @__PURE__ */ React4.createElement("td", { className: "p-2 whitespace-pre-wrap break-all" }, formatValue(state))), /* @__PURE__ */ React4.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ React4.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Theme"), /* @__PURE__ */ React4.createElement("td", { className: "p-2" }, theme)), /* @__PURE__ */ React4.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ React4.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Display Mode"), /* @__PURE__ */ React4.createElement("td", { className: "p-2" }, displayMode)), /* @__PURE__ */ React4.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ React4.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Locale"), /* @__PURE__ */ React4.createElement("td", { className: "p-2" }, locale)), /* @__PURE__ */ React4.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ React4.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Max Height"), /* @__PURE__ */ React4.createElement("td", { className: "p-2" }, maxHeight, "px")), /* @__PURE__ */ React4.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ React4.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "User Agent"), /* @__PURE__ */ React4.createElement("td", { className: "p-2" }, formatUserAgent(userAgent))), /* @__PURE__ */ React4.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ React4.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Safe Area"), /* @__PURE__ */ React4.createElement("td", { className: "p-2" }, formatSafeArea(safeArea))), /* @__PURE__ */ React4.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ React4.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "API Available"), /* @__PURE__ */ React4.createElement("td", { className: "p-2" }, isAvailable ? "Yes" : "No")), /* @__PURE__ */ React4.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ React4.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "window.openai Keys"), /* @__PURE__ */ React4.createElement("td", { className: "p-2" }, windowOpenAiKeys.length > 0 ? windowOpenAiKeys.join(", ") : "N/A")))), /* @__PURE__ */ React4.createElement("h2", { className: "text-base font-bold mt-8 mb-4 border-b border-gray-700 pb-2" }, "Actions"), /* @__PURE__ */ React4.createElement("div", { className: "flex flex-col gap-3" }, /* @__PURE__ */ React4.createElement("div", { className: "flex gap-2 items-center" }, /* @__PURE__ */ React4.createElement(
      "input",
      {
        type: "text",
        value: toolName,
        onChange: (e) => setToolName(e.target.value),
        placeholder: "Tool name",
        className: "py-1.5 px-2 bg-[#1a1a1a] text-white border border-gray-700 rounded font-mono text-xs w-[150px]"
      }
    ), /* @__PURE__ */ React4.createElement(
      "input",
      {
        type: "text",
        value: toolArgs,
        onChange: (e) => setToolArgs(e.target.value),
        placeholder: '{"key": "value"}',
        className: "py-1.5 px-2 bg-[#1a1a1a] text-white border border-gray-700 rounded font-mono text-xs flex-1"
      }
    ), /* @__PURE__ */ React4.createElement(
      "button",
      {
        onClick: handleCallTool,
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs"
      },
      "Call Tool"
    )), /* @__PURE__ */ React4.createElement("div", { className: "flex gap-2 items-center" }, /* @__PURE__ */ React4.createElement(
      "input",
      {
        type: "text",
        value: followUpMessage,
        onChange: (e) => setFollowUpMessage(e.target.value),
        placeholder: "Follow-up message",
        className: "py-1.5 px-2 bg-[#1a1a1a] text-white border border-gray-700 rounded font-mono text-xs flex-1"
      }
    ), /* @__PURE__ */ React4.createElement(
      "button",
      {
        onClick: handleSendFollowUpMessage,
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs"
      },
      "Send Follow-Up"
    )), /* @__PURE__ */ React4.createElement("div", { className: "flex gap-2 items-center" }, /* @__PURE__ */ React4.createElement(
      "input",
      {
        type: "text",
        value: externalUrl,
        onChange: (e) => setExternalUrl(e.target.value),
        placeholder: "External URL",
        className: "py-1.5 px-2 bg-[#1a1a1a] text-white border border-gray-700 rounded font-mono text-xs flex-1"
      }
    ), /* @__PURE__ */ React4.createElement(
      "button",
      {
        onClick: handleOpenExternal,
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs"
      },
      "Open Link"
    )), /* @__PURE__ */ React4.createElement("div", { className: "flex gap-2 items-center" }, /* @__PURE__ */ React4.createElement("span", { className: "w-[150px] text-xs" }, "Display Mode:"), /* @__PURE__ */ React4.createElement(
      "button",
      {
        onClick: () => handleRequestDisplayMode("inline"),
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs flex-1"
      },
      "Inline"
    ), /* @__PURE__ */ React4.createElement(
      "button",
      {
        onClick: () => handleRequestDisplayMode("pip"),
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs flex-1"
      },
      "PiP"
    ), /* @__PURE__ */ React4.createElement(
      "button",
      {
        onClick: () => handleRequestDisplayMode("fullscreen"),
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs flex-1"
      },
      "Fullscreen"
    )), /* @__PURE__ */ React4.createElement("div", { className: "flex gap-2 items-center" }, /* @__PURE__ */ React4.createElement(
      "button",
      {
        onClick: handleSetState,
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs"
      },
      "Set State (Add Timestamp)"
    )), actionResult && /* @__PURE__ */ React4.createElement("div", { className: "mt-2 p-2 bg-[#1a1a1a] border border-gray-700 rounded whitespace-pre-wrap break-all text-[11px] max-h-[200px] overflow-auto" }, /* @__PURE__ */ React4.createElement("div", { className: "font-bold mb-1 text-gray-400" }, "Result:"), actionResult, /* @__PURE__ */ React4.createElement(
      "button",
      {
        onClick: () => setActionResult(""),
        className: "mt-2 py-1 px-2 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-[11px]"
      },
      "Clear"
    ))))
  ));
}
__name(WidgetControls, "WidgetControls");

// src/react/McpUseProvider.tsx
import React5, {
  StrictMode,
  useCallback as useCallback3,
  useEffect as useEffect5,
  useRef as useRef3,
  useState as useState5
} from "react";
var HEIGHT_DEBOUNCE_MS = 150;
var MIN_HEIGHT_CHANGE_PX = 5;
function McpUseProvider({
  children,
  debugger: enableDebugger = false,
  viewControls = false,
  autoSize = true
}) {
  const [containerElement, setContainerElement] = useState5(null);
  const lastHeightRef = useRef3(0);
  const debounceTimeoutRef = useRef3(null);
  const notificationInProgressRef = useRef3(false);
  const notifyHeight = useCallback3((height) => {
    if (typeof window === "undefined") return;
    notificationInProgressRef.current = true;
    if (window.openai?.notifyIntrinsicHeight) {
      window.openai.notifyIntrinsicHeight(height).then(() => {
        notificationInProgressRef.current = false;
      }).catch((error) => {
        notificationInProgressRef.current = false;
        console.error(
          "[McpUseProvider] Failed to notify intrinsic height (ChatGPT):",
          error
        );
      });
      return;
    }
    try {
      const bridge = getMcpAppsBridge();
      bridge.sendSizeChanged({ height });
      console.log("[McpUseProvider] Sent size-changed notification:", height);
      notificationInProgressRef.current = false;
    } catch (error) {
      notificationInProgressRef.current = false;
      console.error(
        "[McpUseProvider] Failed to notify size change (MCP Apps):",
        error
      );
    }
  }, []);
  const debouncedNotifyHeight = useCallback3(
    (height) => {
      if (debounceTimeoutRef.current) {
        clearTimeout(debounceTimeoutRef.current);
      }
      debounceTimeoutRef.current = setTimeout(() => {
        const heightDiff = Math.abs(height - lastHeightRef.current);
        if (heightDiff >= MIN_HEIGHT_CHANGE_PX && height > 0) {
          lastHeightRef.current = height;
          notifyHeight(height);
        }
      }, HEIGHT_DEBOUNCE_MS);
    },
    [notifyHeight]
  );
  useEffect5(() => {
    if (!autoSize) {
      console.log("[McpUseProvider] autoSize is disabled");
      return;
    }
    if (!containerElement) {
      console.log("[McpUseProvider] No container element found for autoSize");
      return;
    }
    if (typeof ResizeObserver === "undefined") {
      console.log("[McpUseProvider] ResizeObserver not available");
      return;
    }
    console.log("[McpUseProvider] Setting up ResizeObserver for autoSize");
    const observer = new ResizeObserver((entries) => {
      if (notificationInProgressRef.current) {
        console.log(
          "[McpUseProvider] Skipping resize - notification in progress"
        );
        return;
      }
      for (const entry of entries) {
        const height = entry.contentRect.height;
        const scrollHeight = entry.target.scrollHeight;
        const intrinsicHeight = Math.max(height, scrollHeight);
        console.log("[McpUseProvider] ResizeObserver fired:", {
          height,
          scrollHeight,
          intrinsicHeight
        });
        debouncedNotifyHeight(intrinsicHeight);
      }
    });
    observer.observe(containerElement);
    const initialHeight = Math.max(
      containerElement.offsetHeight,
      containerElement.scrollHeight
    );
    console.log("[McpUseProvider] Initial height measurement:", initialHeight);
    if (initialHeight > 0) {
      debouncedNotifyHeight(initialHeight);
    }
    return () => {
      console.log("[McpUseProvider] Cleaning up ResizeObserver");
      observer.disconnect();
      if (debounceTimeoutRef.current) {
        clearTimeout(debounceTimeoutRef.current);
        debounceTimeoutRef.current = null;
      }
      notificationInProgressRef.current = false;
    };
  }, [autoSize, containerElement, debouncedNotifyHeight]);
  let content = children;
  content = /* @__PURE__ */ React5.createElement(ErrorBoundary, null, content);
  if (enableDebugger || viewControls) {
    content = /* @__PURE__ */ React5.createElement(WidgetControls, { debugger: enableDebugger, viewControls }, content);
  }
  content = /* @__PURE__ */ React5.createElement(ThemeProvider, null, content);
  if (autoSize) {
    const containerStyle = {
      width: "100%",
      minHeight: 0
    };
    content = /* @__PURE__ */ React5.createElement("div", { ref: setContainerElement, style: containerStyle }, content);
  }
  return /* @__PURE__ */ React5.createElement(StrictMode, null, content);
}
__name(McpUseProvider, "McpUseProvider");

// src/react/useCallTool.ts
import { useCallback as useCallback4, useRef as useRef4, useState as useState6 } from "react";
function useCallTool(name) {
  const [{ status, data, error }, setCallToolState] = useState6({ status: "idle", data: void 0, error: void 0 });
  const callIdRef = useRef4(0);
  const execute = /* @__PURE__ */ __name(async (args) => {
    const callId = ++callIdRef.current;
    setCallToolState({ status: "pending", data: void 0, error: void 0 });
    try {
      let raw;
      if (typeof window !== "undefined") {
        if (window.openai?.callTool) {
          raw = await window.openai.callTool(
            name,
            args
          );
        } else if (window !== window.parent) {
          const bridge = getMcpAppsBridge();
          raw = await bridge.callTool(name, args);
        } else {
          throw new Error("No tool calling interface available");
        }
      } else {
        throw new Error("useCallTool can only be used in browser environment");
      }
      const normalized = normalizeCallToolResponse(raw);
      if (callId === callIdRef.current) {
        setCallToolState({
          status: "success",
          data: normalized,
          error: void 0
        });
      }
      return normalized;
    } catch (error2) {
      if (callId === callIdRef.current) {
        setCallToolState({ status: "error", data: void 0, error: error2 });
      }
      throw error2;
    }
  }, "execute");
  const callToolAsync = useCallback4(
    ((args) => {
      if (args === void 0) {
        return execute(null);
      }
      return execute(args);
    }),
    [name]
  );
  const callTool = useCallback4(
    ((firstArg, sideEffects) => {
      let args;
      if (firstArg && typeof firstArg === "object" && ("onSuccess" in firstArg || "onError" in firstArg || "onSettled" in firstArg)) {
        args = null;
        sideEffects = firstArg;
      } else {
        args = firstArg === void 0 ? null : firstArg;
      }
      execute(args).then((data2) => {
        sideEffects?.onSuccess?.(data2, args);
        sideEffects?.onSettled?.(data2, void 0, args);
      }).catch((error2) => {
        sideEffects?.onError?.(error2, args);
        sideEffects?.onSettled?.(void 0, error2, args);
      });
    }),
    [name]
  );
  const callToolState = {
    status,
    data,
    error,
    isIdle: status === "idle",
    isPending: status === "pending",
    isSuccess: status === "success",
    isError: status === "error"
  };
  return {
    ...callToolState,
    callTool,
    callToolAsync
  };
}
__name(useCallTool, "useCallTool");

// src/react/generateHelpers.ts
function generateHelpers() {
  const useCallTool2 = /* @__PURE__ */ __name((name) => {
    return useCallTool(
      name
    );
  }, "useCallTool");
  const useToolInfo = /* @__PURE__ */ __name(() => {
    return useWidget();
  }, "useToolInfo");
  return {
    useCallTool: useCallTool2,
    useToolInfo
  };
}
__name(generateHelpers, "generateHelpers");

// src/react/McpClientProvider.tsx
import React6, {
  createContext,
  useCallback as useCallback5,
  useContext,
  useEffect as useEffect6,
  useMemo as useMemo3,
  useRef as useRef5,
  useState as useState7
} from "react";
var providerLogger = Logger.get("McpClientProvider");
var McpClientContext = createContext(null);
var MAX_NOTIFICATIONS = 500;
function McpServerWrapper({
  id,
  options,
  defaultProxyConfig,
  defaultAutoProxyFallback,
  clientInfo: providerClientInfo,
  cachedMetadata,
  onUpdate,
  rpcWrapTransport,
  onGlobalSamplingRequest,
  onGlobalElicitationRequest
}) {
  const {
    name,
    onSamplingRequest,
    onElicitationRequest,
    onNotificationReceived,
    wrapTransport: optionsWrapTransport
  } = options;
  const mcpOptions = useMemo3(() => {
    const {
      name: _name,
      onSamplingRequest: _onSamplingRequest,
      onElicitationRequest: _onElicitationRequest,
      onNotificationReceived: _onNotificationReceived,
      wrapTransport: _wrapTransport,
      ...rest
    } = options;
    return {
      ...rest,
      // Use server-specific proxyConfig if provided, otherwise use default
      proxyConfig: rest.proxyConfig || defaultProxyConfig,
      // Use server-specific autoProxyFallback if provided, otherwise use default
      autoProxyFallback: rest.autoProxyFallback !== void 0 ? rest.autoProxyFallback : defaultAutoProxyFallback,
      // Merge provider clientInfo with server-specific clientInfo
      // Server-specific takes precedence
      clientInfo: rest.clientInfo ? providerClientInfo ? { ...providerClientInfo, ...rest.clientInfo } : rest.clientInfo : providerClientInfo,
      // Pass cached metadata as initial server info if available
      _initialServerInfo: cachedMetadata
    };
  }, [
    options,
    defaultProxyConfig,
    defaultAutoProxyFallback,
    providerClientInfo,
    cachedMetadata
  ]);
  const combinedWrapTransport = useMemo3(() => {
    if (!rpcWrapTransport && !optionsWrapTransport) return void 0;
    return (transport) => {
      let wrapped = transport;
      if (rpcWrapTransport) {
        wrapped = rpcWrapTransport(wrapped, id);
      }
      if (optionsWrapTransport) {
        wrapped = optionsWrapTransport(wrapped, id);
      }
      return wrapped;
    };
  }, [rpcWrapTransport, optionsWrapTransport, id]);
  const [notifications, setNotifications] = useState7([]);
  const [pendingSamplingRequests, setPendingSamplingRequests] = useState7([]);
  const samplingIdCounter = useRef5(0);
  const [pendingElicitationRequests, setPendingElicitationRequests] = useState7([]);
  const elicitationIdCounter = useRef5(0);
  const markNotificationRead = useCallback5((notificationId) => {
    setNotifications(
      (prev) => prev.map((n) => n.id === notificationId ? { ...n, read: true } : n)
    );
  }, []);
  const markAllNotificationsRead = useCallback5(() => {
    setNotifications((prev) => prev.map((n) => ({ ...n, read: true })));
  }, []);
  const clearNotifications = useCallback5(() => {
    setNotifications([]);
  }, []);
  const handleNotification = useCallback5(
    (notification) => {
      const mcpNotification = {
        id: globalThis.crypto?.randomUUID?.() || `${Date.now()}-${Math.random()}`,
        method: notification.method,
        params: notification.params,
        timestamp: Date.now(),
        read: false
      };
      setNotifications((prev) => {
        const updated = [mcpNotification, ...prev];
        if (updated.length > MAX_NOTIFICATIONS) {
          return updated.slice(0, MAX_NOTIFICATIONS);
        }
        return updated;
      });
      onNotificationReceived?.(mcpNotification);
    },
    [onNotificationReceived]
  );
  const approveSampling = useCallback5(
    (requestId, result) => {
      setPendingSamplingRequests((prev) => {
        const request = prev.find((r) => r.id === requestId);
        if (request) {
          request.resolve(result);
          return prev.filter((r) => r.id !== requestId);
        }
        return prev;
      });
    },
    []
  );
  const rejectSampling = useCallback5((requestId, error) => {
    setPendingSamplingRequests((prev) => {
      const request = prev.find((r) => r.id === requestId);
      if (request) {
        request.reject(new Error(error || "User rejected sampling request"));
        return prev.filter((r) => r.id !== requestId);
      }
      return prev;
    });
  }, []);
  const samplingCallback = useCallback5(
    async (params) => {
      return new Promise((resolve, reject) => {
        const requestId = `sampling-${samplingIdCounter.current++}`;
        const request = {
          id: requestId,
          request: { method: "sampling/createMessage", params },
          timestamp: Date.now(),
          serverName: name || id
        };
        const newRequest = {
          ...request,
          resolve,
          reject
        };
        setPendingSamplingRequests((prev) => [...prev, newRequest]);
        onSamplingRequest?.(request);
        onGlobalSamplingRequest?.(
          request,
          id,
          name || id,
          approveSampling,
          rejectSampling
        );
      });
    },
    [
      id,
      name,
      onSamplingRequest,
      onGlobalSamplingRequest,
      approveSampling,
      rejectSampling
    ]
  );
  const approveElicitation = useCallback5(
    (requestId, result) => {
      setPendingElicitationRequests((prev) => {
        const request = prev.find((r) => r.id === requestId);
        if (request) {
          request.resolve(result);
          return prev.filter((r) => r.id !== requestId);
        }
        return prev;
      });
    },
    []
  );
  const rejectElicitation = useCallback5((requestId, error) => {
    setPendingElicitationRequests((prev) => {
      const request = prev.find((r) => r.id === requestId);
      if (request) {
        request.reject(new Error(error || "User rejected elicitation request"));
        return prev.filter((r) => r.id !== requestId);
      }
      return prev;
    });
  }, []);
  const elicitationCallback = useCallback5(
    async (params) => {
      return new Promise((resolve, reject) => {
        const requestId = `elicitation-${elicitationIdCounter.current++}`;
        const request = {
          id: requestId,
          request: params,
          timestamp: Date.now(),
          serverName: name || id
        };
        const newRequest = {
          ...request,
          resolve,
          reject
        };
        setPendingElicitationRequests((prev) => [...prev, newRequest]);
        onElicitationRequest?.(request);
        onGlobalElicitationRequest?.(
          request,
          id,
          name || id,
          approveElicitation,
          rejectElicitation
        );
      });
    },
    [
      id,
      name,
      onElicitationRequest,
      onGlobalElicitationRequest,
      approveElicitation,
      rejectElicitation
    ]
  );
  const mcp = useMcp({
    ...mcpOptions,
    onNotification: handleNotification,
    onSampling: samplingCallback,
    onElicitation: elicitationCallback,
    wrapTransport: combinedWrapTransport
  });
  const publicSamplingRequests = useMemo3(
    () => pendingSamplingRequests.map((r) => ({
      id: r.id,
      request: r.request,
      timestamp: r.timestamp,
      serverName: r.serverName
    })),
    [pendingSamplingRequests]
  );
  const publicElicitationRequests = useMemo3(
    () => pendingElicitationRequests.map((r) => ({
      id: r.id,
      request: r.request,
      timestamp: r.timestamp,
      serverName: r.serverName
    })),
    [pendingElicitationRequests]
  );
  const unreadNotificationCount = useMemo3(
    () => notifications.filter((n) => !n.read).length,
    [notifications]
  );
  const toolsFingerprint = useMemo3(() => {
    const fingerprint = JSON.stringify(
      mcp.tools.map((t) => ({
        name: t.name,
        description: t.description,
        inputSchema: t.inputSchema,
        _meta: t._meta
      })).sort((a, b) => a.name.localeCompare(b.name))
    );
    return fingerprint;
  }, [mcp.tools, id]);
  const resourcesFingerprint = useMemo3(
    () => JSON.stringify(
      mcp.resources.map((r) => ({
        uri: r.uri,
        name: r.name,
        description: r.description,
        mimeType: r.mimeType
      })).sort((a, b) => a.uri.localeCompare(b.uri))
    ),
    [mcp.resources]
  );
  const promptsFingerprint = useMemo3(
    () => JSON.stringify(
      mcp.prompts.map((p) => ({
        name: p.name,
        description: p.description,
        arguments: p.arguments
      })).sort((a, b) => a.name.localeCompare(b.name))
    ),
    [mcp.prompts]
  );
  const onUpdateRef = useRef5(onUpdate);
  const prevServerRef = useRef5(null);
  const prevFingerprintsRef = useRef5({ tools: "", resources: "", prompts: "" });
  useEffect6(() => {
    onUpdateRef.current = onUpdate;
  }, [onUpdate]);
  useEffect6(() => {
    const server = {
      ...mcp,
      id,
      url: options.url || "",
      name: name || id,
      notifications,
      unreadNotificationCount,
      markNotificationRead,
      markAllNotificationsRead,
      clearNotifications,
      pendingSamplingRequests: publicSamplingRequests,
      approveSampling,
      rejectSampling,
      pendingElicitationRequests: publicElicitationRequests,
      approveElicitation,
      rejectElicitation
    };
    const prevServer = prevServerRef.current;
    const prevFingerprints = prevFingerprintsRef.current;
    const toolsChanged = prevFingerprints.tools !== toolsFingerprint;
    const resourcesChanged = prevFingerprints.resources !== resourcesFingerprint;
    const promptsChanged = prevFingerprints.prompts !== promptsFingerprint;
    if (!prevServer || prevServer.state !== server.state || prevServer.error !== server.error || prevServer.authUrl !== server.authUrl || toolsChanged || resourcesChanged || promptsChanged || prevServer.serverInfo !== server.serverInfo || prevServer.capabilities !== server.capabilities || prevServer.notifications.length !== server.notifications.length || prevServer.unreadNotificationCount !== server.unreadNotificationCount || prevServer.pendingSamplingRequests.length !== server.pendingSamplingRequests.length || prevServer.pendingElicitationRequests.length !== server.pendingElicitationRequests.length || !prevServer.client) {
      prevServerRef.current = server;
      prevFingerprintsRef.current = {
        tools: toolsFingerprint,
        resources: resourcesFingerprint,
        prompts: promptsFingerprint
      };
      onUpdateRef.current(server);
    } else {
      providerLogger.debug(
        `[McpServerWrapper ${id}] No meaningful changes detected, skipping onUpdate`
      );
    }
  }, [
    id,
    name,
    options.url,
    // Primitive values that indicate meaningful state changes
    mcp.state,
    mcp.error,
    mcp.authUrl,
    // Use fingerprints to detect content changes (including renames)
    toolsFingerprint,
    resourcesFingerprint,
    promptsFingerprint,
    // serverInfo and capabilities - include for reference comparison
    mcp.serverInfo,
    mcp.capabilities,
    // Functions excluded - they're stable via useCallback in useMcp
    // mcp.log excluded - log changes shouldn't trigger provider updates
    // mcp.client excluded - client reference stability handled by manual check
    notifications.length,
    unreadNotificationCount,
    publicSamplingRequests.length,
    publicElicitationRequests.length,
    // Callback functions are stable via useCallback
    markNotificationRead,
    markAllNotificationsRead,
    clearNotifications,
    approveSampling,
    rejectSampling,
    approveElicitation,
    rejectElicitation
  ]);
  return null;
}
__name(McpServerWrapper, "McpServerWrapper");
function McpClientProvider({
  children,
  mcpServers,
  defaultProxyConfig,
  defaultAutoProxyFallback = true,
  clientInfo,
  storageProvider,
  enableRpcLogging = false,
  onServerAdded,
  onServerRemoved,
  onServerStateChange,
  onSamplingRequest,
  onElicitationRequest
}) {
  const [serverConfigs, setServerConfigs] = useState7([]);
  const [servers, setServers] = useState7([]);
  const [storageLoaded, setStorageLoaded] = useState7(false);
  const cachedMetadataRef = useRef5({});
  const [rpcWrapTransport, setRpcWrapTransport] = useState7(void 0);
  const [rpcLoggingReady, setRpcLoggingReady] = useState7(false);
  useEffect6(() => {
    if (!enableRpcLogging || typeof window === "undefined") {
      setRpcWrapTransport(void 0);
      setRpcLoggingReady(true);
      return;
    }
    import("./rpc-logger-TPNV75J4.js").then((module) => {
      providerLogger.debug("[McpClientProvider] RPC logger loaded");
      setRpcWrapTransport(() => module.wrapTransportForLogging);
      setRpcLoggingReady(true);
    }).catch((err) => {
      providerLogger.error(
        "[McpClientProvider] Failed to load RPC logger:",
        err
      );
      setRpcWrapTransport(void 0);
      setRpcLoggingReady(true);
    });
  }, [enableRpcLogging]);
  useEffect6(() => {
    if (!rpcLoggingReady) {
      providerLogger.debug(
        "[McpClientProvider] Waiting for RPC logging to be ready before loading servers"
      );
      return;
    }
    const loadServers = /* @__PURE__ */ __name(async () => {
      providerLogger.debug(
        "[McpClientProvider] Loading servers, storageProvider:",
        !!storageProvider,
        "mcpServers:",
        mcpServers
      );
      if (!storageProvider) {
        if (mcpServers) {
          const configs = Object.entries(mcpServers).map(([id, options]) => ({
            id,
            options
          }));
          providerLogger.debug(
            "[McpClientProvider] Loaded from mcpServers prop:",
            configs.length
          );
          setServerConfigs(configs);
        }
        setStorageLoaded(true);
        return;
      }
      try {
        const storedServers = await Promise.resolve(
          storageProvider.getServers()
        );
        providerLogger.debug(
          "[McpClientProvider] Loaded from storage:",
          Object.keys(storedServers).length
        );
        if (storageProvider.getServerMetadata) {
          try {
            const serverIds = Object.keys(storedServers);
            const metadataPromises = serverIds.map(async (id) => {
              const metadata = await Promise.resolve(
                storageProvider.getServerMetadata(id)
              );
              return [id, metadata];
            });
            const metadataEntries = await Promise.all(metadataPromises);
            cachedMetadataRef.current = Object.fromEntries(
              metadataEntries.filter(
                (entry) => entry[1] !== void 0
              )
            );
            providerLogger.debug(
              "[McpClientProvider] Loaded cached metadata for",
              Object.keys(cachedMetadataRef.current).length,
              "servers"
            );
          } catch (metadataError) {
            providerLogger.warn(
              "[McpClientProvider] Failed to load cached metadata:",
              metadataError
            );
          }
        }
        const mergedServers = { ...storedServers, ...mcpServers };
        const configs = Object.entries(mergedServers).map(([id, options]) => ({
          id,
          options
        }));
        providerLogger.debug(
          "[McpClientProvider] Total servers after merge:",
          configs.length
        );
        setServerConfigs(configs);
        setStorageLoaded(true);
      } catch (error) {
        providerLogger.error(
          "[McpClientProvider] Failed to load from storage:",
          error
        );
        if (mcpServers) {
          const configs = Object.entries(mcpServers).map(([id, options]) => ({
            id,
            options
          }));
          setServerConfigs(configs);
        }
        setStorageLoaded(true);
      }
    }, "loadServers");
    loadServers();
  }, [storageProvider, mcpServers, rpcLoggingReady]);
  useEffect6(() => {
    if (!storageProvider || !storageLoaded) return;
    const saveServers = /* @__PURE__ */ __name(async () => {
      try {
        const serversToSave = serverConfigs.reduce(
          (acc, config) => {
            acc[config.id] = config.options;
            return acc;
          },
          {}
        );
        await Promise.resolve(storageProvider.setServers(serversToSave));
      } catch (error) {
        providerLogger.error(
          "[McpClientProvider] Failed to save to storage:",
          error
        );
      }
    }, "saveServers");
    saveServers();
  }, [serverConfigs, storageProvider, storageLoaded]);
  const handleServerUpdate = useCallback5(
    (updatedServer) => {
      providerLogger.debug(
        `[McpClientProvider] handleServerUpdate called for server ${updatedServer.id}`,
        {
          toolCount: updatedServer.tools.length,
          state: updatedServer.state
        }
      );
      const callbacksToRun = [];
      setServers((prev) => {
        const index = prev.findIndex((s) => s.id === updatedServer.id);
        const isNewServer = index === -1;
        if (isNewServer) {
          providerLogger.debug(
            `[McpClientProvider] Adding new server ${updatedServer.id} to state`
          );
          callbacksToRun.push(
            () => onServerAdded?.(updatedServer.id, updatedServer)
          );
          return [...prev, updatedServer];
        }
        const current = prev[index];
        const stateChanged = current.state !== updatedServer.state;
        const serverInfoChanged = current.serverInfo !== updatedServer.serverInfo;
        providerLogger.debug(
          `[McpClientProvider] Comparing server ${updatedServer.id}:`,
          {
            toolsChanged: current.tools !== updatedServer.tools,
            currentToolCount: current.tools.length,
            updatedToolCount: updatedServer.tools.length,
            stateChanged
          }
        );
        if (current.state === updatedServer.state && current.tools === updatedServer.tools && current.resources === updatedServer.resources && current.prompts === updatedServer.prompts && current.error === updatedServer.error && current.serverInfo === updatedServer.serverInfo && current.client === updatedServer.client && current.notifications === updatedServer.notifications && current.unreadNotificationCount === updatedServer.unreadNotificationCount && current.pendingSamplingRequests.length === updatedServer.pendingSamplingRequests.length && current.pendingElicitationRequests.length === updatedServer.pendingElicitationRequests.length) {
          providerLogger.debug(
            `[McpClientProvider] No changes detected for server ${updatedServer.id}, skipping update`
          );
          return prev;
        }
        providerLogger.debug(
          `[McpClientProvider] Updating server ${updatedServer.id} in state`
        );
        if (stateChanged) {
          callbacksToRun.push(
            () => onServerStateChange?.(updatedServer.id, updatedServer.state)
          );
        }
        if (serverInfoChanged && updatedServer.serverInfo && storageProvider?.setServerMetadata) {
          const metadata = {
            name: updatedServer.serverInfo.name,
            version: updatedServer.serverInfo.version,
            title: updatedServer.serverInfo.title,
            websiteUrl: updatedServer.serverInfo.websiteUrl,
            icons: updatedServer.serverInfo.icons,
            icon: updatedServer.serverInfo.icon
          };
          cachedMetadataRef.current[updatedServer.id] = metadata;
          Promise.resolve(
            storageProvider.setServerMetadata(updatedServer.id, metadata)
          ).catch((err) => {
            providerLogger.error(
              "[McpClientProvider] Failed to save server metadata:",
              err
            );
          });
        }
        const newServers = [...prev];
        newServers[index] = updatedServer;
        return newServers;
      });
      if (callbacksToRun.length > 0) {
        queueMicrotask(() => {
          callbacksToRun.forEach((callback) => callback());
        });
      }
    },
    [onServerAdded, onServerStateChange, storageProvider]
  );
  const addServer = useCallback5((id, options) => {
    providerLogger.debug("[McpClientProvider] addServer called:", id, options);
    setServerConfigs((prev) => {
      if (prev.find((s) => s.id === id)) {
        providerLogger.warn(
          `[McpClientProvider] Server with id "${id}" already exists`
        );
        return prev;
      }
      providerLogger.debug(
        "[McpClientProvider] Adding new server to configs:",
        id
      );
      return [...prev, { id, options }];
    });
  }, []);
  const removeServer = useCallback5(
    (id) => {
      setServers((prev) => {
        const server = prev.find((s) => s.id === id);
        if (server?.disconnect) {
          server.disconnect();
        }
        if (server?.clearStorage) {
          server.clearStorage();
        }
        return prev.filter((s) => s.id !== id);
      });
      setServerConfigs((prev) => prev.filter((s) => s.id !== id));
      onServerRemoved?.(id);
    },
    [onServerRemoved]
  );
  const updateServer = useCallback5(
    async (id, options) => {
      return new Promise((resolve) => {
        const currentConfig = serverConfigs.find((s) => s.id === id);
        if (!currentConfig) {
          providerLogger.warn(
            `[McpClientProvider] Cannot update server "${id}" - not found`
          );
          resolve();
          return;
        }
        const updatedOptions = {
          ...currentConfig.options,
          ...options,
          // Add a version counter to force React to remount the wrapper
          _updateVersion: (currentConfig.options._updateVersion || 0) + 1
        };
        setServers((prev) => {
          const server = prev.find((s) => s.id === id);
          if (server?.disconnect) {
            server.disconnect();
          }
          if (server?.clearStorage) {
            server.clearStorage();
          }
          return prev.filter((s) => s.id !== id);
        });
        setServerConfigs((prev) => {
          const updated = prev.map(
            (s) => s.id === id ? { id, options: updatedOptions } : s
          );
          setTimeout(() => resolve(), 0);
          return updated;
        });
      });
    },
    [serverConfigs]
  );
  const getServer = useCallback5(
    (id) => {
      return servers.find((s) => s.id === id);
    },
    [servers]
  );
  const contextValue = useMemo3(
    () => ({
      servers,
      addServer,
      removeServer,
      updateServer,
      getServer,
      storageLoaded
    }),
    [servers, addServer, removeServer, updateServer, getServer, storageLoaded]
  );
  return /* @__PURE__ */ React6.createElement(McpClientContext.Provider, { value: contextValue }, children, serverConfigs.map((config) => /* @__PURE__ */ React6.createElement(
    McpServerWrapper,
    {
      key: `${config.id}-v${config.options._updateVersion || 0}`,
      id: config.id,
      options: config.options,
      defaultProxyConfig,
      defaultAutoProxyFallback,
      clientInfo,
      cachedMetadata: cachedMetadataRef.current[config.id],
      onUpdate: handleServerUpdate,
      rpcWrapTransport,
      onGlobalSamplingRequest: onSamplingRequest,
      onGlobalElicitationRequest: onElicitationRequest
    }
  )));
}
__name(McpClientProvider, "McpClientProvider");
function useMcpClient() {
  const context = useContext(McpClientContext);
  if (!context) {
    throw new Error("useMcpClient must be used within a McpClientProvider");
  }
  return context;
}
__name(useMcpClient, "useMcpClient");
function useMcpServer(id) {
  const { getServer } = useMcpClient();
  return getServer(id);
}
__name(useMcpServer, "useMcpServer");

// src/react/storage/LocalStorageProvider.ts
var LocalStorageProvider = class {
  constructor(storageKey = "mcp-client-servers") {
    this.storageKey = storageKey;
    this.metadataKey = `${storageKey}-metadata`;
  }
  static {
    __name(this, "LocalStorageProvider");
  }
  metadataKey;
  getServers() {
    try {
      const stored = localStorage.getItem(this.storageKey);
      return stored ? JSON.parse(stored) : {};
    } catch (error) {
      console.error("[LocalStorageProvider] Failed to load servers:", error);
      return {};
    }
  }
  setServers(servers) {
    try {
      localStorage.setItem(this.storageKey, JSON.stringify(servers));
    } catch (error) {
      console.error("[LocalStorageProvider] Failed to save servers:", error);
    }
  }
  setServer(id, config) {
    const servers = this.getServers();
    servers[id] = config;
    this.setServers(servers);
  }
  removeServer(id) {
    const servers = this.getServers();
    delete servers[id];
    this.setServers(servers);
    this.removeServerMetadata(id);
  }
  clear() {
    try {
      localStorage.removeItem(this.storageKey);
      localStorage.removeItem(this.metadataKey);
    } catch (error) {
      console.error("[LocalStorageProvider] Failed to clear:", error);
    }
  }
  getAllMetadata() {
    try {
      const stored = localStorage.getItem(this.metadataKey);
      return stored ? JSON.parse(stored) : {};
    } catch (error) {
      console.error("[LocalStorageProvider] Failed to load metadata:", error);
      return {};
    }
  }
  setAllMetadata(metadata) {
    try {
      localStorage.setItem(this.metadataKey, JSON.stringify(metadata));
    } catch (error) {
      console.error("[LocalStorageProvider] Failed to save metadata:", error);
    }
  }
  getServerMetadata(id) {
    const allMetadata = this.getAllMetadata();
    return allMetadata[id];
  }
  setServerMetadata(id, metadata) {
    const allMetadata = this.getAllMetadata();
    allMetadata[id] = {
      ...metadata,
      cachedAt: Date.now()
    };
    this.setAllMetadata(allMetadata);
  }
  removeServerMetadata(id) {
    const allMetadata = this.getAllMetadata();
    delete allMetadata[id];
    this.setAllMetadata(allMetadata);
  }
};

// src/react/storage/MemoryStorageProvider.ts
var MemoryStorageProvider = class {
  static {
    __name(this, "MemoryStorageProvider");
  }
  storage = {};
  metadata = {};
  getServers() {
    return { ...this.storage };
  }
  setServers(servers) {
    this.storage = { ...servers };
  }
  setServer(id, config) {
    this.storage[id] = config;
  }
  removeServer(id) {
    delete this.storage[id];
    this.removeServerMetadata(id);
  }
  clear() {
    this.storage = {};
    this.metadata = {};
  }
  getServerMetadata(id) {
    return this.metadata[id];
  }
  setServerMetadata(id, metadata) {
    this.metadata[id] = {
      ...metadata,
      cachedAt: Date.now()
    };
  }
  removeServerMetadata(id) {
    delete this.metadata[id];
  }
};

export {
  useMcp,
  ErrorBoundary,
  Image,
  useWidget,
  useWidgetProps,
  useWidgetTheme,
  useWidgetState,
  ThemeProvider,
  WidgetControls,
  McpUseProvider,
  useCallTool,
  generateHelpers,
  McpClientProvider,
  useMcpClient,
  useMcpServer,
  LocalStorageProvider,
  MemoryStorageProvider
};
