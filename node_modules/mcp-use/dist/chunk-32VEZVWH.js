import {
  ConnectionManager
} from "./chunk-GKPKUKD6.js";
import {
  BaseConnector
} from "./chunk-ZAA33UB5.js";
import {
  logger
} from "./chunk-QWQYAQCK.js";
import {
  __name
} from "./chunk-3GQAWCBQ.js";

// src/connectors/stdio.ts
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import process2 from "process";

// src/task_managers/stdio.ts
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";
var StdioConnectionManager = class extends ConnectionManager {
  static {
    __name(this, "StdioConnectionManager");
  }
  serverParams;
  errlog;
  _transport = null;
  /**
   * Create a new stdio connection manager.
   *
   * @param serverParams Parameters for the stdio server process.
   * @param errlog       Stream to which the server's stderr should be piped.
   *                     Defaults to `process.stderr`.
   */
  constructor(serverParams, errlog = process.stderr) {
    super();
    this.serverParams = serverParams;
    this.errlog = errlog;
  }
  /**
   * Establish the stdio connection by spawning the server process and starting
   * the SDK's transport. Returns the live `StdioClientTransport` instance.
   */
  async establishConnection() {
    this._transport = new StdioClientTransport(this.serverParams);
    if (this._transport.stderr && typeof this._transport.stderr.pipe === "function") {
      this._transport.stderr.pipe(
        this.errlog
      );
    }
    logger.debug(`${this.constructor.name} connected successfully`);
    return this._transport;
  }
  /**
   * Close the stdio connection, making sure the transport cleans up the child
   * process and associated resources.
   */
  async closeConnection(_connection) {
    if (this._transport) {
      try {
        await this._transport.close();
      } catch (e) {
        logger.warn(`Error closing stdio transport: ${e}`);
      } finally {
        this._transport = null;
      }
    }
  }
};

// src/connectors/stdio.ts
var StdioConnector = class extends BaseConnector {
  static {
    __name(this, "StdioConnector");
  }
  command;
  args;
  env;
  errlog;
  clientInfo;
  constructor({
    command = "npx",
    args = [],
    env,
    errlog = process2.stderr,
    ...rest
  } = {}) {
    super(rest);
    this.command = command;
    this.args = args;
    this.env = env;
    this.errlog = errlog;
    this.clientInfo = rest.clientInfo ?? {
      name: "stdio-connector",
      version: "1.0.0"
    };
  }
  /** Establish connection to the MCP implementation. */
  async connect() {
    if (this.connected) {
      logger.debug("Already connected to MCP implementation");
      return;
    }
    logger.debug(`Connecting to MCP implementation via stdio: ${this.command}`);
    try {
      let mergedEnv;
      if (this.env) {
        mergedEnv = {};
        for (const [key, value] of Object.entries(process2.env)) {
          if (value !== void 0) {
            mergedEnv[key] = value;
          }
        }
        Object.assign(mergedEnv, this.env);
      }
      const serverParams = {
        command: this.command,
        args: this.args,
        env: mergedEnv
      };
      this.connectionManager = new StdioConnectionManager(
        serverParams,
        this.errlog
      );
      const transport = await this.connectionManager.start();
      const clientOptions = {
        ...this.opts.clientOptions || {},
        capabilities: {
          ...this.opts.clientOptions?.capabilities || {},
          roots: { listChanged: true },
          // Always advertise roots capability
          // Add sampling capability if callback is provided
          ...this.opts.onSampling ?? this.opts.samplingCallback ? { sampling: {} } : {},
          // Add elicitation capability if callback is provided
          ...this.opts.onElicitation ?? this.opts.elicitationCallback ? { elicitation: { form: {}, url: {} } } : {}
        }
      };
      this.client = new Client(this.clientInfo, clientOptions);
      await this.client.connect(transport);
      this.connected = true;
      this.setupNotificationHandler();
      this.setupRootsHandler();
      this.setupSamplingHandler();
      this.setupElicitationHandler();
      logger.debug(
        `Successfully connected to MCP implementation: ${this.command}`
      );
      this.trackConnectorInit({
        serverCommand: this.command,
        serverArgs: this.args,
        publicIdentifier: `${this.command} ${this.args.join(" ")}`
      });
    } catch (err) {
      logger.error(`Failed to connect to MCP implementation: ${err}`);
      await this.cleanupResources();
      throw err;
    }
  }
  get publicIdentifier() {
    return {
      type: "stdio",
      "command&args": `${this.command} ${this.args.join(" ")}`
    };
  }
};

export {
  StdioConnector
};
