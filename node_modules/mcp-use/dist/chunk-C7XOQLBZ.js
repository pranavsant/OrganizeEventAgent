import {
  LangChainAdapter
} from "./chunk-3RU35UU4.js";
import {
  Telemetry,
  extractModelInfo,
  getPackageVersion
} from "./chunk-YEK7642C.js";
import {
  logger
} from "./chunk-QWQYAQCK.js";
import {
  __name
} from "./chunk-3GQAWCBQ.js";

// src/managers/tools/acquire_active_mcp_server.ts
import { z } from "zod";

// src/managers/tools/base.ts
import { StructuredTool } from "@langchain/core/tools";
var MCPServerTool = class extends StructuredTool {
  static {
    __name(this, "MCPServerTool");
  }
  name = "mcp_server_tool";
  description = "Base tool for MCP server operations.";
  schema;
  _manager;
  constructor(manager) {
    super();
    this._manager = manager;
  }
  async _call(_arg, _runManager, _parentConfig) {
    throw new Error("Method not implemented.");
  }
  get manager() {
    return this._manager;
  }
};

// src/managers/tools/acquire_active_mcp_server.ts
var PresentActiveServerSchema = z.object({});
var AcquireActiveMCPServerTool = class extends MCPServerTool {
  static {
    __name(this, "AcquireActiveMCPServerTool");
  }
  name = "get_active_mcp_server";
  description = "Get the currently active MCP (Model Context Protocol) server";
  schema = PresentActiveServerSchema;
  constructor(manager) {
    super(manager);
  }
  async _call() {
    if (!this.manager.activeServer) {
      return `No MCP server is currently active. Use connect_to_mcp_server to connect to a server.`;
    }
    return `Currently active MCP server: ${this.manager.activeServer}`;
  }
};

// src/managers/tools/add_server_from_config.ts
import { StructuredTool as StructuredTool2 } from "@langchain/core/tools";
import { z as z2 } from "zod";
var AddMCPServerFromConfigTool = class extends StructuredTool2 {
  static {
    __name(this, "AddMCPServerFromConfigTool");
  }
  name = "add_mcp_server_from_config";
  description = "Adds a new MCP server to the client from a configuration object and connects to it, making its tools available.";
  schema = z2.object({
    serverName: z2.string().describe("The name for the new MCP server."),
    serverConfig: z2.any().describe(
      'The configuration object for the server. This should not include the top-level "mcpServers" key.'
    )
  });
  manager;
  constructor(manager) {
    super();
    this.manager = manager;
  }
  async _call({
    serverName,
    serverConfig
  }) {
    try {
      this.manager.client.addServer(serverName, serverConfig);
      let result = `Server '${serverName}' added to the client.`;
      logger.debug(
        `Connecting to new server '${serverName}' and discovering tools.`
      );
      const session = await this.manager.client.createSession(serverName);
      const connector = session.connector;
      const tools = await this.manager.adapter.createToolsFromConnectors([connector]);
      this.manager.serverTools[serverName] = tools;
      this.manager.initializedServers[serverName] = true;
      this.manager.activeServer = serverName;
      const numTools = tools.length;
      result += ` Session created and connected. '${serverName}' is now the active server with ${numTools} tools available.`;
      result += `

${tools.map((t) => t.name).join("\n")}`;
      logger.info(result);
      return result;
    } catch (e) {
      logger.error(
        `Failed to add or connect to server '${serverName}': ${e.message}`
      );
      return `Failed to add or connect to server '${serverName}': ${e.message}`;
    }
  }
};

// src/managers/tools/connect_mcp_server.ts
import { z as z3 } from "zod";
var ConnectMCPServerSchema = z3.object({
  serverName: z3.string().describe("The name of the MCP server.")
});
var ConnectMCPServerTool = class extends MCPServerTool {
  static {
    __name(this, "ConnectMCPServerTool");
  }
  name = "connect_to_mcp_server";
  description = "Connect to a specific MCP (Model Context Protocol) server to use its tools. Use this tool to connect to a specific server and use its tools.";
  schema = ConnectMCPServerSchema;
  constructor(manager) {
    super(manager);
  }
  async _call({ serverName }) {
    const serverNames = this.manager.client.getServerNames();
    if (!serverNames.includes(serverName)) {
      const available = serverNames.length > 0 ? serverNames.join(", ") : "none";
      return `Server '${serverName}' not found. Available servers: ${available}`;
    }
    if (this.manager.activeServer === serverName) {
      return `Already connected to MCP server '${serverName}'`;
    }
    try {
      let session = this.manager.client.getSession(serverName);
      logger.debug(`Using existing session for server '${serverName}'`);
      if (!session) {
        logger.debug(`Creating new session for server '${serverName}'`);
        session = await this.manager.client.createSession(serverName);
      }
      this.manager.activeServer = serverName;
      if (!this.manager.serverTools[serverName]) {
        const connector = session.connector;
        const tools = await this.manager.adapter.createToolsFromConnectors([connector]);
        const resources = await this.manager.adapter.createResourcesFromConnectors([connector]);
        const prompts = await this.manager.adapter.createPromptsFromConnectors([connector]);
        const allItems = [...tools, ...resources, ...prompts];
        this.manager.serverTools[serverName] = allItems;
        this.manager.initializedServers[serverName] = true;
        logger.debug(
          `Loaded ${allItems.length} items for server '${serverName}': ${tools.length} tools, ${resources.length} resources, ${prompts.length} prompts`
        );
      }
      const serverTools = this.manager.serverTools[serverName] || [];
      const numTools = serverTools.length;
      return `Connected to MCP server '${serverName}'. ${numTools} tools, resources, and prompts are now available.`;
    } catch (error) {
      logger.error(
        `Error connecting to server '${serverName}': ${String(error)}`
      );
      return `Failed to connect to server '${serverName}': ${String(error)}`;
    }
  }
};

// src/managers/tools/list_mcp_servers.ts
import { z as z4 } from "zod";
var EnumerateServersSchema = z4.object({});
var ListMCPServersTool = class extends MCPServerTool {
  static {
    __name(this, "ListMCPServersTool");
  }
  name = "list_mcp_servers";
  description = `Lists all available MCP (Model Context Protocol) servers that can be connected to, along with the tools available on each server. Use this tool to discover servers and see what functionalities they offer.`;
  schema = EnumerateServersSchema;
  constructor(manager) {
    super(manager);
  }
  async _call() {
    const serverNames = this.manager.client.getServerNames();
    if (serverNames.length === 0) {
      return `No MCP servers are currently defined.`;
    }
    const outputLines = ["Available MCP servers:"];
    for (const serverName of serverNames) {
      const isActiveServer = serverName === this.manager.activeServer;
      const activeFlag = isActiveServer ? " (ACTIVE)" : "";
      outputLines.push(`- ${serverName}${activeFlag}`);
      try {
        const serverTools = this.manager.serverTools?.[serverName] ?? [];
        const numberOfTools = Array.isArray(serverTools) ? serverTools.length : 0;
        outputLines.push(`${numberOfTools} tools available for this server
`);
      } catch (error) {
        logger.error(
          `Unexpected error listing tools for server '${serverName}': ${String(error)}`
        );
      }
    }
    return outputLines.join("\n");
  }
};

// src/managers/tools/release_mcp_server_connection.ts
import { z as z5 } from "zod";
var ReleaseConnectionSchema = z5.object({});
var ReleaseMCPServerConnectionTool = class extends MCPServerTool {
  static {
    __name(this, "ReleaseMCPServerConnectionTool");
  }
  name = "disconnect_from_mcp_server";
  description = "Disconnect from the currently active MCP (Model Context Protocol) server";
  schema = ReleaseConnectionSchema;
  constructor(manager) {
    super(manager);
  }
  async _call() {
    if (!this.manager.activeServer) {
      return `No MCP server is currently active, so there's nothing to disconnect from.`;
    }
    const serverName = this.manager.activeServer;
    this.manager.activeServer = null;
    return `Successfully disconnected from MCP server '${serverName}'.`;
  }
};

// src/managers/server_manager.ts
function isEqual(a, b) {
  if (a === b) return true;
  if (a == null || b == null) return false;
  if (typeof a !== typeof b) return false;
  if (a instanceof Date && b instanceof Date) {
    return a.getTime() === b.getTime();
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    return a.every((item, index) => isEqual(item, b[index]));
  }
  if (typeof a === "object" && typeof b === "object") {
    const keysA = Object.keys(a);
    const keysB = Object.keys(b);
    if (keysA.length !== keysB.length) return false;
    return keysA.every((key) => {
      return Object.prototype.hasOwnProperty.call(b, key) && isEqual(a[key], b[key]);
    });
  }
  return false;
}
__name(isEqual, "isEqual");
var ServerManager = class {
  static {
    __name(this, "ServerManager");
  }
  initializedServers = {};
  serverTools = {};
  client;
  adapter;
  activeServer = null;
  overrideManagementTools;
  constructor(client, adapter, managementTools) {
    this.client = client;
    this.adapter = adapter;
    this.overrideManagementTools = managementTools;
  }
  setManagementTools(tools) {
    this.overrideManagementTools = tools;
    logger.info(
      `Overriding default management tools with a new set of ${tools.length} tools.`
    );
  }
  logState(context) {
    const allServerNames = this.client.getServerNames();
    const activeSessionNames = Object.keys(this.client.getAllActiveSessions());
    if (allServerNames.length === 0) {
      logger.info("Server Manager State: No servers configured.");
      return;
    }
    const tableData = allServerNames.map((name) => ({
      "Server Name": name,
      Connected: activeSessionNames.includes(name) ? "\u2705" : "\u274C",
      Initialized: this.initializedServers[name] ? "\u2705" : "\u274C",
      "Tool Count": this.serverTools[name]?.length ?? 0,
      Active: this.activeServer === name ? "\u2705" : "\u274C"
    }));
    logger.info(`Server Manager State: [${context}]`);
    console.table(tableData);
  }
  initialize() {
    const serverNames = this.client.getServerNames?.();
    if (serverNames.length === 0) {
      logger.warn("No MCP servers defined in client configuration");
    }
  }
  async prefetchServerTools() {
    const servers = this.client.getServerNames();
    for (const serverName of servers) {
      try {
        let session = null;
        session = this.client.getSession(serverName);
        logger.debug(
          `Using existing session for server '${serverName}' to prefetch tools.`
        );
        if (!session) {
          session = await this.client.createSession(serverName).catch((createSessionError) => {
            logger.warn(
              `Could not create session for '${serverName}' during prefetch: ${createSessionError}`
            );
            return null;
          });
          logger.debug(
            `Temporarily created session for '${serverName}' to prefetch tools.`
          );
        }
        if (session) {
          const connector = session.connector;
          let tools = [];
          let resources = [];
          let prompts = [];
          try {
            tools = await this.adapter.createToolsFromConnectors([connector]);
            resources = await this.adapter.createResourcesFromConnectors([
              connector
            ]);
            prompts = await this.adapter.createPromptsFromConnectors([
              connector
            ]);
          } catch (toolFetchError) {
            logger.error(
              `Failed to create tools/resources/prompts from connector for server '${serverName}': ${toolFetchError}`
            );
            continue;
          }
          const allItems = [...tools, ...resources, ...prompts];
          const cachedTools = this.serverTools[serverName];
          const toolsChanged = !cachedTools || !isEqual(cachedTools, allItems);
          if (toolsChanged) {
            this.serverTools[serverName] = allItems;
            this.initializedServers[serverName] = true;
            logger.debug(
              `Prefetched ${allItems.length} items for server '${serverName}': ${tools.length} tools, ${resources.length} resources, ${prompts.length} prompts.`
            );
          } else {
            logger.debug(
              `Tools for server '${serverName}' unchanged, using cached version.`
            );
          }
        }
      } catch (outerError) {
        logger.error(
          `Error prefetching tools for server '${serverName}': ${outerError}`
        );
      }
    }
  }
  get tools() {
    if (logger.level === "debug") {
      this.logState("Providing tools to agent");
    }
    const managementTools = this.overrideManagementTools ?? [
      new AddMCPServerFromConfigTool(this),
      new ListMCPServersTool(this),
      new ConnectMCPServerTool(this),
      new AcquireActiveMCPServerTool(this),
      new ReleaseMCPServerConnectionTool(this)
    ];
    if (this.activeServer && this.serverTools[this.activeServer]) {
      const activeTools = this.serverTools[this.activeServer];
      logger.debug(
        `Adding ${activeTools.length} tools from active server '${this.activeServer}'`
      );
      return [...managementTools, ...activeTools];
    }
    return managementTools;
  }
};

// src/observability/manager.ts
var ObservabilityManager = class {
  static {
    __name(this, "ObservabilityManager");
  }
  customCallbacks;
  availableHandlers = [];
  handlerNames = [];
  initialized = false;
  verbose;
  observe;
  agentId;
  metadata;
  metadataProvider;
  tagsProvider;
  constructor(config = {}) {
    this.customCallbacks = config.customCallbacks;
    this.verbose = config.verbose ?? false;
    this.observe = config.observe ?? true;
    this.agentId = config.agentId;
    this.metadata = config.metadata;
    this.metadataProvider = config.metadataProvider;
    this.tagsProvider = config.tagsProvider;
  }
  /**
   * Collect all available observability handlers from configured platforms.
   */
  async collectAvailableHandlers() {
    if (this.initialized) {
      return;
    }
    try {
      const { langfuseHandler: langfuseHandler2, langfuseInitPromise: langfuseInitPromise2 } = await import("./langfuse-U2OEF7K7.js");
      if (this.agentId || this.metadata || this.metadataProvider || this.tagsProvider) {
        const { initializeLangfuse } = await import("./langfuse-U2OEF7K7.js");
        await initializeLangfuse(
          this.agentId,
          this.metadata,
          this.metadataProvider,
          this.tagsProvider
        );
        logger.debug(
          `ObservabilityManager: Reinitialized Langfuse with agent ID: ${this.agentId}, metadata: ${JSON.stringify(this.metadata)}`
        );
      } else {
        const initPromise = langfuseInitPromise2();
        if (initPromise) {
          await initPromise;
        }
      }
      const handler = langfuseHandler2();
      if (handler) {
        this.availableHandlers.push(handler);
        this.handlerNames.push("Langfuse");
        logger.debug("ObservabilityManager: Langfuse handler available");
      }
    } catch {
      logger.debug("ObservabilityManager: Langfuse module not available");
    }
    this.initialized = true;
  }
  /**
   * Get the list of callbacks to use.
   * @returns List of callbacks - either custom callbacks if provided, or all available observability handlers.
   */
  async getCallbacks() {
    if (!this.observe) {
      logger.debug(
        "ObservabilityManager: Observability disabled via observe=false"
      );
      return [];
    }
    if (this.customCallbacks) {
      logger.debug(
        `ObservabilityManager: Using ${this.customCallbacks.length} custom callbacks`
      );
      return this.customCallbacks;
    }
    await this.collectAvailableHandlers();
    if (this.availableHandlers.length > 0) {
      logger.debug(
        `ObservabilityManager: Using ${this.availableHandlers.length} handlers`
      );
    } else {
      logger.debug("ObservabilityManager: No callbacks configured");
    }
    return this.availableHandlers;
  }
  /**
   * Get the names of available handlers.
   * @returns List of handler names (e.g., ["Langfuse", "Laminar"])
   */
  async getHandlerNames() {
    if (!this.observe) {
      return [];
    }
    if (this.customCallbacks) {
      return this.customCallbacks.map((cb) => cb.constructor.name);
    }
    await this.collectAvailableHandlers();
    return this.handlerNames;
  }
  /**
   * Check if any callbacks are available.
   * @returns True if callbacks are available, False otherwise.
   */
  async hasCallbacks() {
    if (!this.observe) {
      return false;
    }
    const callbacks = await this.getCallbacks();
    return callbacks.length > 0;
  }
  /**
   * Get the current observability status including metadata and tags.
   * @returns Object containing enabled status, callback count, handler names, metadata, and tags.
   */
  async getStatus() {
    const callbacks = await this.getCallbacks();
    const handlerNames = await this.getHandlerNames();
    const currentMetadata = this.metadataProvider ? this.metadataProvider() : this.metadata || {};
    const currentTags = this.tagsProvider ? this.tagsProvider() : [];
    return {
      enabled: this.observe && callbacks.length > 0,
      callbackCount: callbacks.length,
      handlerNames,
      metadata: currentMetadata,
      tags: currentTags
    };
  }
  /**
   * Add a callback to the custom callbacks list.
   * @param callback The callback to add.
   */
  addCallback(callback) {
    if (!this.customCallbacks) {
      this.customCallbacks = [];
    }
    this.customCallbacks.push(callback);
    logger.debug(
      `ObservabilityManager: Added custom callback: ${callback.constructor.name}`
    );
  }
  /**
   * Clear all custom callbacks.
   */
  clearCallbacks() {
    this.customCallbacks = [];
    logger.debug("ObservabilityManager: Cleared all custom callbacks");
  }
  /**
   * Flush all pending traces to observability platforms.
   * Important for serverless environments and short-lived processes.
   */
  async flush() {
    const callbacks = await this.getCallbacks();
    for (const callback of callbacks) {
      if ("flushAsync" in callback && typeof callback.flushAsync === "function") {
        await callback.flushAsync();
      }
    }
    logger.debug("ObservabilityManager: All traces flushed");
  }
  /**
   * Shutdown all handlers gracefully (for serverless environments).
   */
  async shutdown() {
    await this.flush();
    const callbacks = await this.getCallbacks();
    for (const callback of callbacks) {
      if ("shutdownAsync" in callback && typeof callback.shutdownAsync === "function") {
        await callback.shutdownAsync();
      } else if ("shutdown" in callback && typeof callback.shutdown === "function") {
        await callback.shutdown();
      }
    }
    logger.debug("ObservabilityManager: All handlers shutdown");
  }
  /**
   * String representation of the ObservabilityManager.
   */
  toString() {
    const names = this.handlerNames;
    if (names.length > 0) {
      return `ObservabilityManager(handlers=${names.join(", ")})`;
    }
    return "ObservabilityManager(no handlers)";
  }
};

// src/agents/remote.ts
import { toJSONSchema } from "zod";
var API_CHATS_ENDPOINT = "/api/v1/chats";
var API_CHAT_EXECUTE_ENDPOINT = "/api/v1/chats/{chat_id}/execute";
function normalizeRemoteRunOptions(queryOrOptions, maxSteps, manageConnector, externalHistory, outputSchema) {
  if (typeof queryOrOptions === "object" && queryOrOptions !== null) {
    const options = queryOrOptions;
    return {
      query: options.prompt,
      maxSteps: options.maxSteps,
      manageConnector: options.manageConnector,
      externalHistory: options.externalHistory,
      outputSchema: options.schema
    };
  }
  return {
    query: queryOrOptions,
    maxSteps,
    manageConnector,
    externalHistory,
    outputSchema
  };
}
__name(normalizeRemoteRunOptions, "normalizeRemoteRunOptions");
var RemoteAgent = class {
  static {
    __name(this, "RemoteAgent");
  }
  agentId;
  apiKey;
  baseUrl;
  chatId = null;
  constructor(options) {
    this.agentId = options.agentId;
    this.baseUrl = options.baseUrl ?? "https://cloud.mcp-use.com";
    const apiKey = options.apiKey ?? (typeof process !== "undefined" && process.env?.MCP_USE_API_KEY);
    if (!apiKey) {
      throw new Error(
        "API key is required for remote execution. Please provide it as a parameter or set the MCP_USE_API_KEY environment variable. You can get an API key from https://cloud.mcp-use.com"
      );
    }
    this.apiKey = apiKey;
  }
  pydanticToJsonSchema(schema) {
    return toJSONSchema(schema);
  }
  parseStructuredResponse(responseData, outputSchema) {
    let resultData;
    if (typeof responseData === "object" && responseData !== null) {
      if ("result" in responseData) {
        const outerResult = responseData.result;
        if (typeof outerResult === "object" && outerResult !== null && "result" in outerResult) {
          resultData = outerResult.result;
        } else {
          resultData = outerResult;
        }
      } else {
        resultData = responseData;
      }
    } else if (typeof responseData === "string") {
      try {
        resultData = JSON.parse(responseData);
      } catch {
        resultData = { content: responseData };
      }
    } else {
      resultData = responseData;
    }
    try {
      return outputSchema.parse(resultData);
    } catch (e) {
      logger.warn(`Failed to parse structured output: ${e}`);
      const schemaShape = outputSchema._def?.shape();
      if (schemaShape && "content" in schemaShape) {
        return outputSchema.parse({ content: String(resultData) });
      }
      throw e;
    }
  }
  async createChatSession() {
    const chatPayload = {
      title: `Remote Agent Session - ${this.agentId}`,
      agent_id: this.agentId,
      type: "agent_execution"
    };
    const headers = {
      "Content-Type": "application/json",
      "x-api-key": this.apiKey
    };
    const chatUrl = `${this.baseUrl}${API_CHATS_ENDPOINT}`;
    logger.info(`\u{1F4DD} Creating chat session for agent ${this.agentId}`);
    try {
      const response = await fetch(chatUrl, {
        method: "POST",
        headers,
        body: JSON.stringify(chatPayload)
      });
      if (!response.ok) {
        const responseText = await response.text();
        const statusCode = response.status;
        if (statusCode === 404) {
          throw new Error(
            `Agent not found: Agent '${this.agentId}' does not exist or you don't have access to it. Please verify the agent ID and ensure it exists in your account.`
          );
        }
        throw new Error(
          `Failed to create chat session: ${statusCode} - ${responseText}`
        );
      }
      const chatData = await response.json();
      const chatId = chatData.id;
      logger.info(`\u2705 Chat session created: ${chatId}`);
      return chatId;
    } catch (e) {
      if (e instanceof Error) {
        throw new TypeError(`Failed to create chat session: ${e.message}`);
      }
      throw new Error(`Failed to create chat session: ${String(e)}`);
    }
  }
  async run(queryOrOptions, maxSteps, manageConnector, externalHistory, outputSchema) {
    const {
      query,
      maxSteps: steps,
      externalHistory: history,
      outputSchema: schema
    } = normalizeRemoteRunOptions(
      queryOrOptions,
      maxSteps,
      manageConnector,
      externalHistory,
      outputSchema
    );
    if (history !== void 0) {
      logger.warn("External history is not yet supported for remote execution");
    }
    try {
      logger.info(`\u{1F310} Executing query on remote agent ${this.agentId}`);
      if (this.chatId === null) {
        this.chatId = await this.createChatSession();
      }
      const chatId = this.chatId;
      const executionPayload = {
        query,
        max_steps: steps ?? 10
      };
      if (schema) {
        executionPayload.output_schema = this.pydanticToJsonSchema(schema);
        logger.info(`\u{1F527} Using structured output with schema`);
      }
      const headers = {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey
      };
      const executionUrl = `${this.baseUrl}${API_CHAT_EXECUTE_ENDPOINT.replace("{chat_id}", chatId)}`;
      logger.info(`\u{1F680} Executing agent in chat ${chatId}`);
      const response = await fetch(executionUrl, {
        method: "POST",
        headers,
        body: JSON.stringify(executionPayload),
        signal: AbortSignal.timeout(3e5)
        // 5 minute timeout
      });
      if (!response.ok) {
        const responseText = await response.text();
        const statusCode = response.status;
        if (statusCode === 401) {
          logger.error(`\u274C Authentication failed: ${responseText}`);
          throw new Error(
            "Authentication failed: Invalid or missing API key. Please check your API key and ensure the MCP_USE_API_KEY environment variable is set correctly."
          );
        } else if (statusCode === 403) {
          logger.error(`\u274C Access forbidden: ${responseText}`);
          throw new Error(
            `Access denied: You don't have permission to execute agent '${this.agentId}'. Check if the agent exists and you have the necessary permissions.`
          );
        } else if (statusCode === 404) {
          logger.error(`\u274C Agent not found: ${responseText}`);
          throw new Error(
            `Agent not found: Agent '${this.agentId}' does not exist or you don't have access to it. Please verify the agent ID and ensure it exists in your account.`
          );
        } else if (statusCode === 422) {
          logger.error(`\u274C Validation error: ${responseText}`);
          throw new Error(
            `Request validation failed: ${responseText}. Please check your query parameters and output schema format.`
          );
        } else if (statusCode === 500) {
          logger.error(`\u274C Server error: ${responseText}`);
          throw new Error(
            "Internal server error occurred during agent execution. Please try again later or contact support if the issue persists."
          );
        } else {
          logger.error(
            `\u274C Remote execution failed with status ${statusCode}: ${responseText}`
          );
          throw new Error(
            `Remote agent execution failed: ${statusCode} - ${responseText}`
          );
        }
      }
      const result = await response.json();
      logger.info(`\u{1F527} Response: ${JSON.stringify(result)}`);
      logger.info("\u2705 Remote execution completed successfully");
      if (typeof result === "object" && result !== null) {
        if (result.status === "error" || result.error !== null) {
          const errorMsg = result.error ?? String(result);
          logger.error(`\u274C Remote agent execution failed: ${errorMsg}`);
          throw new Error(`Remote agent execution failed: ${errorMsg}`);
        }
        if (String(result).includes("failed to initialize")) {
          logger.error(`\u274C Agent initialization failed: ${result}`);
          throw new Error(
            `Agent initialization failed on remote server. This usually indicates:
\u2022 Invalid agent configuration (LLM model, system prompt)
\u2022 Missing or invalid MCP server configurations
\u2022 Network connectivity issues with MCP servers
\u2022 Missing environment variables or credentials
Raw error: ${result}`
          );
        }
      }
      if (schema) {
        return this.parseStructuredResponse(result, schema);
      }
      if (typeof result === "object" && result !== null && "result" in result) {
        return result.result;
      } else if (typeof result === "string") {
        return result;
      } else {
        return String(result);
      }
    } catch (e) {
      if (e instanceof Error) {
        if (e.name === "AbortError") {
          logger.error(`\u274C Remote execution timed out: ${e}`);
          throw new Error(
            "Remote agent execution timed out. The server may be overloaded or the query is taking too long to process. Try again or use a simpler query."
          );
        }
        logger.error(`\u274C Remote execution error: ${e}`);
        throw new Error(`Remote agent execution failed: ${e.message}`);
      }
      logger.error(`\u274C Remote execution error: ${e}`);
      throw new Error(`Remote agent execution failed: ${String(e)}`);
    }
  }
  // eslint-disable-next-line require-yield
  async *stream(queryOrOptions, maxSteps, manageConnector, externalHistory, outputSchema) {
    const result = await this.run(
      queryOrOptions,
      maxSteps,
      manageConnector,
      externalHistory,
      outputSchema
    );
    return result;
  }
  async close() {
    logger.info("\u{1F50C} Remote agent client closed");
  }
};

// src/agents/utils/llm_provider.ts
var PROVIDER_CONFIG = {
  openai: {
    package: "@langchain/openai",
    className: "ChatOpenAI",
    envVars: ["OPENAI_API_KEY"],
    defaultModel: "gpt-4o"
  },
  anthropic: {
    package: "@langchain/anthropic",
    className: "ChatAnthropic",
    envVars: ["ANTHROPIC_API_KEY"],
    defaultModel: "claude-3-5-sonnet-20241022"
  },
  google: {
    package: "@langchain/google-genai",
    className: "ChatGoogleGenerativeAI",
    envVars: ["GOOGLE_API_KEY", "GOOGLE_GENERATIVE_AI_API_KEY"],
    defaultModel: "gemini-pro"
  },
  groq: {
    package: "@langchain/groq",
    className: "ChatGroq",
    envVars: ["GROQ_API_KEY"],
    defaultModel: "llama-3.1-70b-versatile"
  }
};
function parseLLMString(llmString) {
  const parts = llmString.split("/");
  if (parts.length !== 2) {
    throw new Error(
      `Invalid LLM string format. Expected 'provider/model', got '${llmString}'. Examples: 'openai/gpt-4', 'anthropic/claude-3-5-sonnet-20241022', 'google/gemini-pro', 'groq/llama-3.1-70b-versatile'`
    );
  }
  const [provider, model] = parts;
  if (!provider || !model) {
    throw new Error(
      `Invalid LLM string format. Both provider and model must be non-empty. Got '${llmString}'`
    );
  }
  const normalizedProvider = provider.toLowerCase();
  if (!(normalizedProvider in PROVIDER_CONFIG)) {
    const supportedProviders = Object.keys(PROVIDER_CONFIG).join(", ");
    throw new Error(
      `Unsupported LLM provider '${provider}'. Supported providers: ${supportedProviders}`
    );
  }
  return { provider: normalizedProvider, model };
}
__name(parseLLMString, "parseLLMString");
function getAPIKey(provider, config) {
  if (config?.apiKey) {
    return config.apiKey;
  }
  const providerConfig = PROVIDER_CONFIG[provider];
  if (typeof process !== "undefined" && process.env) {
    for (const envVar of providerConfig.envVars) {
      const apiKey = process.env[envVar];
      if (apiKey) {
        logger.debug(
          `Using API key from environment variable ${envVar} for provider ${provider}`
        );
        return apiKey;
      }
    }
  }
  const envVarsStr = providerConfig.envVars.join(" or ");
  throw new Error(
    `API key not found for provider '${provider}'. Set ${envVarsStr} environment variable or pass apiKey in llmConfig. Example: new MCPAgent({ llm: '${provider}/model', llmConfig: { apiKey: 'your-key' } })`
  );
}
__name(getAPIKey, "getAPIKey");
async function createLLMFromString(llmString, config) {
  logger.info(`Creating LLM from string: ${llmString}`);
  const { provider, model } = parseLLMString(llmString);
  const providerConfig = PROVIDER_CONFIG[provider];
  const apiKey = getAPIKey(provider, config);
  let providerModule;
  try {
    logger.debug(`Importing package ${providerConfig.package}...`);
    providerModule = await import(providerConfig.package);
  } catch (error) {
    if (error?.code === "MODULE_NOT_FOUND" || error?.message?.includes("Cannot find module") || error?.message?.includes("Cannot find package")) {
      throw new Error(
        `Package '${providerConfig.package}' is not installed. Install it with: npm install ${providerConfig.package} or yarn add ${providerConfig.package}`
      );
    }
    throw new Error(
      `Failed to import ${providerConfig.package}: ${error?.message || error}`
    );
  }
  const LLMClass = providerModule[providerConfig.className];
  if (!LLMClass) {
    throw new Error(
      `Could not find ${providerConfig.className} in package ${providerConfig.package}. This might be a version compatibility issue.`
    );
  }
  const llmConfig = {
    model,
    apiKey,
    ...config
  };
  if (config?.apiKey) {
    delete llmConfig.apiKey;
    llmConfig.apiKey = apiKey;
  }
  if (provider === "anthropic") {
    llmConfig.model = model;
  } else if (provider === "google") {
    llmConfig.model = model;
  } else if (provider === "openai") {
    llmConfig.model = model;
  } else if (provider === "groq") {
    llmConfig.model = model;
  }
  try {
    const llmInstance = new LLMClass(llmConfig);
    logger.info(`Successfully created ${provider} LLM with model ${model}`);
    return llmInstance;
  } catch (error) {
    throw new Error(
      `Failed to instantiate ${providerConfig.className} with model '${model}': ${error?.message || error}`
    );
  }
}
__name(createLLMFromString, "createLLMFromString");
function isValidLLMString(llmString) {
  try {
    parseLLMString(llmString);
    return true;
  } catch {
    return false;
  }
}
__name(isValidLLMString, "isValidLLMString");
function getSupportedProviders() {
  return Object.keys(PROVIDER_CONFIG);
}
__name(getSupportedProviders, "getSupportedProviders");

// src/agents/mcp_agent.ts
import {
  AIMessage,
  createAgent,
  HumanMessage,
  modelCallLimitMiddleware,
  SystemMessage as SystemMessage2,
  ToolMessage
} from "langchain";
import { toJSONSchema as toJSONSchema2 } from "zod";

// src/agents/prompts/system_prompt_builder.ts
import { SystemMessage } from "langchain";
function generateToolDescriptions(tools, disallowedTools) {
  const disallowedSet = new Set(disallowedTools ?? []);
  const descriptions = [];
  for (const tool of tools) {
    if (disallowedSet.has(tool.name)) continue;
    const escaped = tool.description.replace(/\{/g, "{{").replace(/\}/g, "}}");
    descriptions.push(`- ${tool.name}: ${escaped}`);
  }
  return descriptions;
}
__name(generateToolDescriptions, "generateToolDescriptions");
function buildSystemPromptContent(template, toolDescriptionLines, additionalInstructions) {
  const block = toolDescriptionLines.join("\n");
  let content;
  if (template.includes("{tool_descriptions}")) {
    content = template.replace("{tool_descriptions}", block);
  } else {
    console.warn(
      "`{tool_descriptions}` placeholder not found; appending at end."
    );
    content = `${template}

Available tools:
${block}`;
  }
  if (additionalInstructions) {
    content += `

${additionalInstructions}`;
  }
  return content;
}
__name(buildSystemPromptContent, "buildSystemPromptContent");
function createSystemMessage(tools, systemPromptTemplate, serverManagerTemplate, useServerManager, disallowedTools, userProvidedPrompt, additionalInstructions) {
  if (userProvidedPrompt) {
    return new SystemMessage({ content: userProvidedPrompt });
  }
  const template = useServerManager ? serverManagerTemplate : systemPromptTemplate;
  const toolLines = generateToolDescriptions(tools, disallowedTools);
  const finalContent = buildSystemPromptContent(
    template,
    toolLines,
    additionalInstructions
  );
  return new SystemMessage({ content: finalContent });
}
__name(createSystemMessage, "createSystemMessage");

// src/agents/prompts/templates.ts
var DEFAULT_SYSTEM_PROMPT_TEMPLATE = `You are a helpful AI assistant.
You have access to the following tools:

{tool_descriptions}

Use the following format:

Question: the input question you must answer
Thought: you should always think about what to do
Action: the action to take, should be one of the available tools
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question`;
var SERVER_MANAGER_SYSTEM_PROMPT_TEMPLATE = `You are a helpful assistant designed to interact with MCP
 (Model Context Protocol) servers. You can manage connections to different servers and use the tools
 provided by the currently active server.

Important: The available tools change depending on which server is active.
If a request requires tools not listed below (e.g., file operations, web browsing,
 image manipulation), you MUST first connect to the appropriate server using
 'connect_to_mcp_server'.
Use 'list_mcp_servers' to find the relevant server if you are unsure.
Only after successfully connecting and seeing the new tools listed in
the response should you attempt to use those server-specific tools.
Before attempting a task that requires specific tools, you should
ensure you are connected to the correct server and aware of its
available tools. If unsure, use 'list_mcp_servers' to see options
or 'get_active_mcp_server' to check the current connection.

When you connect to a server using 'connect_to_mcp_server',
 you will be informed about the new tools that become available.
You can then use these server-specific tools in subsequent steps.

Here are the tools *currently* available to you (this list includes server management tools and will
 change when you connect to a server):
{tool_descriptions}
`;

// src/agents/mcp_agent.ts
function normalizeRunOptions(queryOrOptions, maxSteps, manageConnector, externalHistory, outputSchema, signal) {
  if (typeof queryOrOptions === "object" && queryOrOptions !== null) {
    const options = queryOrOptions;
    return {
      query: options.prompt,
      maxSteps: options.maxSteps,
      manageConnector: options.manageConnector,
      externalHistory: options.externalHistory,
      outputSchema: options.schema,
      signal: options.signal
    };
  }
  return {
    query: queryOrOptions,
    maxSteps,
    manageConnector,
    externalHistory,
    outputSchema,
    signal
  };
}
__name(normalizeRunOptions, "normalizeRunOptions");
var MCPAgent = class {
  static {
    __name(this, "MCPAgent");
  }
  /**
   * Get the mcp-use package version.
   * Works in all environments (Node.js, browser, Cloudflare Workers, Deno, etc.)
   */
  static getPackageVersion() {
    return getPackageVersion();
  }
  llm;
  client;
  connectors;
  maxSteps;
  autoInitialize;
  memoryEnabled;
  disallowedTools;
  additionalTools;
  toolsUsedNames = [];
  exposeResourcesAsTools = true;
  exposePromptsAsTools = true;
  useServerManager;
  verbose;
  observe;
  systemPrompt;
  systemPromptTemplateOverride;
  additionalInstructions;
  _initialized = false;
  conversationHistory = [];
  _agentExecutor = null;
  sessions = {};
  systemMessage = null;
  _tools = [];
  adapter;
  serverManager = null;
  telemetry;
  modelProvider;
  modelName;
  // Observability support
  observabilityManager;
  callbacks = [];
  metadata = {};
  tags = [];
  // Remote agent support
  isRemote = false;
  remoteAgent = null;
  // Simplified mode support
  isSimplifiedMode = false;
  llmString;
  llmConfig;
  mcpServersConfig;
  clientOwnedByAgent = false;
  constructor(options) {
    if (options.agentId) {
      this.isRemote = true;
      this.remoteAgent = new RemoteAgent({
        agentId: options.agentId,
        apiKey: options.apiKey,
        baseUrl: options.baseUrl
      });
      this.maxSteps = options.maxSteps ?? 5;
      this.memoryEnabled = options.memoryEnabled ?? true;
      this.autoInitialize = options.autoInitialize ?? false;
      this.verbose = options.verbose ?? false;
      this.observe = options.observe ?? true;
      this.connectors = [];
      this.disallowedTools = [];
      this.additionalTools = [];
      this.useServerManager = false;
      this.adapter = new LangChainAdapter();
      this.telemetry = Telemetry.getInstance();
      this.modelProvider = "remote";
      this.modelName = "remote-agent";
      this.observabilityManager = new ObservabilityManager({
        customCallbacks: options.callbacks,
        agentId: options.agentId
      });
      this.callbacks = [];
      return;
    }
    if (!options.llm) {
      throw new Error(
        "llm is required for local execution. For remote execution, provide agentId instead."
      );
    }
    const isSimplifiedMode = typeof options.llm === "string";
    if (isSimplifiedMode) {
      this.isSimplifiedMode = true;
      this.llmString = options.llm;
      this.llmConfig = options.llmConfig;
      this.mcpServersConfig = options.mcpServers;
      if (!this.mcpServersConfig || Object.keys(this.mcpServersConfig).length === 0) {
        throw new Error(
          "Simplified mode requires 'mcpServers' configuration. Provide an object with server configurations, e.g., { filesystem: { command: 'npx', args: [...] } }"
        );
      }
      this.llm = void 0;
      this.client = void 0;
      this.clientOwnedByAgent = true;
      this.connectors = [];
      logger.info(
        `\u{1F3AF} Simplified mode enabled: LLM will be created from '${this.llmString}'`
      );
    } else {
      this.isSimplifiedMode = false;
      this.llm = options.llm;
      this.client = options.client;
      this.connectors = options.connectors ?? [];
      this.clientOwnedByAgent = false;
      if (!this.client && this.connectors.length === 0) {
        throw new Error(
          "Explicit mode requires either 'client' or at least one 'connector'. Alternatively, use simplified mode with 'llm' as a string and 'mcpServers' config."
        );
      }
    }
    this.maxSteps = options.maxSteps ?? 5;
    this.autoInitialize = options.autoInitialize ?? false;
    this.memoryEnabled = options.memoryEnabled ?? true;
    this.systemPrompt = options.systemPrompt ?? null;
    this.systemPromptTemplateOverride = options.systemPromptTemplate ?? null;
    this.additionalInstructions = options.additionalInstructions ?? null;
    this.disallowedTools = options.disallowedTools ?? [];
    this.additionalTools = options.additionalTools ?? [];
    this.toolsUsedNames = options.toolsUsedNames ?? [];
    this.exposeResourcesAsTools = options.exposeResourcesAsTools ?? true;
    this.exposePromptsAsTools = options.exposePromptsAsTools ?? true;
    this.useServerManager = options.useServerManager ?? false;
    this.verbose = options.verbose ?? false;
    this.observe = options.observe ?? true;
    if (!this.isSimplifiedMode) {
      if (this.useServerManager) {
        if (!this.client) {
          throw new Error(
            "'client' must be provided when 'useServerManager' is true."
          );
        }
        this.adapter = options.adapter ?? new LangChainAdapter(this.disallowedTools);
        this.serverManager = options.serverManagerFactory?.(this.client) ?? new ServerManager(this.client, this.adapter);
      } else {
        this.adapter = options.adapter ?? new LangChainAdapter(this.disallowedTools);
      }
      this.telemetry = Telemetry.getInstance();
      if (this.llm) {
        const [provider, name] = extractModelInfo(this.llm);
        this.modelProvider = provider;
        this.modelName = name;
      } else {
        this.modelProvider = "unknown";
        this.modelName = "unknown";
      }
    } else {
      this.adapter = options.adapter ?? new LangChainAdapter(this.disallowedTools);
      this.telemetry = Telemetry.getInstance();
      this.modelProvider = "unknown";
      this.modelName = "unknown";
    }
    this.observabilityManager = new ObservabilityManager({
      customCallbacks: options.callbacks,
      verbose: this.verbose,
      observe: this.observe,
      agentId: options.agentId,
      metadataProvider: /* @__PURE__ */ __name(() => this.getMetadata(), "metadataProvider"),
      tagsProvider: /* @__PURE__ */ __name(() => this.getTags(), "tagsProvider")
    });
    Object.defineProperty(this, "agentExecutor", {
      get: /* @__PURE__ */ __name(() => this._agentExecutor, "get"),
      configurable: true
    });
    Object.defineProperty(this, "tools", {
      get: /* @__PURE__ */ __name(() => this._tools, "get"),
      configurable: true
    });
    Object.defineProperty(this, "initialized", {
      get: /* @__PURE__ */ __name(() => this._initialized, "get"),
      configurable: true
    });
  }
  async initialize() {
    if (this.isRemote) {
      this._initialized = true;
      return;
    }
    logger.info("\u{1F680} Initializing MCP agent and connecting to services...");
    if (this.isSimplifiedMode) {
      logger.info(
        "\u{1F3AF} Simplified mode: Creating client and LLM from configuration..."
      );
      if (this.mcpServersConfig) {
        logger.info(
          `Creating MCPClient with ${Object.keys(this.mcpServersConfig).length} server(s)...`
        );
        const { MCPClient } = await import("./src/client.js");
        this.client = new MCPClient({ mcpServers: this.mcpServersConfig });
        logger.info("\u2705 MCPClient created successfully");
      }
      if (this.llmString) {
        logger.info(`Creating LLM from string: ${this.llmString}...`);
        try {
          this.llm = await createLLMFromString(this.llmString, this.llmConfig);
          logger.info("\u2705 LLM created successfully");
          const [provider, name] = extractModelInfo(this.llm);
          this.modelProvider = provider;
          this.modelName = name;
        } catch (error) {
          throw new Error(
            `Failed to create LLM from string '${this.llmString}': ${error?.message || error}`
          );
        }
      }
      if (this.useServerManager) {
        if (!this.client) {
          throw new Error(
            "'client' must be available when 'useServerManager' is true."
          );
        }
        this.serverManager = new ServerManager(this.client, this.adapter);
      }
    }
    this.callbacks = await this.observabilityManager.getCallbacks();
    const handlerNames = await this.observabilityManager.getHandlerNames();
    if (handlerNames.length > 0) {
      logger.info(`\u{1F4CA} Observability enabled with: ${handlerNames.join(", ")}`);
    }
    if (this.useServerManager && this.serverManager) {
      await this.serverManager.initialize();
      const managementTools = this.serverManager.tools;
      this._tools = managementTools;
      this._tools.push(...this.additionalTools);
      logger.info(
        `\u{1F527} Server manager mode active with ${managementTools.length} management tools`
      );
      await this.createSystemMessageFromTools(this._tools);
    } else {
      if (this.client) {
        this.sessions = this.client.getAllActiveSessions();
        logger.info(
          `\u{1F50C} Found ${Object.keys(this.sessions).length} existing sessions`
        );
        const nonCodeModeSessions = Object.keys(this.sessions).filter(
          (name) => name !== "code_mode"
        );
        if (nonCodeModeSessions.length === 0) {
          logger.info("\u{1F504} No active sessions found, creating new ones...");
          this.sessions = await this.client.createAllSessions();
          logger.info(
            `\u2705 Created ${Object.keys(this.sessions).length} new sessions`
          );
        }
        if (this.client.codeMode) {
          const codeModeSession = this.sessions["code_mode"];
          if (codeModeSession) {
            this._tools = await this.adapter.createToolsFromConnectors([
              codeModeSession.connector
            ]);
            logger.info(`\u{1F6E0}\uFE0F Created ${this._tools.length} code mode tools`);
          } else {
            throw new Error(
              "Code mode enabled but code_mode session not found"
            );
          }
        } else {
          const connectors = Object.values(this.sessions).map(
            (session) => session.connector
          );
          const tools = await this.adapter.createToolsFromConnectors(connectors);
          const resources = this.exposeResourcesAsTools ? await this.adapter.createResourcesFromConnectors(connectors) : [];
          const prompts = this.exposePromptsAsTools ? await this.adapter.createPromptsFromConnectors(connectors) : [];
          this._tools = [...tools, ...resources, ...prompts];
          logger.info(
            `\u{1F6E0}\uFE0F Created ${this._tools.length} LangChain items from client: ${tools.length} tools, ${resources.length} resources, ${prompts.length} prompts`
          );
        }
        this._tools.push(...this.additionalTools);
      } else {
        logger.info(
          `\u{1F517} Connecting to ${this.connectors.length} direct connectors...`
        );
        for (const connector of this.connectors) {
          if (!connector.isClientConnected) {
            await connector.connect();
          }
        }
        const tools = await this.adapter.createToolsFromConnectors(
          this.connectors
        );
        const resources = await this.adapter.createResourcesFromConnectors(
          this.connectors
        );
        const prompts = await this.adapter.createPromptsFromConnectors(
          this.connectors
        );
        this._tools = [...tools, ...resources, ...prompts];
        this._tools.push(...this.additionalTools);
        logger.info(
          `\u{1F6E0}\uFE0F Created ${this._tools.length} LangChain items from connectors: ${tools.length} tools, ${resources.length} resources, ${prompts.length} prompts`
        );
      }
      logger.info(`\u{1F9F0} Found ${this._tools.length} tools across all connectors`);
      await this.createSystemMessageFromTools(this._tools);
    }
    this._agentExecutor = this.createAgent();
    this._initialized = true;
    const mcpServerInfo = this.getMCPServerInfo();
    if (Object.keys(mcpServerInfo).length > 0) {
      this.setMetadata(mcpServerInfo);
      logger.debug(
        `MCP server info added to metadata: ${JSON.stringify(mcpServerInfo)}`
      );
    }
    logger.info("\u2728 Agent initialization complete");
  }
  async createSystemMessageFromTools(tools) {
    const systemPromptTemplate = this.systemPromptTemplateOverride ?? DEFAULT_SYSTEM_PROMPT_TEMPLATE;
    this.systemMessage = createSystemMessage(
      tools,
      systemPromptTemplate,
      SERVER_MANAGER_SYSTEM_PROMPT_TEMPLATE,
      this.useServerManager,
      this.disallowedTools,
      this.systemPrompt ?? void 0,
      this.additionalInstructions ?? void 0
    );
    if (this.memoryEnabled) {
      this.conversationHistory = [
        this.systemMessage,
        ...this.conversationHistory.filter(
          (m) => !(m instanceof SystemMessage2)
        )
      ];
    }
  }
  createAgent() {
    if (!this.llm) {
      throw new Error("LLM is required to create agent");
    }
    const systemContent = this.systemMessage?.content ?? "You are a helpful assistant.";
    const toolNames = this._tools.map((tool) => tool.name);
    logger.info(`\u{1F9E0} Agent ready with tools: ${toolNames.join(", ")}`);
    const middleware = [modelCallLimitMiddleware({ runLimit: this.maxSteps })];
    const agent = createAgent({
      model: this.llm,
      tools: this._tools,
      systemPrompt: systemContent,
      middleware
    });
    logger.debug(
      `Created agent with max_steps=${this.maxSteps} (via ModelCallLimitMiddleware) and ${this.callbacks.length} callbacks`
    );
    return agent;
  }
  getConversationHistory() {
    return [...this.conversationHistory];
  }
  clearConversationHistory() {
    this.conversationHistory = this.memoryEnabled && this.systemMessage ? [this.systemMessage] : [];
  }
  addToHistory(message) {
    if (this.memoryEnabled) this.conversationHistory.push(message);
  }
  getSystemMessage() {
    return this.systemMessage;
  }
  setSystemMessage(message) {
    this.systemMessage = new SystemMessage2(message);
    if (this.memoryEnabled) {
      this.conversationHistory = this.conversationHistory.filter(
        (m) => !(m instanceof SystemMessage2)
      );
      this.conversationHistory.unshift(this.systemMessage);
    }
    if (this._initialized && this._tools.length) {
      this._agentExecutor = this.createAgent();
      logger.debug("Agent recreated with new system message");
    }
  }
  setDisallowedTools(disallowedTools) {
    this.disallowedTools = disallowedTools;
    this.adapter = new LangChainAdapter(this.disallowedTools);
    if (this._initialized) {
      logger.debug(
        "Agent already initialized. Changes will take effect on next initialization."
      );
    }
  }
  getDisallowedTools() {
    return this.disallowedTools;
  }
  /**
   * Set metadata for observability traces
   * @param newMetadata - Key-value pairs to add to metadata. Keys should be strings, values should be serializable.
   */
  setMetadata(newMetadata) {
    const sanitizedMetadata = this.sanitizeMetadata(newMetadata);
    this.metadata = { ...this.metadata, ...sanitizedMetadata };
    logger.debug(`Metadata set: ${JSON.stringify(this.metadata)}`);
  }
  /**
   * Get current metadata
   * @returns A copy of the current metadata object
   */
  getMetadata() {
    return { ...this.metadata };
  }
  /**
   * Set tags for observability traces
   * @param newTags - Array of tag strings to add. Duplicates will be automatically removed.
   */
  setTags(newTags) {
    const sanitizedTags = this.sanitizeTags(newTags);
    this.tags = [.../* @__PURE__ */ new Set([...this.tags, ...sanitizedTags])];
    logger.debug(`Tags set: ${JSON.stringify(this.tags)}`);
  }
  /**
   * Get current tags
   * @returns A copy of the current tags array
   */
  getTags() {
    return [...this.tags];
  }
  /**
   * Sanitize metadata to ensure compatibility with observability platforms
   * @param metadata - Raw metadata object
   * @returns Sanitized metadata object
   */
  sanitizeMetadata(metadata) {
    const sanitized = {};
    for (const [key, value] of Object.entries(metadata)) {
      if (typeof key !== "string" || key.length === 0) {
        logger.warn(`Invalid metadata key: ${key}. Skipping.`);
        continue;
      }
      const sanitizedKey = key.replace(/[^\w-]/g, "_");
      if (value === null || value === void 0) {
        sanitized[sanitizedKey] = value;
      } else if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        sanitized[sanitizedKey] = value;
      } else if (Array.isArray(value)) {
        const sanitizedArray = value.filter(
          (item) => typeof item === "string" || typeof item === "number" || typeof item === "boolean"
        );
        if (sanitizedArray.length > 0) {
          sanitized[sanitizedKey] = sanitizedArray;
        }
      } else if (typeof value === "object") {
        try {
          const serialized = JSON.stringify(value);
          if (serialized.length > 1e3) {
            logger.warn(
              `Metadata value for key '${sanitizedKey}' is too large. Truncating.`
            );
            sanitized[sanitizedKey] = `${serialized.substring(0, 1e3)}...`;
          } else {
            sanitized[sanitizedKey] = value;
          }
        } catch (error) {
          logger.warn(
            `Failed to serialize metadata value for key '${sanitizedKey}': ${error}. Skipping.`
          );
        }
      } else {
        logger.warn(
          `Unsupported metadata value type for key '${sanitizedKey}': ${typeof value}. Skipping.`
        );
      }
    }
    return sanitized;
  }
  /**
   * Sanitize tags to ensure compatibility with observability platforms
   * @param tags - Array of tag strings
   * @returns Array of sanitized tag strings
   */
  sanitizeTags(tags) {
    return tags.filter((tag) => typeof tag === "string" && tag.length > 0).map((tag) => tag.replace(/[^\w:-]/g, "_")).filter((tag) => tag.length <= 50);
  }
  /**
   * Get MCP server information for observability metadata
   */
  getMCPServerInfo() {
    const serverInfo = {};
    try {
      if (this.client) {
        const serverNames = this.client.getServerNames();
        serverInfo.mcp_servers_count = serverNames.length;
        serverInfo.mcp_server_names = serverNames;
        const serverConfigs = {};
        for (const serverName of serverNames) {
          try {
            const config = this.client.getServerConfig(serverName);
            if (config) {
              let serverType = "unknown";
              if (config.command) {
                serverType = "command";
              } else if (config.url) {
                serverType = "http";
              } else if (config.ws_url) {
                serverType = "websocket";
              }
              serverConfigs[serverName] = {
                type: serverType,
                // Include safe configuration details (avoid sensitive data)
                has_args: !!config.args,
                has_env: !!config.env,
                has_headers: !!config.headers,
                url: config.url || null,
                command: config.command || null
              };
            }
          } catch (error) {
            logger.warn(
              `Failed to get config for server '${serverName}': ${error}`
            );
            serverConfigs[serverName] = {
              type: "error",
              error: "config_unavailable"
            };
          }
        }
        serverInfo.mcp_server_configs = serverConfigs;
      } else if (this.connectors && this.connectors.length > 0) {
        serverInfo.mcp_servers_count = this.connectors.length;
        serverInfo.mcp_server_names = this.connectors.map(
          (c) => c.publicIdentifier
        );
        serverInfo.mcp_server_types = this.connectors.map(
          (c) => c.constructor.name
        );
      }
    } catch (error) {
      logger.warn(`Failed to collect MCP server info: ${error}`);
      serverInfo.error = "collection_failed";
    }
    return serverInfo;
  }
  _normalizeOutput(value) {
    try {
      if (typeof value === "string") {
        return value;
      }
      if (value && typeof value === "object" && "content" in value) {
        return this._normalizeOutput(value.content);
      }
      if (Array.isArray(value)) {
        const parts = [];
        for (const item of value) {
          if (typeof item === "object" && item !== null) {
            if ("text" in item && typeof item.text === "string") {
              parts.push(item.text);
            } else if ("content" in item) {
              parts.push(this._normalizeOutput(item.content));
            } else {
              parts.push(String(item));
            }
          } else {
            const partText = item && typeof item === "object" && "text" in item ? item.text : null;
            if (typeof partText === "string") {
              parts.push(partText);
            } else {
              const partContent = item && typeof item === "object" && "content" in item ? item.content : item;
              parts.push(this._normalizeOutput(partContent));
            }
          }
        }
        return parts.join("");
      }
      return String(value);
    } catch (error) {
      return String(value);
    }
  }
  /**
   * Check if a message is AI/assistant-like regardless of whether it's a class instance.
   * Handles version mismatches, serialization boundaries, and different message formats.
   *
   * This method solves the issue where messages from LangChain agents may be plain JavaScript
   * objects (e.g., `{ type: 'ai', content: '...' }`) instead of AIMessage instances due to
   * serialization/deserialization across module boundaries or version mismatches.
   *
   * @example
   * // Real AIMessage instance (standard case)
   * _isAIMessageLike(new AIMessage("hello")) // => true
   *
   * @example
   * // Plain object after serialization (fixes issue #446)
   * _isAIMessageLike({ type: "ai", content: "hello" }) // => true
   *
   * @example
   * // OpenAI-style format with role
   * _isAIMessageLike({ role: "assistant", content: "hello" }) // => true
   *
   * @example
   * // Object with getType() method
   * _isAIMessageLike({ getType: () => "ai", content: "hello" }) // => true
   *
   * @param message - The message object to check
   * @returns true if the message represents an AI/assistant message
   */
  _isAIMessageLike(message) {
    if (message instanceof AIMessage) {
      return true;
    }
    if (typeof message !== "object" || message === null) {
      return false;
    }
    const msg = message;
    if (typeof msg.getType === "function") {
      try {
        const type = msg.getType();
        if (type === "ai" || type === "assistant") {
          return true;
        }
      } catch (error) {
      }
    }
    if (typeof msg._getType === "function") {
      try {
        const type = msg._getType();
        if (type === "ai" || type === "assistant") {
          return true;
        }
      } catch (error) {
      }
    }
    if ("type" in msg) {
      return msg.type === "ai" || msg.type === "assistant";
    }
    if ("role" in msg) {
      return msg.role === "ai" || msg.role === "assistant";
    }
    return false;
  }
  /**
   * Check if a message has tool calls, handling both class instances and plain objects.
   * Safely checks for tool_calls array presence.
   *
   * @example
   * // AIMessage with tool calls
   * const msg = new AIMessage({ content: "", tool_calls: [{ name: "add", args: {} }] });
   * _messageHasToolCalls(msg) // => true
   *
   * @example
   * // Plain object with tool calls
   * _messageHasToolCalls({ type: "ai", tool_calls: [{ name: "add" }] }) // => true
   *
   * @example
   * // Message without tool calls
   * _messageHasToolCalls({ type: "ai", content: "hello" }) // => false
   *
   * @param message - The message object to check
   * @returns true if the message has non-empty tool_calls array
   */
  _messageHasToolCalls(message) {
    if (typeof message === "object" && message !== null && "tool_calls" in message && Array.isArray(message.tool_calls)) {
      return message.tool_calls.length > 0;
    }
    return false;
  }
  /**
   * Check if a message is a HumanMessage-like object.
   * Handles both class instances and plain objects from serialization.
   *
   * @example
   * _isHumanMessageLike(new HumanMessage("hello")) // => true
   * _isHumanMessageLike({ type: "human", content: "hello" }) // => true
   *
   * @param message - The message object to check
   * @returns true if the message represents a human message
   */
  _isHumanMessageLike(message) {
    if (message instanceof HumanMessage) {
      return true;
    }
    if (typeof message !== "object" || message === null) {
      return false;
    }
    const msg = message;
    if (typeof msg.getType === "function") {
      try {
        const type = msg.getType();
        if (type === "human" || type === "user") {
          return true;
        }
      } catch (error) {
      }
    }
    if ("type" in msg && (msg.type === "human" || msg.type === "user")) {
      return true;
    }
    if ("role" in msg && (msg.role === "human" || msg.role === "user")) {
      return true;
    }
    return false;
  }
  /**
   * Check if a message is a ToolMessage-like object.
   * Handles both class instances and plain objects from serialization.
   *
   * @example
   * _isToolMessageLike(new ToolMessage({ content: "result", tool_call_id: "123" })) // => true
   * _isToolMessageLike({ type: "tool", content: "result" }) // => true
   *
   * @param message - The message object to check
   * @returns true if the message represents a tool message
   */
  _isToolMessageLike(message) {
    if (message instanceof ToolMessage) {
      return true;
    }
    if (typeof message !== "object" || message === null) {
      return false;
    }
    const msg = message;
    if (typeof msg.getType === "function") {
      try {
        const type = msg.getType();
        if (type === "tool") {
          return true;
        }
      } catch (error) {
      }
    }
    if ("type" in msg && msg.type === "tool") {
      return true;
    }
    return false;
  }
  /**
   * Extract content from a message, handling both AIMessage instances and plain objects.
   *
   * @example
   * // From AIMessage instance
   * _getMessageContent(new AIMessage("hello")) // => "hello"
   *
   * @example
   * // From plain object
   * _getMessageContent({ type: "ai", content: "hello" }) // => "hello"
   *
   * @param message - The message object to extract content from
   * @returns The content of the message, or undefined if not present
   */
  _getMessageContent(message) {
    if (message instanceof AIMessage) {
      return message.content;
    }
    if (message && typeof message === "object" && "content" in message) {
      return message.content;
    }
    return void 0;
  }
  async _consumeAndReturn(generator) {
    while (true) {
      const { done, value } = await generator.next();
      if (done) {
        return value;
      }
    }
  }
  async run(queryOrOptions, maxSteps, manageConnector, externalHistory, outputSchema, signal) {
    const {
      query,
      maxSteps: steps,
      manageConnector: manage,
      externalHistory: history,
      outputSchema: schema,
      signal: abortSignal
    } = normalizeRunOptions(
      queryOrOptions,
      maxSteps,
      manageConnector,
      externalHistory,
      outputSchema,
      signal
    );
    if (this.isRemote && this.remoteAgent) {
      return this.remoteAgent.run(query, steps, manage, history, schema);
    }
    const generator = this.stream(
      query,
      steps,
      manage,
      history,
      schema,
      abortSignal
    );
    return this._consumeAndReturn(generator);
  }
  async *stream(queryOrOptions, maxSteps, manageConnector = true, externalHistory, outputSchema, signal) {
    const {
      query,
      maxSteps: steps,
      manageConnector: manage,
      externalHistory: history,
      outputSchema: schema,
      signal: abortSignal
    } = normalizeRunOptions(
      queryOrOptions,
      maxSteps,
      manageConnector,
      externalHistory,
      outputSchema,
      signal
    );
    if (this.isRemote && this.remoteAgent) {
      const result = await this.remoteAgent.run(
        query,
        steps,
        manage,
        history,
        schema
      );
      return result;
    }
    let initializedHere = false;
    const startTime = Date.now();
    let success = false;
    let finalOutput = null;
    let stepsTaken = 0;
    try {
      if (manage && !this._initialized) {
        await this.initialize();
        initializedHere = true;
      } else if (!this._initialized && this.autoInitialize) {
        await this.initialize();
        initializedHere = true;
      }
      if (!this._agentExecutor) {
        throw new Error("MCP agent failed to initialize");
      }
      if (this.useServerManager && this.serverManager) {
        const currentTools = this.serverManager.tools;
        const currentToolNames = new Set(currentTools.map((t) => t.name));
        const existingToolNames = new Set(this._tools.map((t) => t.name));
        if (currentToolNames.size !== existingToolNames.size || [...currentToolNames].some((n) => !existingToolNames.has(n))) {
          logger.info(
            `\u{1F504} Tools changed before execution, updating agent. New tools: ${[...currentToolNames].join(", ")}`
          );
          this._tools = currentTools;
          this._tools.push(...this.additionalTools);
          await this.createSystemMessageFromTools(this._tools);
          this._agentExecutor = this.createAgent();
        }
      }
      const historyToUse = history ?? this.conversationHistory;
      const langchainHistory = [];
      for (const msg of historyToUse) {
        if (this._isHumanMessageLike(msg) || this._isAIMessageLike(msg) || this._isToolMessageLike(msg)) {
          langchainHistory.push(msg);
        }
      }
      const displayQuery = query.length > 50 ? `${query.slice(0, 50).replace(/\n/g, " ")}...` : query.replace(/\n/g, " ");
      logger.info(`\u{1F4AC} Received query: '${displayQuery}'`);
      logger.info("\u{1F3C1} Starting agent execution");
      const maxRestarts = 3;
      let restartCount = 0;
      const accumulatedMessages = [
        ...langchainHistory,
        new HumanMessage(query)
      ];
      while (restartCount <= maxRestarts) {
        const inputs = { messages: accumulatedMessages };
        let shouldRestart = false;
        const stream = await this._agentExecutor.stream(inputs, {
          streamMode: "updates",
          // Get updates as they happen
          callbacks: this.callbacks,
          metadata: this.getMetadata(),
          tags: this.getTags(),
          // Set trace name for LangChain/Langfuse
          runName: this.metadata.trace_name || "mcp-use-agent",
          // Set recursion limit to 3x maxSteps to account for model calls + tool executions
          recursionLimit: this.maxSteps * 3,
          // Pass sessionId for Langfuse if present in metadata
          ...this.metadata.session_id && {
            sessionId: this.metadata.session_id
          },
          // Pass abort signal if provided
          ...abortSignal && { signal: abortSignal }
        });
        for await (const chunk of stream) {
          if (abortSignal?.aborted) {
            break;
          }
          for (const [nodeName, nodeOutput] of Object.entries(chunk)) {
            logger.debug(
              `\u{1F4E6} Node '${nodeName}' output: ${JSON.stringify(nodeOutput)}`
            );
            if (nodeOutput && typeof nodeOutput === "object" && "messages" in nodeOutput) {
              let messages = nodeOutput.messages;
              if (!Array.isArray(messages)) {
                messages = [messages];
              }
              for (const msg of messages) {
                if (!accumulatedMessages.includes(msg)) {
                  accumulatedMessages.push(msg);
                }
              }
              for (const message of messages) {
                if ("tool_calls" in message && Array.isArray(message.tool_calls) && message.tool_calls.length > 0) {
                  for (const toolCall of message.tool_calls) {
                    const toolName = toolCall.name || "unknown";
                    const toolInput = toolCall.args || {};
                    this.toolsUsedNames.push(toolName);
                    stepsTaken++;
                    let toolInputStr = JSON.stringify(toolInput);
                    if (toolInputStr.length > 100) {
                      toolInputStr = `${toolInputStr.slice(0, 97)}...`;
                    }
                    logger.info(
                      `\u{1F527} Tool call: ${toolName} with input: ${toolInputStr}`
                    );
                    yield {
                      action: {
                        tool: toolName,
                        toolInput,
                        log: `Calling tool ${toolName}`
                      },
                      observation: ""
                      // Will be filled in by tool result
                    };
                  }
                }
                if (this._isToolMessageLike(message)) {
                  const observation = message.content;
                  let observationStr = String(observation);
                  if (observationStr.length > 100) {
                    observationStr = `${observationStr.slice(0, 97)}...`;
                  }
                  observationStr = observationStr.replace(/\n/g, " ");
                  logger.info(`\u{1F4C4} Tool result: ${observationStr}`);
                  if (this.useServerManager && this.serverManager) {
                    const currentTools = this.serverManager.tools;
                    const currentToolNames = new Set(
                      currentTools.map((t) => t.name)
                    );
                    const existingToolNames = new Set(
                      this._tools.map((t) => t.name)
                    );
                    if (currentToolNames.size !== existingToolNames.size || [...currentToolNames].some(
                      (n) => !existingToolNames.has(n)
                    )) {
                      logger.info(
                        `\u{1F504} Tools changed during execution. New tools: ${[...currentToolNames].join(", ")}`
                      );
                      this._tools = currentTools;
                      this._tools.push(...this.additionalTools);
                      await this.createSystemMessageFromTools(this._tools);
                      this._agentExecutor = this.createAgent();
                      shouldRestart = true;
                      restartCount++;
                      logger.info(
                        `\u{1F503} Restarting execution with updated tools (restart ${restartCount}/${maxRestarts})`
                      );
                      break;
                    }
                  }
                }
                if (this._isAIMessageLike(message) && !this._messageHasToolCalls(message)) {
                  finalOutput = this._normalizeOutput(
                    this._getMessageContent(message)
                  );
                  logger.info("\u2705 Agent finished with output");
                }
              }
              if (shouldRestart) {
                break;
              }
            }
          }
          if (shouldRestart) {
            break;
          }
        }
        if (!shouldRestart) {
          break;
        }
        if (restartCount > maxRestarts) {
          logger.warn(
            `\u26A0\uFE0F Max restarts (${maxRestarts}) reached. Continuing with current tools.`
          );
          break;
        }
      }
      if (this.memoryEnabled) {
        const newMessages = accumulatedMessages.slice(langchainHistory.length);
        for (const msg of newMessages) {
          this.addToHistory(msg);
        }
      }
      if (schema && finalOutput) {
        try {
          logger.info("\u{1F527} Attempting structured output...");
          const structuredResult = await this._attemptStructuredOutput(
            finalOutput,
            this.llm,
            schema
          );
          if (this.memoryEnabled) {
            this.addToHistory(
              new AIMessage(
                `Structured result: ${JSON.stringify(structuredResult)}`
              )
            );
          }
          logger.info("\u2705 Structured output successful");
          success = true;
          return structuredResult;
        } catch (e) {
          logger.error(`\u274C Structured output failed: ${e}`);
          throw new Error(
            `Failed to generate structured output: ${e instanceof Error ? e.message : String(e)}`
          );
        }
      }
      logger.info(
        `\u{1F389} Agent execution complete in ${((Date.now() - startTime) / 1e3).toFixed(2)} seconds`
      );
      success = true;
      return finalOutput || "No output generated";
    } catch (e) {
      logger.error(`\u274C Error running query: ${e}`);
      if (initializedHere && manage) {
        logger.info("\u{1F9F9} Cleaning up resources after error");
        await this.close();
      }
      throw e;
    } finally {
      const executionTimeMs = Date.now() - startTime;
      let serverCount = 0;
      if (this.client) {
        serverCount = Object.keys(this.client.getAllActiveSessions()).length;
      } else if (this.connectors) {
        serverCount = this.connectors.length;
      }
      const conversationHistoryLength = this.memoryEnabled ? this.conversationHistory.length : 0;
      const toolsAvailable = this._tools || [];
      await this.telemetry.trackAgentExecution({
        executionMethod: "stream",
        query,
        success,
        modelProvider: this.modelProvider,
        modelName: this.modelName,
        serverCount,
        serverIdentifiers: this.connectors.map(
          (connector) => connector.publicIdentifier
        ),
        totalToolsAvailable: toolsAvailable.length,
        toolsAvailableNames: toolsAvailable.map((t) => t.name),
        maxStepsConfigured: this.maxSteps,
        memoryEnabled: this.memoryEnabled,
        useServerManager: this.useServerManager,
        maxStepsUsed: steps ?? null,
        manageConnector: manage ?? true,
        externalHistoryUsed: history !== void 0,
        stepsTaken,
        toolsUsedCount: this.toolsUsedNames.length,
        toolsUsedNames: this.toolsUsedNames,
        response: finalOutput || "",
        executionTimeMs,
        errorType: success ? null : "execution_error",
        conversationHistoryLength
      });
      if (manage && !this.client && initializedHere) {
        logger.info("\u{1F9F9} Closing agent after stream completion");
        await this.close();
      }
    }
  }
  /**
   * Flush observability traces to the configured observability platform.
   * Important for serverless environments where traces need to be sent before function termination.
   */
  async flush() {
    if (this.isRemote && this.remoteAgent) {
      return;
    }
    logger.debug("Flushing observability traces...");
    await this.observabilityManager.flush();
  }
  async close() {
    if (this.isRemote && this.remoteAgent) {
      await this.remoteAgent.close();
      return;
    }
    logger.info("\u{1F50C} Closing MCPAgent resources\u2026");
    await this.observabilityManager.shutdown();
    try {
      this._agentExecutor = null;
      this._tools = [];
      if (this.client) {
        if (this.clientOwnedByAgent) {
          logger.info(
            "\u{1F504} Closing internally-created client (simplified mode) and cleaning up resources"
          );
          await this.client.close();
          this.sessions = {};
          this.client = void 0;
        } else {
          logger.info("\u{1F504} Closing client and cleaning up resources");
          await this.client.close();
          this.sessions = {};
        }
      } else {
        for (const connector of this.connectors) {
          logger.info("\u{1F504} Disconnecting connector");
          await connector.disconnect();
        }
      }
      if (this.isSimplifiedMode && this.llm) {
        logger.debug("\u{1F504} Clearing LLM reference (simplified mode)");
        this.llm = void 0;
      }
      if ("connectorToolMap" in this.adapter) {
        this.adapter = new LangChainAdapter();
      }
    } finally {
      this._initialized = false;
      logger.info("\u{1F44B} Agent closed successfully");
    }
  }
  async *prettyStreamEvents(queryOrOptions, maxSteps, manageConnector = true, externalHistory, outputSchema) {
    const { prettyStreamEvents: prettyStream } = await import("./display-A5IEINAP.js");
    const finalResponse = "";
    for await (const _ of prettyStream(
      this.streamEvents(
        queryOrOptions,
        maxSteps,
        manageConnector,
        externalHistory,
        outputSchema
      )
    )) {
      yield;
    }
    return finalResponse;
  }
  async *streamEvents(queryOrOptions, maxSteps, manageConnector = true, externalHistory, outputSchema, signal) {
    const normalized = normalizeRunOptions(
      queryOrOptions,
      maxSteps,
      manageConnector,
      externalHistory,
      outputSchema,
      signal
    );
    let { query } = normalized;
    const {
      maxSteps: steps,
      manageConnector: manage,
      externalHistory: history,
      outputSchema: schema,
      signal: abortSignal
    } = normalized;
    let initializedHere = false;
    const startTime = Date.now();
    let success = false;
    let eventCount = 0;
    let totalResponseLength = 0;
    let finalResponse = "";
    if (schema) {
      query = this._enhanceQueryWithSchema(query, schema);
    }
    try {
      if (manage && !this._initialized) {
        await this.initialize();
        initializedHere = true;
      } else if (!this._initialized && this.autoInitialize) {
        await this.initialize();
        initializedHere = true;
      }
      const agentExecutor = this._agentExecutor;
      if (!agentExecutor) {
        throw new Error("MCP agent failed to initialize");
      }
      this.maxSteps = steps ?? this.maxSteps;
      const display_query = typeof query === "string" && query.length > 50 ? `${query.slice(0, 50).replace(/\n/g, " ")}...` : typeof query === "string" ? query.replace(/\n/g, " ") : String(query);
      logger.info(`\u{1F4AC} Received query for streamEvents: '${display_query}'`);
      if (this.memoryEnabled) {
        logger.info(`\u{1F504} Adding user message to history: ${display_query}`);
        this.addToHistory(new HumanMessage({ content: query }));
      }
      const historyToUse = history ?? this.conversationHistory;
      const langchainHistory = [];
      for (const msg of historyToUse) {
        if (this._isHumanMessageLike(msg) || this._isAIMessageLike(msg) || this._isToolMessageLike(msg)) {
          langchainHistory.push(msg);
        } else {
          logger.info(
            `\u26A0\uFE0F Skipped message of type: ${msg.constructor?.name || typeof msg}`
          );
        }
      }
      const inputs = [
        ...langchainHistory,
        new HumanMessage(query)
      ];
      logger.info("callbacks", this.callbacks);
      const eventStream = agentExecutor.streamEvents(
        { messages: inputs },
        {
          streamMode: "messages",
          version: "v2",
          callbacks: this.callbacks,
          metadata: this.getMetadata(),
          tags: this.getTags(),
          // Set trace name for LangChain/Langfuse
          runName: this.metadata.trace_name || "mcp-use-agent",
          // Set recursion limit to 3x maxSteps to account for model calls + tool executions
          recursionLimit: this.maxSteps * 3,
          // Pass sessionId for Langfuse if present in metadata
          ...this.metadata.session_id && {
            sessionId: this.metadata.session_id
          },
          // Pass abort signal if provided
          ...abortSignal && { signal: abortSignal }
        }
      );
      for await (const event of eventStream) {
        if (abortSignal?.aborted) {
          break;
        }
        eventCount++;
        if (!event || typeof event !== "object") {
          continue;
        }
        if (event.event === "on_chat_model_stream" && event.data?.chunk?.content) {
          totalResponseLength += event.data.chunk.content.length;
        }
        if (event.event === "on_chat_model_stream" && event.data?.chunk) {
          const chunk = event.data.chunk;
          if (chunk.content) {
            if (!finalResponse) {
              finalResponse = "";
            }
            const normalizedContent = this._normalizeOutput(chunk.content);
            finalResponse += normalizedContent;
            logger.debug(
              `\u{1F4DD} Accumulated response length: ${finalResponse.length}`
            );
          }
        }
        yield event;
        if (event.event === "on_chain_end" && event.data?.output && !finalResponse) {
          const output = event.data.output;
          if (Array.isArray(output) && output.length > 0 && output[0]?.text) {
            finalResponse = output[0].text;
          } else if (typeof output === "string") {
            finalResponse = output;
          } else if (output && typeof output === "object" && "output" in output) {
            finalResponse = output.output;
          }
        }
      }
      if (schema && finalResponse) {
        logger.info("\u{1F527} Attempting structured output conversion...");
        try {
          let conversionCompleted = false;
          let conversionResult = null;
          let conversionError = null;
          this._attemptStructuredOutput(finalResponse, this.llm, schema).then((result) => {
            conversionCompleted = true;
            conversionResult = result;
            return result;
          }).catch((error) => {
            conversionCompleted = true;
            conversionError = error;
            throw error;
          });
          let progressCount = 0;
          while (!conversionCompleted) {
            await new Promise((resolve) => setTimeout(resolve, 2e3));
            if (!conversionCompleted) {
              progressCount++;
              yield {
                event: "on_structured_output_progress",
                data: {
                  message: `Converting to structured output... (${progressCount * 2}s)`,
                  elapsed: progressCount * 2
                }
              };
            }
          }
          if (conversionError) {
            throw conversionError;
          }
          if (conversionResult) {
            yield {
              event: "on_structured_output",
              data: { output: conversionResult }
            };
            if (this.memoryEnabled) {
              this.addToHistory(
                new AIMessage(
                  `Structured result: ${JSON.stringify(conversionResult)}`
                )
              );
            }
            logger.info("\u2705 Structured output successful");
          }
        } catch (e) {
          logger.warn(`\u26A0\uFE0F Structured output failed: ${e}`);
          yield {
            event: "on_structured_output_error",
            data: { error: e instanceof Error ? e.message : String(e) }
          };
        }
      } else if (this.memoryEnabled && finalResponse) {
        this.addToHistory(new AIMessage(finalResponse));
      }
      console.log("\n\n");
      logger.info(`\u{1F389} StreamEvents complete - ${eventCount} events emitted`);
      success = true;
    } catch (e) {
      logger.error(`\u274C Error during streamEvents: ${e}`);
      if (initializedHere && manage) {
        logger.info(
          "\u{1F9F9} Cleaning up resources after initialization error in streamEvents"
        );
        await this.close();
      }
      throw e;
    } finally {
      const executionTimeMs = Date.now() - startTime;
      let serverCount = 0;
      if (this.client) {
        serverCount = Object.keys(this.client.getAllActiveSessions()).length;
      } else if (this.connectors) {
        serverCount = this.connectors.length;
      }
      const conversationHistoryLength = this.memoryEnabled ? this.conversationHistory.length : 0;
      await this.telemetry.trackAgentExecution({
        executionMethod: "streamEvents",
        query,
        success,
        modelProvider: this.modelProvider,
        modelName: this.modelName,
        serverCount,
        serverIdentifiers: this.connectors.map(
          (connector) => connector.publicIdentifier
        ),
        totalToolsAvailable: this._tools.length,
        toolsAvailableNames: this._tools.map((t) => t.name),
        maxStepsConfigured: this.maxSteps,
        memoryEnabled: this.memoryEnabled,
        useServerManager: this.useServerManager,
        maxStepsUsed: steps ?? null,
        manageConnector: manage ?? true,
        externalHistoryUsed: history !== void 0,
        response: `[STREAMED RESPONSE - ${totalResponseLength} chars]`,
        executionTimeMs,
        errorType: success ? null : "streaming_error",
        conversationHistoryLength
      });
      if (manage && !this.client && initializedHere) {
        logger.info("\u{1F9F9} Closing agent after streamEvents completion");
        await this.close();
      }
    }
  }
  /**
   * Attempt to create structured output from raw result with validation and retry logic.
   *
   * @param rawResult - The raw text result from the agent
   * @param llm - LLM to use for structured output
   * @param outputSchema - The Zod schema to validate against
   */
  async _attemptStructuredOutput(rawResult, llm, outputSchema) {
    logger.info(
      `\u{1F504} Attempting structured output with schema: ${JSON.stringify(outputSchema, null, 2)}`
    );
    logger.info(`\u{1F504} Raw result: ${JSON.stringify(rawResult, null, 2)}`);
    let structuredLlm = null;
    let schemaDescription = "";
    logger.debug(
      `\u{1F504} Structured output requested, schema: ${JSON.stringify(toJSONSchema2(outputSchema), null, 2)}`
    );
    if (llm && "withStructuredOutput" in llm && typeof llm.withStructuredOutput === "function") {
      structuredLlm = llm.withStructuredOutput(outputSchema);
    } else if (llm) {
      structuredLlm = llm;
    } else {
      throw new Error("LLM is required for structured output");
    }
    const jsonSchema = toJSONSchema2(outputSchema);
    const { $schema, additionalProperties, ...cleanSchema } = jsonSchema;
    schemaDescription = JSON.stringify(cleanSchema, null, 2);
    logger.info(`\u{1F504} Schema description: ${schemaDescription}`);
    let textContent = "";
    if (typeof rawResult === "string") {
      textContent = rawResult;
    } else if (rawResult && typeof rawResult === "object") {
      textContent = JSON.stringify(rawResult);
    }
    logger.info("rawResult", rawResult);
    if (!textContent) {
      textContent = JSON.stringify(rawResult);
    }
    const maxRetries = 3;
    let lastError = "";
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      logger.info(`\u{1F504} Structured output attempt ${attempt}/${maxRetries}`);
      let formatPrompt = `
      Please format the following information according to the EXACT schema specified below.
      You must use the exact field names and types as shown in the schema.

      Required schema format:
      ${schemaDescription}

      Content to extract from:
      ${textContent}

      IMPORTANT:
      - Use ONLY the field names specified in the schema
      - Match the data types exactly (string, number, boolean, array, etc.)
      - Include ALL required fields
      - Return valid JSON that matches the schema structure exactly
      - For missing data: use null for nullable fields, omit optional fields entirely
      - Do NOT use empty strings ("") or zero (0) as placeholders for missing data
      `;
      if (attempt > 1) {
        formatPrompt += `

        PREVIOUS ATTEMPT FAILED with error: ${lastError}
        Please fix the issues mentioned above and ensure the output matches the schema exactly.
        `;
      }
      try {
        logger.info(
          `\u{1F504} Structured output attempt ${attempt} - using streaming approach`
        );
        const contentPreview = textContent.length > 300 ? `${textContent.slice(0, 300)}...` : textContent;
        logger.info(
          `\u{1F504} Content being formatted (${textContent.length} chars): ${contentPreview}`
        );
        logger.info(
          `\u{1F504} Full format prompt (${formatPrompt.length} chars):
${formatPrompt}`
        );
        const stream = await structuredLlm.stream(formatPrompt);
        let structuredResult = null;
        let chunkCount = 0;
        for await (const chunk of stream) {
          chunkCount++;
          logger.debug(
            `Chunk ${chunkCount}: ${JSON.stringify(chunk, null, 2)}`
          );
          if (typeof chunk === "string") {
            try {
              structuredResult = JSON.parse(chunk);
            } catch (e) {
              logger.warn(`\u{1F504} Failed to parse string chunk as JSON: ${chunk}`);
            }
          } else if (chunk && typeof chunk === "object") {
            structuredResult = chunk;
          } else {
            try {
              structuredResult = JSON.parse(String(chunk));
            } catch (e) {
              logger.warn(`\u{1F504} Failed to parse chunk as JSON: ${chunk}`);
            }
          }
          if (chunkCount % 10 === 0) {
            logger.debug(
              `\u{1F504} Structured output streaming: ${chunkCount} chunks`
            );
          }
        }
        logger.info(
          `\u{1F504} Structured result attempt ${attempt}: ${JSON.stringify(structuredResult, null, 2)}`
        );
        if (!structuredResult) {
          throw new Error("No structured result received from stream");
        }
        const validatedResult = this._validateStructuredResult(
          structuredResult,
          outputSchema
        );
        logger.info(`\u2705 Structured output successful on attempt ${attempt}`);
        return validatedResult;
      } catch (e) {
        lastError = e instanceof Error ? e.message : String(e);
        logger.warn(
          `\u26A0\uFE0F Structured output attempt ${attempt} failed: ${lastError}`
        );
        if (attempt === maxRetries) {
          logger.error(
            `\u274C All ${maxRetries} structured output attempts failed`
          );
          throw new Error(
            `Failed to generate valid structured output after ${maxRetries} attempts. Last error: ${lastError}`
          );
        }
        continue;
      }
    }
    throw new Error("Unexpected error in structured output generation");
  }
  /**
   * Validate the structured result against the schema with detailed error reporting
   */
  _validateStructuredResult(structuredResult, outputSchema) {
    try {
      const validatedResult = outputSchema.parse(structuredResult);
      const schemaType = outputSchema;
      if (schemaType._def && schemaType._def.shape) {
        for (const [fieldName, fieldSchema] of Object.entries(
          schemaType._def.shape
        )) {
          const field = fieldSchema;
          const isOptional = field.isOptional?.() ?? field._def?.typeName === "ZodOptional";
          const isNullable = field.isNullable?.() ?? field._def?.typeName === "ZodNullable";
          if (!isOptional && !isNullable) {
            const value = validatedResult[fieldName];
            if (value === null || value === void 0 || typeof value === "string" && !value.trim() || Array.isArray(value) && value.length === 0) {
              throw new Error(
                `Required field '${fieldName}' is missing or empty`
              );
            }
          }
        }
      }
      return validatedResult;
    } catch (e) {
      logger.debug(`Validation details: ${e}`);
      throw e;
    }
  }
  /**
   * Enhance the query with schema information to make the agent aware of required fields.
   */
  _enhanceQueryWithSchema(query, outputSchema) {
    try {
      const jsonSchema = toJSONSchema2(outputSchema);
      const { $schema, additionalProperties, ...cleanSchema } = jsonSchema;
      const schemaDescription = JSON.stringify(cleanSchema, null, 2);
      const enhancedQuery = `
      ${query}

      IMPORTANT: Your response must include sufficient information to populate the following structured output:

      ${schemaDescription}

      Make sure you gather ALL the required information during your task execution.
      If any required information is missing, continue working to find it.
      `;
      return enhancedQuery;
    } catch (e) {
      logger.warn(`Could not extract schema details: ${e}`);
      return query;
    }
  }
};

export {
  AcquireActiveMCPServerTool,
  AddMCPServerFromConfigTool,
  ConnectMCPServerTool,
  ListMCPServersTool,
  ReleaseMCPServerConnectionTool,
  ServerManager,
  ObservabilityManager,
  RemoteAgent,
  parseLLMString,
  createLLMFromString,
  isValidLLMString,
  getSupportedProviders,
  MCPAgent
};
