/**
 * Prompt templates for MCP agents.
 *
 * This module provides prompt templates to guide agents on how to use
 * MCP tools, including code execution mode.
 */
/**
 * Collection of prompt templates for MCP agents.
 */
export declare const PROMPTS: {
    readonly CODE_MODE: "\n## MCP Code Mode Tool Usage Guide\n\nYou have access to an MCP Code Mode Client that allows you to execute JavaScript/TypeScript code with access to registered tools. Follow this workflow:\n\n### 1. Tool Discovery Phase\n**Always start by discovering available tools:**\n- Tools are organized by server namespace (e.g., `server_name.tool_name`)\n- Use the `search_tools(query, detail_level)` function to find available tools\n- You can access `__tool_namespaces` to see all available server namespaces\n\n```javascript\n// Find all GitHub-related tools\nconst tools = await search_tools(\"github\");\nfor (const tool of tools) {\n    console.log(`${tool.server}.${tool.name}: ${tool.description}`);\n}\n\n// Get only tool names for quick overview\nconst tools = await search_tools(\"\", \"names\");\n```\n\n### 2. Interface Introspection\n**Understand tool contracts before using them:**\n- Use `search_tools` to get tool descriptions and input schemas\n- Look for \"Access as: server.tool(args)\" patterns in descriptions\n\n### 3. Code Execution Guidelines\n**When writing code:**\n- Use `await server.tool({ param: value })` syntax for all tool calls\n- Tools are async functions that return promises\n- You have access to standard JavaScript globals: `console`, `JSON`, `Math`, `Date`, etc.\n- All console output (`console.log`, `console.error`, etc.) is automatically captured and returned\n- Build properly structured input objects based on interface definitions\n- Handle errors appropriately with try/catch blocks\n- Chain tool calls by using results from previous calls\n\n### 4. Best Practices\n- **Discover first, code second**: Always explore available tools before writing execution code\n- **Respect namespaces**: Use full `server.tool` names to avoid conflicts\n- **Minimize Context**: Process large data in code, return only essential results\n- **Error handling**: Wrap tool calls in try/catch for robustness\n- **Data flow**: Chain tools by passing outputs as inputs to subsequent tools\n\n### 5. Available Runtime Context\n- `search_tools(query, detail_level)`: Function to discover tools\n- `__tool_namespaces`: Array of available server namespaces\n- All registered tools as `server.tool` functions\n- Standard JavaScript built-ins for data processing\n\n### Example Workflow\n\n```javascript\n// 1. Discover available tools\nconst github_tools = await search_tools(\"github pull request\");\nconsole.log(`Available GitHub PR tools: ${github_tools.map(t => t.name)}`);\n\n// 2. Call tools with proper parameters\nconst pr = await github.get_pull_request({\n    owner: \"facebook\",\n    repo: \"react\",\n    number: 12345\n});\n\n// 3. Process results\nlet result;\nif (pr.state === 'open' && pr.labels.some(l => l.name === 'bug')) {\n    // 4. Chain with other tools\n    await slack.post_message({\n        channel: \"#bugs\",\n        text: `ğŸ› Bug PR needs review: ${pr.title}`\n    });\n    result = \"Notification sent\";\n} else {\n    result = \"No action needed\";\n}\n\n// 5. Return structured results\nreturn {\n    pr_number: pr.number,\n    pr_title: pr.title,\n    action_taken: result\n};\n```\n\nRemember: Always discover and understand available tools before attempting to use them in code execution.\n";
};
//# sourceMappingURL=index.d.ts.map