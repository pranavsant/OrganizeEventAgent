/**
 * React hook for calling MCP tools with TanStack Query-like state management
 */
import type { CallToolResponse, UnknownObject, ToolRegistry } from "./widget-types.js";
type CallToolIdleState = {
    status: "idle";
    isIdle: true;
    isPending: false;
    isSuccess: false;
    isError: false;
    data: undefined;
    error: undefined;
};
type CallToolPendingState = {
    status: "pending";
    isIdle: false;
    isPending: true;
    isSuccess: false;
    isError: false;
    data: undefined;
    error: undefined;
};
type CallToolSuccessState<TData> = {
    status: "success";
    isIdle: false;
    isPending: false;
    isSuccess: true;
    isError: false;
    data: TData;
    error: undefined;
};
type CallToolErrorState = {
    status: "error";
    isIdle: false;
    isPending: false;
    isSuccess: false;
    isError: true;
    data: undefined;
    error: unknown;
};
export type CallToolState<TData> = CallToolIdleState | CallToolPendingState | CallToolSuccessState<TData> | CallToolErrorState;
export type SideEffects<TArgs, TResponse> = {
    onSuccess?: (data: TResponse, args: TArgs) => void;
    onError?: (error: unknown, args: TArgs) => void;
    onSettled?: (data: TResponse | undefined, error: unknown | undefined, args: TArgs) => void;
};
type RequiredKeys<T> = {
    [K in keyof T]-?: Record<string, never> extends Pick<T, K> ? never : K;
}[keyof T];
type HasRequiredKeys<T> = RequiredKeys<T> extends never ? false : true;
type IsArgsOptional<T> = [T] extends [null] ? true : HasRequiredKeys<T> extends false ? true : false;
export type CallToolFn<TArgs, TResponse> = IsArgsOptional<TArgs> extends true ? {
    (): void;
    (sideEffects: SideEffects<TArgs, TResponse>): void;
    (args: TArgs): void;
    (args: TArgs, sideEffects: SideEffects<TArgs, TResponse>): void;
} : {
    (args: TArgs): void;
    (args: TArgs, sideEffects: SideEffects<TArgs, TResponse>): void;
};
export type CallToolAsyncFn<TArgs, TResponse> = IsArgsOptional<TArgs> extends true ? {
    (): Promise<TResponse>;
    (args: TArgs): Promise<TResponse>;
} : (args: TArgs) => Promise<TResponse>;
export type UseCallToolReturn<TArgs, TResponse> = CallToolState<TResponse> & {
    callTool: CallToolFn<TArgs, TResponse>;
    callToolAsync: CallToolAsyncFn<TArgs, TResponse>;
};
/**
 * Helper to resolve input type from ToolRegistry
 */
type ResolveInput<TName extends keyof ToolRegistry> = ToolRegistry[TName] extends {
    input: infer I;
} ? I : null;
/**
 * Helper to resolve output type from ToolRegistry
 */
type ResolveOutput<TName extends keyof ToolRegistry> = ToolRegistry[TName] extends {
    output: infer O;
} ? CallToolResponse & {
    structuredContent: O;
} : CallToolResponse;
/**
 * Hook for calling MCP tools with TanStack Query-like state management.
 *
 * Provides a discriminated union state machine (idle/pending/success/error)
 * plus two methods for calling tools:
 * - `callTool` - fire-and-forget with optional side effect callbacks
 * - `callToolAsync` - returns a Promise for the result
 *
 * Types are automatically inferred from the tool name when using `mcp-use dev`.
 * The dev server generates type definitions in `.mcp-use/tool-registry.d.ts`.
 *
 * @param name - The name of the tool to call (auto-typed from ToolRegistry)
 * @returns State and methods for calling the tool
 *
 * @example
 * ```tsx
 * // Auto-typed from ToolRegistry (when using mcp-use dev)
 * const { callTool, data, isPending } = useCallTool("search-flights");
 * // callTool, data are fully typed based on your server's tool definition
 *
 * // Fire-and-forget with callbacks
 * callTool({ destination: "NYC" }, {
 *   onSuccess: (data) => console.log(data.structuredContent.flights),
 *   onError: (error) => console.error(error)
 * });
 *
 * // Or async/await
 * const result = await callToolAsync({ destination: "NYC" });
 *
 * // Explicit generics as escape hatch
 * const { callTool } = useCallTool<{ query: string }, { results: string[] }>("custom-tool");
 * ```
 */
export declare function useCallTool<TName extends keyof ToolRegistry>(name: TName): UseCallToolReturn<ResolveInput<TName>, ResolveOutput<TName>>;
export declare function useCallTool<TArgs extends UnknownObject | null = null, TResponse extends Partial<CallToolResponse> = CallToolResponse>(name: string): UseCallToolReturn<TArgs, TResponse>;
export {};
//# sourceMappingURL=useCallTool.d.ts.map