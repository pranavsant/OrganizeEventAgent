"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/logging.ts
function resolveLevel(env) {
  const envValue = typeof process !== "undefined" && process.env ? env : void 0;
  switch (envValue?.trim()) {
    case "2":
      return "debug";
    case "1":
      return "info";
    default:
      return "info";
  }
}
function formatArgs(args) {
  if (args.length === 0) return "";
  return args.map((arg) => {
    if (typeof arg === "string") return arg;
    try {
      return JSON.stringify(arg);
    } catch {
      return String(arg);
    }
  }).join(" ");
}
var DEFAULT_LOGGER_NAME, SimpleConsoleLogger, Logger, logger;
var init_logging = __esm({
  "src/logging.ts"() {
    "use strict";
    DEFAULT_LOGGER_NAME = "mcp-use";
    __name(resolveLevel, "resolveLevel");
    __name(formatArgs, "formatArgs");
    SimpleConsoleLogger = class {
      static {
        __name(this, "SimpleConsoleLogger");
      }
      _level;
      name;
      format;
      constructor(name = DEFAULT_LOGGER_NAME, level = "info", format = "minimal") {
        this.name = name;
        this._level = level;
        this.format = format;
      }
      shouldLog(level) {
        if (this._level === "silent") return false;
        const levels = [
          "silent",
          "error",
          "warn",
          "info",
          "http",
          "verbose",
          "debug",
          "silly"
        ];
        const currentIndex = levels.indexOf(this._level);
        const messageIndex = levels.indexOf(level);
        return messageIndex <= currentIndex;
      }
      formatMessage(level, message, args) {
        const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", { hour12: false });
        const extraArgs = formatArgs(args);
        const fullMessage = extraArgs ? `${message} ${extraArgs}` : message;
        switch (this.format) {
          case "detailed":
            return `${timestamp} [${this.name}] ${level.toUpperCase()}: ${fullMessage}`;
          case "emoji": {
            const emojiMap = {
              silent: "",
              error: "\u274C",
              warn: "\u26A0\uFE0F",
              info: "\u2139\uFE0F",
              http: "\u{1F310}",
              verbose: "\u{1F4DD}",
              debug: "\u{1F50D}",
              silly: "\u{1F92A}"
            };
            return `${timestamp} [${this.name}] ${emojiMap[level] || ""} ${level.toUpperCase()}: ${fullMessage}`;
          }
          case "minimal":
          default:
            return `${timestamp} [${this.name}] ${level}: ${fullMessage}`;
        }
      }
      error(message, ...args) {
        if (this.shouldLog("error")) {
          console.error(this.formatMessage("error", message, args));
        }
      }
      warn(message, ...args) {
        if (this.shouldLog("warn")) {
          console.warn(this.formatMessage("warn", message, args));
        }
      }
      info(message, ...args) {
        if (this.shouldLog("info")) {
          console.info(this.formatMessage("info", message, args));
        }
      }
      debug(message, ...args) {
        if (this.shouldLog("debug")) {
          console.debug(this.formatMessage("debug", message, args));
        }
      }
      http(message, ...args) {
        if (this.shouldLog("http")) {
          console.log(this.formatMessage("http", message, args));
        }
      }
      verbose(message, ...args) {
        if (this.shouldLog("verbose")) {
          console.log(this.formatMessage("verbose", message, args));
        }
      }
      silly(message, ...args) {
        if (this.shouldLog("silly")) {
          console.log(this.formatMessage("silly", message, args));
        }
      }
      get level() {
        return this._level;
      }
      set level(newLevel) {
        this._level = newLevel;
      }
      setFormat(format) {
        this.format = format;
      }
    };
    Logger = class {
      static {
        __name(this, "Logger");
      }
      static instances = {};
      static currentFormat = "minimal";
      static get(name = DEFAULT_LOGGER_NAME) {
        if (!this.instances[name]) {
          const debugEnv = typeof process !== "undefined" && process.env?.DEBUG || void 0;
          this.instances[name] = new SimpleConsoleLogger(
            name,
            resolveLevel(debugEnv),
            this.currentFormat
          );
        }
        return this.instances[name];
      }
      static configure(options = {}) {
        const { level, format = "minimal" } = options;
        const debugEnv = typeof process !== "undefined" && process.env?.DEBUG || void 0;
        const resolvedLevel = level ?? resolveLevel(debugEnv);
        this.currentFormat = format;
        Object.values(this.instances).forEach((logger4) => {
          logger4.level = resolvedLevel;
          logger4.setFormat(format);
        });
      }
      static setDebug(enabled) {
        let level;
        if (enabled === 2 || enabled === true) level = "debug";
        else if (enabled === 1) level = "info";
        else level = "info";
        Object.values(this.instances).forEach((logger4) => {
          logger4.level = level;
        });
        if (typeof process !== "undefined" && process.env) {
          process.env.DEBUG = enabled ? enabled === true ? "2" : String(enabled) : "0";
        }
      }
      static setFormat(format) {
        this.currentFormat = format;
        this.configure({ format });
      }
    };
    logger = Logger.get();
  }
});

// src/react/rpc-logger.ts
var rpc_logger_exports = {};
__export(rpc_logger_exports, {
  clearRpcLogs: () => clearRpcLogs,
  getAllRpcLogs: () => getAllRpcLogs,
  getRpcLogs: () => getRpcLogs,
  subscribeToRpcLogs: () => subscribeToRpcLogs,
  wrapTransportForLogging: () => wrapTransportForLogging
});
function getRpcLogs(serverId) {
  return rpcLogStore.getLogsForServer(serverId);
}
function getAllRpcLogs() {
  return rpcLogStore.getAllLogs();
}
function subscribeToRpcLogs(listener) {
  return rpcLogStore.subscribe(listener);
}
function clearRpcLogs(serverId) {
  rpcLogStore.clear(serverId);
}
function wrapTransportForLogging(transport, serverId) {
  class LoggingTransport {
    constructor(inner) {
      this.inner = inner;
      this.inner.onmessage = (message, extra) => {
        rpcLogStore.publish({
          serverId,
          direction: "receive",
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          message
        });
        this.onmessage?.(message, extra);
      };
      this.inner.onclose = () => {
        this.onclose?.();
      };
      this.inner.onerror = (error) => {
        this.onerror?.(error);
      };
    }
    static {
      __name(this, "LoggingTransport");
    }
    onclose;
    onerror;
    onmessage;
    async start() {
      if (typeof this.inner.start === "function") {
        await this.inner.start();
      }
    }
    async send(message, options) {
      rpcLogStore.publish({
        serverId,
        direction: "send",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        message
      });
      await this.inner.send(message, options);
    }
    async close() {
      await this.inner.close();
    }
    get sessionId() {
      return this.inner.sessionId;
    }
    setProtocolVersion(version) {
      if (typeof this.inner.setProtocolVersion === "function") {
        this.inner.setProtocolVersion(version);
      }
    }
  }
  return new LoggingTransport(transport);
}
var logger3, RpcLogStore, rpcLogStore;
var init_rpc_logger = __esm({
  "src/react/rpc-logger.ts"() {
    "use strict";
    init_logging();
    logger3 = Logger.get("RpcLogger");
    RpcLogStore = class {
      static {
        __name(this, "RpcLogStore");
      }
      logs = [];
      listeners = /* @__PURE__ */ new Set();
      maxLogs = 1e3;
      publish(entry) {
        logger3.debug(
          "[RPC Logger] Publishing log:",
          entry.direction,
          entry.serverId,
          entry.message?.method
        );
        this.logs.push(entry);
        if (this.logs.length > this.maxLogs) {
          this.logs = this.logs.slice(-this.maxLogs);
        }
        logger3.debug(
          "[RPC Logger] Total logs:",
          this.logs.length,
          "Listeners:",
          this.listeners.size
        );
        this.listeners.forEach((listener) => {
          try {
            listener(entry);
          } catch (err) {
            logger3.error("[RPC Logger] Listener error:", err);
          }
        });
      }
      subscribe(listener) {
        this.listeners.add(listener);
        return () => this.listeners.delete(listener);
      }
      getLogsForServer(serverId) {
        return this.logs.filter((log) => log.serverId === serverId);
      }
      getAllLogs() {
        return [...this.logs];
      }
      clear(serverId) {
        if (serverId) {
          this.logs = this.logs.filter((log) => log.serverId !== serverId);
        } else {
          this.logs = [];
        }
      }
    };
    rpcLogStore = new RpcLogStore();
    __name(getRpcLogs, "getRpcLogs");
    __name(getAllRpcLogs, "getAllRpcLogs");
    __name(subscribeToRpcLogs, "subscribeToRpcLogs");
    __name(clearRpcLogs, "clearRpcLogs");
    __name(wrapTransportForLogging, "wrapTransportForLogging");
  }
});

// src/react/index.ts
var react_exports = {};
__export(react_exports, {
  BrowserTelemetry: () => Tel,
  ErrorBoundary: () => ErrorBoundary,
  Image: () => Image,
  LocalStorageProvider: () => LocalStorageProvider,
  McpClientProvider: () => McpClientProvider,
  McpUseProvider: () => McpUseProvider,
  MemoryStorageProvider: () => MemoryStorageProvider,
  Tel: () => Tel,
  Telemetry: () => Telemetry,
  ThemeProvider: () => ThemeProvider,
  WidgetControls: () => WidgetControls,
  clearRpcLogs: () => clearRpcLogs,
  generateHelpers: () => generateHelpers,
  getAllRpcLogs: () => getAllRpcLogs,
  getRpcLogs: () => getRpcLogs,
  onMcpAuthorization: () => onMcpAuthorization,
  setBrowserTelemetrySource: () => setTelemetrySource,
  setTelemetrySource: () => setTelemetrySource,
  subscribeToRpcLogs: () => subscribeToRpcLogs,
  useCallTool: () => useCallTool,
  useMcp: () => useMcp,
  useMcpClient: () => useMcpClient,
  useMcpServer: () => useMcpServer,
  useWidget: () => useWidget,
  useWidgetProps: () => useWidgetProps,
  useWidgetState: () => useWidgetState,
  useWidgetTheme: () => useWidgetTheme
});
module.exports = __toCommonJS(react_exports);

// src/react/useMcp.ts
var import_auth3 = require("@modelcontextprotocol/sdk/client/auth.js");

// src/auth/probe-www-auth.ts
var import_auth = require("@modelcontextprotocol/sdk/client/auth.js");
async function probeAuthParams(serverUrl, fetchFn = fetch) {
  const base = serverUrl.replace(/\/$/, "");
  const url = base.endsWith("/mcp") ? base : `${base}/mcp`;
  const response = await fetchFn(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      jsonrpc: "2.0",
      method: "initialize",
      id: 1,
      params: {}
    })
  });
  if (response.status !== 401) {
    return {};
  }
  const { resourceMetadataUrl, scope } = (0, import_auth.extractWWWAuthenticateParams)(response);
  return { resourceMetadataUrl, scope };
}
__name(probeAuthParams, "probeAuthParams");

// src/react/useMcp.ts
var import_react = require("react");

// src/connectors/http.ts
var import_client = require("@modelcontextprotocol/sdk/client/index.js");
var import_streamableHttp = require("@modelcontextprotocol/sdk/client/streamableHttp.js");
init_logging();

// src/task_managers/sse.ts
var import_sse = require("@modelcontextprotocol/sdk/client/sse.js");
init_logging();

// src/task_managers/base.ts
init_logging();
var ConnectionManager = class {
  static {
    __name(this, "ConnectionManager");
  }
  _readyPromise;
  _readyResolver;
  _donePromise;
  _doneResolver;
  _exception = null;
  _connection = null;
  _task = null;
  _abortController = null;
  constructor() {
    this.reset();
  }
  /**
   * Start the connection manager and establish a connection.
   *
   * @returns The established connection.
   * @throws If the connection cannot be established.
   */
  async start() {
    this.reset();
    logger.debug(`Starting ${this.constructor.name}`);
    this._task = this.connectionTask();
    await this._readyPromise;
    if (this._exception) {
      throw this._exception;
    }
    if (this._connection === null) {
      throw new Error("Connection was not established");
    }
    return this._connection;
  }
  /**
   * Stop the connection manager and close the connection.
   */
  async stop() {
    if (this._task && this._abortController) {
      logger.debug(`Cancelling ${this.constructor.name} task`);
      this._abortController.abort();
      try {
        await this._task;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError") {
          logger.debug(`${this.constructor.name} task aborted successfully`);
        } else {
          logger.warn(`Error stopping ${this.constructor.name} task: ${e}`);
        }
      }
    }
    await this._donePromise;
    logger.debug(`${this.constructor.name} task completed`);
  }
  /**
   * Reset all internal state.
   */
  reset() {
    this._readyPromise = new Promise((res) => this._readyResolver = res);
    this._donePromise = new Promise((res) => this._doneResolver = res);
    this._exception = null;
    this._connection = null;
    this._task = null;
    this._abortController = new AbortController();
  }
  /**
   * The background task responsible for establishing and maintaining the
   * connection until it is cancelled.
   */
  async connectionTask() {
    logger.debug(`Running ${this.constructor.name} task`);
    try {
      this._connection = await this.establishConnection();
      logger.debug(`${this.constructor.name} connected successfully`);
      this._readyResolver();
      await this.waitForAbort();
    } catch (err) {
      this._exception = err;
      logger.error(`Error in ${this.constructor.name} task: ${err}`);
      this._readyResolver();
    } finally {
      if (this._connection !== null) {
        try {
          await this.closeConnection(this._connection);
        } catch (closeErr) {
          logger.warn(
            `Error closing connection in ${this.constructor.name}: ${closeErr}`
          );
        }
        this._connection = null;
      }
      this._doneResolver();
    }
  }
  /**
   * Helper that returns a promise which resolves when the abort signal fires.
   */
  async waitForAbort() {
    return new Promise((_resolve, _reject) => {
      if (!this._abortController) {
        return;
      }
      const signal = this._abortController.signal;
      if (signal.aborted) {
        _resolve();
        return;
      }
      const onAbort = /* @__PURE__ */ __name(() => {
        signal.removeEventListener("abort", onAbort);
        _resolve();
      }, "onAbort");
      signal.addEventListener("abort", onAbort);
    });
  }
};

// src/task_managers/sse.ts
var SseConnectionManager = class extends ConnectionManager {
  static {
    __name(this, "SseConnectionManager");
  }
  url;
  opts;
  _transport = null;
  reinitializing = false;
  /**
   * Create an SSE connection manager.
   *
   * @param url  The SSE endpoint URL.
   * @param opts Optional transport options (auth, headers, etc.).
   */
  constructor(url, opts) {
    super();
    this.url = typeof url === "string" ? new URL(url) : url;
    this.opts = opts;
  }
  /**
   * Spawn a new `SSEClientTransport` and wrap it with 404 handling.
   * Per MCP spec, clients MUST re-initialize when receiving 404 for stale sessions.
   */
  async establishConnection() {
    const transport = new import_sse.SSEClientTransport(this.url, this.opts);
    const originalSend = transport.send.bind(transport);
    transport.send = async (message) => {
      const sendMessage = /* @__PURE__ */ __name(async (msg) => {
        if (Array.isArray(msg)) {
          for (const singleMsg of msg) {
            await originalSend(singleMsg);
          }
        } else {
          await originalSend(msg);
        }
      }, "sendMessage");
      try {
        await sendMessage(message);
      } catch (error) {
        if (error?.code === 404 && transport.sessionId && !this.reinitializing) {
          logger.warn(
            `[SSE] Session not found (404), re-initializing per MCP spec...`
          );
          this.reinitializing = true;
          try {
            transport.sessionId = void 0;
            await this.reinitialize(transport);
            logger.info(`[SSE] Re-initialization successful, retrying request`);
            await sendMessage(message);
          } finally {
            this.reinitializing = false;
          }
        } else {
          throw error;
        }
      }
    };
    this._transport = transport;
    logger.debug(`${this.constructor.name} connected successfully`);
    return transport;
  }
  /**
   * Re-initialize the transport with a new session
   * This is called when the server returns 404 for a stale session
   */
  async reinitialize(transport) {
    logger.debug(`[SSE] Re-initialization triggered`);
  }
  /**
   * Close the underlying transport and clean up resources.
   */
  async closeConnection(_connection) {
    if (this._transport) {
      try {
        await this._transport.close();
      } catch (e) {
        logger.warn(`Error closing SSE transport: ${e}`);
      } finally {
        this._transport = null;
      }
    }
  }
};

// src/connectors/base.ts
var import_types = require("@modelcontextprotocol/sdk/types.js");
init_logging();

// src/telemetry/events.ts
var import_ext_apps = require("@modelcontextprotocol/ext-apps");
var BaseTelemetryEvent = class {
  static {
    __name(this, "BaseTelemetryEvent");
  }
};
var MCPAgentExecutionEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "MCPAgentExecutionEvent");
  }
  get name() {
    return "mcp_agent_execution";
  }
  get properties() {
    return {
      // Core execution info
      execution_method: this.data.executionMethod,
      query: this.data.query,
      query_length: this.data.query.length,
      success: this.data.success,
      // Agent configuration
      model_provider: this.data.modelProvider,
      model_name: this.data.modelName,
      server_count: this.data.serverCount,
      server_identifiers: this.data.serverIdentifiers,
      total_tools_available: this.data.totalToolsAvailable,
      tools_available_names: this.data.toolsAvailableNames,
      max_steps_configured: this.data.maxStepsConfigured,
      memory_enabled: this.data.memoryEnabled,
      use_server_manager: this.data.useServerManager,
      // Execution parameters (always include, even if null)
      max_steps_used: this.data.maxStepsUsed,
      manage_connector: this.data.manageConnector,
      external_history_used: this.data.externalHistoryUsed,
      // Execution results (always include, even if null)
      steps_taken: this.data.stepsTaken ?? null,
      tools_used_count: this.data.toolsUsedCount ?? null,
      tools_used_names: this.data.toolsUsedNames ?? null,
      response: this.data.response ?? null,
      response_length: this.data.response ? this.data.response.length : null,
      execution_time_ms: this.data.executionTimeMs ?? null,
      error_type: this.data.errorType ?? null,
      conversation_history_length: this.data.conversationHistoryLength ?? null
    };
  }
};
function createServerRunEventData(server, transport) {
  const toolRegistrations = Array.from(server.registrations.tools.values());
  const promptRegistrations = Array.from(server.registrations.prompts.values());
  const resourceRegistrations = Array.from(
    server.registrations.resources.values()
  );
  const templateRegistrations = Array.from(
    server.registrations.resourceTemplates.values()
  );
  const allResources = resourceRegistrations.map((r) => ({
    name: r.config.name,
    title: r.config.title ?? null,
    description: r.config.description ?? null,
    uri: r.config.uri ?? null,
    mime_type: r.config.mimeType ?? null
  }));
  const appsSdkResources = allResources.filter(
    (r) => r.mime_type === "text/html+skybridge"
  );
  const mcpUiResources = allResources.filter(
    (r) => r.mime_type === "text/uri-list" || r.mime_type === "text/html"
  );
  const mcpAppsResources = allResources.filter(
    (r) => r.mime_type === import_ext_apps.RESOURCE_MIME_TYPE
  );
  return {
    transport,
    toolsNumber: server.registeredTools.length,
    resourcesNumber: server.registeredResources.length,
    promptsNumber: server.registeredPrompts.length,
    auth: !!server.oauthProvider,
    name: server.config.name,
    description: server.config.description ?? null,
    baseUrl: server.serverBaseUrl ?? null,
    toolNames: server.registeredTools.length > 0 ? server.registeredTools : null,
    resourceNames: server.registeredResources.length > 0 ? server.registeredResources : null,
    promptNames: server.registeredPrompts.length > 0 ? server.registeredPrompts : null,
    tools: toolRegistrations.length > 0 ? toolRegistrations.map((r) => ({
      name: r.config.name,
      title: r.config.title ?? null,
      description: r.config.description ?? null,
      input_schema: r.config.schema ? JSON.stringify(r.config.schema) : null,
      output_schema: r.config.outputSchema ? JSON.stringify(r.config.outputSchema) : null
    })) : null,
    resources: allResources.length > 0 ? allResources : null,
    prompts: promptRegistrations.length > 0 ? promptRegistrations.map((r) => ({
      name: r.config.name,
      title: r.config.title ?? null,
      description: r.config.description ?? null,
      args: r.config.args ? JSON.stringify(r.config.args) : null
    })) : null,
    templates: templateRegistrations.length > 0 ? templateRegistrations.map((r) => ({
      name: r.config.name,
      title: r.config.title ?? null,
      description: r.config.description ?? null
    })) : null,
    capabilities: {
      logging: true,
      resources: { subscribe: true, listChanged: true }
    },
    appsSdkResources: appsSdkResources.length > 0 ? appsSdkResources : null,
    appsSdkResourcesNumber: appsSdkResources.length,
    mcpUiResources: mcpUiResources.length > 0 ? mcpUiResources : null,
    mcpUiResourcesNumber: mcpUiResources.length,
    mcpAppsResources: mcpAppsResources.length > 0 ? mcpAppsResources : null,
    mcpAppsResourcesNumber: mcpAppsResources.length
  };
}
__name(createServerRunEventData, "createServerRunEventData");
var ServerRunEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ServerRunEvent");
  }
  get name() {
    return "server_run";
  }
  get properties() {
    return {
      transport: this.data.transport,
      tools_number: this.data.toolsNumber,
      resources_number: this.data.resourcesNumber,
      prompts_number: this.data.promptsNumber,
      auth: this.data.auth,
      name: this.data.name,
      description: this.data.description ?? null,
      base_url: this.data.baseUrl ?? null,
      tool_names: this.data.toolNames ?? null,
      resource_names: this.data.resourceNames ?? null,
      prompt_names: this.data.promptNames ?? null,
      tools: this.data.tools ?? null,
      resources: this.data.resources ?? null,
      prompts: this.data.prompts ?? null,
      templates: this.data.templates ?? null,
      capabilities: this.data.capabilities ? JSON.stringify(this.data.capabilities) : null,
      apps_sdk_resources: this.data.appsSdkResources ? JSON.stringify(this.data.appsSdkResources) : null,
      apps_sdk_resources_number: this.data.appsSdkResourcesNumber ?? 0,
      mcp_ui_resources: this.data.mcpUiResources ? JSON.stringify(this.data.mcpUiResources) : null,
      mcp_ui_resources_number: this.data.mcpUiResourcesNumber ?? 0,
      mcp_apps_resources: this.data.mcpAppsResources ? JSON.stringify(this.data.mcpAppsResources) : null,
      mcp_apps_resources_number: this.data.mcpAppsResourcesNumber ?? 0
    };
  }
};
var ServerInitializeEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ServerInitializeEvent");
  }
  get name() {
    return "server_initialize_call";
  }
  get properties() {
    return {
      protocol_version: this.data.protocolVersion,
      client_info: JSON.stringify(this.data.clientInfo),
      client_capabilities: JSON.stringify(this.data.clientCapabilities),
      session_id: this.data.sessionId ?? null
    };
  }
};
var ServerToolCallEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ServerToolCallEvent");
  }
  get name() {
    return "server_tool_call";
  }
  get properties() {
    return {
      tool_name: this.data.toolName,
      length_input_argument: this.data.lengthInputArgument,
      success: this.data.success,
      error_type: this.data.errorType ?? null,
      execution_time_ms: this.data.executionTimeMs ?? null
    };
  }
};
var ServerResourceCallEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ServerResourceCallEvent");
  }
  get name() {
    return "server_resource_call";
  }
  get properties() {
    return {
      name: this.data.name,
      description: this.data.description,
      contents: this.data.contents,
      success: this.data.success,
      error_type: this.data.errorType ?? null
    };
  }
};
var ServerPromptCallEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ServerPromptCallEvent");
  }
  get name() {
    return "server_prompt_call";
  }
  get properties() {
    return {
      name: this.data.name,
      description: this.data.description,
      success: this.data.success,
      error_type: this.data.errorType ?? null
    };
  }
};
var ServerContextEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ServerContextEvent");
  }
  get name() {
    return `server_context_${this.data.contextType}`;
  }
  get properties() {
    return {
      context_type: this.data.contextType,
      notification_type: this.data.notificationType ?? null
    };
  }
};
var MCPClientInitEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "MCPClientInitEvent");
  }
  get name() {
    return "mcpclient_init";
  }
  get properties() {
    return {
      code_mode: this.data.codeMode,
      sandbox: this.data.sandbox,
      all_callbacks: this.data.allCallbacks,
      verify: this.data.verify,
      servers: this.data.servers,
      num_servers: this.data.numServers,
      is_browser: this.data.isBrowser
    };
  }
};
var ConnectorInitEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ConnectorInitEvent");
  }
  get name() {
    return "connector_init";
  }
  get properties() {
    return {
      connector_type: this.data.connectorType,
      server_command: this.data.serverCommand ?? null,
      server_args: this.data.serverArgs ?? null,
      server_url: this.data.serverUrl ?? null,
      public_identifier: this.data.publicIdentifier ?? null
    };
  }
};
var ClientAddServerEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ClientAddServerEvent");
  }
  get name() {
    return "client_add_server";
  }
  get properties() {
    const { serverName, serverConfig } = this.data;
    const url = serverConfig.url;
    return {
      server_name: serverName,
      server_url_domain: url ? this._extractHostname(url) : null,
      transport: serverConfig.transport ?? null,
      has_auth: !!(serverConfig.authToken || serverConfig.authProvider)
    };
  }
  _extractHostname(url) {
    try {
      return new URL(url).hostname;
    } catch {
      return null;
    }
  }
};
var ClientRemoveServerEvent = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  static {
    __name(this, "ClientRemoveServerEvent");
  }
  get name() {
    return "client_remove_server";
  }
  get properties() {
    return {
      server_name: this.data.serverName
    };
  }
};

// src/version.ts
var VERSION = "1.20.5";
function getPackageVersion() {
  return VERSION;
}
__name(getPackageVersion, "getPackageVersion");

// src/telemetry/telemetry-browser.ts
init_logging();
function generateUUID() {
  if (typeof globalThis !== "undefined" && globalThis.crypto && typeof globalThis.crypto.randomUUID === "function") {
    return globalThis.crypto.randomUUID();
  }
  if (typeof globalThis !== "undefined" && globalThis.crypto && typeof globalThis.crypto.getRandomValues === "function") {
    const array = new Uint8Array(16);
    globalThis.crypto.getRandomValues(array);
    const hex = Array.from(array, (v) => v.toString(16).padStart(2, "0")).join(
      ""
    );
    return `${hex.substring(0, 8)}-${hex.substring(8, 12)}-${hex.substring(12, 16)}-${hex.substring(16, 20)}-${hex.substring(20)}`;
  }
  return `${Date.now()}-${Math.random().toString(36).substring(2, 15)}-${Math.random().toString(36).substring(2, 15)}`;
}
__name(generateUUID, "generateUUID");
function secureRandomString() {
  if (typeof window !== "undefined" && window.crypto && typeof window.crypto.getRandomValues === "function") {
    const array = new Uint8Array(8);
    window.crypto.getRandomValues(array);
    return Array.from(array, (v) => v.toString(16).padStart(2, "0")).join("");
  }
  if (typeof globalThis !== "undefined" && globalThis.crypto && typeof globalThis.crypto.getRandomValues === "function") {
    const array = new Uint8Array(8);
    globalThis.crypto.getRandomValues(array);
    return Array.from(array, (v) => v.toString(16).padStart(2, "0")).join("");
  }
  return Math.random().toString(36).substring(2, 15);
}
__name(secureRandomString, "secureRandomString");
var USER_ID_STORAGE_KEY = "mcp_use_user_id";
function isLocalStorageFunctional() {
  return typeof localStorage !== "undefined" && typeof localStorage.getItem === "function" && typeof localStorage.setItem === "function" && typeof localStorage.removeItem === "function";
}
__name(isLocalStorageFunctional, "isLocalStorageFunctional");
function detectRuntimeEnvironment() {
  try {
    if (typeof window !== "undefined" && typeof document !== "undefined") {
      return "browser";
    }
    return "unknown";
  } catch {
    return "unknown";
  }
}
__name(detectRuntimeEnvironment, "detectRuntimeEnvironment");
function getStorageCapability(env) {
  if (env === "browser") {
    try {
      if (isLocalStorageFunctional()) {
        localStorage.setItem("__mcp_use_test__", "1");
        localStorage.removeItem("__mcp_use_test__");
        return "localStorage";
      }
    } catch {
    }
  }
  return "session-only";
}
__name(getStorageCapability, "getStorageCapability");
var cachedEnvironment = null;
function getRuntimeEnvironment() {
  if (cachedEnvironment === null) {
    cachedEnvironment = detectRuntimeEnvironment();
  }
  return cachedEnvironment;
}
__name(getRuntimeEnvironment, "getRuntimeEnvironment");
var Telemetry = class _Telemetry {
  static {
    __name(this, "Telemetry");
  }
  static instance = null;
  PROJECT_API_KEY = "phc_lyTtbYwvkdSbrcMQNPiKiiRWrrM1seyKIMjycSvItEI";
  HOST = "https://eu.i.posthog.com";
  UNKNOWN_USER_ID = "UNKNOWN_USER_ID";
  _currUserId = null;
  _posthogBrowserClient = null;
  _posthogLoading = null;
  _runtimeEnvironment;
  _storageCapability;
  _source;
  constructor() {
    this._runtimeEnvironment = getRuntimeEnvironment();
    this._storageCapability = getStorageCapability(this._runtimeEnvironment);
    this._source = this._getSourceFromLocalStorage() || this._runtimeEnvironment;
    const telemetryDisabled = this._checkTelemetryDisabled();
    const canSupportTelemetry = this._runtimeEnvironment !== "unknown";
    if (telemetryDisabled) {
      this._posthogBrowserClient = null;
      logger.debug("Telemetry disabled via localStorage");
    } else if (!canSupportTelemetry) {
      this._posthogBrowserClient = null;
      logger.debug(
        `Telemetry disabled - unknown environment: ${this._runtimeEnvironment}`
      );
    } else {
      logger.info(
        "Anonymized telemetry enabled. Set MCP_USE_ANONYMIZED_TELEMETRY=false in localStorage to disable."
      );
      this._posthogLoading = this._initPostHogBrowser();
    }
  }
  _getSourceFromLocalStorage() {
    try {
      if (isLocalStorageFunctional()) {
        return localStorage.getItem("MCP_USE_TELEMETRY_SOURCE");
      }
    } catch {
    }
    return null;
  }
  _checkTelemetryDisabled() {
    if (isLocalStorageFunctional() && localStorage.getItem("MCP_USE_ANONYMIZED_TELEMETRY") === "false") {
      return true;
    }
    return false;
  }
  async _initPostHogBrowser() {
    try {
      const posthogModule = await import("posthog-js");
      const posthogModuleTyped = posthogModule;
      const posthog = posthogModuleTyped.default || posthogModuleTyped.posthog;
      if (!posthog || typeof posthog.init !== "function") {
        throw new Error("posthog-js module did not export expected interface");
      }
      posthog.init(this.PROJECT_API_KEY, {
        api_host: this.HOST,
        persistence: "localStorage",
        autocapture: false,
        // We only want explicit captures
        capture_pageview: false,
        // We don't want automatic pageview tracking
        disable_session_recording: true,
        // No session recording
        loaded: /* @__PURE__ */ __name(() => {
          logger.debug("PostHog browser client initialized");
        }, "loaded")
      });
      this._posthogBrowserClient = posthog;
    } catch (e) {
      logger.warn(`Failed to initialize PostHog browser telemetry: ${e}`);
      this._posthogBrowserClient = null;
    }
  }
  /**
   * Get the detected runtime environment
   */
  get runtimeEnvironment() {
    return this._runtimeEnvironment;
  }
  /**
   * Get the storage capability for this environment
   */
  get storageCapability() {
    return this._storageCapability;
  }
  static getInstance() {
    if (!_Telemetry.instance) {
      _Telemetry.instance = new _Telemetry();
    }
    return _Telemetry.instance;
  }
  /**
   * Set the source identifier for telemetry events.
   * This allows tracking usage from different applications.
   * @param source - The source identifier (e.g., "my-app", "cli", "vs-code-extension")
   */
  setSource(source) {
    this._source = source;
    try {
      if (isLocalStorageFunctional()) {
        localStorage.setItem("MCP_USE_TELEMETRY_SOURCE", source);
      }
    } catch {
    }
    logger.debug(`Telemetry source set to: ${source}`);
  }
  /**
   * Get the current source identifier.
   */
  getSource() {
    return this._source;
  }
  /**
   * Check if telemetry is enabled.
   */
  get isEnabled() {
    return this._posthogBrowserClient !== null;
  }
  get userId() {
    if (this._currUserId) {
      return this._currUserId;
    }
    try {
      switch (this._storageCapability) {
        case "localStorage":
          this._currUserId = this._getUserIdFromLocalStorage();
          break;
        case "session-only":
        default:
          try {
            this._currUserId = `session-${generateUUID()}`;
          } catch (uuidError) {
            this._currUserId = `session-${Date.now()}-${secureRandomString()}`;
          }
          break;
      }
    } catch (e) {
      this._currUserId = this.UNKNOWN_USER_ID;
    }
    return this._currUserId;
  }
  /**
   * Get or create user ID from localStorage (Browser)
   */
  _getUserIdFromLocalStorage() {
    try {
      if (!isLocalStorageFunctional()) {
        throw new Error("localStorage is not available or not functional");
      }
      localStorage.setItem("__mcp_use_test__", "1");
      localStorage.removeItem("__mcp_use_test__");
      let userId = localStorage.getItem(USER_ID_STORAGE_KEY);
      if (!userId) {
        try {
          userId = generateUUID();
        } catch (uuidError) {
          userId = `${Date.now()}-${secureRandomString()}`;
        }
        localStorage.setItem(USER_ID_STORAGE_KEY, userId);
      }
      return userId;
    } catch (e) {
      logger.debug(`Failed to access localStorage for user ID: ${e}`);
      let sessionId;
      try {
        sessionId = `session-${generateUUID()}`;
      } catch (uuidError) {
        sessionId = `session-${Date.now()}-${secureRandomString()}`;
      }
      return sessionId;
    }
  }
  async capture(event) {
    if (this._posthogLoading) {
      await this._posthogLoading;
    }
    if (!this._posthogBrowserClient) {
      return;
    }
    const currentUserId = this.userId;
    const properties = { ...event.properties };
    properties.mcp_use_version = getPackageVersion();
    properties.language = "typescript";
    properties.source = this._source;
    properties.runtime = this._runtimeEnvironment;
    if (this._posthogBrowserClient) {
      try {
        this._posthogBrowserClient.capture(event.name, {
          ...properties,
          distinct_id: currentUserId
        });
      } catch (e) {
        logger.debug(
          `Failed to track PostHog Browser event ${event.name}: ${e}`
        );
      }
    }
  }
  // ============================================================================
  // Agent Events
  // ============================================================================
  async trackAgentExecution(data) {
    if (!this.isEnabled) return;
    const event = new MCPAgentExecutionEvent(data);
    await this.capture(event);
  }
  // ============================================================================
  // Server Events
  // ============================================================================
  /**
   * Track server run event directly from an MCPServer instance.
   */
  async trackServerRunFromServer(server, transport) {
    if (!this.isEnabled) return;
    const data = createServerRunEventData(server, transport);
    const event = new ServerRunEvent(data);
    await this.capture(event);
  }
  async trackServerInitialize(data) {
    if (!this.isEnabled) return;
    const event = new ServerInitializeEvent(data);
    await this.capture(event);
  }
  async trackServerToolCall(data) {
    if (!this.isEnabled) return;
    const event = new ServerToolCallEvent(data);
    await this.capture(event);
  }
  async trackServerResourceCall(data) {
    if (!this.isEnabled) return;
    const event = new ServerResourceCallEvent(data);
    await this.capture(event);
  }
  async trackServerPromptCall(data) {
    if (!this.isEnabled) return;
    const event = new ServerPromptCallEvent(data);
    await this.capture(event);
  }
  async trackServerContext(data) {
    if (!this.isEnabled) return;
    const event = new ServerContextEvent(data);
    await this.capture(event);
  }
  // ============================================================================
  // Client Events
  // ============================================================================
  async trackMCPClientInit(data) {
    if (!this.isEnabled) return;
    const event = new MCPClientInitEvent(data);
    await this.capture(event);
  }
  async trackConnectorInit(data) {
    if (!this.isEnabled) return;
    const event = new ConnectorInitEvent(data);
    await this.capture(event);
  }
  async trackClientAddServer(serverName, serverConfig) {
    if (!this.isEnabled) return;
    const event = new ClientAddServerEvent({ serverName, serverConfig });
    await this.capture(event);
  }
  async trackClientRemoveServer(serverName) {
    if (!this.isEnabled) return;
    const event = new ClientRemoveServerEvent({ serverName });
    await this.capture(event);
  }
  // ============================================================================
  // React Hook / Browser specific events
  // ============================================================================
  async trackUseMcpConnection(data) {
    if (!this.isEnabled) return;
    await this.capture({
      name: "usemcp_connection",
      properties: {
        url_domain: new URL(data.url).hostname,
        // Only domain for privacy
        transport_type: data.transportType,
        success: data.success,
        error_type: data.errorType ?? null,
        connection_time_ms: data.connectionTimeMs ?? null,
        has_oauth: data.hasOAuth,
        has_sampling: data.hasSampling,
        has_elicitation: data.hasElicitation
      }
    });
  }
  async trackUseMcpToolCall(data) {
    if (!this.isEnabled) return;
    await this.capture({
      name: "usemcp_tool_call",
      properties: {
        tool_name: data.toolName,
        success: data.success,
        error_type: data.errorType ?? null,
        execution_time_ms: data.executionTimeMs ?? null
      }
    });
  }
  async trackUseMcpResourceRead(data) {
    if (!this.isEnabled) return;
    await this.capture({
      name: "usemcp_resource_read",
      properties: {
        resource_uri_scheme: data.resourceUri.split(":")[0],
        // Only scheme for privacy
        success: data.success,
        error_type: data.errorType ?? null
      }
    });
  }
  // ============================================================================
  // Browser-specific Methods
  // ============================================================================
  /**
   * Identify the current user (useful for linking sessions)
   * Browser only
   */
  identify(userId, properties) {
    if (this._posthogBrowserClient) {
      try {
        this._posthogBrowserClient.identify(userId, properties);
      } catch (e) {
        logger.debug(`Failed to identify user: ${e}`);
      }
    }
  }
  /**
   * Reset the user identity (useful for logout)
   * Browser only
   */
  reset() {
    if (this._posthogBrowserClient) {
      try {
        this._posthogBrowserClient.reset();
      } catch (e) {
        logger.debug(`Failed to reset user: ${e}`);
      }
    }
    this._currUserId = null;
  }
  // ============================================================================
  // Node.js-specific Methods (no-ops in browser)
  // ============================================================================
  /**
   * Flush the telemetry queue (Node.js only - no-op in browser)
   */
  flush() {
  }
  /**
   * Shutdown the telemetry client (Node.js only - no-op in browser)
   */
  shutdown() {
  }
  /**
   * Track package download event (Node.js only - no-op in browser)
   */
  async trackPackageDownload(properties) {
  }
};
var Tel = Telemetry;
function setTelemetrySource(source) {
  Tel.getInstance().setSource(source);
}
__name(setTelemetrySource, "setTelemetrySource");

// src/connectors/base.ts
var BaseConnector = class {
  static {
    __name(this, "BaseConnector");
  }
  client = null;
  connectionManager = null;
  toolsCache = null;
  capabilitiesCache = null;
  serverInfoCache = null;
  connected = false;
  opts;
  notificationHandlers = [];
  rootsCache = [];
  constructor(opts = {}) {
    const finalOpts = {
      ...opts,
      onSampling: opts.onSampling ?? opts.samplingCallback,
      onElicitation: opts.onElicitation ?? opts.elicitationCallback
    };
    if (opts.samplingCallback && !opts.onSampling) {
      logger.warn(
        '[BaseConnector] The "samplingCallback" option is deprecated. Use "onSampling" instead.'
      );
    }
    if (opts.elicitationCallback && !opts.onElicitation) {
      console.warn(
        '[BaseConnector] The "elicitationCallback" option is deprecated. Use "onElicitation" instead.'
      );
    }
    this.opts = finalOpts;
    if (finalOpts.roots) {
      this.rootsCache = [...finalOpts.roots];
    }
    if (finalOpts.onNotification) {
      this.notificationHandlers.push(finalOpts.onNotification);
    }
  }
  /**
   * Track connector initialization event
   * Should be called by subclasses after successful connection
   */
  trackConnectorInit(data) {
    const connectorType = this.constructor.name;
    Telemetry.getInstance().trackConnectorInit({
      connectorType,
      ...data
    }).catch((e) => logger.debug(`Failed to track connector init: ${e}`));
  }
  /**
   * Register a handler for server notifications
   *
   * @param handler - Function to call when a notification is received
   *
   * @example
   * ```typescript
   * connector.onNotification((notification) => {
   *   console.log(`Received: ${notification.method}`, notification.params);
   * });
   * ```
   */
  onNotification(handler) {
    this.notificationHandlers.push(handler);
    if (this.client) {
      this.setupNotificationHandler();
    }
  }
  /**
   * Internal: wire notification handlers to the SDK client
   * Includes automatic handling for list_changed notifications per MCP spec
   */
  setupNotificationHandler() {
    if (!this.client) return;
    this.client.fallbackNotificationHandler = async (notification) => {
      switch (notification.method) {
        case "notifications/tools/list_changed":
          await this.refreshToolsCache();
          break;
        case "notifications/resources/list_changed":
          await this.onResourcesListChanged();
          break;
        case "notifications/prompts/list_changed":
          await this.onPromptsListChanged();
          break;
        default:
          break;
      }
      for (const handler of this.notificationHandlers) {
        try {
          await handler(notification);
        } catch (err) {
          logger.error("Error in notification handler:", err);
        }
      }
    };
  }
  /**
   * Auto-refresh tools cache when server sends tools/list_changed notification
   */
  async refreshToolsCache() {
    if (!this.client) return;
    try {
      logger.debug(
        "[Auto] Refreshing tools cache due to list_changed notification"
      );
      const result = await this.client.listTools();
      this.toolsCache = result.tools ?? [];
      logger.debug(
        `[Auto] Refreshed tools cache: ${this.toolsCache.length} tools`
      );
    } catch (err) {
      logger.warn("[Auto] Failed to refresh tools cache:", err);
    }
  }
  /**
   * Called when server sends resources/list_changed notification
   * Resources aren't cached by default, but we log for user awareness
   */
  async onResourcesListChanged() {
    logger.debug(
      "[Auto] Resources list changed - clients should re-fetch if needed"
    );
  }
  /**
   * Called when server sends prompts/list_changed notification
   * Prompts aren't cached by default, but we log for user awareness
   */
  async onPromptsListChanged() {
    logger.debug(
      "[Auto] Prompts list changed - clients should re-fetch if needed"
    );
  }
  /**
   * Set roots and notify the server.
   * Roots represent directories or files that the client has access to.
   *
   * @param roots - Array of Root objects with `uri` (must start with "file://") and optional `name`
   *
   * @example
   * ```typescript
   * await connector.setRoots([
   *   { uri: "file:///home/user/project", name: "My Project" },
   *   { uri: "file:///home/user/data" }
   * ]);
   * ```
   */
  async setRoots(roots) {
    this.rootsCache = [...roots];
    if (this.client) {
      logger.debug(
        `Sending roots/list_changed notification with ${roots.length} root(s)`
      );
      await this.client.sendRootsListChanged();
    }
  }
  /**
   * Get the current roots.
   */
  getRoots() {
    return [...this.rootsCache];
  }
  /**
   * Internal: set up roots/list request handler.
   * This is called after the client connects to register the handler for server requests.
   */
  setupRootsHandler() {
    if (!this.client) return;
    this.client.setRequestHandler(
      import_types.ListRootsRequestSchema,
      async (_request, _extra) => {
        logger.debug(
          `Server requested roots list, returning ${this.rootsCache.length} root(s)`
        );
        return { roots: this.rootsCache };
      }
    );
  }
  /**
   * Internal: set up sampling/createMessage request handler.
   * This is called after the client connects to register the handler for sampling requests.
   */
  setupSamplingHandler() {
    if (!this.client) {
      logger.debug("setupSamplingHandler: No client available");
      return;
    }
    const samplingCallback = this.opts.onSampling ?? this.opts.samplingCallback;
    if (!samplingCallback) {
      logger.debug("setupSamplingHandler: No sampling callback provided");
      return;
    }
    logger.debug("setupSamplingHandler: Setting up sampling request handler");
    this.client.setRequestHandler(
      import_types.CreateMessageRequestSchema,
      async (request, _extra) => {
        logger.debug("Server requested sampling, forwarding to callback");
        return await samplingCallback(request.params);
      }
    );
    logger.debug(
      "setupSamplingHandler: Sampling handler registered successfully"
    );
  }
  /**
   * Internal: set up elicitation/create request handler.
   * This is called after the client connects to register the handler for elicitation requests.
   */
  setupElicitationHandler() {
    if (!this.client) {
      logger.debug("setupElicitationHandler: No client available");
      return;
    }
    const elicitationCallback = this.opts.onElicitation ?? this.opts.elicitationCallback;
    if (!elicitationCallback) {
      logger.debug("setupElicitationHandler: No elicitation callback provided");
      return;
    }
    logger.debug(
      "setupElicitationHandler: Setting up elicitation request handler"
    );
    this.client.setRequestHandler(
      import_types.ElicitRequestSchema,
      async (request, _extra) => {
        logger.debug("Server requested elicitation, forwarding to callback");
        return await elicitationCallback(request.params);
      }
    );
    logger.debug(
      "setupElicitationHandler: Elicitation handler registered successfully"
    );
  }
  /** Disconnect and release resources. */
  async disconnect() {
    if (!this.connected) {
      logger.debug("Not connected to MCP implementation");
      return;
    }
    logger.debug("Disconnecting from MCP implementation");
    await this.cleanupResources();
    this.connected = false;
    logger.debug("Disconnected from MCP implementation");
  }
  /** Check if the client is connected */
  get isClientConnected() {
    return this.client != null;
  }
  /**
   * Initialise the MCP session **after** `connect()` has succeeded.
   *
   * In the SDK, `Client.connect(transport)` automatically performs the
   * protocollevel `initialize` handshake, so we only need to cache the list of
   * tools and expose some server info.
   */
  async initialize(defaultRequestOptions = this.opts.defaultRequestOptions ?? {}) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug("Caching server capabilities & tools");
    const capabilities = this.client.getServerCapabilities();
    this.capabilitiesCache = capabilities || null;
    const serverInfo = this.client.getServerVersion();
    this.serverInfoCache = serverInfo || null;
    try {
      const listToolsRes = await this.client.listTools(
        void 0,
        defaultRequestOptions
      );
      this.toolsCache = listToolsRes.tools ?? [];
      logger.debug(`Fetched ${this.toolsCache.length} tools from server`);
    } catch (err) {
      const error = err;
      if (error.code === -32601) {
        logger.debug("Server does not implement tools/list, assuming no tools");
      } else {
        logger.debug("Failed to list tools, assuming empty:", error.message);
      }
      this.toolsCache = [];
    }
    logger.debug("Server capabilities:", capabilities);
    logger.debug("Server info:", serverInfo);
    return capabilities;
  }
  /** Lazily expose the cached tools list. */
  get tools() {
    if (!this.toolsCache) {
      throw new Error("MCP client is not initialized; call initialize() first");
    }
    return this.toolsCache;
  }
  /** Expose cached server capabilities. */
  get serverCapabilities() {
    return this.capabilitiesCache || {};
  }
  /** Expose cached server info. */
  get serverInfo() {
    return this.serverInfoCache;
  }
  /** Call a tool on the server. */
  async callTool(name, args, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    const enhancedOptions = options ? { ...options } : void 0;
    if (enhancedOptions?.resetTimeoutOnProgress && !enhancedOptions.onprogress) {
      enhancedOptions.onprogress = () => {
      };
      logger.debug(
        `[BaseConnector] Added onprogress callback for tool '${name}' to enable progressToken`
      );
    }
    logger.debug(`Calling tool '${name}' with args`, args);
    const res = await this.client.callTool(
      { name, arguments: args },
      void 0,
      enhancedOptions
    );
    logger.debug(`Tool '${name}' returned`, res);
    return res;
  }
  /**
   * List all available tools from the MCP server.
   * This method fetches fresh tools from the server, unlike the `tools` getter which returns cached tools.
   *
   * @param options - Optional request options
   * @returns Array of available tools
   */
  async listTools(options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug("[listTools] Fetching fresh tools from server...");
    const result = await this.client.listTools(void 0, options);
    const tools = result.tools ? [...result.tools] : [];
    logger.debug(
      `[listTools] Returned ${tools.length} tools:`,
      tools.map((t) => t.name)
    );
    return tools;
  }
  /**
   * List resources from the server with optional pagination
   *
   * @param cursor - Optional cursor for pagination
   * @param options - Request options
   * @returns Resource list with optional nextCursor for pagination
   */
  async listResources(cursor, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug("Listing resources", cursor ? `with cursor: ${cursor}` : "");
    return await this.client.listResources({ cursor }, options);
  }
  /**
   * List all resources from the server, automatically handling pagination
   *
   * @param options - Request options
   * @returns Complete list of all resources
   */
  async listAllResources(options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    if (!this.capabilitiesCache?.resources) {
      logger.debug("Server does not advertise resources capability, skipping");
      return { resources: [] };
    }
    try {
      logger.debug("Listing all resources (with auto-pagination)");
      const allResources = [];
      let cursor = void 0;
      do {
        const result = await this.client.listResources({ cursor }, options);
        allResources.push(...result.resources || []);
        cursor = result.nextCursor;
      } while (cursor);
      return { resources: allResources };
    } catch (err) {
      const error = err;
      if (error.code === -32601) {
        logger.debug("Server advertised resources but method not found");
        return { resources: [] };
      }
      throw err;
    }
  }
  /**
   * List resource templates from the server
   *
   * @param options - Request options
   * @returns List of available resource templates
   */
  async listResourceTemplates(options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug("Listing resource templates");
    return await this.client.listResourceTemplates(void 0, options);
  }
  /** Read a resource by URI. */
  async readResource(uri, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Reading resource ${uri}`);
    const res = await this.client.readResource({ uri }, options);
    return res;
  }
  /**
   * Subscribe to resource updates
   *
   * @param uri - URI of the resource to subscribe to
   * @param options - Request options
   */
  async subscribeToResource(uri, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Subscribing to resource: ${uri}`);
    return await this.client.subscribeResource({ uri }, options);
  }
  /**
   * Unsubscribe from resource updates
   *
   * @param uri - URI of the resource to unsubscribe from
   * @param options - Request options
   */
  async unsubscribeFromResource(uri, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Unsubscribing from resource: ${uri}`);
    return await this.client.unsubscribeResource({ uri }, options);
  }
  async listPrompts() {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    if (!this.capabilitiesCache?.prompts) {
      logger.debug("Server does not advertise prompts capability, skipping");
      return { prompts: [] };
    }
    try {
      logger.debug("Listing prompts");
      return await this.client.listPrompts();
    } catch (err) {
      const error = err;
      if (error.code === -32601) {
        logger.debug("Server advertised prompts but method not found");
        return { prompts: [] };
      }
      throw err;
    }
  }
  async getPrompt(name, args) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Getting prompt ${name}`);
    return await this.client.getPrompt({ name, arguments: args });
  }
  /** Send a raw request through the client. */
  async request(method, params = null, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Sending raw request '${method}' with params`, params);
    return await this.client.request(
      { method, params: params ?? {} },
      void 0,
      options
    );
  }
  /**
   * Helper to tear down the client & connection manager safely.
   */
  async cleanupResources() {
    const issues = [];
    if (this.client) {
      try {
        if (typeof this.client.close === "function") {
          await this.client.close();
        }
      } catch (e) {
        const msg = `Error closing client: ${e}`;
        logger.warn(msg);
        issues.push(msg);
      } finally {
        this.client = null;
      }
    }
    if (this.connectionManager) {
      try {
        await this.connectionManager.stop();
      } catch (e) {
        const msg = `Error stopping connection manager: ${e}`;
        logger.warn(msg);
        issues.push(msg);
      } finally {
        this.connectionManager = null;
      }
    }
    this.toolsCache = null;
    if (issues.length) {
      logger.warn(`Resource cleanup finished with ${issues.length} issue(s)`);
    }
  }
};

// src/connectors/http.ts
var HttpConnector = class extends BaseConnector {
  static {
    __name(this, "HttpConnector");
  }
  baseUrl;
  headers;
  timeout;
  sseReadTimeout;
  customFetch;
  clientInfo;
  preferSse;
  disableSseFallback;
  gatewayUrl;
  serverId;
  transportType = null;
  streamableTransport = null;
  constructor(baseUrl, opts = {}) {
    super(opts);
    const originalUrl = baseUrl.replace(/\/$/, "");
    this.gatewayUrl = opts.gatewayUrl;
    this.serverId = opts.serverId;
    if (this.gatewayUrl) {
      this.baseUrl = this.gatewayUrl.replace(/\/$/, "");
      this.headers = { ...opts.headers ?? {} };
      this.headers["X-Target-URL"] = originalUrl;
      if (this.serverId) {
        this.headers["X-Server-Id"] = this.serverId;
      }
    } else {
      this.baseUrl = originalUrl;
      this.headers = { ...opts.headers ?? {} };
    }
    if (opts.authToken) {
      this.headers.Authorization = `Bearer ${opts.authToken}`;
    }
    this.timeout = opts.timeout ?? 1e4;
    this.sseReadTimeout = opts.sseReadTimeout ?? 3e5;
    this.customFetch = opts.fetch;
    this.clientInfo = opts.clientInfo ?? {
      name: "http-connector",
      version: "1.0.0"
    };
    this.preferSse = opts.preferSse ?? false;
    this.disableSseFallback = opts.disableSseFallback ?? false;
  }
  buildClientOptions() {
    return {
      ...this.opts.clientOptions || {},
      capabilities: {
        ...this.opts.clientOptions?.capabilities || {},
        roots: { listChanged: true },
        ...this.opts.onSampling ? { sampling: {} } : {},
        ...this.opts.onElicitation ?? this.opts.elicitationCallback ? { elicitation: { form: {}, url: {} } } : {}
      }
    };
  }
  unwrapStreamableError(err) {
    if (err instanceof import_streamableHttp.StreamableHTTPError) {
      return err;
    }
    if (err instanceof Error && err.cause instanceof import_streamableHttp.StreamableHTTPError) {
      return err.cause;
    }
    return null;
  }
  classifyStreamableHttpFailure(err) {
    let fallbackReason = "Unknown error";
    let is401Error = false;
    let httpStatusCode;
    const streamableErr = this.unwrapStreamableError(err);
    if (streamableErr) {
      is401Error = streamableErr.code === 401;
      httpStatusCode = streamableErr.code;
      if (streamableErr.code === 400 && streamableErr.message.includes("Missing session ID")) {
        fallbackReason = "Server requires session ID (FastMCP compatibility) - using SSE transport";
        logger.warn(`\u26A0\uFE0F  ${fallbackReason}`);
      } else if (streamableErr.code === 404 || streamableErr.code === 405) {
        fallbackReason = `Server returned ${streamableErr.code} - server likely doesn't support streamable HTTP`;
        logger.debug(fallbackReason);
      } else {
        fallbackReason = `Server returned ${streamableErr.code}: ${streamableErr.message}`;
        logger.debug(fallbackReason);
      }
      return { fallbackReason, is401Error, httpStatusCode };
    }
    if (err instanceof Error) {
      const errorStr = err.toString();
      const errorMsg = err.message || "";
      is401Error = errorStr.includes("401") || errorMsg.includes("Unauthorized");
      if (errorStr.includes("Missing session ID") || errorStr.includes("Bad Request: Missing session ID") || errorMsg.includes("FastMCP session ID error")) {
        fallbackReason = "Server requires session ID (FastMCP compatibility) - using SSE transport";
        logger.warn(`\u26A0\uFE0F  ${fallbackReason}`);
      } else if (errorStr.includes("405 Method Not Allowed") || errorStr.includes("404 Not Found")) {
        fallbackReason = "Server doesn't support streamable HTTP (405/404)";
        logger.debug(fallbackReason);
      } else {
        fallbackReason = `Streamable HTTP failed: ${err.message}`;
        logger.debug(fallbackReason);
      }
    }
    return { fallbackReason, is401Error, httpStatusCode };
  }
  /** Establish connection to the MCP implementation via HTTP (streamable or SSE). */
  async connect() {
    if (this.connected) {
      logger.debug("Already connected to MCP implementation");
      return;
    }
    const baseUrl = this.baseUrl;
    if (this.preferSse) {
      logger.debug(`Connecting to MCP implementation via HTTP/SSE: ${baseUrl}`);
      await this.connectWithSse(baseUrl);
      return;
    }
    logger.debug(`Connecting to MCP implementation via HTTP: ${baseUrl}`);
    try {
      logger.info("\u{1F504} Attempting streamable HTTP transport...");
      await this.connectWithStreamableHttp(baseUrl);
      logger.info("\u2705 Successfully connected via streamable HTTP");
    } catch (err) {
      logger.debug("Streamable HTTP connect failed", err);
      const { fallbackReason, is401Error, httpStatusCode } = this.classifyStreamableHttpFailure(err);
      if (is401Error) {
        logger.info("Authentication required - skipping SSE fallback");
        await this.cleanupResources();
        const authError = new Error("Authentication required");
        authError.code = 401;
        throw authError;
      }
      if (this.disableSseFallback) {
        logger.info("SSE fallback disabled - failing connection");
        await this.cleanupResources();
        throw new Error(`Streamable HTTP connection failed: ${fallbackReason}`);
      }
      logger.info("\u{1F504} Falling back to SSE transport...");
      try {
        await this.connectWithSse(baseUrl);
      } catch (sseErr) {
        logger.error("Failed to connect with both transports:");
        logger.error(`  Streamable HTTP: ${fallbackReason}`);
        logger.error(`  SSE: ${sseErr}`);
        await this.cleanupResources();
        const sseIs401 = sseErr?.message?.includes("401") || sseErr?.message?.includes("Unauthorized");
        if (sseIs401) {
          const authError = new Error("Authentication required");
          authError.code = 401;
          throw authError;
        }
        const finalError = new Error(
          `Could not connect to server with any available transport. Streamable HTTP: ${fallbackReason}`
        );
        if (httpStatusCode !== void 0) {
          Object.defineProperty(finalError, "code", {
            value: httpStatusCode,
            writable: false,
            enumerable: true,
            configurable: true
          });
          logger.debug(
            `Preserving HTTP status code ${httpStatusCode} in error for proxy fallback detection`
          );
        }
        throw finalError;
      }
    }
  }
  async connectWithStreamableHttp(baseUrl) {
    try {
      logger.debug("[HttpConnector] Connecting with Streamable HTTP", {
        baseUrl,
        originalUrl: this.baseUrl,
        gatewayUrl: this.gatewayUrl || "none",
        authProviderUrl: this.opts.authProvider?.serverUrl || "none",
        headers: this.headers
      });
      const streamableTransport = new import_streamableHttp.StreamableHTTPClientTransport(
        new URL(baseUrl),
        {
          authProvider: this.opts.authProvider,
          //  Pass OAuth provider to SDK
          fetch: this.customFetch,
          requestInit: {
            headers: this.headers
          },
          // Pass through reconnection options
          reconnectionOptions: {
            maxReconnectionDelay: 3e4,
            initialReconnectionDelay: 1e3,
            reconnectionDelayGrowFactor: 1.5,
            maxRetries: 2
            // Disable automatic reconnection - let higher-level logic handle it
          }
          // Don't pass sessionId - let the SDK generate it automatically during connect()
        }
      );
      let transport = streamableTransport;
      if (this.opts.wrapTransport) {
        const serverId = this.baseUrl;
        transport = this.opts.wrapTransport(
          transport,
          serverId
        );
      }
      const clientOptions = this.buildClientOptions();
      logger.debug(
        `Creating Client with capabilities:`,
        JSON.stringify(clientOptions.capabilities, null, 2)
      );
      this.client = new import_client.Client(this.clientInfo, clientOptions);
      this.setupRootsHandler();
      logger.debug("Roots handler registered before connect");
      try {
        await this.client.connect(transport, {
          timeout: this.timeout
        });
        const sessionId = streamableTransport.sessionId;
        if (sessionId) {
          logger.debug(`Session ID obtained: ${sessionId}`);
        } else {
          logger.warn(
            "Session ID not available after connect - this may cause issues with SSE stream"
          );
        }
      } catch (connectErr) {
        if (connectErr instanceof Error) {
          const errMsg = connectErr.message || connectErr.toString();
          if (errMsg.includes("Missing session ID") || errMsg.includes("Bad Request: Missing session ID") || errMsg.includes("Mcp-Session-Id header is required")) {
            const wrappedError = new Error(
              `Session ID error: ${errMsg}. The SDK should automatically extract session ID from initialize response.`
            );
            wrappedError.cause = connectErr;
            throw wrappedError;
          }
        }
        throw connectErr;
      }
      this.streamableTransport = streamableTransport;
      this.connectionManager = {
        stop: /* @__PURE__ */ __name(async () => {
          if (this.streamableTransport) {
            try {
              await this.streamableTransport.terminateSession();
              await this.streamableTransport.close();
            } catch (e) {
              logger.warn(`Error closing Streamable HTTP transport: ${e}`);
            } finally {
              this.streamableTransport = null;
            }
          }
        }, "stop")
      };
      this.connected = true;
      this.transportType = "streamable-http";
      this.setupNotificationHandler();
      this.setupSamplingHandler();
      this.setupElicitationHandler();
      logger.debug(
        `Successfully connected to MCP implementation via streamable HTTP: ${baseUrl}`
      );
      this.trackConnectorInit({
        serverUrl: this.baseUrl,
        publicIdentifier: `${this.baseUrl} (streamable-http)`
      });
    } catch (err) {
      await this.cleanupResources();
      throw err;
    }
  }
  async connectWithSse(baseUrl) {
    try {
      this.connectionManager = new SseConnectionManager(baseUrl, {
        authProvider: this.opts.authProvider,
        //  Pass OAuth provider to SDK (same as streamable HTTP)
        requestInit: {
          headers: this.headers
        }
      });
      let transport = await this.connectionManager.start();
      if (this.opts.wrapTransport) {
        const serverId = this.baseUrl;
        transport = this.opts.wrapTransport(transport, serverId);
      }
      const clientOptions = this.buildClientOptions();
      logger.debug(
        `Creating Client with capabilities (SSE):`,
        JSON.stringify(clientOptions.capabilities, null, 2)
      );
      this.client = new import_client.Client(this.clientInfo, clientOptions);
      this.setupRootsHandler();
      logger.debug("Roots handler registered before connect (SSE)");
      await this.client.connect(transport);
      this.connected = true;
      this.transportType = "sse";
      this.setupNotificationHandler();
      this.setupSamplingHandler();
      this.setupElicitationHandler();
      logger.debug(
        `Successfully connected to MCP implementation via HTTP/SSE: ${baseUrl}`
      );
      this.trackConnectorInit({
        serverUrl: this.baseUrl,
        publicIdentifier: `${this.baseUrl} (sse)`
      });
    } catch (err) {
      await this.cleanupResources();
      throw err;
    }
  }
  get publicIdentifier() {
    return {
      type: "http",
      url: this.baseUrl,
      transport: this.transportType || "unknown"
    };
  }
  /**
   * Get the transport type being used (streamable-http or sse)
   */
  getTransportType() {
    return this.transportType;
  }
};

// src/config.ts
function resolveCallbacks(perServer, globalDefaults) {
  const pickSampling = perServer?.onSampling ?? perServer?.samplingCallback ?? globalDefaults?.onSampling ?? globalDefaults?.samplingCallback;
  const pickElicitation = perServer?.onElicitation ?? perServer?.elicitationCallback ?? globalDefaults?.onElicitation ?? globalDefaults?.elicitationCallback;
  const pickNotification = perServer?.onNotification ?? globalDefaults?.onNotification;
  return {
    onSampling: pickSampling,
    onElicitation: pickElicitation,
    onNotification: pickNotification
  };
}
__name(resolveCallbacks, "resolveCallbacks");
function getDefaultClientInfo() {
  return {
    name: "mcp-use",
    title: "mcp-use",
    version: getPackageVersion(),
    description: "mcp-use is a complete TypeScript framework for building and using MCP",
    icons: [
      {
        src: "https://mcp-use.com/logo.png"
      }
    ],
    websiteUrl: "https://mcp-use.com"
  };
}
__name(getDefaultClientInfo, "getDefaultClientInfo");
function normalizeClientInfo(input) {
  const fallback = getDefaultClientInfo();
  if (!input || typeof input !== "object") return fallback;
  const ci = input;
  if (!ci.name || !ci.version) return fallback;
  return { ...fallback, ...ci };
}
__name(normalizeClientInfo, "normalizeClientInfo");

// src/client/browser.ts
init_logging();

// src/client/base.ts
init_logging();

// src/session.ts
var MCPSession = class {
  static {
    __name(this, "MCPSession");
  }
  /**
   * The underlying connector managing the transport layer.
   * This is the Stdio, HTTP, or WebSocket connector handling actual communication.
   */
  connector;
  /**
   * Whether to automatically connect when initializing.
   * @internal
   */
  autoConnect;
  /**
   * Creates a new MCP session.
   *
   * @param connector - The connector to use for communication (Stdio, HTTP, WebSocket)
   * @param autoConnect - Whether to automatically connect during initialization (default: true)
   *
   * @example
   * ```typescript
   * const connector = new HttpConnector({ url: 'http://localhost:3000/mcp' });
   * const session = new MCPSession(connector);
   * await session.initialize(); // Auto-connects and initializes
   * ```
   *
   * @example
   * ```typescript
   * // Manual connection control
   * const session = new MCPSession(connector, false);
   * await session.connect();
   * await session.initialize();
   * ```
   */
  constructor(connector, autoConnect = true) {
    this.connector = connector;
    this.autoConnect = autoConnect;
  }
  /**
   * Establishes the connection to the MCP server.
   *
   * This method starts the underlying transport (spawns process for Stdio,
   * opens WebSocket, etc.) but does not perform the MCP initialization
   * handshake. Call {@link initialize} after connecting.
   *
   * @returns Promise that resolves when connected
   *
   * @example
   * ```typescript
   * await session.connect();
   * await session.initialize();
   * ```
   *
   * @see {@link initialize} for performing the MCP handshake
   * @see {@link disconnect} for closing the connection
   */
  async connect() {
    await this.connector.connect();
  }
  /**
   * Closes the connection to the MCP server.
   *
   * This method gracefully shuts down the transport and cleans up resources.
   * After disconnecting, the session cannot be used until reconnected.
   *
   * @returns Promise that resolves when disconnected
   *
   * @example
   * ```typescript
   * await session.disconnect();
   * console.log('Session closed');
   * ```
   *
   * @see {@link connect} for establishing connections
   */
  async disconnect() {
    await this.connector.disconnect();
  }
  /**
   * Initializes the MCP session with the server.
   *
   * This method performs the MCP initialization handshake, exchanging
   * capabilities and metadata with the server. If `autoConnect` is true
   * and the session is not yet connected, it will connect first.
   *
   * After initialization, you can list and call tools, read resources, etc.
   *
   * @returns Promise that resolves when initialized
   *
   * @example
   * ```typescript
   * const session = await client.createSession('my-server', false);
   * await session.connect();
   * await session.initialize();
   * // Now ready to use
   * const tools = await session.listTools();
   * ```
   *
   * @see {@link connect} for establishing the connection first
   */
  async initialize() {
    if (!this.isConnected && this.autoConnect) {
      await this.connect();
    }
    await this.connector.initialize();
  }
  /**
   * Checks if the session is currently connected to the server.
   *
   * @returns True if connected, false otherwise
   *
   * @example
   * ```typescript
   * if (session.isConnected) {
   *   const tools = await session.listTools();
   * }
   * ```
   */
  get isConnected() {
    return this.connector && this.connector.isClientConnected;
  }
  /**
   * Register an event handler for session events
   *
   * @param event - The event type to listen for
   * @param handler - The handler function to call when the event occurs
   *
   * @example
   * ```typescript
   * session.on("notification", async (notification) => {
   *   console.log(`Received: ${notification.method}`, notification.params);
   *
   *   if (notification.method === "notifications/tools/list_changed") {
   *     // Refresh tools list
   *   }
   * });
   * ```
   */
  on(event, handler) {
    if (event === "notification") {
      this.connector.onNotification(handler);
    }
  }
  /**
   * Set roots and notify the server.
   * Roots represent directories or files that the client has access to.
   *
   * @param roots - Array of Root objects with `uri` (must start with "file://") and optional `name`
   *
   * @example
   * ```typescript
   * await session.setRoots([
   *   { uri: "file:///home/user/project", name: "My Project" },
   *   { uri: "file:///home/user/data" }
   * ]);
   * ```
   */
  async setRoots(roots) {
    return this.connector.setRoots(roots);
  }
  /**
   * Gets the current roots advertised to the server.
   *
   * Roots represent directories or files that the client has provided access to.
   * The server may use this information to scope its operations.
   *
   * @returns Array of Root objects
   *
   * @example
   * ```typescript
   * const roots = session.getRoots();
   * console.log(`Current roots: ${roots.map(r => r.uri).join(', ')}`);
   * ```
   *
   * @see {@link setRoots} for updating roots
   */
  getRoots() {
    return this.connector.getRoots();
  }
  /**
   * Get the cached list of tools from the server.
   *
   * @returns Array of available tools
   *
   * @example
   * ```typescript
   * const tools = session.tools;
   * console.log(`Available tools: ${tools.map(t => t.name).join(", ")}`);
   * ```
   */
  get tools() {
    return this.connector.tools;
  }
  /**
   * List all available tools from the MCP server.
   * This method fetches fresh tools from the server, unlike the `tools` getter which returns cached tools.
   *
   * @param options - Optional request options
   * @returns Array of available tools
   *
   * @example
   * ```typescript
   * const tools = await session.listTools();
   * console.log(`Available tools: ${tools.map(t => t.name).join(", ")}`);
   * ```
   */
  async listTools(options) {
    return this.connector.listTools(options);
  }
  /**
   * Get the server capabilities advertised during initialization.
   *
   * @returns Server capabilities object
   */
  get serverCapabilities() {
    return this.connector.serverCapabilities;
  }
  /**
   * Get the server information (name and version).
   *
   * @returns Server info object or null if not available
   */
  get serverInfo() {
    return this.connector.serverInfo;
  }
  /**
   * Call a tool on the server.
   *
   * @param name - Name of the tool to call
   * @param args - Arguments to pass to the tool (defaults to empty object)
   * @param options - Optional request options (timeout, progress handlers, etc.)
   * @returns Result from the tool execution
   *
   * @example
   * ```typescript
   * const result = await session.callTool("add", { a: 5, b: 3 });
   * console.log(`Result: ${result.content[0].text}`);
   * ```
   */
  async callTool(name, args = {}, options) {
    return this.connector.callTool(name, args, options);
  }
  /**
   * List resources from the server with optional pagination.
   *
   * @param cursor - Optional cursor for pagination
   * @param options - Request options
   * @returns Resource list with optional nextCursor for pagination
   *
   * @example
   * ```typescript
   * const result = await session.listResources();
   * console.log(`Found ${result.resources.length} resources`);
   * ```
   */
  async listResources(cursor, options) {
    return this.connector.listResources(cursor, options);
  }
  /**
   * List all resources from the server, automatically handling pagination.
   *
   * @param options - Request options
   * @returns Complete list of all resources
   *
   * @example
   * ```typescript
   * const result = await session.listAllResources();
   * console.log(`Total resources: ${result.resources.length}`);
   * ```
   */
  async listAllResources(options) {
    return this.connector.listAllResources(options);
  }
  /**
   * List resource templates from the server.
   *
   * @param options - Request options
   * @returns List of available resource templates
   *
   * @example
   * ```typescript
   * const result = await session.listResourceTemplates();
   * console.log(`Available templates: ${result.resourceTemplates.length}`);
   * ```
   */
  async listResourceTemplates(options) {
    return this.connector.listResourceTemplates(options);
  }
  /**
   * Read a resource by URI.
   *
   * @param uri - URI of the resource to read
   * @param options - Request options
   * @returns Resource content
   *
   * @example
   * ```typescript
   * const resource = await session.readResource("file:///path/to/file.txt");
   * console.log(resource.contents);
   * ```
   */
  async readResource(uri, options) {
    return this.connector.readResource(uri, options);
  }
  /**
   * Subscribe to resource updates.
   *
   * @param uri - URI of the resource to subscribe to
   * @param options - Request options
   *
   * @example
   * ```typescript
   * await session.subscribeToResource("file:///path/to/file.txt");
   * // Now you'll receive notifications when this resource changes
   * ```
   */
  async subscribeToResource(uri, options) {
    return this.connector.subscribeToResource(uri, options);
  }
  /**
   * Unsubscribe from resource updates.
   *
   * @param uri - URI of the resource to unsubscribe from
   * @param options - Request options
   *
   * @example
   * ```typescript
   * await session.unsubscribeFromResource("file:///path/to/file.txt");
   * ```
   */
  async unsubscribeFromResource(uri, options) {
    return this.connector.unsubscribeFromResource(uri, options);
  }
  /**
   * List available prompts from the server.
   *
   * @returns List of available prompts
   *
   * @example
   * ```typescript
   * const result = await session.listPrompts();
   * console.log(`Available prompts: ${result.prompts.length}`);
   * ```
   */
  async listPrompts() {
    return this.connector.listPrompts();
  }
  /**
   * Get a specific prompt with arguments.
   *
   * @param name - Name of the prompt to get
   * @param args - Arguments for the prompt
   * @returns Prompt result
   *
   * @example
   * ```typescript
   * const prompt = await session.getPrompt("greeting", { name: "Alice" });
   * console.log(prompt.messages);
   * ```
   */
  async getPrompt(name, args) {
    return this.connector.getPrompt(name, args);
  }
  /**
   * Send a raw request through the client.
   *
   * @param method - MCP method name
   * @param params - Request parameters
   * @param options - Request options
   * @returns Response from the server
   *
   * @example
   * ```typescript
   * const result = await session.request("custom/method", { key: "value" });
   * ```
   */
  async request(method, params = null, options) {
    return this.connector.request(method, params, options);
  }
};

// src/client/base.ts
var BaseMCPClient = class {
  static {
    __name(this, "BaseMCPClient");
  }
  /**
   * Internal configuration object containing MCP server definitions.
   * @protected
   */
  config = {};
  /**
   * Map of server names to their active sessions.
   * @protected
   */
  sessions = {};
  /**
   * List of server names that have active sessions.
   * This array is kept in sync with the sessions map and can be used
   * to iterate over active connections.
   *
   * @example
   * ```typescript
   * console.log(`Active servers: ${client.activeSessions.join(', ')}`);
   * ```
   */
  activeSessions = [];
  /**
   * Creates a new BaseMCPClient instance.
   *
   * @param config - Optional configuration object with MCP server definitions
   *
   * @example
   * ```typescript
   * const client = new MCPClient({
   *   mcpServers: {
   *     'example': {
   *       command: 'node',
   *       args: ['server.js']
   *     }
   *   }
   * });
   * ```
   */
  constructor(config) {
    if (config) {
      this.config = config;
    }
  }
  /**
   * Creates a client instance from a configuration dictionary.
   *
   * This static factory method must be implemented by concrete subclasses
   * to provide proper type information and platform-specific initialization.
   *
   * @param _cfg - Configuration dictionary
   * @returns Client instance
   * @throws {Error} If called on the base class instead of a concrete implementation
   *
   * @example
   * ```typescript
   * const client = MCPClient.fromDict({
   *   mcpServers: {
   *     'my-server': { command: 'node', args: ['server.js'] }
   *   }
   * });
   * ```
   */
  static fromDict(_cfg) {
    throw new Error("fromDict must be implemented by concrete class");
  }
  /**
   * Adds a new MCP server configuration to the client.
   *
   * This method adds or updates a server configuration dynamically without
   * needing to restart the client. The server can then be used to create
   * new sessions.
   *
   * @param name - Unique name for the server
   * @param serverConfig - Server configuration object (connector type, command, args, etc.)
   *
   * @example
   * ```typescript
   * client.addServer('new-server', {
   *   command: 'python',
   *   args: ['server.py']
   * });
   *
   * // Now you can create a session
   * const session = await client.createSession('new-server');
   * ```
   *
   * @see {@link removeServer} for removing servers
   * @see {@link getServerConfig} for retrieving configurations
   */
  addServer(name, serverConfig) {
    this.config.mcpServers = this.config.mcpServers || {};
    this.config.mcpServers[name] = serverConfig;
    Tel.getInstance().trackClientAddServer(name, serverConfig);
  }
  /**
   * Removes an MCP server configuration from the client.
   *
   * This method removes a server configuration and cleans up any active
   * sessions associated with that server. If there's an active session,
   * it will be removed from the active sessions list.
   *
   * @param name - Name of the server to remove
   *
   * @example
   * ```typescript
   * // Remove a server configuration
   * client.removeServer('old-server');
   *
   * // The server name will no longer appear in getServerNames()
   * console.log(client.getServerNames()); // 'old-server' is gone
   * ```
   *
   * @see {@link addServer} for adding servers
   * @see {@link closeSession} for properly closing sessions before removal
   */
  removeServer(name) {
    if (this.config.mcpServers?.[name]) {
      delete this.config.mcpServers[name];
      this.activeSessions = this.activeSessions.filter((n) => n !== name);
      Tel.getInstance().trackClientRemoveServer(name);
    }
  }
  /**
   * Gets the names of all configured MCP servers.
   *
   * @returns Array of server names defined in the configuration
   *
   * @example
   * ```typescript
   * const serverNames = client.getServerNames();
   * console.log(`Configured servers: ${serverNames.join(', ')}`);
   *
   * // Create sessions for all servers
   * for (const name of serverNames) {
   *   await client.createSession(name);
   * }
   * ```
   *
   * @see {@link activeSessions} for servers with active sessions
   */
  getServerNames() {
    return Object.keys(this.config.mcpServers ?? {});
  }
  /**
   * Gets the configuration for a specific MCP server.
   *
   * @param name - Name of the server
   * @returns Server configuration object, or undefined if not found
   *
   * @example
   * ```typescript
   * const config = client.getServerConfig('my-server');
   * if (config) {
   *   console.log(`Command: ${config.command}`);
   *   console.log(`Args: ${config.args.join(' ')}`);
   * }
   * ```
   *
   * @see {@link getConfig} for retrieving the entire configuration
   */
  getServerConfig(name) {
    return this.config.mcpServers?.[name];
  }
  /**
   * Gets the complete client configuration.
   *
   * @returns Complete configuration object including all server definitions
   *
   * @example
   * ```typescript
   * const config = client.getConfig();
   * console.log(`Total servers: ${Object.keys(config.mcpServers).length}`);
   * ```
   *
   * @see {@link getServerConfig} for retrieving individual server configurations
   */
  getConfig() {
    return this.config ?? {};
  }
  /**
   * Creates a new session for connecting to an MCP server.
   *
   * This method initializes a connection to the specified server using the
   * configuration provided during client construction. Sessions manage the
   * lifecycle of connections and provide methods for calling tools, listing
   * resources, and more.
   *
   * If a session already exists for the server, it will be replaced with a new one.
   *
   * @param serverName - The name of the server as defined in the client configuration
   * @param autoInitialize - Whether to automatically initialize the session (default: true)
   * @returns A promise that resolves to the created MCPSession instance
   * @throws {Error} If the server is not found in the configuration
   *
   * @example
   * ```typescript
   * // Create and initialize a session
   * const session = await client.createSession('my-server');
   * const tools = await session.listTools();
   *
   * // Create without auto-initialization
   * const session = await client.createSession('my-server', false);
   * await session.connect();
   * await session.initialize();
   * ```
   *
   * @see {@link MCPSession} for session management methods
   * @see {@link closeSession} for closing sessions
   * @see {@link getSession} for retrieving existing sessions
   */
  async createSession(serverName, autoInitialize = true) {
    const servers = this.config.mcpServers ?? {};
    if (Object.keys(servers).length === 0) {
      logger.warn("No MCP servers defined in config");
    }
    if (!servers[serverName]) {
      throw new Error(`Server '${serverName}' not found in config`);
    }
    const connector = await Promise.resolve(
      this.createConnectorFromConfig(servers[serverName])
    );
    const session = new MCPSession(connector);
    if (autoInitialize) {
      await session.initialize();
    }
    this.sessions[serverName] = session;
    if (!this.activeSessions.includes(serverName)) {
      this.activeSessions.push(serverName);
    }
    return session;
  }
  /**
   * Creates sessions for all configured MCP servers.
   *
   * This is a convenience method that iterates through all servers in the
   * configuration and creates a session for each one. Sessions are created
   * sequentially to avoid overwhelming the system.
   *
   * @param autoInitialize - Whether to automatically initialize each session (default: true)
   * @returns A promise that resolves to a map of server names to sessions
   *
   * @example
   * ```typescript
   * // Create sessions for all configured servers
   * const sessions = await client.createAllSessions();
   * console.log(`Created ${Object.keys(sessions).length} sessions`);
   *
   * // List tools from all servers
   * for (const [name, session] of Object.entries(sessions)) {
   *   const tools = await session.listTools();
   *   console.log(`${name}: ${tools.length} tools`);
   * }
   * ```
   *
   * @see {@link createSession} for creating individual sessions
   * @see {@link closeAllSessions} for closing all sessions
   */
  async createAllSessions(autoInitialize = true) {
    const servers = this.config.mcpServers ?? {};
    if (Object.keys(servers).length === 0) {
      logger.warn("No MCP servers defined in config");
    }
    for (const name of Object.keys(servers)) {
      await this.createSession(name, autoInitialize);
    }
    return this.sessions;
  }
  /**
   * Retrieves an existing session by server name.
   *
   * This method returns null if no session exists, making it safe for
   * checking session existence without throwing errors.
   *
   * @param serverName - Name of the server
   * @returns The session instance or null if not found
   *
   * @example
   * ```typescript
   * const session = client.getSession('my-server');
   * if (session) {
   *   const tools = await session.listTools();
   * } else {
   *   console.log('Session not found, creating...');
   *   await client.createSession('my-server');
   * }
   * ```
   *
   * @see {@link requireSession} for getting a session that throws if not found
   * @see {@link createSession} for creating sessions
   */
  getSession(serverName) {
    const session = this.sessions[serverName];
    if (!session) {
      return null;
    }
    return session;
  }
  /**
   * Retrieves an existing session by server name, throwing if not found.
   *
   * This method is useful when you need to ensure a session exists before
   * proceeding. It throws a descriptive error if the session is not found.
   *
   * @param serverName - Name of the server
   * @returns The session instance
   * @throws {Error} If the session is not found
   *
   * @example
   * ```typescript
   * try {
   *   const session = client.requireSession('my-server');
   *   const tools = await session.listTools();
   * } catch (error) {
   *   console.error('Session not found:', error.message);
   * }
   * ```
   *
   * @see {@link getSession} for a null-returning alternative
   * @see {@link createSession} for creating sessions
   */
  requireSession(serverName) {
    const session = this.sessions[serverName];
    if (!session) {
      throw new Error(
        `Session '${serverName}' not found. Available sessions: ${this.activeSessions.join(", ") || "none"}`
      );
    }
    return session;
  }
  /**
   * Gets all active sessions as a map of server names to sessions.
   *
   * @returns Map of server names to their active sessions
   *
   * @example
   * ```typescript
   * const sessions = client.getAllActiveSessions();
   *
   * // Iterate over all active sessions
   * for (const [name, session] of Object.entries(sessions)) {
   *   console.log(`Server: ${name}`);
   *   const tools = await session.listTools();
   *   console.log(`  Tools: ${tools.length}`);
   * }
   * ```
   *
   * @see {@link activeSessions} for just the list of server names
   * @see {@link getSession} for retrieving individual sessions
   */
  getAllActiveSessions() {
    return Object.fromEntries(
      this.activeSessions.map((n) => [n, this.sessions[n]])
    );
  }
  /**
   * Closes a session and cleans up its resources.
   *
   * This method gracefully disconnects from the server and removes the
   * session from the active sessions list. It's safe to call even if
   * the session doesn't exist.
   *
   * @param serverName - Name of the server whose session should be closed
   *
   * @example
   * ```typescript
   * // Close a specific session
   * await client.closeSession('my-server');
   *
   * // Verify it's closed
   * console.log(client.activeSessions.includes('my-server')); // false
   * ```
   *
   * @see {@link closeAllSessions} for closing all sessions at once
   * @see {@link createSession} for creating new sessions
   */
  async closeSession(serverName) {
    const session = this.sessions[serverName];
    if (!session) {
      logger.warn(
        `No session exists for server ${serverName}, nothing to close`
      );
      return;
    }
    try {
      logger.debug(`Closing session for server ${serverName}`);
      await session.disconnect();
    } catch (e) {
      logger.error(`Error closing session for server '${serverName}': ${e}`);
    } finally {
      delete this.sessions[serverName];
      this.activeSessions = this.activeSessions.filter((n) => n !== serverName);
    }
  }
  /**
   * Closes all active sessions and cleans up their resources.
   *
   * This method iterates through all sessions and attempts to close each one
   * gracefully. If any session fails to close, the error is logged but the
   * method continues to close remaining sessions.
   *
   * This is particularly useful for cleanup on application shutdown.
   *
   * @example
   * ```typescript
   * // Clean shutdown
   * try {
   *   await client.closeAllSessions();
   *   console.log('All sessions closed successfully');
   * } catch (error) {
   *   console.error('Error during cleanup:', error);
   * }
   * ```
   *
   * @example
   * ```typescript
   * // Use in application shutdown handler
   * process.on('SIGINT', async () => {
   *   console.log('Shutting down...');
   *   await client.closeAllSessions();
   *   process.exit(0);
   * });
   * ```
   *
   * @see {@link closeSession} for closing individual sessions
   * @see {@link createAllSessions} for creating sessions
   */
  async closeAllSessions() {
    const serverNames = Object.keys(this.sessions);
    const errors = [];
    for (const serverName of serverNames) {
      try {
        logger.debug(`Closing session for server ${serverName}`);
        await this.closeSession(serverName);
      } catch (e) {
        const errorMsg = `Failed to close session for server '${serverName}': ${e}`;
        logger.error(errorMsg);
        errors.push(errorMsg);
      }
    }
    if (errors.length) {
      logger.error(
        `Encountered ${errors.length} errors while closing sessions`
      );
    } else {
      logger.debug("All sessions closed successfully");
    }
  }
};

// src/client/browser.ts
var BrowserMCPClient = class _BrowserMCPClient extends BaseMCPClient {
  static {
    __name(this, "BrowserMCPClient");
  }
  /**
   * Get the mcp-use package version.
   * Works in all environments (Node.js, browser, Cloudflare Workers, Deno, etc.)
   */
  static getPackageVersion() {
    return getPackageVersion();
  }
  constructor(config) {
    super(config);
    this._trackClientInit();
  }
  _trackClientInit() {
    const servers = Object.keys(this.config.mcpServers ?? {});
    Tel.getInstance().trackMCPClientInit({
      codeMode: false,
      // Browser client doesn't support code mode
      sandbox: false,
      // Sandbox not supported in browser
      allCallbacks: false,
      // Will be set per-server
      verify: false,
      servers,
      numServers: servers.length,
      isBrowser: true
      // Browser MCPClient
    }).catch(
      (e) => logger.debug(`Failed to track BrowserMCPClient init: ${e}`)
    );
  }
  static fromDict(cfg) {
    return new _BrowserMCPClient(cfg);
  }
  /**
   * Create a connector from server configuration (Browser version)
   * Supports HTTP connector only
   */
  createConnectorFromConfig(serverConfig) {
    const {
      url,
      headers,
      fetch: fetch2,
      authToken,
      authProvider,
      wrapTransport,
      clientOptions,
      disableSseFallback,
      preferSse,
      gatewayUrl,
      serverId
    } = serverConfig;
    if (!url) {
      throw new Error("Server URL is required");
    }
    const globalDefaults = this.config;
    const resolved = resolveCallbacks(
      serverConfig,
      globalDefaults
    );
    const clientInfo = normalizeClientInfo(
      serverConfig.clientInfo ?? this.config.clientInfo
    );
    const connectorOptions = {
      headers,
      fetch: fetch2,
      authToken,
      authProvider,
      wrapTransport,
      clientOptions,
      onSampling: resolved.onSampling,
      onElicitation: resolved.onElicitation,
      onNotification: resolved.onNotification,
      disableSseFallback,
      preferSse,
      clientInfo,
      gatewayUrl,
      serverId
    };
    logger.debug(
      `[BrowserMCPClient] Connector options prepared (clientOptions: ${clientOptions ? "provided" : "none"})`
    );
    return new HttpConnector(url, connectorOptions);
  }
};

// src/react/useMcp.ts
init_logging();

// src/utils/assert.ts
function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
__name(assert, "assert");

// src/utils/favicon-detector.ts
function isLocalServer(domain) {
  return domain === "localhost" || domain === "127.0.0.1" || domain.startsWith("127.") || domain.startsWith("192.168.") || domain.startsWith("10.") || domain.startsWith("172.");
}
__name(isLocalServer, "isLocalServer");
function getSubdomainLevels(hostname) {
  const parts = hostname.split(".");
  const levels = [];
  for (let i = 0; i < parts.length - 1; i++) {
    levels.push(parts.slice(i).join("."));
  }
  return levels;
}
__name(getSubdomainLevels, "getSubdomainLevels");
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      resolve(reader.result);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}
__name(blobToBase64, "blobToBase64");
async function detectFavicon(serverUrl) {
  console.debug(
    "[favicon-detector] Starting favicon detection for:",
    serverUrl
  );
  try {
    let domain;
    if (serverUrl.startsWith("http://") || serverUrl.startsWith("https://")) {
      domain = new URL(serverUrl).hostname;
    } else if (serverUrl.includes("://")) {
      domain = serverUrl.split("://")[1].split("/")[0];
    } else {
      domain = serverUrl.split("/")[0];
    }
    console.debug("[favicon-detector] Extracted domain:", domain);
    if (isLocalServer(domain)) {
      console.debug("[favicon-detector] Skipping local server:", domain);
      return null;
    }
    const domainsToTry = getSubdomainLevels(domain);
    console.debug("[favicon-detector] Domains to try:", domainsToTry);
    for (const currentDomain of domainsToTry) {
      try {
        const faviconApiUrl = `https://favicon.tools.mcp-use.com/${currentDomain}?response=json`;
        console.debug(
          "[favicon-detector] Attempting to fetch favicon metadata for:",
          currentDomain,
          "from:",
          faviconApiUrl
        );
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 2e3);
        try {
          const response = await fetch(faviconApiUrl, {
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (!response.ok) {
            console.debug(
              "[favicon-detector] Fetch failed for",
              currentDomain,
              "with status:",
              response.status
            );
            continue;
          }
          const data = await response.json();
          console.debug(
            "[favicon-detector] Retrieved favicon metadata for:",
            currentDomain,
            "source:",
            data.source
          );
          const imageUrl = data.url.replace(/^http:\/\//, "https://");
          const imageResponse = await fetch(imageUrl);
          if (!imageResponse.ok) {
            console.debug(
              "[favicon-detector] Failed to fetch favicon image for",
              currentDomain,
              "status:",
              imageResponse.status
            );
            continue;
          }
          const blob = await imageResponse.blob();
          const base64Image = await blobToBase64(blob);
          if (data.source === "default") {
            console.debug(
              "[favicon-detector] Found default favicon for:",
              currentDomain,
              "skipping and continuing to search for non-default"
            );
            continue;
          }
          console.debug(
            "[favicon-detector] Successfully retrieved non-default favicon for:",
            currentDomain,
            "source:",
            data.source,
            "size:",
            blob.size,
            "bytes"
          );
          return base64Image;
        } catch (err) {
          clearTimeout(timeoutId);
          console.debug(
            "[favicon-detector] Fetch error for",
            currentDomain,
            ":",
            err instanceof Error ? err.message : String(err)
          );
          continue;
        }
      } catch (error) {
        console.debug(
          "[favicon-detector] Error processing domain",
          currentDomain,
          ":",
          error instanceof Error ? error.message : String(error)
        );
        continue;
      }
    }
    console.debug(
      "[favicon-detector] No non-default favicon found for:",
      serverUrl,
      "returning null to show gradient fallback"
    );
    return null;
  } catch (error) {
    console.warn("[favicon-detector] Error detecting favicon:", error);
    return null;
  }
}
__name(detectFavicon, "detectFavicon");

// src/utils/proxy-config.ts
function applyProxyConfig(originalUrl, proxyConfig) {
  const proxyHeaders = proxyConfig?.headers ?? proxyConfig?.customHeaders ?? {};
  if (proxyConfig?.customHeaders && !proxyConfig?.headers) {
    console.warn(
      '[applyProxyConfig] The "customHeaders" option in proxyConfig is deprecated. Use "headers" instead.'
    );
  }
  if (!proxyConfig?.proxyAddress) {
    return {
      url: originalUrl,
      headers: proxyHeaders
    };
  }
  const proxyUrl = new URL(proxyConfig.proxyAddress);
  const targetUrl = new URL(originalUrl);
  const finalUrl = `${proxyUrl.origin}${proxyUrl.pathname}${targetUrl.pathname}${targetUrl.search}`;
  const headers = {
    "X-Target-URL": originalUrl,
    ...proxyHeaders
  };
  return { url: finalUrl, headers };
}
__name(applyProxyConfig, "applyProxyConfig");

// src/utils/url-sanitize.ts
function sanitizeUrl(raw) {
  const abort = /* @__PURE__ */ __name(() => {
    throw new Error(`Invalid url to pass to open(): ${raw}`);
  }, "abort");
  let url;
  try {
    url = new URL(raw);
  } catch (_) {
    abort();
  }
  if (url.protocol !== "https:" && url.protocol !== "http:") abort();
  if (url.hostname !== encodeURIComponent(url.hostname)) abort();
  if (url.username) url.username = encodeURIComponent(url.username);
  if (url.password) url.password = encodeURIComponent(url.password);
  url.pathname = url.pathname.slice(0, 1) + encodeURIComponent(url.pathname.slice(1)).replace(/%2f/gi, "/");
  url.search = url.search.slice(0, 1) + Array.from(url.searchParams.entries()).map(sanitizeParam).join("&");
  url.hash = url.hash.slice(0, 1) + encodeURIComponent(url.hash.slice(1));
  return url.href;
}
__name(sanitizeUrl, "sanitizeUrl");
function sanitizeParam([k, v]) {
  return `${encodeURIComponent(k)}${v.length > 0 ? `=${encodeURIComponent(v)}` : ""}`;
}
__name(sanitizeParam, "sanitizeParam");

// src/auth/browser-provider.ts
var import_auth2 = require("@modelcontextprotocol/sdk/client/auth.js");
async function serializeBody(body) {
  if (typeof body === "string") return body;
  if (body instanceof URLSearchParams || body instanceof FormData) {
    return Object.fromEntries(body.entries());
  }
  if (body instanceof Blob) return await body.text();
  return body;
}
__name(serializeBody, "serializeBody");
var BrowserOAuthClientProvider = class {
  static {
    __name(this, "BrowserOAuthClientProvider");
  }
  serverUrl;
  storageKeyPrefix;
  serverUrlHash;
  clientName;
  clientUri;
  logoUri;
  callbackUrl;
  preventAutoAuth;
  useRedirectFlow;
  oauthProxyUrl;
  connectionUrl;
  // MCP proxy URL that client connected to
  originalFetch;
  _cachedAuthServerUrl = null;
  _cachedMetadata = null;
  _refreshPromise = null;
  onPopupWindow;
  constructor(serverUrl, options = {}) {
    this.serverUrl = serverUrl;
    this.storageKeyPrefix = options.storageKeyPrefix || "mcp:auth";
    this.serverUrlHash = this.hashString(serverUrl);
    this.clientName = options.clientName || "mcp-use";
    this.clientUri = options.clientUri || (typeof window !== "undefined" ? window.location.origin : "");
    this.logoUri = options.logoUri || "https://mcp-use.com/logo.png";
    this.callbackUrl = sanitizeUrl(
      options.callbackUrl || (typeof window !== "undefined" ? new URL("/oauth/callback", window.location.origin).toString() : "/oauth/callback")
    );
    this.preventAutoAuth = options.preventAutoAuth;
    this.useRedirectFlow = options.useRedirectFlow;
    this.oauthProxyUrl = options.oauthProxyUrl;
    this.connectionUrl = options.connectionUrl;
    this.onPopupWindow = options.onPopupWindow;
  }
  /**
   * Install fetch interceptor to proxy OAuth requests through the backend
   */
  installFetchInterceptor() {
    if (!this.oauthProxyUrl) {
      console.warn(
        "[BrowserOAuthProvider] No OAuth proxy URL configured, skipping fetch interceptor installation"
      );
      return;
    }
    if (!this.originalFetch) {
      this.originalFetch = window.fetch;
    } else {
      console.warn(
        "[BrowserOAuthProvider] Fetch interceptor already installed"
      );
      return;
    }
    const oauthProxyUrl = this.oauthProxyUrl;
    const connectionUrl = this.connectionUrl;
    const serverUrl = this.serverUrl;
    const originalFetch = this.originalFetch;
    console.log(
      `[BrowserOAuthProvider] Installing fetch interceptor with proxy: ${oauthProxyUrl}`
    );
    window.fetch = /* @__PURE__ */ __name(async function interceptedFetch(input, init) {
      const url = typeof input === "string" ? input : input instanceof URL ? input.toString() : input.url;
      const isOAuthRequest = url.includes("/.well-known/") || url.match(/\/(register|token|authorize)$/);
      if (!isOAuthRequest) {
        return await originalFetch(input, init);
      }
      try {
        const urlObj = new URL(url);
        const proxyUrlObj = new URL(oauthProxyUrl);
        if (urlObj.origin === proxyUrlObj.origin && (urlObj.pathname.startsWith(proxyUrlObj.pathname) || url.includes("/inspector/api/oauth"))) {
          return await originalFetch(input, init);
        }
      } catch {
      }
      try {
        const isMetadata = url.includes("/.well-known/");
        let metadataUrl = url;
        if (isMetadata && serverUrl) {
          try {
            const urlObj = new URL(url);
            const serverUrlObj = new URL(serverUrl);
            if (urlObj.protocol === "http:" && serverUrlObj.protocol === "https:") {
              const pathMatch = urlObj.pathname.match(/(\/.well-known\/[^/]+)/);
              const wellKnownPath = pathMatch ? pathMatch[1] : urlObj.pathname;
              metadataUrl = `${serverUrlObj.origin}${wellKnownPath}`;
              console.log(
                `[OAuth Proxy] Rewrote gateway metadata URL ${url} to server URL ${metadataUrl}`
              );
            } else if (connectionUrl) {
              const connectionUrlObj = new URL(connectionUrl);
              if (urlObj.origin === connectionUrlObj.origin && urlObj.origin !== serverUrlObj.origin) {
                const pathMatch = urlObj.pathname.match(
                  /(\/.well-known\/[^/]+)/
                );
                const wellKnownPath = pathMatch ? pathMatch[1] : urlObj.pathname;
                metadataUrl = `${serverUrlObj.origin}${wellKnownPath}`;
                console.log(
                  `[OAuth Proxy] Rewrote gateway metadata URL ${url} to server URL ${metadataUrl}`
                );
              }
            }
          } catch (e) {
            console.error(`[OAuth Proxy] Error rewriting metadata URL:`, e);
          }
        }
        const proxyEndpoint = isMetadata ? `${oauthProxyUrl}/metadata?url=${encodeURIComponent(metadataUrl)}` : `${oauthProxyUrl}/proxy`;
        console.log(
          `[OAuth Proxy] Routing ${isMetadata ? "metadata" : "request"} through: ${proxyEndpoint}`
        );
        if (isMetadata) {
          const headers = {
            ...init?.headers ? Object.fromEntries(new Headers(init.headers)) : {}
          };
          if (connectionUrl) {
            headers["X-Connection-URL"] = connectionUrl;
          }
          const proxyUrl = new URL(proxyEndpoint);
          if (serverUrl) {
            proxyUrl.searchParams.set("mcp_url", serverUrl);
          }
          return await originalFetch(proxyUrl.toString(), {
            ...init,
            method: "GET",
            headers
          });
        }
        let requestUrl = url;
        if (url.includes("/authorize") && serverUrl) {
          try {
            const urlObj = new URL(url);
            const resourceParam = urlObj.searchParams.get("resource");
            if (resourceParam && connectionUrl) {
              const connectionUrlObj = new URL(connectionUrl);
              if (resourceParam.startsWith(connectionUrlObj.origin) || resourceParam === connectionUrl) {
                urlObj.searchParams.set("resource", serverUrl);
                requestUrl = urlObj.toString();
                console.log(
                  `[OAuth Proxy] Rewrote authorize resource parameter from ${resourceParam} to ${serverUrl}`
                );
              }
            }
          } catch (e) {
            console.error(`[OAuth Proxy] Error rewriting authorize URL:`, e);
          }
        }
        let body = init?.body ? await serializeBody(init.body) : void 0;
        if (url.includes("/token") && serverUrl && connectionUrl && body) {
          try {
            const params = new URLSearchParams(body);
            const resourceParam = params.get("resource");
            if (resourceParam) {
              const connectionUrlObj = new URL(connectionUrl);
              if (resourceParam.startsWith(connectionUrlObj.origin) || resourceParam === connectionUrl) {
                params.set("resource", serverUrl);
                body = params.toString();
                console.log(
                  `[OAuth Proxy] Rewrote token resource parameter from ${resourceParam} to ${serverUrl}`
                );
              }
            }
          } catch (e) {
            console.error(`[OAuth Proxy] Error rewriting token body:`, e);
          }
        }
        const response = await originalFetch(proxyEndpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            url: requestUrl,
            method: init?.method || "POST",
            headers: init?.headers ? Object.fromEntries(new Headers(init.headers)) : {},
            body
          })
        });
        const data = await response.json();
        return new Response(JSON.stringify(data.body), {
          status: data.status,
          statusText: data.statusText,
          headers: new Headers(data.headers)
        });
      } catch (error) {
        console.error(
          "[OAuth Proxy] Request failed, falling back to direct fetch:",
          error
        );
        return await originalFetch(input, init);
      }
    }, "interceptedFetch");
  }
  /**
   * Restore original fetch after OAuth flow completes
   */
  restoreFetch() {
    if (this.originalFetch) {
      console.log("[BrowserOAuthProvider] Restoring original fetch");
      window.fetch = this.originalFetch;
      this.originalFetch = void 0;
    }
  }
  // --- SDK Interface Methods ---
  get redirectUrl() {
    return sanitizeUrl(this.callbackUrl);
  }
  get clientMetadata() {
    return {
      redirect_uris: [this.redirectUrl],
      token_endpoint_auth_method: "none",
      // Public client
      grant_types: ["authorization_code", "refresh_token"],
      response_types: ["code"],
      client_name: this.clientName,
      client_uri: this.clientUri,
      logo_uri: this.logoUri
      // scope: 'openid profile email mcp', // Example scopes, adjust as needed
    };
  }
  async clientInformation() {
    const key = this.getKey("client_info");
    const data = localStorage.getItem(key);
    if (!data) return void 0;
    try {
      return JSON.parse(data);
    } catch (e) {
      console.warn(
        `[${this.storageKeyPrefix}] Failed to parse client information:`,
        e
      );
      localStorage.removeItem(key);
      return void 0;
    }
  }
  // NOTE: The SDK's auth() function uses this if dynamic registration is needed.
  // Ensure your OAuthClientInformationFull matches the expected structure if DCR is used.
  async saveClientInformation(clientInformation) {
    const key = this.getKey("client_info");
    localStorage.setItem(key, JSON.stringify(clientInformation));
  }
  async tokens() {
    const key = this.getKey("tokens");
    const data = localStorage.getItem(key);
    if (!data) return void 0;
    try {
      const tokens = JSON.parse(data);
      if (tokens.access_token && tokens.refresh_token) {
        try {
          const payload = JSON.parse(atob(tokens.access_token.split(".")[1]));
          if (payload.exp && Date.now() >= (payload.exp - 30) * 1e3) {
            console.log("[tokens] Access token expiring soon, refreshing...");
            const refreshed = await this._dedupedRefresh(tokens);
            if (refreshed) {
              console.log("[tokens] Refreshed successfully");
              return refreshed;
            }
          }
        } catch {
        }
      }
      return tokens;
    } catch (e) {
      console.warn(`[${this.storageKeyPrefix}] Failed to parse tokens:`, e);
      localStorage.removeItem(key);
      return void 0;
    }
  }
  async saveTokens(tokens) {
    const key = this.getKey("tokens");
    localStorage.setItem(key, JSON.stringify(tokens));
    localStorage.removeItem(this.getKey("code_verifier"));
    localStorage.removeItem(this.getKey("last_auth_url"));
  }
  async _refresh(tokens) {
    try {
      if (!this._cachedAuthServerUrl || !this._cachedMetadata) {
        const resourceMetadata = await (0, import_auth2.discoverOAuthProtectedResourceMetadata)(
          this.serverUrl
        );
        const authServerUrl = resourceMetadata.authorization_servers?.[0];
        if (!authServerUrl) return null;
        const metadata = await (0, import_auth2.discoverAuthorizationServerMetadata)(authServerUrl);
        if (!metadata) return null;
        this._cachedAuthServerUrl = authServerUrl;
        this._cachedMetadata = metadata;
      }
      const clientInfo = await this.clientInformation();
      if (!clientInfo) return null;
      const newTokens = await (0, import_auth2.refreshAuthorization)(this._cachedAuthServerUrl, {
        metadata: this._cachedMetadata,
        clientInformation: clientInfo,
        refreshToken: tokens.refresh_token
      });
      await this.saveTokens(newTokens);
      return newTokens;
    } catch {
      return null;
    }
  }
  async _dedupedRefresh(tokens) {
    if (this._refreshPromise) return this._refreshPromise;
    this._refreshPromise = this._refresh(tokens);
    try {
      return await this._refreshPromise;
    } finally {
      this._refreshPromise = null;
    }
  }
  async invalidateCredentials(scope) {
    switch (scope) {
      case "all":
        localStorage.removeItem(this.getKey("tokens"));
        localStorage.removeItem(this.getKey("client_info"));
        localStorage.removeItem(this.getKey("code_verifier"));
        localStorage.removeItem(this.getKey("last_auth_url"));
        break;
      case "client":
        localStorage.removeItem(this.getKey("client_info"));
        break;
      case "tokens":
        localStorage.removeItem(this.getKey("tokens"));
        break;
      case "verifier":
        localStorage.removeItem(this.getKey("code_verifier"));
        break;
      default:
        break;
    }
  }
  async saveCodeVerifier(codeVerifier) {
    const key = this.getKey("code_verifier");
    localStorage.setItem(key, codeVerifier);
  }
  async codeVerifier() {
    const key = this.getKey("code_verifier");
    const verifier = localStorage.getItem(key);
    if (!verifier) {
      throw new Error(
        `[${this.storageKeyPrefix}] Code verifier not found in storage for key ${key}. Auth flow likely corrupted or timed out.`
      );
    }
    return verifier;
  }
  /**
   * Generates and stores the authorization URL with state, without opening a popup.
   * Used when preventAutoAuth is enabled to provide the URL for manual navigation.
   * @param authorizationUrl The fully constructed authorization URL from the SDK.
   * @returns The full authorization URL with state parameter.
   */
  async prepareAuthorizationUrl(authorizationUrl) {
    if (this.connectionUrl && this.serverUrl) {
      const resourceParam = authorizationUrl.searchParams.get("resource");
      if (resourceParam) {
        try {
          const connectionUrlObj = new URL(this.connectionUrl);
          if (resourceParam.startsWith(connectionUrlObj.origin) || resourceParam === this.connectionUrl) {
            authorizationUrl.searchParams.set("resource", this.serverUrl);
            console.log(
              `[OAuth] Rewrote authorize resource parameter from ${resourceParam} to ${this.serverUrl}`
            );
          }
        } catch (e) {
          console.error(`[OAuth] Error rewriting resource parameter:`, e);
        }
      }
    }
    const state = globalThis.crypto.randomUUID();
    const stateKey = `${this.storageKeyPrefix}:state_${state}`;
    const stateData = {
      serverUrlHash: this.serverUrlHash,
      expiry: Date.now() + 1e3 * 60 * 10,
      // State expires in 10 minutes
      // Store provider options needed to reconstruct on callback
      providerOptions: {
        serverUrl: this.serverUrl,
        storageKeyPrefix: this.storageKeyPrefix,
        clientName: this.clientName,
        clientUri: this.clientUri,
        callbackUrl: this.callbackUrl,
        // Include OAuth proxy settings so callback can bypass CORS for token exchange
        oauthProxyUrl: this.oauthProxyUrl,
        connectionUrl: this.connectionUrl
      },
      // Store flow type so callback knows how to handle the response
      flowType: this.useRedirectFlow ? "redirect" : "popup",
      // Always store current URL so we can return to it after auth
      // This is critical for popup flow when popup is blocked and user clicks link manually
      returnUrl: typeof window !== "undefined" ? window.location.href : void 0
    };
    console.log(`[OAuth] Storing state key: ${stateKey}`);
    localStorage.setItem(stateKey, JSON.stringify(stateData));
    const verified = localStorage.getItem(stateKey);
    console.log(`[OAuth] State stored successfully: ${!!verified}`);
    authorizationUrl.searchParams.set("state", state);
    const authUrlString = authorizationUrl.toString();
    const sanitizedAuthUrl = sanitizeUrl(authUrlString);
    localStorage.setItem(this.getKey("last_auth_url"), sanitizedAuthUrl);
    return sanitizedAuthUrl;
  }
  /**
   * Redirects the user agent to the authorization URL, storing necessary state.
   * This now adheres to the SDK's void return type expectation for the interface.
   * @param authorizationUrl The fully constructed authorization URL from the SDK.
   */
  async redirectToAuthorization(authorizationUrl) {
    const sanitizedAuthUrl = await this.prepareAuthorizationUrl(authorizationUrl);
    if (this.preventAutoAuth) {
      console.info(
        `[${this.storageKeyPrefix}] Auto-auth prevented. Authorization URL stored for manual trigger.`
      );
      return;
    }
    if (this.useRedirectFlow) {
      console.info(
        `[${this.storageKeyPrefix}] Redirecting to authorization URL (full-page redirect).`
      );
      window.location.href = sanitizedAuthUrl;
      return;
    }
    const popupFeatures = "width=600,height=700,resizable=yes,scrollbars=yes,status=yes";
    try {
      const popup = window.open(
        sanitizedAuthUrl,
        `mcp_auth_${this.serverUrlHash}`,
        popupFeatures
      );
      if (this.onPopupWindow) {
        this.onPopupWindow(sanitizedAuthUrl, popupFeatures, popup);
      }
      if (!popup || popup.closed || typeof popup.closed === "undefined") {
        console.warn(
          `[${this.storageKeyPrefix}] Popup likely blocked by browser. Manual navigation might be required using the stored URL.`
        );
      } else {
        popup.focus();
        console.info(
          `[${this.storageKeyPrefix}] Redirecting to authorization URL in popup.`
        );
      }
    } catch (e) {
      console.error(
        `[${this.storageKeyPrefix}] Error opening popup window:`,
        e
      );
    }
  }
  // --- Helper Methods ---
  /**
   * Retrieves the last URL passed to `redirectToAuthorization`. Useful for manual fallback.
   */
  getLastAttemptedAuthUrl() {
    const storedUrl = localStorage.getItem(this.getKey("last_auth_url"));
    return storedUrl ? sanitizeUrl(storedUrl) : null;
  }
  clearStorage() {
    const prefixPattern = `${this.storageKeyPrefix}_${this.serverUrlHash}_`;
    const statePattern = `${this.storageKeyPrefix}:state_`;
    const keysToRemove = [];
    let count = 0;
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (!key) continue;
      if (key.startsWith(prefixPattern)) {
        keysToRemove.push(key);
      } else if (key.startsWith(statePattern)) {
        try {
          const item = localStorage.getItem(key);
          if (item) {
            const state = JSON.parse(item);
            if (state.serverUrlHash === this.serverUrlHash) {
              keysToRemove.push(key);
            }
          }
        } catch (e) {
          console.warn(
            `[${this.storageKeyPrefix}] Error parsing state key ${key} during clearStorage:`,
            e
          );
        }
      }
    }
    const uniqueKeysToRemove = [...new Set(keysToRemove)];
    uniqueKeysToRemove.forEach((key) => {
      localStorage.removeItem(key);
      count++;
    });
    return count;
  }
  hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(16);
  }
  getKey(keySuffix) {
    return `${this.storageKeyPrefix}_${this.serverUrlHash}_${keySuffix}`;
  }
};

// src/react/useMcp-helpers.ts
var USE_MCP_SERVER_NAME = "inspector-server";
function deriveOAuthClientConfigFromClientInfo(clientInfo) {
  return {
    name: clientInfo.name,
    version: clientInfo.version,
    uri: clientInfo.websiteUrl,
    logo_uri: clientInfo.icons?.[0]?.src
  };
}
__name(deriveOAuthClientConfigFromClientInfo, "deriveOAuthClientConfigFromClientInfo");
function isOAuthDiscoveryFailure(error) {
  const errorMessage = error instanceof Error ? error.message : String(error);
  const msg = errorMessage.toLowerCase();
  return msg.includes("oauth discovery failed") || msg.includes("oauth-authorization-server") || msg.includes("not valid json") || msg.includes("404") && (msg.includes("openid-configuration") || msg.includes("oauth-protected-resources") || msg.includes("oauth-authorization-url") || msg.includes("register")) || msg.includes("invalid oauth error response") && msg.includes("not found");
}
__name(isOAuthDiscoveryFailure, "isOAuthDiscoveryFailure");
function deriveOAuthProxyUrl(gatewayUrl) {
  if (!gatewayUrl) {
    return void 0;
  }
  const gatewayUrlObj = new URL(gatewayUrl);
  const basePath = gatewayUrlObj.pathname.replace(/\/proxy\/?$/, "");
  return `${gatewayUrlObj.origin}${basePath}/oauth`;
}
__name(deriveOAuthProxyUrl, "deriveOAuthProxyUrl");
function createBrowserOAuthProvider(params) {
  const oauthProxyUrl = deriveOAuthProxyUrl(params.gatewayUrl);
  const provider = new BrowserOAuthClientProvider(params.effectiveOAuthUrl, {
    storageKeyPrefix: params.storageKeyPrefix,
    clientName: params.oauthClientConfig.name,
    clientUri: params.oauthClientConfig.uri,
    logoUri: params.oauthClientConfig.logo_uri || "https://mcp-use.com/logo.png",
    callbackUrl: params.callbackUrl,
    preventAutoAuth: params.preventAutoAuth,
    useRedirectFlow: params.useRedirectFlow,
    oauthProxyUrl,
    connectionUrl: params.gatewayUrl,
    onPopupWindow: params.onPopupWindow
  });
  if (oauthProxyUrl && params.installFetchInterceptor) {
    provider.installFetchInterceptor();
  }
  return { provider, oauthProxyUrl };
}
__name(createBrowserOAuthProvider, "createBrowserOAuthProvider");
function startConnectionHealthMonitoring(params) {
  let healthCheckInterval = null;
  let lastSuccessfulCheck = Date.now();
  const healthCheckIntervalMs = params.healthCheckIntervalMs ?? 1e4;
  const healthCheckTimeoutMs = params.healthCheckTimeoutMs ?? 3e4;
  const checkConnectionHealth = /* @__PURE__ */ __name(async () => {
    if (!params.isMountedRef.current || params.stateRef.current !== "ready") {
      if (healthCheckInterval) {
        clearInterval(healthCheckInterval);
        healthCheckInterval = null;
      }
      return;
    }
    try {
      const healthCheckUrl = params.gatewayUrl || params.url;
      if (!healthCheckUrl) {
        return;
      }
      const authHeaders = params.getAuthHeaders ? await params.getAuthHeaders() : {};
      const response = await fetch(healthCheckUrl, {
        method: "HEAD",
        headers: { ...params.allHeaders, ...authHeaders },
        signal: AbortSignal.timeout(5e3)
      });
      if (response.ok || response.status < 500) {
        lastSuccessfulCheck = Date.now();
      } else {
        throw new Error(`Server returned ${response.status}`);
      }
    } catch {
      const timeSinceLastSuccess = Date.now() - lastSuccessfulCheck;
      if (timeSinceLastSuccess > healthCheckTimeoutMs) {
        params.addLog(
          "warn",
          `Connection appears to be broken (no response for ${Math.round(timeSinceLastSuccess / 1e3)}s), attempting to reconnect...`
        );
        if (healthCheckInterval) {
          clearInterval(healthCheckInterval);
          healthCheckInterval = null;
        }
        if (params.autoReconnectRef.current && params.isMountedRef.current) {
          params.setState("discovering");
          params.addLog("info", "Auto-reconnecting to MCP server...");
          setTimeout(
            () => {
              if (params.isMountedRef.current && params.stateRef.current === "discovering") {
                params.connect();
              }
            },
            typeof params.autoReconnectRef.current === "number" ? params.autoReconnectRef.current : params.defaultReconnectDelay
          );
        }
      }
    }
  }, "checkConnectionHealth");
  healthCheckInterval = setInterval(
    checkConnectionHealth,
    healthCheckIntervalMs
  );
  return () => {
    if (healthCheckInterval) {
      clearInterval(healthCheckInterval);
      healthCheckInterval = null;
    }
  };
}
__name(startConnectionHealthMonitoring, "startConnectionHealthMonitoring");

// src/react/useMcp.ts
var DEFAULT_RECONNECT_DELAY = 3e3;
var DEFAULT_RETRY_DELAY = 5e3;
function useMcp(options) {
  const {
    url,
    enabled = true,
    callbackUrl = typeof window !== "undefined" ? sanitizeUrl(
      new URL("/oauth/callback", window.location.origin).toString()
    ) : "/oauth/callback",
    storageKeyPrefix = "mcp:auth",
    clientConfig = {},
    authProvider: providedAuthProvider,
    headers: headersOption,
    customHeaders: customHeadersOption,
    proxyConfig,
    autoProxyFallback = true,
    debug: _debug = false,
    logLevel: logLevelOption,
    autoRetry = false,
    autoReconnect = DEFAULT_RECONNECT_DELAY,
    transportType = "auto",
    preventAutoAuth = true,
    // Default to true - require explicit user action for OAuth
    useRedirectFlow = false,
    // Default to false for backward compatibility (use popup)
    onPopupWindow,
    timeout = 3e4,
    // 30 seconds default for connection timeout
    sseReadTimeout = 3e5,
    // 5 minutes default for SSE read timeout
    wrapTransport,
    fetch: customFetch,
    clientOptions,
    onNotification,
    onSampling: onSamplingOption,
    samplingCallback: samplingCallbackOption,
    onElicitation: onElicitationOption,
    elicitationCallback: elicitationCallbackOption
  } = options;
  const instanceLogger = (0, import_react.useMemo)(() => {
    const name = `useMcp:${url || "no-url"}`;
    const inst = Logger.get(name);
    if (logLevelOption) {
      inst.level = logLevelOption;
    } else if (_debug) {
      inst.level = "debug";
    }
    return inst;
  }, [url, logLevelOption, _debug]);
  const headers = headersOption ?? customHeadersOption ?? {};
  if (customHeadersOption && !headersOption) {
    instanceLogger.warn(
      '[useMcp] The "customHeaders" option is deprecated. Use "headers" instead.'
    );
  }
  const onSampling = onSamplingOption ?? samplingCallbackOption;
  if (samplingCallbackOption && !onSamplingOption) {
    instanceLogger.warn(
      '[useMcp] The "samplingCallback" option is deprecated. Use "onSampling" instead.'
    );
  }
  const onElicitation = onElicitationOption ?? elicitationCallbackOption;
  if (elicitationCallbackOption && !onElicitationOption) {
    logger.warn(
      '[useMcp] The "elicitationCallback" option is deprecated. Use "onElicitation" instead.'
    );
  }
  const defaultClientInfo = (0, import_react.useMemo)(
    () => ({
      name: "mcp-use",
      title: "mcp-use",
      version: getPackageVersion(),
      description: "mcp-use is a complete TypeScript framework for building and using MCP",
      icons: [
        {
          src: "https://mcp-use.com/logo.png"
        }
      ],
      websiteUrl: "https://mcp-use.com"
    }),
    []
  );
  const mergedClientInfo = (0, import_react.useMemo)(
    () => options.clientInfo ? { ...defaultClientInfo, ...options.clientInfo } : defaultClientInfo,
    [options.clientInfo, defaultClientInfo]
  );
  const derivedOAuthClientConfig = (0, import_react.useMemo)(
    () => deriveOAuthClientConfigFromClientInfo(mergedClientInfo),
    [mergedClientInfo]
  );
  const oauthClientConfig = (0, import_react.useMemo)(() => {
    if (clientConfig && Object.keys(clientConfig).length > 0) {
      instanceLogger.warn(
        "[useMcp] The 'clientConfig' option is deprecated and will be removed in a future version. Use 'clientInfo' instead. The clientConfig will be automatically derived from clientInfo."
      );
      return { ...derivedOAuthClientConfig, ...clientConfig };
    }
    return derivedOAuthClientConfig;
  }, [clientConfig, derivedOAuthClientConfig]);
  const autoProxyFallbackConfig = (0, import_react.useMemo)(() => {
    if (!autoProxyFallback) {
      return { enabled: false, proxyAddress: void 0 };
    }
    if (typeof autoProxyFallback === "boolean") {
      return {
        enabled: autoProxyFallback,
        proxyAddress: "https://inspector.mcp-use.com/inspector/api/proxy"
      };
    }
    return {
      enabled: autoProxyFallback.enabled !== false,
      proxyAddress: autoProxyFallback.proxyAddress || "https://inspector.mcp-use.com/inspector/api/proxy"
    };
  }, [autoProxyFallback]);
  const hasTriedProxyFallbackRef = (0, import_react.useRef)(false);
  const [effectiveProxyConfig, setEffectiveProxyConfig] = (0, import_react.useState)(proxyConfig);
  (0, import_react.useEffect)(() => {
    setEffectiveProxyConfig(proxyConfig);
  }, [proxyConfig]);
  const { gatewayUrl, proxyHeaders } = (0, import_react.useMemo)(() => {
    const result = applyProxyConfig(url || "", proxyConfig);
    return {
      gatewayUrl: proxyConfig?.proxyAddress,
      proxyHeaders: result.headers
    };
  }, [url, proxyConfig]);
  const effectiveOAuthUrl = (0, import_react.useMemo)(() => {
    return url || "";
  }, [url]);
  const allHeaders = (0, import_react.useMemo)(
    () => ({ ...proxyHeaders, ...headers }),
    [proxyHeaders, headers]
  );
  const [state, setState] = (0, import_react.useState)("discovering");
  const [tools, setTools] = (0, import_react.useState)([]);
  const [resources, setResources] = (0, import_react.useState)([]);
  const [resourceTemplates, setResourceTemplates] = (0, import_react.useState)([]);
  const [prompts, setPrompts] = (0, import_react.useState)([]);
  const [serverInfo, setServerInfo] = (0, import_react.useState)(
    // Only use cached metadata if it has at least a name
    options._initialServerInfo?.name ? options._initialServerInfo : void 0
  );
  const [capabilities, setCapabilities] = (0, import_react.useState)();
  const [error, setError] = (0, import_react.useState)(void 0);
  const [log, setLog] = (0, import_react.useState)([]);
  const [authUrl, setAuthUrl] = (0, import_react.useState)(void 0);
  const [authTokens, setAuthTokens] = (0, import_react.useState)(void 0);
  const clientRef = (0, import_react.useRef)(null);
  const authProviderRef = (0, import_react.useRef)(
    providedAuthProvider ?? null
  );
  const iconLoadingPromiseRef = (0, import_react.useRef)(null);
  const connectingRef = (0, import_react.useRef)(false);
  const isMountedRef = (0, import_react.useRef)(true);
  const connectAttemptRef = (0, import_react.useRef)(0);
  const authTimeoutRef = (0, import_react.useRef)(null);
  const retryScheduledRef = (0, import_react.useRef)(false);
  const stateRef = (0, import_react.useRef)(state);
  const autoReconnectRef = (0, import_react.useRef)(autoReconnect);
  const successfulTransportRef = (0, import_react.useRef)(null);
  const connectRef = (0, import_react.useRef)(null);
  const failConnectionRef = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(() => {
    stateRef.current = state;
    autoReconnectRef.current = autoReconnect;
  }, [state, autoReconnect]);
  (0, import_react.useEffect)(() => {
    authProviderRef.current = providedAuthProvider ?? null;
  }, [providedAuthProvider]);
  const addLog = (0, import_react.useCallback)(
    (level, message, ...args) => {
      const fullMessage = args.length > 0 ? `${message} ${args.map((arg) => JSON.stringify(arg)).join(" ")}` : message;
      const logMsg = `[useMcp] ${fullMessage}`;
      switch (level) {
        case "error":
          instanceLogger.error(logMsg);
          break;
        case "warn":
          instanceLogger.warn(logMsg);
          break;
        case "info":
          instanceLogger.info(logMsg);
          break;
        case "debug":
          instanceLogger.debug(logMsg);
          break;
        default:
          instanceLogger.info(logMsg);
      }
      if (isMountedRef.current) {
        setLog((prevLog) => [
          ...prevLog.slice(-100),
          { level, message: fullMessage, timestamp: Date.now() }
        ]);
      }
    },
    [instanceLogger]
  );
  const disconnect = (0, import_react.useCallback)(
    async (quiet = false) => {
      if (!quiet) addLog("info", "Disconnecting...");
      connectingRef.current = false;
      if (authTimeoutRef.current) clearTimeout(authTimeoutRef.current);
      authTimeoutRef.current = null;
      if (clientRef.current) {
        try {
          const serverName = USE_MCP_SERVER_NAME;
          const session = clientRef.current.getSession(serverName);
          if (session && session._healthCheckCleanup) {
            session._healthCheckCleanup();
            session._healthCheckCleanup = null;
          }
          if (session) {
            await clientRef.current.closeSession(serverName);
          }
        } catch (err) {
          if (!quiet) addLog("warn", "Error closing session:", err);
        }
      }
      clientRef.current = null;
      if (isMountedRef.current && !quiet) {
        setState("discovering");
        setTools([]);
        setResources([]);
        setResourceTemplates([]);
        setPrompts([]);
        setError(void 0);
        setAuthUrl(void 0);
      }
    },
    [addLog]
  );
  const failConnection = (0, import_react.useCallback)(
    (errorMessage, connectionError) => {
      addLog("error", errorMessage, connectionError ?? "");
      const errorCode = connectionError && "code" in connectionError ? connectionError.code : void 0;
      const shouldTryProxyFallback = autoProxyFallbackConfig.enabled && !effectiveProxyConfig?.proxyAddress;
      const isCorsError = errorMessage.includes("CORS") || errorMessage.includes("blocked by CORS policy") || errorMessage.includes("Failed to fetch");
      const is400Error = errorCode === 400;
      const hasOther4xxError = typeof errorCode === "number" && errorCode >= 404 && errorCode < 500;
      const isAuthError = errorCode === 401 || errorCode === 403;
      const shouldFallback = shouldTryProxyFallback && (isCorsError || is400Error || hasOther4xxError) && !isAuthError;
      if (shouldFallback) {
        const errorType = isCorsError ? "CORS error" : is400Error ? "HTTP 400 (Bad Request)" : "HTTP 4xx error";
        addLog(
          "info",
          `Direct connection failed with ${errorType}. Trying with proxy...`
        );
        clientRef.current = null;
        if (!providedAuthProvider) {
          authProviderRef.current = null;
        }
        addLog("debug", "Cleared client and auth provider for proxy fallback");
        setEffectiveProxyConfig({
          proxyAddress: autoProxyFallbackConfig.proxyAddress
        });
        if (isMountedRef.current) {
          setState("discovering");
        }
        setTimeout(() => {
          if (isMountedRef.current) {
            connectRef.current?.();
          }
        }, 1e3);
        return true;
      }
      if (isMountedRef.current) {
        addLog("info", "Setting state to FAILED:", errorMessage);
        setState("failed");
        setError(errorMessage);
        const manualUrl = authProviderRef.current?.getLastAttemptedAuthUrl?.();
        if (manualUrl) {
          setAuthUrl(manualUrl);
          addLog(
            "info",
            "Manual authentication URL may be available.",
            manualUrl
          );
        }
      }
      connectingRef.current = false;
      if (url) {
        Tel.getInstance().trackUseMcpConnection({
          url,
          transportType,
          success: false,
          errorType: connectionError?.name || "UnknownError",
          hasOAuth: !!authProviderRef.current,
          hasSampling: !!onSampling,
          hasElicitation: !!onElicitation
        }).catch(() => {
        });
      }
      return false;
    },
    [
      addLog,
      url,
      transportType,
      onSampling,
      onElicitation,
      autoProxyFallbackConfig,
      effectiveProxyConfig,
      providedAuthProvider
    ]
  );
  const connect = (0, import_react.useCallback)(async () => {
    if (!enabled || !url) {
      addLog(
        "debug",
        enabled ? "No server URL provided, skipping connection." : "Connection disabled via enabled flag."
      );
      return;
    }
    if (connectingRef.current) {
      addLog("debug", "Connection attempt already in progress.");
      return;
    }
    if (!isMountedRef.current) {
      addLog("debug", "Connect called after unmount, aborting.");
      return;
    }
    connectingRef.current = true;
    connectAttemptRef.current += 1;
    setError(void 0);
    setAuthUrl(void 0);
    successfulTransportRef.current = null;
    setState("discovering");
    addLog(
      "info",
      `Connecting attempt #${connectAttemptRef.current} to ${url}...`
    );
    if (!authProviderRef.current) {
      const { provider, oauthProxyUrl } = createBrowserOAuthProvider({
        effectiveOAuthUrl,
        storageKeyPrefix,
        oauthClientConfig,
        callbackUrl,
        preventAutoAuth,
        useRedirectFlow,
        gatewayUrl,
        onPopupWindow,
        installFetchInterceptor: true
      });
      authProviderRef.current = provider;
      if (oauthProxyUrl) {
        addLog(
          "debug",
          `OAuth proxy URL derived from gateway: ${oauthProxyUrl}`
        );
      }
      addLog(
        "debug",
        `BrowserOAuthClientProvider initialized with URL: ${effectiveOAuthUrl}, proxy: ${oauthProxyUrl ? "enabled" : "disabled"}, gateway: ${gatewayUrl ? "enabled" : "disabled"}`
      );
    }
    if (!clientRef.current) {
      clientRef.current = new BrowserMCPClient();
      addLog("debug", "BrowserMCPClient initialized in connect.");
    } else {
      addLog("debug", "BrowserMCPClient already exists, reusing.");
    }
    const tryConnectWithTransport = /* @__PURE__ */ __name(async (transportTypeParam) => {
      if (!isMountedRef.current) {
        addLog("debug", "Connection attempt aborted - component unmounted");
        return "failed";
      }
      addLog(
        "info",
        `Attempting connection with transport: ${transportTypeParam}`
      );
      addLog(
        "debug",
        `Client ref status at start of tryConnectWithTransport: ${clientRef.current ? "initialized" : "NULL"}`
      );
      try {
        const serverName = USE_MCP_SERVER_NAME;
        const serverConfig = {
          url,
          // Use original URL, not transformed proxy URL
          transport: transportTypeParam === "sse" ? "http" : transportTypeParam,
          // Only disable SSE fallback when user explicitly set transportType: "http"
          // Don't disable it when we're in auto mode and just trying HTTP first
          disableSseFallback: transportType === "http",
          // Use SSE transport when explicitly requested
          preferSse: transportTypeParam === "sse",
          clientInfo: mergedClientInfo,
          // Pass custom fetch if provided (e.g., OAuth retry fetch for scope-step-up)
          ...customFetch && { fetch: customFetch },
          // Pass clientOptions for custom capabilities (e.g., MCP Apps extension)
          ...clientOptions && { clientOptions }
        };
        if (gatewayUrl) {
          serverConfig.gatewayUrl = gatewayUrl;
          addLog(
            "debug",
            `Using proxy gateway: ${gatewayUrl} for target: ${url}`
          );
        }
        if (allHeaders && Object.keys(allHeaders).length > 0) {
          serverConfig.headers = allHeaders;
        }
        if (!clientRef.current) {
          if (!isMountedRef.current) {
            addLog(
              "debug",
              "Connection aborted - component unmounted, client cleaned up"
            );
            return "failed";
          }
          const initError = new Error(
            "Client not initialized - this is a bug in the connection flow"
          );
          addLog(
            "error",
            "Client ref is null in tryConnectWithTransport but component is still mounted"
          );
          throw initError;
        }
        clientRef.current.addServer(serverName, {
          ...serverConfig,
          authProvider: authProviderRef.current,
          onSampling,
          onElicitation,
          wrapTransport: wrapTransport ? (transport) => {
            addLog(
              "debug",
              "Applying transport wrapper for server:",
              serverName,
              "url:",
              url
            );
            return wrapTransport(transport, url);
          } : void 0
        });
        const session = await clientRef.current.createSession(
          serverName,
          false
        );
        if (!isMountedRef.current) {
          addLog(
            "debug",
            "Connection aborted after session creation - component unmounted"
          );
          return "failed";
        }
        session.on("notification", (notification) => {
          addLog(
            "debug",
            "Notification received:",
            notification.method,
            notification
          );
          onNotification?.(notification);
          if (notification.method === "notifications/tools/list_changed") {
            addLog("info", "Tools list changed, auto-refreshing...");
            refreshTools().catch((err) => {
              addLog("warn", "Auto-refresh tools failed:", err);
            });
          } else if (notification.method === "notifications/resources/list_changed") {
            addLog("info", "Resources list changed, auto-refreshing...");
            refreshResources().catch(
              (err) => addLog("warn", "Auto-refresh resources failed:", err)
            );
          } else if (notification.method === "notifications/prompts/list_changed") {
            addLog("info", "Prompts list changed, auto-refreshing...");
            refreshPrompts().catch(
              (err) => addLog("warn", "Auto-refresh prompts failed:", err)
            );
          }
        });
        await session.initialize();
        if (!isMountedRef.current) {
          addLog(
            "debug",
            "Connection completed but component unmounted, aborting"
          );
          return "failed";
        }
        addLog("info", "\u2705 Successfully connected to MCP server");
        addLog("info", "Server info:", session.connector.serverInfo);
        addLog(
          "info",
          "Server capabilities:",
          session.connector.serverCapabilities
        );
        if (!isMountedRef.current) {
          addLog("debug", "Skipping state update - component unmounted");
          return "failed";
        }
        setState("ready");
        successfulTransportRef.current = transportTypeParam;
        if (autoReconnect) {
          const cleanup = startConnectionHealthMonitoring({
            gatewayUrl,
            url,
            allHeaders,
            getAuthHeaders: /* @__PURE__ */ __name(async () => {
              try {
                const tokens = await authProviderRef.current?.tokens?.();
                if (tokens?.access_token) {
                  const tokenType = tokens.token_type || "bearer";
                  return {
                    Authorization: `${tokenType.charAt(0).toUpperCase() + tokenType.slice(1)} ${tokens.access_token}`
                  };
                }
              } catch {
              }
              return {};
            }, "getAuthHeaders"),
            isMountedRef,
            stateRef,
            autoReconnectRef,
            setState,
            addLog,
            connect,
            defaultReconnectDelay: DEFAULT_RECONNECT_DELAY
          });
          session._healthCheckCleanup = cleanup;
        }
        Tel.getInstance().trackUseMcpConnection({
          url,
          transportType: transportTypeParam,
          success: true,
          hasOAuth: !!authProviderRef.current,
          hasSampling: !!onSampling,
          hasElicitation: !!onElicitation
        }).catch(() => {
        });
        setTools(session.connector.tools || []);
        const resourcesResult = await session.connector.listAllResources();
        if (!isMountedRef.current) {
          addLog(
            "debug",
            "Connection aborted after listing resources - component unmounted"
          );
          return "failed";
        }
        setResources(resourcesResult.resources || []);
        const promptsResult = await session.connector.listPrompts();
        if (!isMountedRef.current) {
          addLog(
            "debug",
            "Connection aborted after listing prompts - component unmounted"
          );
          return "failed";
        }
        setPrompts(promptsResult.prompts || []);
        const serverInfo2 = session.connector.serverInfo;
        const capabilities2 = session.connector.serverCapabilities;
        if (serverInfo2) {
          addLog("debug", "Server info:", serverInfo2);
          if (!isMountedRef.current) {
            addLog("debug", "Skipping state update - component unmounted");
            return "failed";
          }
          setServerInfo(serverInfo2);
          const loadIconPromise = (async () => {
            try {
              const serverIcons = serverInfo2.icons;
              if (serverIcons && Array.isArray(serverIcons) && serverIcons.length > 0) {
                const iconUrl = serverIcons[0].src || serverIcons[0].url;
                if (iconUrl) {
                  addLog("info", "Server provided icon:", iconUrl);
                  const res = await fetch(iconUrl);
                  const blob = await res.blob();
                  const base64 = await new Promise(
                    (resolve, reject) => {
                      const reader = new FileReader();
                      reader.onloadend = () => resolve(reader.result);
                      reader.onerror = reject;
                      reader.readAsDataURL(blob);
                    }
                  );
                  if (isMountedRef.current) {
                    setServerInfo(
                      (prev) => prev ? { ...prev, icon: base64 } : void 0
                    );
                    addLog("debug", "Server icon converted to base64");
                  }
                  return base64;
                }
              }
              if (url) {
                const faviconBase64 = await detectFavicon(url);
                if (!isMountedRef.current) {
                  addLog(
                    "debug",
                    "Connection aborted after favicon detection - component unmounted"
                  );
                  return null;
                }
                if (faviconBase64) {
                  setServerInfo(
                    (prev) => prev ? { ...prev, icon: faviconBase64 } : void 0
                  );
                  addLog("debug", "Favicon detected and added to serverInfo");
                  return faviconBase64;
                }
              }
              return null;
            } catch (err) {
              addLog("debug", "Icon loading failed (non-critical):", err);
              return null;
            }
          })();
          iconLoadingPromiseRef.current = loadIconPromise;
        }
        if (capabilities2) {
          addLog("debug", "Server capabilities:", capabilities2);
          if (!isMountedRef.current) {
            addLog("debug", "Skipping state update - component unmounted");
            return "failed";
          }
          setCapabilities(capabilities2);
        }
        if (authProviderRef.current) {
          const tokens = await authProviderRef.current.tokens?.();
          if (!isMountedRef.current) {
            addLog(
              "debug",
              "Connection aborted after token fetch for auth tokens - component unmounted"
            );
            return "failed";
          }
          if (tokens?.access_token) {
            const expiresAt = tokens.expires_in ? Date.now() + tokens.expires_in * 1e3 : void 0;
            if (!isMountedRef.current) {
              addLog("debug", "Skipping state update - component unmounted");
              return "failed";
            }
            setAuthTokens({
              access_token: tokens.access_token,
              token_type: tokens.token_type || "Bearer",
              expires_at: expiresAt,
              refresh_token: tokens.refresh_token,
              scope: tokens.scope
            });
          }
        }
        return "success";
      } catch (err) {
        const error2 = err;
        const errorMessage = error2?.message || String(err);
        const oauthDiscoveryFailed = isOAuthDiscoveryFailure(err);
        const is401Error = error2.code === 401 || errorMessage.includes("401") || errorMessage.includes("Unauthorized");
        if (oauthDiscoveryFailed && headers && Object.keys(headers).length > 0) {
          failConnection(
            "Authentication failed (HTTP 401). Server does not support OAuth. Check your Authorization header value is correct."
          );
          return "failed";
        }
        if (oauthDiscoveryFailed && (!headers || Object.keys(headers).length === 0)) {
          failConnection(
            "Authentication required (HTTP 401). Server does not support OAuth. Add an Authorization header in the Custom Headers section (e.g., Authorization: Bearer YOUR_API_KEY)."
          );
          return "failed";
        }
        if (is401Error) {
          if (oauthDiscoveryFailed) {
            failConnection(
              "Authentication required (HTTP 401). Server does not support OAuth. Add an Authorization header in the Custom Headers section (e.g., Authorization: Bearer YOUR_API_KEY)."
            );
            return "failed";
          }
          if (authProviderRef.current) {
            addLog(
              "info",
              "Authentication required. OAuth provider available."
            );
            if (preventAutoAuth) {
              addLog(
                "info",
                "Waiting for user to initiate authentication flow..."
              );
              if (isMountedRef.current) {
                setState("pending_auth");
                const storedAuthUrl = authProviderRef.current?.getLastAttemptedAuthUrl?.();
                if (storedAuthUrl) {
                  setAuthUrl(storedAuthUrl);
                  addLog(
                    "info",
                    "Retrieved stored auth URL for manual authentication"
                  );
                }
              }
              connectingRef.current = false;
              return "auth_redirect";
            } else {
              addLog(
                "info",
                "Triggering automatic OAuth authentication flow..."
              );
              try {
                const { resourceMetadataUrl, scope } = await probeAuthParams(url);
                const authResult = await (0, import_auth3.auth)(authProviderRef.current, {
                  serverUrl: url,
                  ...resourceMetadataUrl && { resourceMetadataUrl },
                  ...scope && { scope }
                });
                if (authResult === "REDIRECT") {
                  const authCode = await authProviderRef.current.getAuthorizationCode?.();
                  if (!authCode) {
                    throw new Error(
                      "Authorization code not captured by headless provider"
                    );
                  }
                  await (0, import_auth3.auth)(authProviderRef.current, {
                    serverUrl: url,
                    ...resourceMetadataUrl && { resourceMetadataUrl },
                    ...scope && { scope },
                    authorizationCode: authCode
                  });
                }
                addLog("info", "OAuth flow completed, reconnecting...");
                return await tryConnectWithTransport(transportTypeParam);
              } catch (authError) {
                const authErrorMessage = authError instanceof Error ? authError.message : String(authError);
                failConnection(
                  `Automatic OAuth authentication failed: ${authErrorMessage}`,
                  authError instanceof Error ? authError : new Error(String(authError))
                );
                return "failed";
              }
            }
          }
          if (headers && Object.keys(headers).length > 0) {
            failConnection(
              "Authentication failed: Server returned 401 Unauthorized. Check your Authorization header value is correct."
            );
            return "failed";
          }
          failConnection(
            "Authentication required: Server returned 401 Unauthorized. Add an Authorization header in the Custom Headers section (e.g., Authorization: Bearer YOUR_API_KEY)."
          );
          return "failed";
        }
        const isRetryingWithProxy = failConnection(
          errorMessage,
          error2 instanceof Error ? error2 : new Error(String(error2))
        );
        return isRetryingWithProxy ? "auth_redirect" : "failed";
      }
    }, "tryConnectWithTransport");
    let finalStatus = "failed";
    if (transportType === "sse") {
      addLog("debug", "Using SSE-only transport mode");
      finalStatus = await tryConnectWithTransport("sse");
    } else if (transportType === "http") {
      addLog("debug", "Using HTTP-only transport mode");
      finalStatus = await tryConnectWithTransport("http");
    } else {
      addLog("debug", "Using auto transport mode (HTTP with SSE fallback)");
      const httpResult = await tryConnectWithTransport("http");
      if (httpResult === "fallback" && isMountedRef.current && stateRef.current !== "authenticating") {
        addLog("info", "HTTP failed, attempting SSE fallback...");
        const sseResult = await tryConnectWithTransport("sse");
        finalStatus = sseResult;
      } else {
        finalStatus = httpResult;
      }
    }
    if (finalStatus === "success" || finalStatus === "failed" || finalStatus === "auth_redirect") {
      connectingRef.current = false;
    }
    addLog("debug", `Connection sequence finished with status: ${finalStatus}`);
  }, [
    addLog,
    failConnection,
    disconnect,
    url,
    storageKeyPrefix,
    callbackUrl,
    oauthClientConfig.name,
    oauthClientConfig.version,
    oauthClientConfig.uri,
    oauthClientConfig.logo_uri,
    headers,
    transportType,
    preventAutoAuth,
    useRedirectFlow,
    onPopupWindow,
    enabled,
    timeout,
    sseReadTimeout,
    mergedClientInfo,
    // IMPORTANT: Include proxy-related dependencies so connect() uses updated values after fallback
    gatewayUrl,
    allHeaders,
    effectiveOAuthUrl
  ]);
  (0, import_react.useEffect)(() => {
    connectRef.current = connect;
    failConnectionRef.current = failConnection;
  }, [connect, failConnection]);
  const callTool = (0, import_react.useCallback)(
    async (name, args, options2) => {
      if (stateRef.current !== "ready" || !clientRef.current) {
        throw new Error(
          `MCP client is not ready (current state: ${state}). Cannot call tool "${name}".`
        );
      }
      addLog("info", `Calling tool: ${name}`, args);
      const startTime = Date.now();
      try {
        const serverName = USE_MCP_SERVER_NAME;
        const session = clientRef.current.getSession(serverName);
        if (!session) {
          throw new Error("No active session found");
        }
        const result = await session.connector.callTool(
          name,
          args || {},
          options2
        );
        addLog("info", `Tool "${name}" call successful:`, result);
        Tel.getInstance().trackUseMcpToolCall({
          toolName: name,
          success: true,
          executionTimeMs: Date.now() - startTime
        }).catch(() => {
        });
        return result;
      } catch (err) {
        addLog("error", `Tool "${name}" call failed:`, err);
        Tel.getInstance().trackUseMcpToolCall({
          toolName: name,
          success: false,
          errorType: err instanceof Error ? err.name : "UnknownError",
          executionTimeMs: Date.now() - startTime
        }).catch(() => {
        });
        throw err;
      }
    },
    [state]
  );
  const retry = (0, import_react.useCallback)(() => {
    if (stateRef.current === "failed") {
      addLog("info", "Retry requested...");
      connectRef.current?.();
    } else {
      addLog(
        "warn",
        `Retry called but state is not 'failed' (state: ${stateRef.current}). Ignoring.`
      );
    }
  }, [addLog]);
  const authenticate = (0, import_react.useCallback)(async () => {
    addLog("info", "Manual authentication requested...");
    const currentState = stateRef.current;
    if (currentState === "failed") {
      addLog("info", "Attempting to reconnect and authenticate via retry...");
      retry();
    } else if (currentState === "pending_auth") {
      addLog("info", "Proceeding with authentication from pending state...");
      try {
        assert(
          authProviderRef.current,
          "Auth Provider not available for manual auth"
        );
        assert(url, "Server URL is required for authentication");
        if (providedAuthProvider) {
          addLog(
            "info",
            "Using provided authProvider for manual authentication"
          );
          const baseUrl2 = new URL(url).origin;
          await (0, import_auth3.auth)(authProviderRef.current, {
            serverUrl: baseUrl2
          });
          connectRef.current?.();
          return;
        }
        const clearedCount = authProviderRef.current.clearStorage?.() ?? 0;
        addLog(
          "info",
          `Cleared ${clearedCount} OAuth storage item(s) for fresh authentication`
        );
        setState("authenticating");
        const { provider: freshAuthProvider, oauthProxyUrl } = createBrowserOAuthProvider({
          effectiveOAuthUrl,
          storageKeyPrefix,
          oauthClientConfig,
          callbackUrl,
          preventAutoAuth: false,
          useRedirectFlow,
          gatewayUrl,
          onPopupWindow,
          installFetchInterceptor: !gatewayUrl
        });
        if (oauthProxyUrl && !gatewayUrl) {
          addLog("info", "Installed OAuth fetch interceptor for manual auth");
        } else if (oauthProxyUrl && gatewayUrl) {
          addLog(
            "info",
            "Using MCP gateway proxy for OAuth (no fetch interceptor needed)"
          );
        }
        authProviderRef.current = freshAuthProvider;
        addLog("info", "Triggering fresh OAuth authorization...");
        const baseUrl = new URL(url).origin;
        try {
          await (0, import_auth3.auth)(freshAuthProvider, {
            serverUrl: baseUrl
          });
          addLog("info", "OAuth flow completed (tokens obtained)");
        } catch (err) {
          addLog(
            "info",
            "OAuth flow initiated (popup/redirect):",
            err instanceof Error ? err.message : "Redirecting..."
          );
        }
        const newAuthUrl = freshAuthProvider.getLastAttemptedAuthUrl?.();
        if (newAuthUrl) {
          setAuthUrl(newAuthUrl);
          addLog("info", "Updated auth URL for fallback:", newAuthUrl);
        }
      } catch (authError) {
        if (!isMountedRef.current) return;
        setState("pending_auth");
        addLog(
          "error",
          `Manual authentication failed: ${authError instanceof Error ? authError.message : String(authError)}`
        );
      }
    } else if (currentState === "authenticating") {
      addLog(
        "warn",
        "Already attempting authentication. Check for blocked popups or wait for timeout."
      );
      const manualUrl = authProviderRef.current?.getLastAttemptedAuthUrl?.();
      if (manualUrl && !authUrl) {
        setAuthUrl(manualUrl);
        addLog("info", "Manual authentication URL retrieved:", manualUrl);
      }
    } else {
      addLog(
        "info",
        `Client not in a state requiring manual authentication trigger (state: ${currentState}). If needed, try disconnecting and reconnecting.`
      );
    }
  }, [
    addLog,
    retry,
    authUrl,
    url,
    useRedirectFlow,
    onPopupWindow,
    storageKeyPrefix,
    oauthClientConfig.name,
    oauthClientConfig.uri,
    oauthClientConfig.logo_uri,
    callbackUrl,
    mergedClientInfo,
    providedAuthProvider
  ]);
  const clearStorage = (0, import_react.useCallback)(() => {
    if (authProviderRef.current?.clearStorage) {
      const count = authProviderRef.current.clearStorage();
      addLog("info", `Cleared ${count} item(s) from localStorage for ${url}.`);
      setAuthUrl(void 0);
      disconnect();
    } else {
      addLog("warn", "Auth provider not initialized, cannot clear storage.");
    }
  }, [url, addLog, disconnect]);
  const listResources = (0, import_react.useCallback)(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      throw new Error(
        `MCP client is not ready (current state: ${state}). Cannot list resources.`
      );
    }
    addLog("info", "Listing resources");
    try {
      const serverName = USE_MCP_SERVER_NAME;
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        throw new Error("No active session found");
      }
      const resourcesResult = await session.connector.listAllResources();
      setResources(resourcesResult.resources || []);
      addLog("info", "Resources listed successfully");
    } catch (err) {
      addLog("error", "List resources failed:", err);
      throw err;
    }
  }, [state]);
  const readResource = (0, import_react.useCallback)(
    async (uri) => {
      if (stateRef.current !== "ready" || !clientRef.current) {
        throw new Error(
          `MCP client is not ready (current state: ${state}). Cannot read resource.`
        );
      }
      addLog("info", `Reading resource: ${uri}`);
      try {
        const serverName = USE_MCP_SERVER_NAME;
        const session = clientRef.current.getSession(serverName);
        if (!session) {
          throw new Error("No active session found");
        }
        const result = await session.connector.readResource(uri);
        addLog("info", "Resource read successful:", result);
        Tel.getInstance().trackUseMcpResourceRead({
          resourceUri: uri,
          success: true
        }).catch(() => {
        });
        return result;
      } catch (err) {
        addLog("error", "Resource read failed:", err);
        Tel.getInstance().trackUseMcpResourceRead({
          resourceUri: uri,
          success: false,
          errorType: err instanceof Error ? err.name : "UnknownError"
        }).catch(() => {
        });
        throw err;
      }
    },
    [state]
  );
  const listPrompts = (0, import_react.useCallback)(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      throw new Error(
        `MCP client is not ready (current state: ${state}). Cannot list prompts.`
      );
    }
    addLog("info", "Listing prompts");
    try {
      const serverName = USE_MCP_SERVER_NAME;
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        throw new Error("No active session found");
      }
      const promptsResult = await session.connector.listPrompts();
      setPrompts(promptsResult.prompts || []);
      addLog("info", "Prompts listed successfully");
    } catch (err) {
      addLog("error", "List prompts failed:", err);
      throw err;
    }
  }, [state]);
  const refreshTools = (0, import_react.useCallback)(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      addLog(
        "debug",
        "Cannot refresh tools - client not ready. State:",
        stateRef.current
      );
      return;
    }
    addLog("debug", "Refreshing tools list");
    try {
      const serverName = USE_MCP_SERVER_NAME;
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        addLog("warn", "No active session found for tools refresh");
        return;
      }
      addLog("debug", "Calling listTools...");
      const toolsResult = await session.connector.listTools();
      addLog("debug", "listTools returned:", toolsResult?.length, "tools");
      setTools(toolsResult || []);
      addLog("info", "Tools list refreshed successfully");
    } catch (err) {
      addLog("error", "Failed to refresh tools:", err);
    }
  }, [addLog]);
  const refreshResources = (0, import_react.useCallback)(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      addLog("debug", "Cannot refresh resources - client not ready");
      return;
    }
    addLog("debug", "Refreshing resources list");
    try {
      const serverName = USE_MCP_SERVER_NAME;
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        addLog("warn", "No active session found for resources refresh");
        return;
      }
      const resourcesResult = await session.connector.listAllResources();
      setResources(resourcesResult.resources || []);
      addLog("info", "Resources list refreshed successfully");
    } catch (err) {
      addLog("warn", "Failed to refresh resources:", err);
    }
  }, [addLog]);
  const refreshPrompts = (0, import_react.useCallback)(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      addLog("debug", "Cannot refresh prompts - client not ready");
      return;
    }
    addLog("debug", "Refreshing prompts list");
    try {
      const serverName = USE_MCP_SERVER_NAME;
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        addLog("warn", "No active session found for prompts refresh");
        return;
      }
      const promptsResult = await session.connector.listPrompts();
      setPrompts(promptsResult.prompts || []);
      addLog("info", "Prompts list refreshed successfully");
    } catch (err) {
      addLog("warn", "Failed to refresh prompts:", err);
    }
  }, [addLog]);
  const refreshAll = (0, import_react.useCallback)(async () => {
    addLog("info", "Refreshing all lists (tools, resources, prompts)");
    await Promise.all([refreshTools(), refreshResources(), refreshPrompts()]);
  }, [refreshTools, refreshResources, refreshPrompts, addLog]);
  const getPrompt = (0, import_react.useCallback)(
    async (name, args) => {
      if (stateRef.current !== "ready" || !clientRef.current) {
        throw new Error(
          `MCP client is not ready (current state: ${state}). Cannot get prompt.`
        );
      }
      addLog("info", `Getting prompt: ${name}`, args);
      try {
        const serverName = USE_MCP_SERVER_NAME;
        const session = clientRef.current.getSession(serverName);
        if (!session) {
          throw new Error("No active session found");
        }
        const result = await session.connector.getPrompt(name, args || {});
        addLog("info", `Prompt "${name}" retrieved successfully:`, result);
        return result;
      } catch (err) {
        addLog("error", `Prompt "${name}" retrieval failed:`, err);
        throw err;
      }
    },
    [state]
  );
  (0, import_react.useEffect)(() => {
    const messageHandler = /* @__PURE__ */ __name((event) => {
      if (event.origin !== window.location.origin) return;
      if (event.data?.type === "mcp_auth_callback") {
        addLog("info", "Received auth callback message.", event.data);
        if (authTimeoutRef.current) clearTimeout(authTimeoutRef.current);
        authTimeoutRef.current = null;
        if (event.data.success) {
          addLog(
            "info",
            "Authentication successful via popup. Reconnecting client..."
          );
          if (connectingRef.current) {
            addLog(
              "debug",
              "Connection attempt already in progress, resetting flag to allow reconnection."
            );
          }
          connectingRef.current = false;
          setTimeout(() => {
            if (isMountedRef.current) {
              addLog(
                "debug",
                "Initiating reconnection after successful auth callback."
              );
              connectRef.current?.();
            }
          }, 100);
        } else {
          failConnectionRef.current?.(
            `Authentication failed in callback: ${event.data.error || "Unknown reason."}`
          );
        }
      }
    }, "messageHandler");
    window.addEventListener("message", messageHandler);
    addLog("debug", "Auth callback message listener added.");
    return () => {
      window.removeEventListener("message", messageHandler);
      addLog("debug", "Auth callback message listener removed.");
      if (authTimeoutRef.current) clearTimeout(authTimeoutRef.current);
    };
  }, [addLog]);
  (0, import_react.useEffect)(() => {
    hasTriedProxyFallbackRef.current = false;
    setEffectiveProxyConfig(proxyConfig);
  }, [url, proxyConfig]);
  (0, import_react.useEffect)(() => {
    isMountedRef.current = true;
    if (!enabled || !url) {
      addLog(
        "debug",
        enabled ? "No server URL provided, skipping connection." : "Connection disabled via enabled flag."
      );
      setState("discovering");
      return () => {
        isMountedRef.current = false;
      };
    }
    addLog("debug", "useMcp mounted, initiating connection.");
    connectAttemptRef.current = 0;
    if (providedAuthProvider) {
      authProviderRef.current = providedAuthProvider;
      addLog("debug", "Using externally provided authProvider");
    } else if (!authProviderRef.current || authProviderRef.current.serverUrl !== effectiveOAuthUrl) {
      const { provider, oauthProxyUrl } = createBrowserOAuthProvider({
        effectiveOAuthUrl,
        storageKeyPrefix,
        oauthClientConfig,
        callbackUrl,
        preventAutoAuth,
        useRedirectFlow,
        gatewayUrl,
        onPopupWindow,
        installFetchInterceptor: true
      });
      authProviderRef.current = provider;
      if (oauthProxyUrl) {
        addLog(
          "debug",
          `OAuth proxy URL derived from gateway: ${oauthProxyUrl}`
        );
      }
      addLog(
        "debug",
        `BrowserOAuthClientProvider initialized/updated with URL: ${effectiveOAuthUrl}, proxy: ${oauthProxyUrl ? "enabled" : "disabled"}, gateway: ${gatewayUrl ? "enabled" : "disabled"}`
      );
    }
    connect();
    return () => {
      isMountedRef.current = false;
      addLog("debug", "useMcp unmounting, disconnecting.");
      if ((stateRef.current === "authenticating" || stateRef.current === "pending_auth") && authProviderRef.current) {
        try {
          const count = authProviderRef.current.clearStorage?.() ?? 0;
          if (count > 0) {
            addLog(
              "debug",
              `Cleared ${count} OAuth state item(s) during unmount to prevent corruption`
            );
          }
        } catch (err) {
          addLog("debug", "Error clearing OAuth state during unmount:", err);
        }
      }
      disconnect(true);
    };
  }, [
    url,
    enabled,
    storageKeyPrefix,
    callbackUrl,
    oauthClientConfig.name,
    oauthClientConfig.version,
    oauthClientConfig.uri,
    oauthClientConfig.logo_uri,
    useRedirectFlow,
    mergedClientInfo,
    effectiveOAuthUrl,
    // Triggers reconnection when proxy fallback changes OAuth URL
    proxyConfig,
    // Triggers reconnection when proxy config (including headers) changes
    providedAuthProvider
  ]);
  const retryRef = (0, import_react.useRef)(retry);
  const addLogRef = (0, import_react.useRef)(addLog);
  (0, import_react.useEffect)(() => {
    retryRef.current = retry;
    addLogRef.current = addLog;
  }, [retry, addLog]);
  (0, import_react.useEffect)(() => {
    let retryTimeoutId = null;
    if (state === "failed" && autoRetry && connectAttemptRef.current > 0) {
      if (!retryScheduledRef.current) {
        retryScheduledRef.current = true;
        const delay = typeof autoRetry === "number" ? autoRetry : DEFAULT_RETRY_DELAY;
        addLogRef.current(
          "info",
          `Connection failed, auto-retrying in ${delay}ms...`
        );
        retryTimeoutId = setTimeout(() => {
          retryScheduledRef.current = false;
          if (isMountedRef.current && stateRef.current === "failed") {
            retryRef.current();
          }
        }, delay);
      }
    } else if (state !== "failed") {
      retryScheduledRef.current = false;
    }
    return () => {
      if (retryTimeoutId) {
        clearTimeout(retryTimeoutId);
        retryScheduledRef.current = false;
      }
    };
  }, [state, autoRetry]);
  const ensureIconLoaded = (0, import_react.useCallback)(async () => {
    if (stateRef.current !== "ready") {
      addLog("warn", "Cannot ensure icon loaded - not connected");
      return null;
    }
    if (serverInfo?.icon) {
      return serverInfo.icon;
    }
    if (iconLoadingPromiseRef.current) {
      addLog("debug", "Waiting for icon to finish loading...");
      const icon = await iconLoadingPromiseRef.current;
      return icon;
    }
    addLog("debug", "No icon available and no loading in progress");
    return null;
  }, [serverInfo, addLog]);
  return {
    state,
    name: serverInfo?.name || url || "",
    tools,
    resources,
    resourceTemplates,
    prompts,
    serverInfo,
    capabilities,
    error,
    log,
    authUrl,
    authTokens,
    client: clientRef.current,
    callTool,
    readResource,
    listResources,
    listPrompts,
    getPrompt,
    refreshTools,
    refreshResources,
    refreshPrompts,
    refreshAll,
    retry,
    disconnect,
    authenticate,
    clearStorage,
    ensureIconLoaded
  };
}
__name(useMcp, "useMcp");

// src/auth/callback.ts
var import_auth4 = require("@modelcontextprotocol/sdk/client/auth.js");
async function onMcpAuthorization() {
  const queryParams = new URLSearchParams(window.location.search);
  const code = queryParams.get("code");
  const state = queryParams.get("state");
  const error = queryParams.get("error");
  const errorDescription = queryParams.get("error_description");
  const logPrefix = "[mcp-callback]";
  console.log(`${logPrefix} Handling callback...`, {
    code,
    state,
    error,
    errorDescription
  });
  let provider = null;
  let storedStateData = null;
  let stateKey = null;
  try {
    if (error) {
      throw new Error(
        `OAuth error: ${error} - ${errorDescription || "No description provided."}`
      );
    }
    if (!code) {
      throw new Error(
        "Authorization code not found in callback query parameters."
      );
    }
    if (!state) {
      throw new Error(
        "State parameter not found or invalid in callback query parameters."
      );
    }
    console.log(`[mcp-callback] Looking for state: ${state}`);
    console.log(
      `[mcp-callback] All localStorage keys:`,
      Object.keys(localStorage)
    );
    const defaultStateKey = `mcp:auth:state_${state}`;
    if (localStorage.getItem(defaultStateKey)) {
      stateKey = defaultStateKey;
      console.log(
        `[mcp-callback] Found state with default key: ${defaultStateKey}`
      );
    } else {
      const stateKeySuffix = `:state_${state}`;
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.endsWith(stateKeySuffix)) {
          stateKey = key;
          console.log(`[mcp-callback] Found state with dynamic key: ${key}`);
          break;
        }
      }
    }
    if (!stateKey) {
      const stateKeys = Object.keys(localStorage).filter(
        (k) => k.includes("state")
      );
      console.log(`[mcp-callback] State keys in storage:`, stateKeys);
      throw new Error(
        `Invalid or expired state parameter "${state}". No matching state found in storage.`
      );
    }
    const storedStateJSON = localStorage.getItem(stateKey);
    if (!storedStateJSON) {
      throw new Error(
        `Invalid or expired state parameter "${state}". No matching state found in storage.`
      );
    }
    try {
      storedStateData = JSON.parse(storedStateJSON);
    } catch (e) {
      throw new Error("Failed to parse stored OAuth state.");
    }
    if (!storedStateData.expiry || storedStateData.expiry < Date.now()) {
      localStorage.removeItem(stateKey);
      throw new Error(
        "OAuth state has expired. Please try initiating authentication again."
      );
    }
    if (!storedStateData.providerOptions) {
      throw new Error("Stored state is missing required provider options.");
    }
    const { serverUrl, ...providerOptions } = storedStateData.providerOptions;
    let oauthProxyUrl = providerOptions.oauthProxyUrl;
    const connectionUrl = providerOptions.connectionUrl;
    if (!oauthProxyUrl) {
      try {
        const callbackUrl = new URL(window.location.href);
        if (callbackUrl.pathname.includes("/oauth/callback")) {
          let basePath = callbackUrl.pathname.replace(
            /\/oauth\/callback.*$/,
            ""
          );
          if (!basePath || basePath === "") {
            basePath = "/inspector";
            console.log(
              `${logPrefix} Callback at root /oauth/callback, using /inspector as base path for OAuth proxy`
            );
          }
          oauthProxyUrl = `${callbackUrl.origin}${basePath}/api/oauth`;
          console.log(
            `${logPrefix} Inferred OAuth proxy URL from callback: ${oauthProxyUrl}`
          );
        }
      } catch (e) {
        console.warn(`${logPrefix} Could not infer OAuth proxy URL:`, e);
      }
    }
    console.log(
      `${logPrefix} Re-instantiating provider for server: ${serverUrl}`
    );
    provider = new BrowserOAuthClientProvider(serverUrl, {
      ...providerOptions,
      oauthProxyUrl,
      connectionUrl
    });
    if (oauthProxyUrl) {
      console.log(
        `${logPrefix} Installing fetch interceptor for token exchange (proxy: ${oauthProxyUrl})`
      );
      provider.installFetchInterceptor();
    }
    console.log(`${logPrefix} Calling SDK auth() to exchange code...`);
    const sdkServerUrl = connectionUrl || new URL(serverUrl).origin;
    console.log(
      `${logPrefix} Using SDK serverUrl: ${sdkServerUrl} (connectionUrl: ${connectionUrl || "none"})`
    );
    const authResult = await (0, import_auth4.auth)(provider, {
      serverUrl: sdkServerUrl,
      authorizationCode: code
    });
    if (authResult === "AUTHORIZED") {
      console.log(`${logPrefix} Authorization successful via SDK auth().`);
      const isRedirectFlow = storedStateData.flowType === "redirect";
      if (isRedirectFlow && storedStateData.returnUrl) {
        console.log(
          `${logPrefix} Redirect flow complete. Returning to: ${storedStateData.returnUrl}`
        );
        localStorage.removeItem(stateKey);
        window.location.href = storedStateData.returnUrl;
      } else if (window.opener && !window.opener.closed) {
        console.log(`${logPrefix} Popup flow complete. Notifying opener...`);
        window.opener.postMessage(
          { type: "mcp_auth_callback", success: true },
          window.location.origin
        );
        localStorage.removeItem(stateKey);
        window.close();
      } else if (storedStateData.returnUrl) {
        console.log(
          `${logPrefix} Popup flow without opener. Returning to: ${storedStateData.returnUrl}`
        );
        localStorage.removeItem(stateKey);
        window.location.href = storedStateData.returnUrl;
      } else {
        console.warn(
          `${logPrefix} No opener window or return URL detected. Redirecting to root.`
        );
        localStorage.removeItem(stateKey);
        const pathParts = window.location.pathname.split("/").filter(Boolean);
        const basePath = pathParts.length > 0 && pathParts[pathParts.length - 1] === "callback" ? "/" + pathParts.slice(0, -2).join("/") : "/";
        window.location.href = basePath || "/";
      }
    } else {
      console.warn(
        `${logPrefix} SDK auth() returned unexpected status: ${authResult}`
      );
      throw new Error(
        `Unexpected result from authentication library: ${authResult}`
      );
    }
  } catch (err) {
    console.error(`${logPrefix} Error during OAuth callback handling:`, err);
    const errorMessage = err instanceof Error ? err.message : String(err);
    if (window.opener && !window.opener.closed) {
      window.opener.postMessage(
        { type: "mcp_auth_callback", success: false, error: errorMessage },
        window.location.origin
      );
    }
    try {
      document.body.innerHTML = "";
      const container = document.createElement("div");
      container.style.fontFamily = "sans-serif";
      container.style.padding = "20px";
      const heading = document.createElement("h1");
      heading.textContent = "Authentication Error";
      container.appendChild(heading);
      const errorPara = document.createElement("p");
      errorPara.style.color = "red";
      errorPara.style.backgroundColor = "#ffebeb";
      errorPara.style.border = "1px solid red";
      errorPara.style.padding = "10px";
      errorPara.style.borderRadius = "4px";
      errorPara.textContent = errorMessage;
      container.appendChild(errorPara);
      const closePara = document.createElement("p");
      closePara.textContent = "You can close this window or ";
      const closeLink = document.createElement("a");
      closeLink.href = "#";
      closeLink.textContent = "click here to close";
      closeLink.onclick = (e) => {
        e.preventDefault();
        window.close();
        return false;
      };
      closePara.appendChild(closeLink);
      closePara.appendChild(document.createTextNode("."));
      container.appendChild(closePara);
      if (err instanceof Error && err.stack) {
        const stackPre = document.createElement("pre");
        stackPre.style.fontSize = "0.8em";
        stackPre.style.color = "#555";
        stackPre.style.marginTop = "20px";
        stackPre.style.whiteSpace = "pre-wrap";
        stackPre.textContent = err.stack;
        container.appendChild(stackPre);
      }
      document.body.appendChild(container);
    } catch (displayError) {
      console.error(
        `${logPrefix} Could not display error in callback window:`,
        displayError
      );
    }
    if (stateKey) {
      localStorage.removeItem(stateKey);
    }
    if (provider) {
      localStorage.removeItem(provider.getKey("code_verifier"));
      localStorage.removeItem(provider.getKey("last_auth_url"));
    }
  }
}
__name(onMcpAuthorization, "onMcpAuthorization");

// src/react/ErrorBoundary.tsx
var import_react2 = __toESM(require("react"), 1);
init_logging();
var logger2 = Logger.get("ErrorBoundary");
var ErrorBoundary = class extends import_react2.default.Component {
  static {
    __name(this, "ErrorBoundary");
  }
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidCatch(error, errorInfo) {
    logger2.error("Widget Error:", error, errorInfo);
  }
  render() {
    if (this.state.hasError) {
      return /* @__PURE__ */ import_react2.default.createElement("div", { className: "p-4 border border-red-500 bg-red-50 text-red-900 rounded-md dark:bg-red-900/20 dark:text-red-100" }, /* @__PURE__ */ import_react2.default.createElement("h3", { className: "font-bold mb-2" }, "Widget Error"), /* @__PURE__ */ import_react2.default.createElement("pre", { className: "text-sm whitespace-pre-wrap" }, this.state.error?.message));
    }
    return this.props.children;
  }
};

// src/react/Image.tsx
var import_react3 = __toESM(require("react"), 1);
var Image = /* @__PURE__ */ __name(({ src, ...props }) => {
  const publicUrl = typeof window !== "undefined" ? window.__mcpPublicAssetsUrl || window.__mcpPublicUrl || "" : "";
  const getFinalSrc = /* @__PURE__ */ __name((source) => {
    if (!source) return source;
    if (source.startsWith("http://") || source.startsWith("https://") || source.startsWith("data:")) {
      return source;
    }
    if (!publicUrl) {
      return source;
    }
    const cleanSrc = source.startsWith("/") ? source.slice(1) : source;
    return `${publicUrl}/${cleanSrc}`;
  }, "getFinalSrc");
  const finalSrc = getFinalSrc(src);
  return /* @__PURE__ */ import_react3.default.createElement("img", { src: finalSrc, ...props });
}, "Image");

// src/react/ThemeProvider.tsx
var import_react5 = __toESM(require("react"), 1);

// src/react/useWidget.ts
var import_react4 = require("react");

// src/server/utils/jsonrpc-helpers.ts
function createNotification(method, params) {
  return {
    jsonrpc: "2.0",
    method,
    ...params && { params }
  };
}
__name(createNotification, "createNotification");
function createRequest(id, method, params) {
  return {
    jsonrpc: "2.0",
    id,
    method,
    ...params && { params }
  };
}
__name(createRequest, "createRequest");

// src/react/constants.ts
var WIDGET_DEFAULTS = {
  /** Polling interval for checking window.openai availability (ms) */
  POLL_INTERVAL: 100,
  /** Maximum timeout for window.openai availability check (ms) */
  MAX_TIMEOUT: 5e3,
  /** Default maximum height for widgets */
  MAX_HEIGHT: 600,
  /** Default locale */
  LOCALE: "en"
};
var MCP_APPS_BRIDGE_CONFIG = {
  /** Request timeout (ms) */
  REQUEST_TIMEOUT: 3e4,
  /** App name for identification */
  APP_NAME: "mcp-use-widget",
  /** App version */
  APP_VERSION: "1.0.0",
  /** MCP Apps protocol version */
  PROTOCOL_VERSION: "2025-06-18"
};

// src/react/mcp-apps-bridge.ts
var McpAppsBridge = class {
  static {
    __name(this, "McpAppsBridge");
  }
  connected = false;
  connectPromise = null;
  requestId = 1;
  pendingRequests = /* @__PURE__ */ new Map();
  listeners = /* @__PURE__ */ new Set();
  // State
  toolInput = null;
  partialToolInput = null;
  toolOutput = null;
  toolResponseMetadata = null;
  hostContext = null;
  initialized = false;
  // Event handlers
  toolInputHandlers = /* @__PURE__ */ new Set();
  toolInputPartialHandlers = /* @__PURE__ */ new Set();
  toolResultHandlers = /* @__PURE__ */ new Set();
  hostContextHandlers = /* @__PURE__ */ new Set();
  constructor() {
    if (typeof window === "undefined") return;
    const handleMessage = /* @__PURE__ */ __name((event) => {
      const message = event.data;
      if (!message || message.jsonrpc !== "2.0") return;
      if ("result" in message || "error" in message) {
        const response = message;
        if (response.id !== null && response.id !== void 0) {
          const pending = this.pendingRequests.get(response.id);
          if (pending) {
            this.pendingRequests.delete(response.id);
            if ("error" in response && response.error) {
              pending.reject(new Error(response.error.message));
            } else {
              pending.resolve(response.result);
            }
          }
        }
        return;
      }
      if ("method" in message && !("id" in message)) {
        this.handleNotification(message);
      }
    }, "handleMessage");
    window.addEventListener("message", handleMessage);
    this.listeners.add(handleMessage);
    this.interceptConsole();
  }
  /**
   * Intercept console methods and proxy to MCP Apps host
   */
  interceptConsole() {
    if (typeof window === "undefined" || typeof console === "undefined") return;
    const originalConsole = {
      log: console.log.bind(console),
      warn: console.warn.bind(console),
      error: console.error.bind(console),
      info: console.info.bind(console),
      debug: console.debug.bind(console)
    };
    const consoleLevelToRfc5424 = {
      log: "info",
      warn: "warning",
      error: "error",
      info: "info",
      debug: "debug"
    };
    const serializeForPostMessage = /* @__PURE__ */ __name((value, seen = /* @__PURE__ */ new WeakSet()) => {
      if (value === null || value === void 0) return value;
      if (typeof value !== "object") return value;
      if (seen.has(value)) return "[Circular]";
      if (value instanceof Response) {
        return {
          __type: "Response",
          status: value.status,
          statusText: value.statusText,
          ok: value.ok,
          url: value.url,
          headers: Object.fromEntries(value.headers.entries())
        };
      }
      if (value instanceof Request) {
        return {
          __type: "Request",
          method: value.method,
          url: value.url,
          headers: Object.fromEntries(value.headers.entries())
        };
      }
      if (value instanceof Error) {
        return {
          __type: "Error",
          name: value.name,
          message: value.message,
          stack: value.stack
        };
      }
      if (value instanceof Event) {
        return {
          __type: "Event",
          type: value.type,
          target: value.target?.constructor?.name
        };
      }
      if (typeof HTMLElement !== "undefined" && value instanceof HTMLElement) {
        return {
          __type: "HTMLElement",
          tagName: value.tagName,
          id: value.id,
          className: value.className
        };
      }
      if (typeof value === "function") {
        return `[Function: ${value.name || "anonymous"}]`;
      }
      if (Array.isArray(value)) {
        seen.add(value);
        return value.map((item) => serializeForPostMessage(item, seen));
      }
      try {
        seen.add(value);
        const serialized = {};
        for (const key in value) {
          if (Object.prototype.hasOwnProperty.call(value, key)) {
            try {
              serialized[key] = serializeForPostMessage(value[key], seen);
            } catch {
              serialized[key] = "[Unserializable]";
            }
          }
        }
        return serialized;
      } catch {
        return "[Object]";
      }
    }, "serializeForPostMessage");
    const sendLog = /* @__PURE__ */ __name((level, args) => {
      try {
        const serializedArgs = args.map((arg) => serializeForPostMessage(arg));
        this.sendNotification("notifications/message", {
          level: consoleLevelToRfc5424[level] || "info",
          logger: "console",
          data: serializedArgs.length === 1 ? serializedArgs[0] : serializedArgs
        });
      } catch (error) {
        originalConsole.warn(
          "[MCP Apps Bridge] Failed to forward console message:",
          error
        );
      }
    }, "sendLog");
    console.log = (...args) => {
      sendLog("log", args);
      originalConsole.log(...args);
    };
    console.warn = (...args) => {
      sendLog("warn", args);
      originalConsole.warn(...args);
    };
    console.error = (...args) => {
      sendLog("error", args);
      originalConsole.error(...args);
    };
    console.info = (...args) => {
      sendLog("info", args);
      originalConsole.info(...args);
    };
    console.debug = (...args) => {
      sendLog("debug", args);
      originalConsole.debug(...args);
    };
  }
  handleNotification(notification) {
    console.log(
      "[MCP Apps Bridge] Received notification:",
      notification.method,
      notification.params
    );
    switch (notification.method) {
      case "ui/notifications/tool-input": {
        const params = notification.params;
        console.log("[MCP Apps Bridge] Tool input received:", params.arguments);
        this.toolInput = params.arguments;
        this.toolInputHandlers.forEach((handler) => handler(params.arguments));
        break;
      }
      case "ui/notifications/tool-input-partial": {
        const params = notification.params;
        console.log(
          "[MCP Apps Bridge] Partial tool input received:",
          params.arguments
        );
        this.partialToolInput = params.arguments;
        this.toolInputPartialHandlers.forEach(
          (handler) => handler(params.arguments)
        );
        break;
      }
      case "ui/notifications/tool-result": {
        const params = notification.params;
        const output = params.structuredContent || this.parseTextContent(params);
        const meta = params._meta || null;
        this.toolOutput = output;
        this.toolResponseMetadata = meta;
        this.partialToolInput = null;
        this.toolResultHandlers.forEach((handler) => handler(output));
        break;
      }
      case "ui/notifications/host-context-changed": {
        const context = notification.params;
        console.log("[MCP Apps Bridge] Host context changed:", context);
        this.hostContext = { ...this.hostContext, ...context };
        console.log("[MCP Apps Bridge] Merged hostContext:", this.hostContext);
        console.log(
          "[MCP Apps Bridge] Calling handlers:",
          this.hostContextHandlers.size
        );
        this.hostContextHandlers.forEach(
          (handler) => handler(this.hostContext)
        );
        break;
      }
      case "ui/notifications/initialized": {
        this.initialized = true;
        break;
      }
      default:
        break;
    }
  }
  parseTextContent(result) {
    if (result.content && Array.isArray(result.content)) {
      for (const block of result.content) {
        if (block.type === "text" && block.text) {
          try {
            const parsed = JSON.parse(block.text);
            if (parsed && typeof parsed === "object" && !Array.isArray(parsed)) {
              return parsed;
            }
          } catch {
          }
        }
      }
    }
    return {};
  }
  sendRequest(method, params) {
    if (typeof window === "undefined" || !window.parent) {
      return Promise.reject(new Error("Not in iframe context"));
    }
    const id = this.requestId++;
    const message = createRequest(
      id,
      method,
      params
    );
    return new Promise((resolve, reject) => {
      this.pendingRequests.set(id, { resolve, reject });
      window.parent.postMessage(message, "*");
      setTimeout(() => {
        if (this.pendingRequests.has(id)) {
          this.pendingRequests.delete(id);
          reject(new Error(`Request timeout: ${method}`));
        }
      }, MCP_APPS_BRIDGE_CONFIG.REQUEST_TIMEOUT);
    });
  }
  sendNotification(method, params) {
    if (typeof window === "undefined" || !window.parent) return;
    const message = createNotification(
      method,
      params
    );
    window.parent.postMessage(message, "*");
  }
  /**
   * Initialize connection with MCP Apps host.
   * Concurrent calls share the same in-flight connection attempt so that
   * React StrictMode double-invocations and multiple useWidget() hooks
   * only produce a single ui/initialize request.
   */
  async connect() {
    if (this.connected) return;
    if (typeof window === "undefined" || window === window.parent) {
      console.log("[MCP Apps Bridge] Not in iframe, skipping connection");
      return;
    }
    if (!this.connectPromise) {
      this.connectPromise = this.doConnect();
      this.connectPromise.catch(() => {
        this.connectPromise = null;
      });
    }
    return this.connectPromise;
  }
  async doConnect() {
    console.log("[MCP Apps Bridge] Connecting to MCP Apps host...");
    try {
      const result = await this.sendRequest("ui/initialize", {
        appCapabilities: {},
        appInfo: {
          name: MCP_APPS_BRIDGE_CONFIG.APP_NAME,
          version: MCP_APPS_BRIDGE_CONFIG.APP_VERSION
        },
        protocolVersion: MCP_APPS_BRIDGE_CONFIG.PROTOCOL_VERSION
      });
      console.log("[MCP Apps Bridge] Initialize result:", result);
      if (result.hostContext) {
        this.hostContext = result.hostContext;
        console.log("[MCP Apps Bridge] Host context:", this.hostContext);
      }
      this.sendNotification("ui/notifications/initialized", {});
      this.connected = true;
      console.log("[MCP Apps Bridge] Successfully connected");
    } catch (error) {
      console.error("[MCP Apps Bridge] Failed to connect:", error);
      throw error;
    }
  }
  /**
   * Check if connected to MCP Apps host
   */
  isConnected() {
    return this.connected;
  }
  /**
   * Get current tool input (props)
   */
  getToolInput() {
    return this.toolInput;
  }
  /**
   * Get current partial/streaming tool input
   */
  getPartialToolInput() {
    return this.partialToolInput;
  }
  /**
   * Get current tool output (structuredContent from tool result)
   */
  getToolOutput() {
    return this.toolOutput;
  }
  /**
   * Get tool response metadata (_meta from tool result)
   */
  getToolResponseMetadata() {
    return this.toolResponseMetadata;
  }
  /**
   * Get host context
   */
  getHostContext() {
    return this.hostContext;
  }
  /**
   * Subscribe to tool input changes
   */
  onToolInput(handler) {
    this.toolInputHandlers.add(handler);
    return () => this.toolInputHandlers.delete(handler);
  }
  /**
   * Subscribe to partial/streaming tool input changes
   */
  onToolInputPartial(handler) {
    this.toolInputPartialHandlers.add(handler);
    return () => this.toolInputPartialHandlers.delete(handler);
  }
  /**
   * Subscribe to tool result changes
   */
  onToolResult(handler) {
    this.toolResultHandlers.add(handler);
    return () => this.toolResultHandlers.delete(handler);
  }
  /**
   * Subscribe to host context changes
   */
  onHostContextChange(handler) {
    this.hostContextHandlers.add(handler);
    return () => this.hostContextHandlers.delete(handler);
  }
  /**
   * Call a tool on the server
   */
  async callTool(name, args) {
    return this.sendRequest("tools/call", { name, arguments: args });
  }
  /**
   * Send a message to the conversation
   */
  async sendMessage(content) {
    const contentArray = Array.isArray(content) ? content : [content];
    await this.sendRequest("ui/message", {
      role: "user",
      content: contentArray
    });
  }
  /**
   * Open an external link
   */
  async openLink(url) {
    await this.sendRequest("ui/open-link", { url });
  }
  /**
   * Request display mode change
   */
  async requestDisplayMode(mode) {
    const result = await this.sendRequest("ui/request-display-mode", { mode });
    return result;
  }
  /**
   * Update the host's model context (SEP-1865 ui/update-model-context).
   * The host will include this data in the model's context on future turns.
   * Each call overwrites the previous context.
   */
  async updateModelContext(params) {
    await this.sendRequest("ui/update-model-context", params);
  }
  /**
   * Notify host about size changes for auto-sizing
   * Sends ui/notifications/size-changed notification per SEP-1865
   */
  sendSizeChanged(params) {
    this.sendNotification("ui/notifications/size-changed", params);
  }
  /**
   * Cleanup
   */
  disconnect() {
    this.listeners.forEach((listener) => {
      if (typeof window !== "undefined") {
        window.removeEventListener("message", listener);
      }
    });
    this.listeners.clear();
    this.pendingRequests.clear();
    this.toolInputHandlers.clear();
    this.toolInputPartialHandlers.clear();
    this.toolResultHandlers.clear();
    this.hostContextHandlers.clear();
    this.connected = false;
    this.connectPromise = null;
  }
};
var bridgeInstance = null;
function getMcpAppsBridge() {
  if (!bridgeInstance) {
    bridgeInstance = new McpAppsBridge();
  }
  return bridgeInstance;
}
__name(getMcpAppsBridge, "getMcpAppsBridge");

// src/react/widget-utils.ts
function normalizeCallToolResponse(raw) {
  if (raw && typeof raw === "object" && "result" in raw) {
    return raw;
  }
  const content = raw?.content || [];
  const structuredContent = raw?.structuredContent || {};
  const result = content.filter((block) => block.type === "text" && block.text).map((block) => block.text).join("\n");
  const isError = raw?.isError ?? false;
  const _meta = raw?._meta;
  return {
    content,
    structuredContent,
    isError,
    result,
    _meta
  };
}
__name(normalizeCallToolResponse, "normalizeCallToolResponse");

// src/react/widget-types.ts
var SET_GLOBALS_EVENT_TYPE = "openai:set_globals";

// src/react/useWidget.ts
function useOpenAiGlobal(key) {
  return (0, import_react4.useSyncExternalStore)(
    (onChange) => {
      let lastValue = typeof window !== "undefined" && window.openai ? window.openai[key] : void 0;
      const handleSetGlobal = /* @__PURE__ */ __name((event) => {
        const customEvent = event;
        const value = customEvent.detail.globals[key];
        if (value === void 0) {
          return;
        }
        if (value === lastValue) return;
        lastValue = value;
        onChange();
      }, "handleSetGlobal");
      if (typeof window !== "undefined") {
        window.addEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobal);
      }
      return () => {
        if (typeof window !== "undefined") {
          window.removeEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobal);
        }
      };
    },
    () => typeof window !== "undefined" && window.openai ? window.openai[key] : void 0
  );
}
__name(useOpenAiGlobal, "useOpenAiGlobal");
function useWidget(defaultProps) {
  const [isOpenAiAvailable, setIsOpenAiAvailable] = (0, import_react4.useState)(
    () => typeof window !== "undefined" && !!window.openai
  );
  const [isMcpAppsConnected, setIsMcpAppsConnected] = (0, import_react4.useState)(false);
  const [mcpAppsToolInput, setMcpAppsToolInput] = (0, import_react4.useState)(null);
  const [mcpAppsToolOutput, setMcpAppsToolOutput] = (0, import_react4.useState)(null);
  const [mcpAppsResponseMetadata, setMcpAppsResponseMetadata] = (0, import_react4.useState)(null);
  const [mcpAppsPartialToolInput, setMcpAppsPartialToolInput] = (0, import_react4.useState)(null);
  const [mcpAppsHostContext, setMcpAppsHostContext] = (0, import_react4.useState)(null);
  (0, import_react4.useEffect)(() => {
    if (typeof window !== "undefined" && window.openai) {
      setIsOpenAiAvailable(true);
      return;
    }
    const checkInterval = setInterval(() => {
      if (typeof window !== "undefined" && window.openai) {
        setIsOpenAiAvailable(true);
        clearInterval(checkInterval);
      }
    }, 100);
    const handleSetGlobals = /* @__PURE__ */ __name(() => {
      if (typeof window !== "undefined" && window.openai) {
        setIsOpenAiAvailable(true);
        clearInterval(checkInterval);
      }
    }, "handleSetGlobals");
    if (typeof window !== "undefined") {
      window.addEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobals);
    }
    const timeout = setTimeout(() => {
      clearInterval(checkInterval);
      if (typeof window !== "undefined") {
        window.removeEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobals);
      }
    }, 5e3);
    return () => {
      clearInterval(checkInterval);
      clearTimeout(timeout);
      if (typeof window !== "undefined") {
        window.removeEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobals);
      }
    };
  }, []);
  (0, import_react4.useEffect)(() => {
    if (typeof window === "undefined" || window.openai || window === window.parent) {
      return;
    }
    const bridge = getMcpAppsBridge();
    bridge.connect().then(() => {
      setIsMcpAppsConnected(true);
      const toolInput2 = bridge.getToolInput();
      const toolOutput2 = bridge.getToolOutput();
      const responseMeta = bridge.getToolResponseMetadata();
      const hostContext = bridge.getHostContext();
      const partialToolInput2 = bridge.getPartialToolInput();
      if (toolInput2) setMcpAppsToolInput(toolInput2);
      if (toolOutput2) setMcpAppsToolOutput(toolOutput2);
      if (responseMeta) setMcpAppsResponseMetadata(responseMeta);
      if (partialToolInput2) setMcpAppsPartialToolInput(partialToolInput2);
      if (hostContext) setMcpAppsHostContext(hostContext);
    }).catch((error) => {
      console.warn("[useWidget] Failed to connect to MCP Apps host:", error);
    });
    const unsubToolInput = bridge.onToolInput((input) => {
      setMcpAppsToolInput(input);
    });
    const unsubToolInputPartial = bridge.onToolInputPartial((input) => {
      setMcpAppsPartialToolInput(input);
    });
    const unsubToolResult = bridge.onToolResult((result) => {
      setMcpAppsToolOutput(result);
      setMcpAppsResponseMetadata(bridge.getToolResponseMetadata());
      setMcpAppsPartialToolInput(null);
    });
    const unsubHostContext = bridge.onHostContextChange((context) => {
      console.log("[useWidget] Host context change received:", context);
      setMcpAppsHostContext(context);
    });
    return () => {
      unsubToolInput();
      unsubToolInputPartial();
      unsubToolResult();
      unsubHostContext();
    };
  }, []);
  const provider = (0, import_react4.useMemo)(() => {
    if (isOpenAiAvailable) return "openai";
    if (isMcpAppsConnected) return "mcp-apps";
    return "mcp-ui";
  }, [isOpenAiAvailable, isMcpAppsConnected]);
  const searchString = typeof window !== "undefined" ? window.location.search : "";
  const urlParams = (0, import_react4.useMemo)(() => {
    const urlParams2 = new URLSearchParams(searchString);
    if (urlParams2.has("mcpUseParams")) {
      return JSON.parse(urlParams2.get("mcpUseParams"));
    }
    return {
      toolInput: {},
      toolOutput: {},
      toolId: ""
    };
  }, [searchString]);
  const openaiToolInput = useOpenAiGlobal("toolInput");
  const openaiToolOutput = useOpenAiGlobal("toolOutput");
  const toolResponseMetadata = useOpenAiGlobal("toolResponseMetadata");
  const widgetState = useOpenAiGlobal("widgetState");
  const openaiTheme = useOpenAiGlobal("theme");
  const openaiDisplayMode = useOpenAiGlobal("displayMode");
  const openaiSafeArea = useOpenAiGlobal("safeArea");
  const openaiMaxHeight = useOpenAiGlobal("maxHeight");
  const openaiUserAgent = useOpenAiGlobal("userAgent");
  const openaiLocale = useOpenAiGlobal("locale");
  const toolInput = (0, import_react4.useMemo)(() => {
    if (provider === "openai") return openaiToolInput;
    if (provider === "mcp-apps")
      return mcpAppsToolInput;
    return urlParams.toolInput;
  }, [provider, openaiToolInput, mcpAppsToolInput, urlParams.toolInput]);
  const toolOutput = (0, import_react4.useMemo)(() => {
    if (provider === "openai") {
      const raw = openaiToolOutput;
      if (raw && raw.structuredContent && typeof raw.structuredContent === "object") {
        return raw.structuredContent;
      }
      return openaiToolOutput;
    }
    if (provider === "mcp-apps")
      return mcpAppsToolOutput;
    return urlParams.toolOutput;
  }, [provider, openaiToolOutput, mcpAppsToolOutput, urlParams.toolOutput]);
  const widgetProps = (0, import_react4.useMemo)(() => {
    const ti = toolInput || {};
    const base = defaultProps || {};
    let structuredContent;
    if (provider === "openai" && openaiToolOutput) {
      const raw = openaiToolOutput;
      if (raw.structuredContent && typeof raw.structuredContent === "object") {
        structuredContent = raw.structuredContent;
      } else {
        structuredContent = raw;
      }
    } else if (provider === "mcp-apps" && mcpAppsToolOutput) {
      structuredContent = mcpAppsToolOutput;
    } else if (provider === "mcp-ui" && urlParams.toolOutput) {
      structuredContent = urlParams.toolOutput;
    }
    const merged = { ...base, ...ti, ...structuredContent || {} };
    return merged;
  }, [
    provider,
    toolInput,
    openaiToolOutput,
    mcpAppsToolOutput,
    urlParams.toolOutput,
    defaultProps
  ]);
  const theme = (0, import_react4.useMemo)(() => {
    if (provider === "openai") return openaiTheme;
    if (provider === "mcp-apps" && mcpAppsHostContext) {
      return mcpAppsHostContext.theme;
    }
    return void 0;
  }, [provider, openaiTheme, mcpAppsHostContext]);
  const displayMode = (0, import_react4.useMemo)(() => {
    if (provider === "openai") return openaiDisplayMode;
    if (provider === "mcp-apps" && mcpAppsHostContext) {
      return mcpAppsHostContext.displayMode;
    }
    return void 0;
  }, [provider, openaiDisplayMode, mcpAppsHostContext]);
  const safeArea = (0, import_react4.useMemo)(() => {
    if (provider === "openai") return openaiSafeArea;
    if (provider === "mcp-apps" && mcpAppsHostContext?.safeAreaInsets) {
      return {
        insets: mcpAppsHostContext.safeAreaInsets
      };
    }
    return void 0;
  }, [provider, openaiSafeArea, mcpAppsHostContext]);
  const maxHeight = (0, import_react4.useMemo)(() => {
    if (provider === "openai") return openaiMaxHeight;
    if (provider === "mcp-apps" && mcpAppsHostContext?.containerDimensions) {
      return mcpAppsHostContext.containerDimensions.maxHeight;
    }
    return void 0;
  }, [provider, openaiMaxHeight, mcpAppsHostContext]);
  const maxWidth = (0, import_react4.useMemo)(() => {
    if (provider === "openai") {
      return void 0;
    }
    if (provider === "mcp-apps" && mcpAppsHostContext?.containerDimensions) {
      return mcpAppsHostContext.containerDimensions.maxWidth;
    }
    return void 0;
  }, [provider, mcpAppsHostContext]);
  const userAgent = (0, import_react4.useMemo)(() => {
    if (provider === "openai") return openaiUserAgent;
    if (provider === "mcp-apps" && mcpAppsHostContext) {
      return {
        device: {
          type: mcpAppsHostContext.platform === "mobile" ? "mobile" : "desktop"
        },
        capabilities: {
          hover: mcpAppsHostContext.deviceCapabilities?.hover ?? false,
          touch: mcpAppsHostContext.deviceCapabilities?.touch ?? false
        }
      };
    }
    return void 0;
  }, [provider, openaiUserAgent, mcpAppsHostContext]);
  const locale = (0, import_react4.useMemo)(() => {
    if (provider === "openai") return openaiLocale;
    if (provider === "mcp-apps" && mcpAppsHostContext) {
      return mcpAppsHostContext.locale;
    }
    return void 0;
  }, [provider, openaiLocale, mcpAppsHostContext]);
  const timeZone = (0, import_react4.useMemo)(() => {
    if (provider === "openai") {
      return typeof window !== "undefined" ? Intl.DateTimeFormat().resolvedOptions().timeZone : void 0;
    }
    if (provider === "mcp-apps" && mcpAppsHostContext) {
      return mcpAppsHostContext.timeZone;
    }
    return void 0;
  }, [provider, mcpAppsHostContext]);
  const mcp_url = (0, import_react4.useMemo)(() => {
    if (typeof window !== "undefined" && window.__mcpPublicUrl) {
      return window.__mcpPublicUrl.replace(/\/mcp-use\/public$/, "");
    }
    return "";
  }, []);
  const [localWidgetState, setLocalWidgetState] = (0, import_react4.useState)(null);
  (0, import_react4.useEffect)(() => {
    if (widgetState !== void 0) {
      setLocalWidgetState(widgetState);
    }
  }, [widgetState]);
  const callTool = (0, import_react4.useCallback)(
    async (name, args) => {
      if (provider === "mcp-apps") {
        const bridge = getMcpAppsBridge();
        const raw2 = await bridge.callTool(name, args);
        return normalizeCallToolResponse(raw2);
      }
      if (!window.openai?.callTool) {
        throw new Error("window.openai.callTool is not available");
      }
      const raw = await window.openai.callTool(name, args);
      return normalizeCallToolResponse(raw);
    },
    [provider]
  );
  const sendFollowUpMessage = (0, import_react4.useCallback)(
    async (prompt) => {
      if (provider === "mcp-apps") {
        const bridge = getMcpAppsBridge();
        await bridge.sendMessage({ type: "text", text: prompt });
        return;
      }
      if (!window.openai?.sendFollowUpMessage) {
        throw new Error("window.openai.sendFollowUpMessage is not available");
      }
      return window.openai.sendFollowUpMessage({ prompt });
    },
    [provider]
  );
  const openExternal = (0, import_react4.useCallback)(
    (href) => {
      if (provider === "mcp-apps") {
        const bridge = getMcpAppsBridge();
        bridge.openLink(href).catch((error) => {
          console.error("Failed to open link:", error);
        });
        return;
      }
      if (!window.openai?.openExternal) {
        throw new Error("window.openai.openExternal is not available");
      }
      window.openai.openExternal({ href });
    },
    [provider]
  );
  const requestDisplayMode = (0, import_react4.useCallback)(
    async (mode) => {
      if (provider === "mcp-apps") {
        const bridge = getMcpAppsBridge();
        return await bridge.requestDisplayMode(mode);
      }
      if (!window.openai?.requestDisplayMode) {
        throw new Error("window.openai.requestDisplayMode is not available");
      }
      return window.openai.requestDisplayMode({ mode });
    },
    [provider]
  );
  const setState = (0, import_react4.useCallback)(
    async (state) => {
      if (provider === "mcp-apps") {
        const currentState2 = localWidgetState;
        const newState2 = typeof state === "function" ? state(currentState2) : state;
        setLocalWidgetState(newState2);
        const bridge = getMcpAppsBridge();
        bridge.updateModelContext({
          structuredContent: newState2,
          content: [{ type: "text", text: JSON.stringify(newState2) }]
        }).catch((err) => {
          console.warn("[useWidget] Failed to update model context:", err);
        });
        return;
      }
      if (!window.openai?.setWidgetState) {
        throw new Error("window.openai.setWidgetState is not available");
      }
      const currentState = widgetState !== void 0 ? widgetState : localWidgetState;
      const newState = typeof state === "function" ? state(currentState) : state;
      setLocalWidgetState(newState);
      return window.openai.setWidgetState(newState);
    },
    [provider, widgetState, localWidgetState]
  );
  const isPending = (0, import_react4.useMemo)(() => {
    if (provider === "openai") {
      return openaiToolOutput === null && toolResponseMetadata === null;
    }
    if (provider === "mcp-apps") {
      return mcpAppsToolOutput === null;
    }
    if (provider === "mcp-ui") {
      if (typeof window !== "undefined" && window !== window.parent && !urlParams.toolId) {
        return true;
      }
      return toolOutput === null || toolOutput === void 0;
    }
    return false;
  }, [
    provider,
    openaiToolOutput,
    toolResponseMetadata,
    mcpAppsToolOutput,
    toolOutput,
    urlParams.toolId
  ]);
  const partialToolInput = (0, import_react4.useMemo)(() => {
    if (provider === "mcp-apps" && mcpAppsPartialToolInput) {
      return mcpAppsPartialToolInput;
    }
    return null;
  }, [provider, mcpAppsPartialToolInput]);
  const isStreaming = (0, import_react4.useMemo)(() => {
    if (provider === "mcp-apps") {
      return mcpAppsPartialToolInput !== null;
    }
    return false;
  }, [provider, mcpAppsPartialToolInput]);
  return {
    // Props and state (with defaults)
    props: widgetProps,
    toolInput: toolInput || {},
    output: toolOutput ?? null,
    metadata: provider === "mcp-apps" ? mcpAppsResponseMetadata ?? null : toolResponseMetadata ?? null,
    state: localWidgetState,
    setState,
    // Layout and theme (with safe defaults)
    theme: theme || "light",
    displayMode: displayMode || "inline",
    safeArea: safeArea || { insets: { top: 0, bottom: 0, left: 0, right: 0 } },
    maxHeight: maxHeight || 600,
    maxWidth,
    userAgent: userAgent || {
      device: { type: "desktop" },
      capabilities: { hover: true, touch: false }
    },
    locale: locale || WIDGET_DEFAULTS.LOCALE,
    timeZone: timeZone || (typeof window !== "undefined" ? Intl.DateTimeFormat().resolvedOptions().timeZone : "UTC"),
    mcp_url,
    // Actions
    callTool,
    sendFollowUpMessage,
    openExternal,
    requestDisplayMode,
    // Availability
    isAvailable: isOpenAiAvailable || isMcpAppsConnected,
    isPending,
    // Streaming
    partialToolInput,
    isStreaming
  };
}
__name(useWidget, "useWidget");
function useWidgetProps(defaultProps) {
  const { props } = useWidget(defaultProps);
  return props;
}
__name(useWidgetProps, "useWidgetProps");
function useWidgetTheme() {
  const { theme } = useWidget();
  return theme;
}
__name(useWidgetTheme, "useWidgetTheme");
function useWidgetState(defaultState) {
  const { state, setState } = useWidget();
  (0, import_react4.useEffect)(() => {
    if (state === null && defaultState !== void 0 && window.openai?.setWidgetState) {
      setState(defaultState);
    }
  }, []);
  return [state, setState];
}
__name(useWidgetState, "useWidgetState");

// src/react/ThemeProvider.tsx
var ThemeProvider = /* @__PURE__ */ __name(({
  children
}) => {
  const { theme, isAvailable } = useWidget();
  const [systemPreference, setSystemPreference] = (0, import_react5.useState)(
    () => {
      if (typeof window === "undefined") return "light";
      return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
  );
  (0, import_react5.useEffect)(() => {
    if (typeof window === "undefined") return;
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    const handleChange = /* @__PURE__ */ __name((e) => {
      setSystemPreference(e.matches ? "dark" : "light");
    }, "handleChange");
    mediaQuery.addEventListener("change", handleChange);
    return () => mediaQuery.removeEventListener("change", handleChange);
  }, []);
  const effectiveTheme = isAvailable ? theme : systemPreference;
  (0, import_react5.useLayoutEffect)(() => {
    if (typeof document === "undefined") return;
    const root = document.documentElement;
    root.classList.remove("light", "dark");
    root.classList.add(effectiveTheme === "dark" ? "dark" : "light");
    root.setAttribute(
      "data-theme",
      effectiveTheme === "dark" ? "dark" : "light"
    );
    root.style.colorScheme = effectiveTheme === "dark" ? "dark" : "light";
  }, [effectiveTheme]);
  return /* @__PURE__ */ import_react5.default.createElement(import_react5.default.Fragment, null, children);
}, "ThemeProvider");

// src/react/WidgetControls.tsx
var import_react6 = __toESM(require("react"), 1);
function WidgetControls({
  children,
  className = "",
  position = "top-right",
  attachTo,
  showLabels = true,
  debugger: enableDebugger = false,
  viewControls = false
}) {
  const {
    props,
    output,
    metadata,
    state,
    theme,
    displayMode,
    safeArea,
    maxHeight,
    userAgent,
    locale,
    isAvailable,
    callTool,
    sendFollowUpMessage,
    openExternal,
    requestDisplayMode,
    setState
  } = useWidget();
  const [isHovered, setIsHovered] = (0, import_react6.useState)(false);
  const [isOverlayOpen, setIsOverlayOpen] = (0, import_react6.useState)(false);
  const containerRef = (0, import_react6.useRef)(null);
  const overlayRef = (0, import_react6.useRef)(null);
  const [windowOpenAiKeys, setWindowOpenAiKeys] = (0, import_react6.useState)([]);
  const [actionResult, setActionResult] = (0, import_react6.useState)("");
  const [toolName, setToolName] = (0, import_react6.useState)("get-my-city");
  const [toolArgs, setToolArgs] = (0, import_react6.useState)("{}");
  const [followUpMessage, setFollowUpMessage] = (0, import_react6.useState)(
    "Test follow-up message"
  );
  const [externalUrl, setExternalUrl] = (0, import_react6.useState)(
    "https://mcp-use.com/docs"
  );
  const isFullscreen = displayMode === "fullscreen" && isAvailable;
  const isPip = displayMode === "pip" && isAvailable;
  const isInInspector = typeof window !== "undefined" && window.location.pathname.includes("/inspector/api/");
  (0, import_react6.useEffect)(() => {
    const timeoutId = setTimeout(() => {
      if (typeof window !== "undefined" && window.openai) {
        try {
          const keys = Object.keys(window.openai);
          setWindowOpenAiKeys(keys);
        } catch (e) {
          setWindowOpenAiKeys([]);
        }
      } else {
        setWindowOpenAiKeys([]);
      }
    }, 100);
    return () => {
      clearTimeout(timeoutId);
    };
  }, []);
  const isDark = theme === "dark";
  const getPositionClasses = /* @__PURE__ */ __name(() => {
    const baseClasses = [
      "absolute",
      "z-[1000]",
      "flex",
      "gap-2",
      "transition-opacity",
      "duration-200",
      "ease-in-out",
      isHovered ? "opacity-100" : "opacity-0",
      isHovered ? "pointer-events-auto" : "pointer-events-none"
    ];
    switch (position) {
      case "top-left":
        return [...baseClasses, "top-4", "left-4"];
      case "top-center":
        return [...baseClasses, "top-4", "left-1/2", "-translate-x-1/2"];
      case "top-right":
        return [...baseClasses, "top-4", "right-4"];
      case "center-left":
        return [...baseClasses, "top-1/2", "left-4", "-translate-y-1/2"];
      case "center-right":
        return [...baseClasses, "top-1/2", "right-4", "-translate-y-1/2"];
      case "bottom-left":
        return [...baseClasses, "bottom-4", "left-4"];
      case "bottom-center":
        return [...baseClasses, "bottom-4", "left-1/2", "-translate-x-1/2"];
      case "bottom-right":
        return [...baseClasses, "bottom-4", "right-4"];
      default:
        return [...baseClasses, "top-4", "right-4"];
    }
  }, "getPositionClasses");
  const getPositionOffsetStyles = /* @__PURE__ */ __name(() => {
    const baseOffset = 16;
    const topOffset = safeArea?.insets?.top ? Math.max(baseOffset, safeArea.insets.top + 8) : baseOffset;
    const rightOffset = safeArea?.insets?.right ? Math.max(baseOffset, safeArea.insets.right + 8) : baseOffset;
    const bottomOffset = safeArea?.insets?.bottom ? Math.max(baseOffset, safeArea.insets.bottom + 8) : baseOffset;
    const leftOffset = safeArea?.insets?.left ? Math.max(baseOffset, safeArea.insets.left + 8) : baseOffset;
    const styles = {};
    switch (position) {
      case "top-left":
        styles.top = `${topOffset}px`;
        styles.left = `${leftOffset}px`;
        break;
      case "top-center":
        styles.top = `${topOffset}px`;
        break;
      case "top-right":
        styles.top = `${topOffset}px`;
        styles.right = `${rightOffset}px`;
        break;
      case "center-left":
        styles.left = `${leftOffset}px`;
        break;
      case "center-right":
        styles.right = `${rightOffset}px`;
        break;
      case "bottom-left":
        styles.bottom = `${bottomOffset}px`;
        styles.left = `${leftOffset}px`;
        break;
      case "bottom-center":
        styles.bottom = `${bottomOffset}px`;
        break;
      case "bottom-right":
        styles.bottom = `${bottomOffset}px`;
        styles.right = `${rightOffset}px`;
        break;
      default:
        styles.top = `${topOffset}px`;
        styles.right = `${rightOffset}px`;
        break;
    }
    return styles;
  }, "getPositionOffsetStyles");
  (0, import_react6.useEffect)(() => {
    if (!attachTo) return;
    const handleMouseEnter = /* @__PURE__ */ __name(() => setIsHovered(true), "handleMouseEnter");
    const handleMouseLeave = /* @__PURE__ */ __name(() => setIsHovered(false), "handleMouseLeave");
    attachTo.addEventListener("mouseenter", handleMouseEnter);
    attachTo.addEventListener("mouseleave", handleMouseLeave);
    return () => {
      attachTo.removeEventListener("mouseenter", handleMouseEnter);
      attachTo.removeEventListener("mouseleave", handleMouseLeave);
    };
  }, [attachTo]);
  (0, import_react6.useEffect)(() => {
    if (!isOverlayOpen) return;
    const handleClickOutside = /* @__PURE__ */ __name((event) => {
      if (overlayRef.current && !overlayRef.current.contains(event.target)) {
        setIsOverlayOpen(false);
      }
    }, "handleClickOutside");
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [isOverlayOpen]);
  (0, import_react6.useEffect)(() => {
    if (isOverlayOpen) {
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = "";
    }
    return () => {
      document.body.style.overflow = "";
    };
  }, [isOverlayOpen]);
  const handleToggleOverlay = /* @__PURE__ */ __name(() => {
    setIsOverlayOpen(!isOverlayOpen);
  }, "handleToggleOverlay");
  const handleCallTool = /* @__PURE__ */ __name(async () => {
    try {
      setActionResult("Calling tool...");
      const args = toolArgs.trim() ? JSON.parse(toolArgs) : {};
      const result = await callTool(toolName, args);
      setActionResult(`Success: ${JSON.stringify(result, null, 2)}`);
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleCallTool");
  const handleSendFollowUpMessage = /* @__PURE__ */ __name(async () => {
    try {
      setActionResult("Sending follow-up message...");
      await sendFollowUpMessage(followUpMessage);
      setActionResult("Follow-up message sent successfully");
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleSendFollowUpMessage");
  const handleOpenExternal = /* @__PURE__ */ __name(() => {
    try {
      openExternal(externalUrl);
      setActionResult(`Opened external link: ${externalUrl}`);
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleOpenExternal");
  const handleRequestDisplayMode = /* @__PURE__ */ __name(async (mode) => {
    try {
      setActionResult(`Requesting display mode: ${mode}...`);
      const result = await requestDisplayMode(mode);
      setActionResult(`Display mode granted: ${result.mode}`);
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleRequestDisplayMode");
  const handleSetState = /* @__PURE__ */ __name(async () => {
    try {
      const newState = state ? { ...state, debugTimestamp: (/* @__PURE__ */ new Date()).toISOString() } : { debugTimestamp: (/* @__PURE__ */ new Date()).toISOString() };
      setActionResult("Setting state...");
      await setState(newState);
      setActionResult(`State updated: ${JSON.stringify(newState, null, 2)}`);
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleSetState");
  const handleFullscreen = /* @__PURE__ */ __name(async () => {
    try {
      await requestDisplayMode("fullscreen");
    } catch (error) {
      console.error("Failed to go fullscreen:", error);
    }
  }, "handleFullscreen");
  const handlePip = /* @__PURE__ */ __name(async () => {
    try {
      await requestDisplayMode("pip");
    } catch (error) {
      console.error("Failed to go pip:", error);
    }
  }, "handlePip");
  const getTooltipClasses = /* @__PURE__ */ __name(() => {
    const baseClasses = [
      "absolute",
      "px-2",
      "py-1",
      "bg-black/90",
      "text-white",
      "rounded",
      "text-xs",
      "whitespace-nowrap",
      "pointer-events-none",
      "transition-opacity",
      "duration-200",
      "ease-in-out"
    ];
    switch (position) {
      case "top-right":
        return [...baseClasses, "top-full", "right-0", "mt-2"];
      case "top-left":
        return [...baseClasses, "top-full", "left-0", "mt-2"];
      case "top-center":
        return [
          ...baseClasses,
          "top-full",
          "left-1/2",
          "-translate-x-1/2",
          "mt-2"
        ];
      case "bottom-right":
        return [...baseClasses, "bottom-full", "right-0", "mb-2"];
      case "bottom-left":
        return [...baseClasses, "bottom-full", "left-0", "mb-2"];
      case "bottom-center":
        return [
          ...baseClasses,
          "bottom-full",
          "left-1/2",
          "-translate-x-1/2",
          "mb-2"
        ];
      case "center-left":
        return [
          ...baseClasses,
          "left-full",
          "top-1/2",
          "-translate-y-1/2",
          "ml-2"
        ];
      case "center-right":
        return [
          ...baseClasses,
          "right-full",
          "top-1/2",
          "-translate-y-1/2",
          "mr-2"
        ];
      default:
        return [...baseClasses, "top-full", "right-0", "mt-2"];
    }
  }, "getTooltipClasses");
  const IconButton = /* @__PURE__ */ __name(({
    onClick,
    label,
    children: icon
  }) => {
    const [isButtonHovered, setIsButtonHovered] = (0, import_react6.useState)(false);
    const tooltipClasses = getTooltipClasses();
    return /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        className: `p-2 ${isDark ? "bg-white/10 hover:bg-white/20" : "bg-black/70 hover:bg-black/90"} text-white border-none rounded-lg cursor-pointer flex items-center justify-center w-8 h-8 transition-colors duration-200 backdrop-blur-md ${isDark ? "shadow-[0_2px_8px_rgba(0,0,0,0.3)]" : "shadow-[0_2px_8px_rgba(0,0,0,0.2)]"} relative`,
        onMouseEnter: () => setIsButtonHovered(true),
        onMouseLeave: () => setIsButtonHovered(false),
        onClick,
        "aria-label": label
      },
      /* @__PURE__ */ import_react6.default.createElement(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          width: "16",
          height: "16",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          className: "block"
        },
        icon
      ),
      showLabels && /* @__PURE__ */ import_react6.default.createElement(
        "span",
        {
          className: `${tooltipClasses.join(" ")} ${isButtonHovered ? "opacity-100" : "opacity-0"}`
        },
        label
      )
    );
  }, "IconButton");
  const formatValue = /* @__PURE__ */ __name((value) => {
    if (value === null) return "null";
    if (value === void 0) return "undefined";
    if (typeof value === "object") {
      try {
        return JSON.stringify(value, null, 2);
      } catch {
        return String(value);
      }
    }
    return String(value);
  }, "formatValue");
  const formatUserAgent = /* @__PURE__ */ __name((ua) => {
    if (!ua) return "N/A";
    return `${ua.device?.type || "unknown"}`;
  }, "formatUserAgent");
  const formatSafeArea = /* @__PURE__ */ __name((sa) => {
    if (!sa?.insets) return "N/A";
    const { top, bottom, left, right } = sa.insets;
    return `T:${top} B:${bottom} L:${left} R:${right}`;
  }, "formatSafeArea");
  return /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, /* @__PURE__ */ import_react6.default.createElement(
    "div",
    {
      ref: containerRef,
      className: `${className} relative h-fit`,
      onMouseEnter: () => !attachTo && setIsHovered(true),
      onMouseLeave: () => !attachTo && setIsHovered(false)
    },
    /* @__PURE__ */ import_react6.default.createElement(
      "div",
      {
        className: getPositionClasses().join(" "),
        style: getPositionOffsetStyles()
      },
      !isInInspector && /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, !isFullscreen && !isPip && /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, (viewControls === true || viewControls === "fullscreen") && /* @__PURE__ */ import_react6.default.createElement(IconButton, { onClick: handleFullscreen, label: "Fullscreen" }, /* @__PURE__ */ import_react6.default.createElement("path", { d: "M15 3h6v6" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "m21 3-7 7" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "m3 21 7-7" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M9 21H3v-6" })), (viewControls === true || viewControls === "pip") && /* @__PURE__ */ import_react6.default.createElement(IconButton, { onClick: handlePip, label: "Picture in Picture" }, /* @__PURE__ */ import_react6.default.createElement("path", { d: "M21 9V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v10c0 1.1.9 2 2 2h4" }), /* @__PURE__ */ import_react6.default.createElement("rect", { width: "10", height: "7", x: "12", y: "13", rx: "2" }))), enableDebugger && /* @__PURE__ */ import_react6.default.createElement(IconButton, { onClick: handleToggleOverlay, label: "Debug Info" }, /* @__PURE__ */ import_react6.default.createElement("path", { d: "M12 20v-9" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M14 7a4 4 0 0 1 4 4v3a6 6 0 0 1-12 0v-3a4 4 0 0 1 4-4z" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M14.12 3.88 16 2" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M21 21a4 4 0 0 0-3.81-4" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M21 5a4 4 0 0 1-3.55 3.97" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M22 13h-4" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M3 21a4 4 0 0 1 3.81-4" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M3 5a4 4 0 0 0 3.55 3.97" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M6 13H2" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "m8 2 1.88 1.88" }), /* @__PURE__ */ import_react6.default.createElement("path", { d: "M9 7.13V6a3 3 0 1 1 6 0v1.13" })))
    ),
    children
  ), isOverlayOpen && enableDebugger && /* @__PURE__ */ import_react6.default.createElement(
    "div",
    {
      ref: overlayRef,
      className: "fixed inset-0 bg-black text-white font-mono text-xs z-[10000] overflow-auto p-4",
      onClick: (e) => {
        if (e.target === overlayRef.current) {
          setIsOverlayOpen(false);
        }
      }
    },
    /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        onClick: () => setIsOverlayOpen(false),
        className: "absolute top-4 right-4 bg-white/10 text-white border-none rounded w-8 h-8 cursor-pointer flex items-center justify-center text-lg leading-none",
        "aria-label": "Close"
      },
      "\xD7"
    ),
    /* @__PURE__ */ import_react6.default.createElement("div", { className: "max-w-[1200px] mx-auto pt-10" }, /* @__PURE__ */ import_react6.default.createElement("h1", { className: "text-lg font-bold mb-4 border-b border-gray-700 pb-2" }, "Debug Info"), /* @__PURE__ */ import_react6.default.createElement("table", { className: "w-full border-collapse border-spacing-0" }, /* @__PURE__ */ import_react6.default.createElement("tbody", null, /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Props"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 whitespace-pre-wrap break-all" }, formatValue(props))), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Output"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 whitespace-pre-wrap break-all" }, formatValue(output))), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Metadata"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 whitespace-pre-wrap break-all" }, formatValue(metadata))), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "State"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 whitespace-pre-wrap break-all" }, formatValue(state))), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Theme"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2" }, theme)), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Display Mode"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2" }, displayMode)), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Locale"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2" }, locale)), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Max Height"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2" }, maxHeight, "px")), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "User Agent"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2" }, formatUserAgent(userAgent))), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Safe Area"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2" }, formatSafeArea(safeArea))), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "API Available"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2" }, isAvailable ? "Yes" : "No")), /* @__PURE__ */ import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "window.openai Keys"), /* @__PURE__ */ import_react6.default.createElement("td", { className: "p-2" }, windowOpenAiKeys.length > 0 ? windowOpenAiKeys.join(", ") : "N/A")))), /* @__PURE__ */ import_react6.default.createElement("h2", { className: "text-base font-bold mt-8 mb-4 border-b border-gray-700 pb-2" }, "Actions"), /* @__PURE__ */ import_react6.default.createElement("div", { className: "flex flex-col gap-3" }, /* @__PURE__ */ import_react6.default.createElement("div", { className: "flex gap-2 items-center" }, /* @__PURE__ */ import_react6.default.createElement(
      "input",
      {
        type: "text",
        value: toolName,
        onChange: (e) => setToolName(e.target.value),
        placeholder: "Tool name",
        className: "py-1.5 px-2 bg-[#1a1a1a] text-white border border-gray-700 rounded font-mono text-xs w-[150px]"
      }
    ), /* @__PURE__ */ import_react6.default.createElement(
      "input",
      {
        type: "text",
        value: toolArgs,
        onChange: (e) => setToolArgs(e.target.value),
        placeholder: '{"key": "value"}',
        className: "py-1.5 px-2 bg-[#1a1a1a] text-white border border-gray-700 rounded font-mono text-xs flex-1"
      }
    ), /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        onClick: handleCallTool,
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs"
      },
      "Call Tool"
    )), /* @__PURE__ */ import_react6.default.createElement("div", { className: "flex gap-2 items-center" }, /* @__PURE__ */ import_react6.default.createElement(
      "input",
      {
        type: "text",
        value: followUpMessage,
        onChange: (e) => setFollowUpMessage(e.target.value),
        placeholder: "Follow-up message",
        className: "py-1.5 px-2 bg-[#1a1a1a] text-white border border-gray-700 rounded font-mono text-xs flex-1"
      }
    ), /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        onClick: handleSendFollowUpMessage,
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs"
      },
      "Send Follow-Up"
    )), /* @__PURE__ */ import_react6.default.createElement("div", { className: "flex gap-2 items-center" }, /* @__PURE__ */ import_react6.default.createElement(
      "input",
      {
        type: "text",
        value: externalUrl,
        onChange: (e) => setExternalUrl(e.target.value),
        placeholder: "External URL",
        className: "py-1.5 px-2 bg-[#1a1a1a] text-white border border-gray-700 rounded font-mono text-xs flex-1"
      }
    ), /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        onClick: handleOpenExternal,
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs"
      },
      "Open Link"
    )), /* @__PURE__ */ import_react6.default.createElement("div", { className: "flex gap-2 items-center" }, /* @__PURE__ */ import_react6.default.createElement("span", { className: "w-[150px] text-xs" }, "Display Mode:"), /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        onClick: () => handleRequestDisplayMode("inline"),
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs flex-1"
      },
      "Inline"
    ), /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        onClick: () => handleRequestDisplayMode("pip"),
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs flex-1"
      },
      "PiP"
    ), /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        onClick: () => handleRequestDisplayMode("fullscreen"),
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs flex-1"
      },
      "Fullscreen"
    )), /* @__PURE__ */ import_react6.default.createElement("div", { className: "flex gap-2 items-center" }, /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        onClick: handleSetState,
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs"
      },
      "Set State (Add Timestamp)"
    )), actionResult && /* @__PURE__ */ import_react6.default.createElement("div", { className: "mt-2 p-2 bg-[#1a1a1a] border border-gray-700 rounded whitespace-pre-wrap break-all text-[11px] max-h-[200px] overflow-auto" }, /* @__PURE__ */ import_react6.default.createElement("div", { className: "font-bold mb-1 text-gray-400" }, "Result:"), actionResult, /* @__PURE__ */ import_react6.default.createElement(
      "button",
      {
        onClick: () => setActionResult(""),
        className: "mt-2 py-1 px-2 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-[11px]"
      },
      "Clear"
    ))))
  ));
}
__name(WidgetControls, "WidgetControls");

// src/react/McpUseProvider.tsx
var import_react7 = __toESM(require("react"), 1);
var HEIGHT_DEBOUNCE_MS = 150;
var MIN_HEIGHT_CHANGE_PX = 5;
function McpUseProvider({
  children,
  debugger: enableDebugger = false,
  viewControls = false,
  autoSize = true
}) {
  const [containerElement, setContainerElement] = (0, import_react7.useState)(null);
  const lastHeightRef = (0, import_react7.useRef)(0);
  const debounceTimeoutRef = (0, import_react7.useRef)(null);
  const notificationInProgressRef = (0, import_react7.useRef)(false);
  const notifyHeight = (0, import_react7.useCallback)((height) => {
    if (typeof window === "undefined") return;
    notificationInProgressRef.current = true;
    if (window.openai?.notifyIntrinsicHeight) {
      window.openai.notifyIntrinsicHeight(height).then(() => {
        notificationInProgressRef.current = false;
      }).catch((error) => {
        notificationInProgressRef.current = false;
        console.error(
          "[McpUseProvider] Failed to notify intrinsic height (ChatGPT):",
          error
        );
      });
      return;
    }
    try {
      const bridge = getMcpAppsBridge();
      bridge.sendSizeChanged({ height });
      console.log("[McpUseProvider] Sent size-changed notification:", height);
      notificationInProgressRef.current = false;
    } catch (error) {
      notificationInProgressRef.current = false;
      console.error(
        "[McpUseProvider] Failed to notify size change (MCP Apps):",
        error
      );
    }
  }, []);
  const debouncedNotifyHeight = (0, import_react7.useCallback)(
    (height) => {
      if (debounceTimeoutRef.current) {
        clearTimeout(debounceTimeoutRef.current);
      }
      debounceTimeoutRef.current = setTimeout(() => {
        const heightDiff = Math.abs(height - lastHeightRef.current);
        if (heightDiff >= MIN_HEIGHT_CHANGE_PX && height > 0) {
          lastHeightRef.current = height;
          notifyHeight(height);
        }
      }, HEIGHT_DEBOUNCE_MS);
    },
    [notifyHeight]
  );
  (0, import_react7.useEffect)(() => {
    if (!autoSize) {
      console.log("[McpUseProvider] autoSize is disabled");
      return;
    }
    if (!containerElement) {
      console.log("[McpUseProvider] No container element found for autoSize");
      return;
    }
    if (typeof ResizeObserver === "undefined") {
      console.log("[McpUseProvider] ResizeObserver not available");
      return;
    }
    console.log("[McpUseProvider] Setting up ResizeObserver for autoSize");
    const observer = new ResizeObserver((entries) => {
      if (notificationInProgressRef.current) {
        console.log(
          "[McpUseProvider] Skipping resize - notification in progress"
        );
        return;
      }
      for (const entry of entries) {
        const height = entry.contentRect.height;
        const scrollHeight = entry.target.scrollHeight;
        const intrinsicHeight = Math.max(height, scrollHeight);
        console.log("[McpUseProvider] ResizeObserver fired:", {
          height,
          scrollHeight,
          intrinsicHeight
        });
        debouncedNotifyHeight(intrinsicHeight);
      }
    });
    observer.observe(containerElement);
    const initialHeight = Math.max(
      containerElement.offsetHeight,
      containerElement.scrollHeight
    );
    console.log("[McpUseProvider] Initial height measurement:", initialHeight);
    if (initialHeight > 0) {
      debouncedNotifyHeight(initialHeight);
    }
    return () => {
      console.log("[McpUseProvider] Cleaning up ResizeObserver");
      observer.disconnect();
      if (debounceTimeoutRef.current) {
        clearTimeout(debounceTimeoutRef.current);
        debounceTimeoutRef.current = null;
      }
      notificationInProgressRef.current = false;
    };
  }, [autoSize, containerElement, debouncedNotifyHeight]);
  let content = children;
  content = /* @__PURE__ */ import_react7.default.createElement(ErrorBoundary, null, content);
  if (enableDebugger || viewControls) {
    content = /* @__PURE__ */ import_react7.default.createElement(WidgetControls, { debugger: enableDebugger, viewControls }, content);
  }
  content = /* @__PURE__ */ import_react7.default.createElement(ThemeProvider, null, content);
  if (autoSize) {
    const containerStyle = {
      width: "100%",
      minHeight: 0
    };
    content = /* @__PURE__ */ import_react7.default.createElement("div", { ref: setContainerElement, style: containerStyle }, content);
  }
  return /* @__PURE__ */ import_react7.default.createElement(import_react7.StrictMode, null, content);
}
__name(McpUseProvider, "McpUseProvider");

// src/react/useCallTool.ts
var import_react8 = require("react");
function useCallTool(name) {
  const [{ status, data, error }, setCallToolState] = (0, import_react8.useState)({ status: "idle", data: void 0, error: void 0 });
  const callIdRef = (0, import_react8.useRef)(0);
  const execute = /* @__PURE__ */ __name(async (args) => {
    const callId = ++callIdRef.current;
    setCallToolState({ status: "pending", data: void 0, error: void 0 });
    try {
      let raw;
      if (typeof window !== "undefined") {
        if (window.openai?.callTool) {
          raw = await window.openai.callTool(
            name,
            args
          );
        } else if (window !== window.parent) {
          const bridge = getMcpAppsBridge();
          raw = await bridge.callTool(name, args);
        } else {
          throw new Error("No tool calling interface available");
        }
      } else {
        throw new Error("useCallTool can only be used in browser environment");
      }
      const normalized = normalizeCallToolResponse(raw);
      if (callId === callIdRef.current) {
        setCallToolState({
          status: "success",
          data: normalized,
          error: void 0
        });
      }
      return normalized;
    } catch (error2) {
      if (callId === callIdRef.current) {
        setCallToolState({ status: "error", data: void 0, error: error2 });
      }
      throw error2;
    }
  }, "execute");
  const callToolAsync = (0, import_react8.useCallback)(
    ((args) => {
      if (args === void 0) {
        return execute(null);
      }
      return execute(args);
    }),
    [name]
  );
  const callTool = (0, import_react8.useCallback)(
    ((firstArg, sideEffects) => {
      let args;
      if (firstArg && typeof firstArg === "object" && ("onSuccess" in firstArg || "onError" in firstArg || "onSettled" in firstArg)) {
        args = null;
        sideEffects = firstArg;
      } else {
        args = firstArg === void 0 ? null : firstArg;
      }
      execute(args).then((data2) => {
        sideEffects?.onSuccess?.(data2, args);
        sideEffects?.onSettled?.(data2, void 0, args);
      }).catch((error2) => {
        sideEffects?.onError?.(error2, args);
        sideEffects?.onSettled?.(void 0, error2, args);
      });
    }),
    [name]
  );
  const callToolState = {
    status,
    data,
    error,
    isIdle: status === "idle",
    isPending: status === "pending",
    isSuccess: status === "success",
    isError: status === "error"
  };
  return {
    ...callToolState,
    callTool,
    callToolAsync
  };
}
__name(useCallTool, "useCallTool");

// src/react/generateHelpers.ts
function generateHelpers() {
  const useCallTool2 = /* @__PURE__ */ __name((name) => {
    return useCallTool(
      name
    );
  }, "useCallTool");
  const useToolInfo = /* @__PURE__ */ __name(() => {
    return useWidget();
  }, "useToolInfo");
  return {
    useCallTool: useCallTool2,
    useToolInfo
  };
}
__name(generateHelpers, "generateHelpers");

// src/react/McpClientProvider.tsx
var import_react9 = __toESM(require("react"), 1);
init_logging();
var providerLogger = Logger.get("McpClientProvider");
var McpClientContext = (0, import_react9.createContext)(null);
var MAX_NOTIFICATIONS = 500;
function McpServerWrapper({
  id,
  options,
  defaultProxyConfig,
  defaultAutoProxyFallback,
  clientInfo: providerClientInfo,
  cachedMetadata,
  onUpdate,
  rpcWrapTransport,
  onGlobalSamplingRequest,
  onGlobalElicitationRequest
}) {
  const {
    name,
    onSamplingRequest,
    onElicitationRequest,
    onNotificationReceived,
    wrapTransport: optionsWrapTransport
  } = options;
  const mcpOptions = (0, import_react9.useMemo)(() => {
    const {
      name: _name,
      onSamplingRequest: _onSamplingRequest,
      onElicitationRequest: _onElicitationRequest,
      onNotificationReceived: _onNotificationReceived,
      wrapTransport: _wrapTransport,
      ...rest
    } = options;
    return {
      ...rest,
      // Use server-specific proxyConfig if provided, otherwise use default
      proxyConfig: rest.proxyConfig || defaultProxyConfig,
      // Use server-specific autoProxyFallback if provided, otherwise use default
      autoProxyFallback: rest.autoProxyFallback !== void 0 ? rest.autoProxyFallback : defaultAutoProxyFallback,
      // Merge provider clientInfo with server-specific clientInfo
      // Server-specific takes precedence
      clientInfo: rest.clientInfo ? providerClientInfo ? { ...providerClientInfo, ...rest.clientInfo } : rest.clientInfo : providerClientInfo,
      // Pass cached metadata as initial server info if available
      _initialServerInfo: cachedMetadata
    };
  }, [
    options,
    defaultProxyConfig,
    defaultAutoProxyFallback,
    providerClientInfo,
    cachedMetadata
  ]);
  const combinedWrapTransport = (0, import_react9.useMemo)(() => {
    if (!rpcWrapTransport && !optionsWrapTransport) return void 0;
    return (transport) => {
      let wrapped = transport;
      if (rpcWrapTransport) {
        wrapped = rpcWrapTransport(wrapped, id);
      }
      if (optionsWrapTransport) {
        wrapped = optionsWrapTransport(wrapped, id);
      }
      return wrapped;
    };
  }, [rpcWrapTransport, optionsWrapTransport, id]);
  const [notifications, setNotifications] = (0, import_react9.useState)([]);
  const [pendingSamplingRequests, setPendingSamplingRequests] = (0, import_react9.useState)([]);
  const samplingIdCounter = (0, import_react9.useRef)(0);
  const [pendingElicitationRequests, setPendingElicitationRequests] = (0, import_react9.useState)([]);
  const elicitationIdCounter = (0, import_react9.useRef)(0);
  const markNotificationRead = (0, import_react9.useCallback)((notificationId) => {
    setNotifications(
      (prev) => prev.map((n) => n.id === notificationId ? { ...n, read: true } : n)
    );
  }, []);
  const markAllNotificationsRead = (0, import_react9.useCallback)(() => {
    setNotifications((prev) => prev.map((n) => ({ ...n, read: true })));
  }, []);
  const clearNotifications = (0, import_react9.useCallback)(() => {
    setNotifications([]);
  }, []);
  const handleNotification = (0, import_react9.useCallback)(
    (notification) => {
      const mcpNotification = {
        id: globalThis.crypto?.randomUUID?.() || `${Date.now()}-${Math.random()}`,
        method: notification.method,
        params: notification.params,
        timestamp: Date.now(),
        read: false
      };
      setNotifications((prev) => {
        const updated = [mcpNotification, ...prev];
        if (updated.length > MAX_NOTIFICATIONS) {
          return updated.slice(0, MAX_NOTIFICATIONS);
        }
        return updated;
      });
      onNotificationReceived?.(mcpNotification);
    },
    [onNotificationReceived]
  );
  const approveSampling = (0, import_react9.useCallback)(
    (requestId, result) => {
      setPendingSamplingRequests((prev) => {
        const request = prev.find((r) => r.id === requestId);
        if (request) {
          request.resolve(result);
          return prev.filter((r) => r.id !== requestId);
        }
        return prev;
      });
    },
    []
  );
  const rejectSampling = (0, import_react9.useCallback)((requestId, error) => {
    setPendingSamplingRequests((prev) => {
      const request = prev.find((r) => r.id === requestId);
      if (request) {
        request.reject(new Error(error || "User rejected sampling request"));
        return prev.filter((r) => r.id !== requestId);
      }
      return prev;
    });
  }, []);
  const samplingCallback = (0, import_react9.useCallback)(
    async (params) => {
      return new Promise((resolve, reject) => {
        const requestId = `sampling-${samplingIdCounter.current++}`;
        const request = {
          id: requestId,
          request: { method: "sampling/createMessage", params },
          timestamp: Date.now(),
          serverName: name || id
        };
        const newRequest = {
          ...request,
          resolve,
          reject
        };
        setPendingSamplingRequests((prev) => [...prev, newRequest]);
        onSamplingRequest?.(request);
        onGlobalSamplingRequest?.(
          request,
          id,
          name || id,
          approveSampling,
          rejectSampling
        );
      });
    },
    [
      id,
      name,
      onSamplingRequest,
      onGlobalSamplingRequest,
      approveSampling,
      rejectSampling
    ]
  );
  const approveElicitation = (0, import_react9.useCallback)(
    (requestId, result) => {
      setPendingElicitationRequests((prev) => {
        const request = prev.find((r) => r.id === requestId);
        if (request) {
          request.resolve(result);
          return prev.filter((r) => r.id !== requestId);
        }
        return prev;
      });
    },
    []
  );
  const rejectElicitation = (0, import_react9.useCallback)((requestId, error) => {
    setPendingElicitationRequests((prev) => {
      const request = prev.find((r) => r.id === requestId);
      if (request) {
        request.reject(new Error(error || "User rejected elicitation request"));
        return prev.filter((r) => r.id !== requestId);
      }
      return prev;
    });
  }, []);
  const elicitationCallback = (0, import_react9.useCallback)(
    async (params) => {
      return new Promise((resolve, reject) => {
        const requestId = `elicitation-${elicitationIdCounter.current++}`;
        const request = {
          id: requestId,
          request: params,
          timestamp: Date.now(),
          serverName: name || id
        };
        const newRequest = {
          ...request,
          resolve,
          reject
        };
        setPendingElicitationRequests((prev) => [...prev, newRequest]);
        onElicitationRequest?.(request);
        onGlobalElicitationRequest?.(
          request,
          id,
          name || id,
          approveElicitation,
          rejectElicitation
        );
      });
    },
    [
      id,
      name,
      onElicitationRequest,
      onGlobalElicitationRequest,
      approveElicitation,
      rejectElicitation
    ]
  );
  const mcp = useMcp({
    ...mcpOptions,
    onNotification: handleNotification,
    onSampling: samplingCallback,
    onElicitation: elicitationCallback,
    wrapTransport: combinedWrapTransport
  });
  const publicSamplingRequests = (0, import_react9.useMemo)(
    () => pendingSamplingRequests.map((r) => ({
      id: r.id,
      request: r.request,
      timestamp: r.timestamp,
      serverName: r.serverName
    })),
    [pendingSamplingRequests]
  );
  const publicElicitationRequests = (0, import_react9.useMemo)(
    () => pendingElicitationRequests.map((r) => ({
      id: r.id,
      request: r.request,
      timestamp: r.timestamp,
      serverName: r.serverName
    })),
    [pendingElicitationRequests]
  );
  const unreadNotificationCount = (0, import_react9.useMemo)(
    () => notifications.filter((n) => !n.read).length,
    [notifications]
  );
  const toolsFingerprint = (0, import_react9.useMemo)(() => {
    const fingerprint = JSON.stringify(
      mcp.tools.map((t) => ({
        name: t.name,
        description: t.description,
        inputSchema: t.inputSchema,
        _meta: t._meta
      })).sort((a, b) => a.name.localeCompare(b.name))
    );
    return fingerprint;
  }, [mcp.tools, id]);
  const resourcesFingerprint = (0, import_react9.useMemo)(
    () => JSON.stringify(
      mcp.resources.map((r) => ({
        uri: r.uri,
        name: r.name,
        description: r.description,
        mimeType: r.mimeType
      })).sort((a, b) => a.uri.localeCompare(b.uri))
    ),
    [mcp.resources]
  );
  const promptsFingerprint = (0, import_react9.useMemo)(
    () => JSON.stringify(
      mcp.prompts.map((p) => ({
        name: p.name,
        description: p.description,
        arguments: p.arguments
      })).sort((a, b) => a.name.localeCompare(b.name))
    ),
    [mcp.prompts]
  );
  const onUpdateRef = (0, import_react9.useRef)(onUpdate);
  const prevServerRef = (0, import_react9.useRef)(null);
  const prevFingerprintsRef = (0, import_react9.useRef)({ tools: "", resources: "", prompts: "" });
  (0, import_react9.useEffect)(() => {
    onUpdateRef.current = onUpdate;
  }, [onUpdate]);
  (0, import_react9.useEffect)(() => {
    const server = {
      ...mcp,
      id,
      url: options.url || "",
      name: name || id,
      notifications,
      unreadNotificationCount,
      markNotificationRead,
      markAllNotificationsRead,
      clearNotifications,
      pendingSamplingRequests: publicSamplingRequests,
      approveSampling,
      rejectSampling,
      pendingElicitationRequests: publicElicitationRequests,
      approveElicitation,
      rejectElicitation
    };
    const prevServer = prevServerRef.current;
    const prevFingerprints = prevFingerprintsRef.current;
    const toolsChanged = prevFingerprints.tools !== toolsFingerprint;
    const resourcesChanged = prevFingerprints.resources !== resourcesFingerprint;
    const promptsChanged = prevFingerprints.prompts !== promptsFingerprint;
    if (!prevServer || prevServer.state !== server.state || prevServer.error !== server.error || prevServer.authUrl !== server.authUrl || toolsChanged || resourcesChanged || promptsChanged || prevServer.serverInfo !== server.serverInfo || prevServer.capabilities !== server.capabilities || prevServer.notifications.length !== server.notifications.length || prevServer.unreadNotificationCount !== server.unreadNotificationCount || prevServer.pendingSamplingRequests.length !== server.pendingSamplingRequests.length || prevServer.pendingElicitationRequests.length !== server.pendingElicitationRequests.length || !prevServer.client) {
      prevServerRef.current = server;
      prevFingerprintsRef.current = {
        tools: toolsFingerprint,
        resources: resourcesFingerprint,
        prompts: promptsFingerprint
      };
      onUpdateRef.current(server);
    } else {
      providerLogger.debug(
        `[McpServerWrapper ${id}] No meaningful changes detected, skipping onUpdate`
      );
    }
  }, [
    id,
    name,
    options.url,
    // Primitive values that indicate meaningful state changes
    mcp.state,
    mcp.error,
    mcp.authUrl,
    // Use fingerprints to detect content changes (including renames)
    toolsFingerprint,
    resourcesFingerprint,
    promptsFingerprint,
    // serverInfo and capabilities - include for reference comparison
    mcp.serverInfo,
    mcp.capabilities,
    // Functions excluded - they're stable via useCallback in useMcp
    // mcp.log excluded - log changes shouldn't trigger provider updates
    // mcp.client excluded - client reference stability handled by manual check
    notifications.length,
    unreadNotificationCount,
    publicSamplingRequests.length,
    publicElicitationRequests.length,
    // Callback functions are stable via useCallback
    markNotificationRead,
    markAllNotificationsRead,
    clearNotifications,
    approveSampling,
    rejectSampling,
    approveElicitation,
    rejectElicitation
  ]);
  return null;
}
__name(McpServerWrapper, "McpServerWrapper");
function McpClientProvider({
  children,
  mcpServers,
  defaultProxyConfig,
  defaultAutoProxyFallback = true,
  clientInfo,
  storageProvider,
  enableRpcLogging = false,
  onServerAdded,
  onServerRemoved,
  onServerStateChange,
  onSamplingRequest,
  onElicitationRequest
}) {
  const [serverConfigs, setServerConfigs] = (0, import_react9.useState)([]);
  const [servers, setServers] = (0, import_react9.useState)([]);
  const [storageLoaded, setStorageLoaded] = (0, import_react9.useState)(false);
  const cachedMetadataRef = (0, import_react9.useRef)({});
  const [rpcWrapTransport, setRpcWrapTransport] = (0, import_react9.useState)(void 0);
  const [rpcLoggingReady, setRpcLoggingReady] = (0, import_react9.useState)(false);
  (0, import_react9.useEffect)(() => {
    if (!enableRpcLogging || typeof window === "undefined") {
      setRpcWrapTransport(void 0);
      setRpcLoggingReady(true);
      return;
    }
    Promise.resolve().then(() => (init_rpc_logger(), rpc_logger_exports)).then((module2) => {
      providerLogger.debug("[McpClientProvider] RPC logger loaded");
      setRpcWrapTransport(() => module2.wrapTransportForLogging);
      setRpcLoggingReady(true);
    }).catch((err) => {
      providerLogger.error(
        "[McpClientProvider] Failed to load RPC logger:",
        err
      );
      setRpcWrapTransport(void 0);
      setRpcLoggingReady(true);
    });
  }, [enableRpcLogging]);
  (0, import_react9.useEffect)(() => {
    if (!rpcLoggingReady) {
      providerLogger.debug(
        "[McpClientProvider] Waiting for RPC logging to be ready before loading servers"
      );
      return;
    }
    const loadServers = /* @__PURE__ */ __name(async () => {
      providerLogger.debug(
        "[McpClientProvider] Loading servers, storageProvider:",
        !!storageProvider,
        "mcpServers:",
        mcpServers
      );
      if (!storageProvider) {
        if (mcpServers) {
          const configs = Object.entries(mcpServers).map(([id, options]) => ({
            id,
            options
          }));
          providerLogger.debug(
            "[McpClientProvider] Loaded from mcpServers prop:",
            configs.length
          );
          setServerConfigs(configs);
        }
        setStorageLoaded(true);
        return;
      }
      try {
        const storedServers = await Promise.resolve(
          storageProvider.getServers()
        );
        providerLogger.debug(
          "[McpClientProvider] Loaded from storage:",
          Object.keys(storedServers).length
        );
        if (storageProvider.getServerMetadata) {
          try {
            const serverIds = Object.keys(storedServers);
            const metadataPromises = serverIds.map(async (id) => {
              const metadata = await Promise.resolve(
                storageProvider.getServerMetadata(id)
              );
              return [id, metadata];
            });
            const metadataEntries = await Promise.all(metadataPromises);
            cachedMetadataRef.current = Object.fromEntries(
              metadataEntries.filter(
                (entry) => entry[1] !== void 0
              )
            );
            providerLogger.debug(
              "[McpClientProvider] Loaded cached metadata for",
              Object.keys(cachedMetadataRef.current).length,
              "servers"
            );
          } catch (metadataError) {
            providerLogger.warn(
              "[McpClientProvider] Failed to load cached metadata:",
              metadataError
            );
          }
        }
        const mergedServers = { ...storedServers, ...mcpServers };
        const configs = Object.entries(mergedServers).map(([id, options]) => ({
          id,
          options
        }));
        providerLogger.debug(
          "[McpClientProvider] Total servers after merge:",
          configs.length
        );
        setServerConfigs(configs);
        setStorageLoaded(true);
      } catch (error) {
        providerLogger.error(
          "[McpClientProvider] Failed to load from storage:",
          error
        );
        if (mcpServers) {
          const configs = Object.entries(mcpServers).map(([id, options]) => ({
            id,
            options
          }));
          setServerConfigs(configs);
        }
        setStorageLoaded(true);
      }
    }, "loadServers");
    loadServers();
  }, [storageProvider, mcpServers, rpcLoggingReady]);
  (0, import_react9.useEffect)(() => {
    if (!storageProvider || !storageLoaded) return;
    const saveServers = /* @__PURE__ */ __name(async () => {
      try {
        const serversToSave = serverConfigs.reduce(
          (acc, config) => {
            acc[config.id] = config.options;
            return acc;
          },
          {}
        );
        await Promise.resolve(storageProvider.setServers(serversToSave));
      } catch (error) {
        providerLogger.error(
          "[McpClientProvider] Failed to save to storage:",
          error
        );
      }
    }, "saveServers");
    saveServers();
  }, [serverConfigs, storageProvider, storageLoaded]);
  const handleServerUpdate = (0, import_react9.useCallback)(
    (updatedServer) => {
      providerLogger.debug(
        `[McpClientProvider] handleServerUpdate called for server ${updatedServer.id}`,
        {
          toolCount: updatedServer.tools.length,
          state: updatedServer.state
        }
      );
      const callbacksToRun = [];
      setServers((prev) => {
        const index = prev.findIndex((s) => s.id === updatedServer.id);
        const isNewServer = index === -1;
        if (isNewServer) {
          providerLogger.debug(
            `[McpClientProvider] Adding new server ${updatedServer.id} to state`
          );
          callbacksToRun.push(
            () => onServerAdded?.(updatedServer.id, updatedServer)
          );
          return [...prev, updatedServer];
        }
        const current = prev[index];
        const stateChanged = current.state !== updatedServer.state;
        const serverInfoChanged = current.serverInfo !== updatedServer.serverInfo;
        providerLogger.debug(
          `[McpClientProvider] Comparing server ${updatedServer.id}:`,
          {
            toolsChanged: current.tools !== updatedServer.tools,
            currentToolCount: current.tools.length,
            updatedToolCount: updatedServer.tools.length,
            stateChanged
          }
        );
        if (current.state === updatedServer.state && current.tools === updatedServer.tools && current.resources === updatedServer.resources && current.prompts === updatedServer.prompts && current.error === updatedServer.error && current.serverInfo === updatedServer.serverInfo && current.client === updatedServer.client && current.notifications === updatedServer.notifications && current.unreadNotificationCount === updatedServer.unreadNotificationCount && current.pendingSamplingRequests.length === updatedServer.pendingSamplingRequests.length && current.pendingElicitationRequests.length === updatedServer.pendingElicitationRequests.length) {
          providerLogger.debug(
            `[McpClientProvider] No changes detected for server ${updatedServer.id}, skipping update`
          );
          return prev;
        }
        providerLogger.debug(
          `[McpClientProvider] Updating server ${updatedServer.id} in state`
        );
        if (stateChanged) {
          callbacksToRun.push(
            () => onServerStateChange?.(updatedServer.id, updatedServer.state)
          );
        }
        if (serverInfoChanged && updatedServer.serverInfo && storageProvider?.setServerMetadata) {
          const metadata = {
            name: updatedServer.serverInfo.name,
            version: updatedServer.serverInfo.version,
            title: updatedServer.serverInfo.title,
            websiteUrl: updatedServer.serverInfo.websiteUrl,
            icons: updatedServer.serverInfo.icons,
            icon: updatedServer.serverInfo.icon
          };
          cachedMetadataRef.current[updatedServer.id] = metadata;
          Promise.resolve(
            storageProvider.setServerMetadata(updatedServer.id, metadata)
          ).catch((err) => {
            providerLogger.error(
              "[McpClientProvider] Failed to save server metadata:",
              err
            );
          });
        }
        const newServers = [...prev];
        newServers[index] = updatedServer;
        return newServers;
      });
      if (callbacksToRun.length > 0) {
        queueMicrotask(() => {
          callbacksToRun.forEach((callback) => callback());
        });
      }
    },
    [onServerAdded, onServerStateChange, storageProvider]
  );
  const addServer = (0, import_react9.useCallback)((id, options) => {
    providerLogger.debug("[McpClientProvider] addServer called:", id, options);
    setServerConfigs((prev) => {
      if (prev.find((s) => s.id === id)) {
        providerLogger.warn(
          `[McpClientProvider] Server with id "${id}" already exists`
        );
        return prev;
      }
      providerLogger.debug(
        "[McpClientProvider] Adding new server to configs:",
        id
      );
      return [...prev, { id, options }];
    });
  }, []);
  const removeServer = (0, import_react9.useCallback)(
    (id) => {
      setServers((prev) => {
        const server = prev.find((s) => s.id === id);
        if (server?.disconnect) {
          server.disconnect();
        }
        if (server?.clearStorage) {
          server.clearStorage();
        }
        return prev.filter((s) => s.id !== id);
      });
      setServerConfigs((prev) => prev.filter((s) => s.id !== id));
      onServerRemoved?.(id);
    },
    [onServerRemoved]
  );
  const updateServer = (0, import_react9.useCallback)(
    async (id, options) => {
      return new Promise((resolve) => {
        const currentConfig = serverConfigs.find((s) => s.id === id);
        if (!currentConfig) {
          providerLogger.warn(
            `[McpClientProvider] Cannot update server "${id}" - not found`
          );
          resolve();
          return;
        }
        const updatedOptions = {
          ...currentConfig.options,
          ...options,
          // Add a version counter to force React to remount the wrapper
          _updateVersion: (currentConfig.options._updateVersion || 0) + 1
        };
        setServers((prev) => {
          const server = prev.find((s) => s.id === id);
          if (server?.disconnect) {
            server.disconnect();
          }
          if (server?.clearStorage) {
            server.clearStorage();
          }
          return prev.filter((s) => s.id !== id);
        });
        setServerConfigs((prev) => {
          const updated = prev.map(
            (s) => s.id === id ? { id, options: updatedOptions } : s
          );
          setTimeout(() => resolve(), 0);
          return updated;
        });
      });
    },
    [serverConfigs]
  );
  const getServer = (0, import_react9.useCallback)(
    (id) => {
      return servers.find((s) => s.id === id);
    },
    [servers]
  );
  const contextValue = (0, import_react9.useMemo)(
    () => ({
      servers,
      addServer,
      removeServer,
      updateServer,
      getServer,
      storageLoaded
    }),
    [servers, addServer, removeServer, updateServer, getServer, storageLoaded]
  );
  return /* @__PURE__ */ import_react9.default.createElement(McpClientContext.Provider, { value: contextValue }, children, serverConfigs.map((config) => /* @__PURE__ */ import_react9.default.createElement(
    McpServerWrapper,
    {
      key: `${config.id}-v${config.options._updateVersion || 0}`,
      id: config.id,
      options: config.options,
      defaultProxyConfig,
      defaultAutoProxyFallback,
      clientInfo,
      cachedMetadata: cachedMetadataRef.current[config.id],
      onUpdate: handleServerUpdate,
      rpcWrapTransport,
      onGlobalSamplingRequest: onSamplingRequest,
      onGlobalElicitationRequest: onElicitationRequest
    }
  )));
}
__name(McpClientProvider, "McpClientProvider");
function useMcpClient() {
  const context = (0, import_react9.useContext)(McpClientContext);
  if (!context) {
    throw new Error("useMcpClient must be used within a McpClientProvider");
  }
  return context;
}
__name(useMcpClient, "useMcpClient");
function useMcpServer(id) {
  const { getServer } = useMcpClient();
  return getServer(id);
}
__name(useMcpServer, "useMcpServer");

// src/react/storage/LocalStorageProvider.ts
var LocalStorageProvider = class {
  constructor(storageKey = "mcp-client-servers") {
    this.storageKey = storageKey;
    this.metadataKey = `${storageKey}-metadata`;
  }
  static {
    __name(this, "LocalStorageProvider");
  }
  metadataKey;
  getServers() {
    try {
      const stored = localStorage.getItem(this.storageKey);
      return stored ? JSON.parse(stored) : {};
    } catch (error) {
      console.error("[LocalStorageProvider] Failed to load servers:", error);
      return {};
    }
  }
  setServers(servers) {
    try {
      localStorage.setItem(this.storageKey, JSON.stringify(servers));
    } catch (error) {
      console.error("[LocalStorageProvider] Failed to save servers:", error);
    }
  }
  setServer(id, config) {
    const servers = this.getServers();
    servers[id] = config;
    this.setServers(servers);
  }
  removeServer(id) {
    const servers = this.getServers();
    delete servers[id];
    this.setServers(servers);
    this.removeServerMetadata(id);
  }
  clear() {
    try {
      localStorage.removeItem(this.storageKey);
      localStorage.removeItem(this.metadataKey);
    } catch (error) {
      console.error("[LocalStorageProvider] Failed to clear:", error);
    }
  }
  getAllMetadata() {
    try {
      const stored = localStorage.getItem(this.metadataKey);
      return stored ? JSON.parse(stored) : {};
    } catch (error) {
      console.error("[LocalStorageProvider] Failed to load metadata:", error);
      return {};
    }
  }
  setAllMetadata(metadata) {
    try {
      localStorage.setItem(this.metadataKey, JSON.stringify(metadata));
    } catch (error) {
      console.error("[LocalStorageProvider] Failed to save metadata:", error);
    }
  }
  getServerMetadata(id) {
    const allMetadata = this.getAllMetadata();
    return allMetadata[id];
  }
  setServerMetadata(id, metadata) {
    const allMetadata = this.getAllMetadata();
    allMetadata[id] = {
      ...metadata,
      cachedAt: Date.now()
    };
    this.setAllMetadata(allMetadata);
  }
  removeServerMetadata(id) {
    const allMetadata = this.getAllMetadata();
    delete allMetadata[id];
    this.setAllMetadata(allMetadata);
  }
};

// src/react/storage/MemoryStorageProvider.ts
var MemoryStorageProvider = class {
  static {
    __name(this, "MemoryStorageProvider");
  }
  storage = {};
  metadata = {};
  getServers() {
    return { ...this.storage };
  }
  setServers(servers) {
    this.storage = { ...servers };
  }
  setServer(id, config) {
    this.storage[id] = config;
  }
  removeServer(id) {
    delete this.storage[id];
    this.removeServerMetadata(id);
  }
  clear() {
    this.storage = {};
    this.metadata = {};
  }
  getServerMetadata(id) {
    return this.metadata[id];
  }
  setServerMetadata(id, metadata) {
    this.metadata[id] = {
      ...metadata,
      cachedAt: Date.now()
    };
  }
  removeServerMetadata(id) {
    delete this.metadata[id];
  }
};

// src/react/index.ts
init_rpc_logger();
