/**
 * React hook for OpenAI Apps SDK and MCP Apps widget development
 * Wraps window.openai API (Apps SDK) and MCP Apps postMessage protocol
 */
import type { Theme, UnknownObject, UseWidgetResult } from "./widget-types.js";
/**
 * React hook for building MCP Apps and ChatGPT Apps SDK widgets.
 *
 * Abstracts over three runtime providers, selected automatically:
 *
 * 1. **ChatGPT Apps SDK** (`window.openai`) — active when the widget is loaded
 *    inside ChatGPT. Data arrives via `window.openai.toolInput`,
 *    `window.openai.toolOutput`, etc. and through the `openai:set_globals`
 *    custom event.
 *
 * 2. **MCP Apps bridge** (SEP-1865 `postMessage`) — active when the widget is
 *    loaded in any SEP-1865-compliant host (e.g. Claude, Cursor) that is not
 *    ChatGPT. The hook connects via `ui/initialize` and listens for
 *    `ui/notifications/tool-input`, `ui/notifications/tool-input-partial`,
 *    `ui/notifications/tool-result`, and `ui/notifications/host-context-changed`.
 *
 * 3. **URL params fallback** (`mcpUseParams`) — used during local development
 *    (`mcp-use dev` inspector) where `toolInput` and `toolOutput` are injected
 *    via the query string. No live streaming in this mode.
 *
 * ### Data flow (per SEP-1865)
 *
 * ```
 * LLM calls tool → host sends tool-input → widget receives toolInput
 *                → host executes tool  → host sends tool-result
 *                                       → widget receives props (structuredContent)
 * ```
 *
 * The server controls what the **LLM** sees (`content` text array) separately
 * from what the **widget** sees (`structuredContent` / `props`). This lets the
 * tool return rich structured data for rendering without polluting the model's
 * context.
 *
 * ### Key fields
 *
 * - `isPending` — `true` until the tool result arrives; `props` is `Partial<TProps>` while pending.
 * - `props` — merged from toolInput (base) and structuredContent (overlay). When the widget is
 *   exposed as a tool, props = toolInput during pending and structuredContent when done. When
 *   the widget is returned by another tool, props = structuredContent (toolInput = parent's args).
 * - `toolInput` — the arguments the model passed to the tool.
 * - `partialToolInput` / `isStreaming` — real-time argument streaming (MCP Apps only).
 * - `theme`, `displayMode`, `locale`, `timeZone`, `safeArea`, `maxHeight` — host context.
 * - `callTool`, `sendFollowUpMessage`, `openExternal`, `requestDisplayMode` — host actions.
 * - `state` / `setState` — persisted state visible to the model on future turns.
 *
 * @example
 * ```tsx
 * const MyWidget: React.FC = () => {
 *   const { props, isPending, toolInput, theme } = useWidget<
 *     { city: string; temperature: number },  // Props (from structuredContent)
 *     {},                                      // State
 *     { city: string; temperature: number },  // Output type
 *     {},                                      // Metadata
 *     { city: string }                         // ToolInput (tool call args)
 *   >();
 *
 *   if (isPending) return <p>Loading…</p>;
 *
 *   return (
 *     <div data-theme={theme}>
 *       <h1>{props.city}</h1>
 *       <p>{props.temperature}°C</p>
 *       <p>Requested: {toolInput.city}</p>
 *     </div>
 *   );
 * };
 * ```
 */
export declare function useWidget<TProps = UnknownObject, TState = UnknownObject, TOutput = UnknownObject, TMetadata = UnknownObject, TToolInput = UnknownObject>(defaultProps?: TProps): UseWidgetResult<TProps, TState, TOutput, TMetadata, TToolInput>;
/**
 * Hook to get just the widget props (most common use case)
 * @example
 * ```tsx
 * const props = useWidgetProps<{ city: string; temperature: number }>();
 * ```
 */
export declare function useWidgetProps<TProps = UnknownObject>(defaultProps?: TProps): Partial<TProps>;
/**
 * Hook to get theme value
 * @example
 * ```tsx
 * const theme = useWidgetTheme();
 * ```
 */
export declare function useWidgetTheme(): Theme;
/**
 * Hook to get and update widget state
 * @example
 * ```tsx
 * const [favorites, setFavorites] = useWidgetState<string[]>([]);
 * ```
 */
export declare function useWidgetState<TState>(defaultState?: TState): readonly [
    TState | null,
    (state: TState | ((prev: TState | null) => TState)) => Promise<void>
];
//# sourceMappingURL=useWidget.d.ts.map