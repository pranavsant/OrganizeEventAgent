import type { StreamableHTTPClientTransportOptions } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
import { StreamableHTTPClientTransport } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
import { ConnectionManager } from "./base.js";
export declare class StreamableHttpConnectionManager extends ConnectionManager<StreamableHTTPClientTransport> {
    private readonly url;
    private readonly opts?;
    private _transport;
    private reinitializing;
    /**
     * Create a Streamable HTTP connection manager.
     *
     * @param url  The HTTP endpoint URL.
     * @param opts Optional transport options (auth, headers, etc.).
     */
    constructor(url: string | URL, opts?: StreamableHTTPClientTransportOptions);
    /**
     * Spawn a new `StreamableHTTPClientTransport` and wrap it with 404 handling.
     * Per MCP spec, clients MUST re-initialize when receiving 404 for stale sessions.
     */
    protected establishConnection(): Promise<StreamableHTTPClientTransport>;
    /**
     * Re-initialize the transport with a new session
     * This is called when the server returns 404 for a stale session
     */
    private reinitialize;
    /**
     * Close the underlying transport and clean up resources.
     * Per MCP specification, terminates the session with DELETE request before closing.
     */
    protected closeConnection(_connection: StreamableHTTPClientTransport): Promise<void>;
    /**
     * Get the session ID from the transport if available.
     */
    get sessionId(): string | undefined;
}
//# sourceMappingURL=streamable_http.d.ts.map