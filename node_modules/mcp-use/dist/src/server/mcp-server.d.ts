import { McpServer as OfficialMcpServer, type RegisteredPrompt, type RegisteredResource, type RegisteredResourceTemplate, type RegisteredTool } from "@modelcontextprotocol/sdk/server/mcp.js";
import type { CreateMessageRequest, CreateMessageResult } from "@modelcontextprotocol/sdk/types.js";
import type { Hono as HonoType } from "hono";
import { convertZodSchemaToParams, createParamsSchema } from "./tools/index.js";
import { uiResourceRegistration } from "./widgets/index.js";
import type { ElicitFormParams, ElicitOptions, ElicitUrlParams, SampleOptions, ToolContext } from "./types/tool-context.js";
export type { ElicitFormParams, ElicitOptions, ElicitUrlParams, SampleOptions, ToolContext, };
import { getActiveSessions, sendNotification, sendNotificationToSession, sendPromptsListChanged, sendResourcesListChanged, sendToolsListChanged } from "./notifications/index.js";
import type { OAuthProvider } from "./oauth/providers/types.js";
import { listRoots, onRootsChanged } from "./roots/index.js";
import type { SessionData } from "./sessions/index.js";
import type { ServerConfig } from "./types/index.js";
import type { InferPromptInput, PromptCallback, PromptDefinition } from "./types/prompt.js";
import type { ReadResourceCallback, ReadResourceTemplateCallback, ResourceDefinition, ResourceTemplateDefinition } from "./types/resource.js";
import type { InferToolInput, InferToolOutput, ToolCallback, ToolDefinition } from "./types/tool.js";
import { parseTemplateUri as parseTemplateUriHelper } from "./utils/index.js";
/**
 * MCP Server class
 *
 * MCPServerClass provides a complete MCP (Model Context Protocol) server implementation
 * built on top of the Hono web framework. It combines MCP protocol handling with HTTP
 * server capabilities, making it easy to build tools, resources, and prompts that can
 * be accessed by MCP clients.
 * The server can be run as a standalone HTTP server or integrated into existing
 * applications (Cloudflare Workers, Vercel Edge Functions, etc.) using {@link getHandler}.
 *
 * @typeParam HasOAuth - Type parameter indicating if OAuth is configured
 *
 * @example
 * ```typescript
 * // Basic server setup
 * const server = new MCPServer({
 *   name: 'my-server',
 *   version: '1.0.0'
 * });
 *
 * // Register a tool
 * server.tool({
 *   name: 'add',
 *   description: 'Add two numbers',
 *   schema: z.object({
 *     a: z.number(),
 *     b: z.number()
 *   })
 * }, async ({ a, b }) => {
 *   return { content: [{ type: 'text', text: String(a + b) }] };
 * });
 *
 * // Start the server
 * await server.listen(3000);
 * ```
 *
 * @example
 * ```typescript
 * // With OAuth authentication
 * const server = new MCPServer({
 *   name: 'secure-server',
 *   version: '1.0.0',
 *   oauth: oauthAuth0Provider({
 *     clientId: process.env.AUTH0_CLIENT_ID!,
 *     clientSecret: process.env.AUTH0_CLIENT_SECRET!,
 *     domain: process.env.AUTH0_DOMAIN!
 *   })
 * });
 *
 * server.tool({
 *   name: 'protected-action',
 *   description: 'Requires authentication'
 * }, async (params, ctx) => {
 *   const auth = ctx.auth; // OAuth user info available
 *   return text(`Hello, ${auth.user.email}`);
 * });
 * ```
 *
 * @see {@link MCPClient} for connecting to MCP servers
 * @see {@link tool} for registering tools
 * @see {@link resource} for serving resources
 * @see {@link prompt} for defining prompts
 */
declare class MCPServerClass<HasOAuth extends boolean = false> {
    /**
     * Gets the mcp-use package version.
     *
     * @returns The package version string (e.g., "1.13.2")
     *
     * @example
     * ```typescript
     * console.log(`Server version: ${MCPServer.getPackageVersion()}`);
     * ```
     */
    static getPackageVersion(): string;
    /**
     * Native MCP server instance from the official SDK.
     *
     * This is the underlying server from `@modelcontextprotocol/sdk` that handles
     * the MCP protocol. Exposed publicly for advanced use cases that need direct
     * access to SDK functionality.
     *
     * @example
     * ```typescript
     * // Access native SDK methods
     * server.nativeServer.server.setRequestHandler(...);
     * ```
     */
    readonly nativeServer: OfficialMcpServer;
    /**
     * @deprecated Use {@link nativeServer} instead.
     * Kept for backward compatibility with older code.
     */
    get server(): OfficialMcpServer;
    /**
     * Server configuration including name, version, OAuth settings, etc.
     */
    config: ServerConfig;
    /**
     * Hono application instance.
     *
     * The underlying Hono app that handles HTTP routing and middleware.
     * Can be used to add custom routes and middleware alongside MCP endpoints.
     *
     * @example
     * ```typescript
     * // Add custom HTTP endpoint
     * server.app.get('/health', (c) => c.json({ status: 'ok' }));
     * ```
     */
    app: HonoType;
    /** @internal Whether MCP endpoints have been mounted */
    private mcpMounted;
    /** @internal Whether inspector UI has been mounted */
    private inspectorMounted;
    /** @internal Whether public routes have been set up and in what mode */
    private publicRoutesMode;
    /**
     * @internal Mutable registry of custom HTTP route handlers for HMR support.
     * Key format: "METHOD:PATH" (e.g., "get:/api/fruits")
     * Handlers are stored here so they can be swapped during HMR without
     * re-registering routes on the immutable Hono router.
     */
    _customRoutes: Map<string, ((...args: any[]) => any)[]>;
    /**
     * Port number the server is listening on (set after calling {@link listen}).
     */
    serverPort?: number;
    /**
     * Hostname the server is bound to (default: "localhost").
     */
    serverHost: string;
    /**
     * Full base URL for the server (e.g., "https://example.com").
     * Used for generating widget URLs and OAuth callbacks.
     */
    serverBaseUrl?: string;
    /**
     * Optional favicon URL to display in inspector and documentation.
     */
    favicon?: string;
    /**
     * List of registered tool names.
     */
    registeredTools: string[];
    /**
     * List of registered prompt names.
     */
    registeredPrompts: string[];
    /**
     * List of registered resource URIs.
     */
    registeredResources: string[];
    /**
     * Optional build identifier for cache busting widget URLs.
     * @internal
     */
    buildId?: string;
    /**
     * Map of active client sessions.
     * Each session represents a connected MCP client with its own server instance.
     */
    sessions: Map<string, SessionData>;
    private idleCleanupInterval?;
    private oauthSetupState;
    oauthProvider?: OAuthProvider;
    private oauthMiddleware?;
    /**
     * Storage for registrations that can be replayed on new server instances
     * Following the official SDK pattern where each session gets its own server instance
     * @internal Exposed for telemetry purposes
     */
    registrations: {
        tools: Map<string, {
            config: ToolDefinition;
            handler: ToolCallback;
        }>;
        prompts: Map<string, {
            config: PromptDefinition;
            handler: PromptCallback;
        }>;
        resources: Map<string, {
            config: ResourceDefinition;
            handler: ReadResourceCallback;
        }>;
        resourceTemplates: Map<string, {
            config: ResourceTemplateDefinition;
            handler: ReadResourceTemplateCallback;
        }>;
    };
    /**
     * Storage for widget definitions, used to inject metadata into tool responses
     * when using the widget() helper with returnsWidget option
     */
    widgetDefinitions: Map<string, Record<string, unknown>>;
    /**
     * Storage for SDK-registered tool/prompt/resource references per session.
     * These refs have update() and remove() methods for hot reloading.
     * @internal Used for HMR in development mode
     */
    sessionRegisteredRefs: Map<string, {
        tools: Map<string, RegisteredTool>;
        prompts: Map<string, RegisteredPrompt>;
        resources: Map<string, RegisteredResource>;
        resourceTemplates: Map<string, RegisteredResourceTemplate>;
    }>;
    /**
     * Resource subscription manager for tracking and notifying resource updates
     */
    private subscriptionManager;
    /**
     * Clean up resource subscriptions for a closed session
     *
     * This method is called automatically when a session is closed to remove
     * all resource subscriptions associated with that session.
     *
     * @param sessionId - The session ID to clean up
     * @internal
     */
    cleanupSessionSubscriptions(sessionId: string): void;
    /**
     * Clean up registered refs for a closed session
     *
     * This method is called automatically when a session is closed to remove
     * all registered tool/prompt/resource refs associated with that session.
     *
     * @param sessionId - The session ID to clean up
     * @internal
     */
    cleanupSessionRefs(sessionId: string): void;
    /**
     * Add a new widget tool directly to all active sessions (for HMR)
     *
     * This method adds a widget tool to all active sessions' internal state
     * immediately, ensuring the tool is queryable before notifications are sent.
     * This prevents race conditions where clients fetch tools before registration completes.
     *
     * Also registers the associated widget resources (static and template) for Apps SDK widgets.
     *
     * @param toolDefinition - The tool definition
     * @param toolCallback - The tool callback function
     * @internal
     */
    addWidgetTool(toolDefinition: any, toolCallback: any): void;
    /**
     * Propagate widget resources (static + template) to all existing sessions.
     *
     * Called from uiResourceRegistration after resource/resourceTemplate have been
     * added to wrapper-level registrations. This ensures existing sessions see
     * newly discovered widgets without requiring a reconnect, even when the widget
     * does not expose an auto-generated tool (exposeAsTool=false).
     *
     * @param widgetName - Name of the widget whose resources should be pushed
     * @internal
     */
    propagateWidgetResourcesToSessions(widgetName: string): void;
    /**
     * Update a widget tool's configuration in place (for HMR)
     *
     * This method updates a widget tool's metadata (description, schema) without
     * re-registering it. It updates both the wrapper's registrations and the SDK's
     * internal state, then sends notifications to all connected clients.
     *
     * @param toolName - The name of the tool to update
     * @param updates - The updated tool configuration
     * @internal
     */
    updateWidgetToolInPlace(toolName: string, updates: {
        description?: string;
        schema?: unknown;
        _meta?: Record<string, unknown>;
    }): boolean;
    /**
     * Remove a widget tool and its associated resources (for HMR)
     *
     * This method removes a widget's tool and resource registrations when
     * the widget is deleted or renamed. It updates both the wrapper's
     * registrations and the SDK's internal state, then sends notifications.
     *
     * @param toolName - The name of the tool/widget to remove
     * @internal
     */
    removeWidgetTool(toolName: string): void;
    /**
     * Sync registrations from another MCPServer instance (for hot reload)
     *
     * This method compares the current registrations with another server instance's
     * registrations and updates existing sessions accordingly:
     * - Removes tools/prompts/resources that no longer exist
     * - Adds new tools/prompts/resources
     * - Updates changed tools/prompts/resources
     *
     * After syncing, sends list_changed notifications to all connected clients.
     *
     * @param other - Another MCPServer instance with updated registrations
     *
     * @example
     * ```typescript
     * // In CLI dev mode, after re-importing the server module
     * const newServer = await import('./server.ts?t=' + Date.now());
     * runningServer.syncRegistrationsFrom(newServer.server);
     * ```
     */
    syncRegistrationsFrom(other: MCPServerClass<boolean>): {
        totalChanges: number;
        tools: {
            added: number;
            removed: number;
            updated: number;
        };
        prompts: {
            added: number;
            removed: number;
            updated: number;
        };
        resources: {
            added: number;
            removed: number;
            updated: number;
        };
    };
    /**
     * Get the most recently created MCPServer instance.
     * Used by CLI dev mode for hot reload support.
     * Uses globalThis to work across ESM module boundaries.
     * @internal
     */
    static getLastCreatedInstance(): MCPServerClass<any> | null;
    /**
     * Creates a new MCP server instance with Hono integration.
     *
     * Initializes the server with the provided configuration, sets up the native MCP
     * server from the official SDK, creates a Hono application for HTTP handling,
     * and configures the environment for serving MCP protocol over HTTP.
     *
     * The constructor automatically:
     * - Creates the native MCP server with protocol capabilities
     * - Initializes the Hono web framework
     * - Sets up OAuth if configured
     * - Configures session management (stateful or stateless)
     * - Wraps registration methods for multi-session support
     * - Returns a proxy that supports both MCP and Hono methods
     *
     * @param config - Server configuration object
     * @param config.name - Server name (displayed to clients)
     * @param config.version - Server version string (default: "1.0.0")
     * @param config.description - Optional server description
     * @param config.host - Hostname for URLs (default: "localhost")
     * @param config.baseUrl - Full base URL (overrides host:port for public URLs)
     * @param config.favicon - Optional favicon URL
     * @param config.oauth - Optional OAuth provider configuration
     * @param config.stateless - Whether to use stateless mode (auto-detected for Deno)
     * @param config.sessionIdleTimeoutMs - Session idle timeout (default: 86400000 = 1 day)
     * @param config.cors - Optional CORS configuration overrides
     * @param config.allowedOrigins - Allowed origins for DNS rebinding host validation
     *
     * @returns Proxied server instance supporting both MCP and Hono methods
     *
     * @example
     * ```typescript
     * // Minimal configuration
     * const server = new MCPServer({
     *   name: 'my-server',
     *   version: '1.0.0'
     * });
     * ```
     *
     * @example
     * ```typescript
     * // With custom host and description
     * const server = new MCPServer({
     *   name: 'api-server',
     *   version: '2.0.0',
     *   description: 'API integration server',
     *   host: '0.0.0.0', // Listen on all interfaces
     *   baseUrl: 'https://api.example.com' // Public URL
     * });
     * ```
     *
     * @example
     * ```typescript
     * // With OAuth authentication
     * const server = new MCPServer({
     *   name: 'secure-server',
     *   version: '1.0.0',
     *   oauth: oauthWorkOSProvider({
     *     clientId: process.env.WORKOS_CLIENT_ID!,
     *     clientSecret: process.env.WORKOS_CLIENT_SECRET!,
     *     apiKey: process.env.WORKOS_API_KEY!
     *   })
     * });
     * ```
     *
     * @example
     * ```typescript
     * // Stateless mode (for serverless platforms)
     * const server = new MCPServer({
     *   name: 'edge-server',
     *   version: '1.0.0',
     *   stateless: true // No session storage
     * });
     * ```
     *
     * @see {@link ServerConfig} for detailed configuration options
     * @see {@link listen} for starting the HTTP server
     * @see {@link getHandler} for serverless deployment
     */
    constructor(config: ServerConfig);
    /**
     * Wrap registration methods to capture registrations following official SDK pattern.
     * Each session will get a fresh server instance with all registrations replayed.
     */
    private wrapRegistrationMethods;
    /**
     * Create a new server instance for a session following official SDK pattern.
     * This is called for each initialize request to create an isolated server.
     *
     * @param sessionId - Optional session ID to store registered refs for hot reload support
     */
    getServerForSession(sessionId?: string): OfficialMcpServer;
    /**
     * Gets the server base URL with fallback to host:port if not configured
     * @returns The complete base URL for the server
     */
    private getServerBaseUrl;
    /**
     * Registers a tool that can be called by MCP clients.
     *
     * Tools are executable functions that clients can invoke to perform actions
     * like reading files, making API calls, running commands, etc. Each tool has
     * a name, description, input schema, and callback function.
     *
     * @param toolDefinition - Tool configuration object
     * @param toolDefinition.name - Unique tool name (used by clients to call it)
     * @param toolDefinition.description - Human-readable description of what the tool does
     * @param toolDefinition.schema - Zod schema for validating input parameters
     * @param toolDefinition.cb - Optional callback function (can also be second parameter)
     * @param callback - Optional callback function (alternative to toolDefinition.cb)
     * @returns This server instance for method chaining
     *
     * @example
     * ```typescript
     * // Basic tool
     * server.tool({
     *   name: 'get-time',
     *   description: 'Get current time'
     * }, async () => {
     *   return text(new Date().toISOString());
     * });
     * ```
     *
     * @example
     * ```typescript
     * // Tool with parameters
     * server.tool({
     *   name: 'add',
     *   description: 'Add two numbers',
     *   schema: z.object({
     *     a: z.number(),
     *     b: z.number()
     *   })
     * }, async ({ a, b }) => {
     *   return text(String(a + b));
     * });
     * ```
     *
     * @example
     * ```typescript
     * // Tool with context (for OAuth)
     * server.tool({
     *   name: 'user-info',
     *   description: 'Get user information'
     * }, async (params, ctx) => {
     *   if (!ctx.auth) {
     *     return error('Not authenticated');
     *   }
     *   return text(`User: ${ctx.auth.user.email}`);
     * });
     * ```
     *
     * @see {@link ToolDefinition} for all configuration options
     * @see {@link ToolCallback} for callback signature
     */
    tool: <T extends ToolDefinition<any, any, HasOAuth>>(toolDefinition: T & ToolDefinition<any, any, HasOAuth>, callback?: ToolCallback<InferToolInput<T>, InferToolOutput<T>, HasOAuth>) => this;
    /**
     * Converts a Zod schema to MCP parameter format.
     * @internal Used internally by tool registration
     */
    convertZodSchemaToParams: typeof convertZodSchemaToParams;
    /**
     * Creates parameter schema from input definitions.
     * @internal Used internally by tool registration
     */
    createParamsSchema: typeof createParamsSchema;
    /**
     * Parses URI parameters from resource template URIs.
     * @internal Used internally by resource templates
     */
    parseTemplateUri: typeof parseTemplateUriHelper;
    /**
     * Registers a resource that can be read by MCP clients.
     *
     * Resources represent data or content that clients can access, such as
     * files, database records, API responses, etc. Each resource has a unique
     * URI and returns content when read.
     *
     * @param resourceDefinition - Resource configuration object
     * @param resourceDefinition.name - Resource display name
     * @param resourceDefinition.uri - Unique resource URI (e.g., "file:///path/to/file")
     * @param resourceDefinition.description - Human-readable description
     * @param resourceDefinition.mimeType - MIME type of content (default: "text/plain")
     * @param callback - Callback function that returns resource content
     * @returns This server instance for method chaining
     *
     * @example
     * ```typescript
     * // Static resource
     * server.resource({
     *   name: 'config',
     *   uri: 'app://config',
     *   description: 'Application configuration'
     * }, async () => {
     *   return text(JSON.stringify(config, null, 2));
     * });
     * ```
     *
     * @example
     * ```typescript
     * // Dynamic resource
     * server.resource({
     *   name: 'system-status',
     *   uri: 'system://status',
     *   mimeType: 'application/json'
     * }, async () => {
     *   const status = await getSystemStatus();
     *   return text(JSON.stringify(status));
     * });
     * ```
     *
     * @see {@link ResourceDefinition} for all configuration options
     * @see {@link resourceTemplate} for parameterized resources
     */
    resource: (resourceDefinition: ResourceDefinition<HasOAuth> | import("./types/index.js").ResourceDefinitionWithoutCallback, callback?: ReadResourceCallback<HasOAuth>) => this;
    /**
     * Registers a resource template for parameterized resources.
     *
     * Resource templates allow clients to read resources with dynamic URIs
     * by providing a URI template with parameters (e.g., "file:///{path}").
     * When a client reads a URI matching the template, the parameters are
     * extracted and passed to the callback.
     *
     * @param templateDefinition - Resource template configuration
     * @param templateDefinition.name - Template display name
     * @param templateDefinition.uriTemplate - URI template with parameters (e.g., "files:///{id}")
     * @param templateDefinition.description - Human-readable description
     * @param templateDefinition.mimeType - MIME type of content
     * @param callback - Callback receiving URI and extracted parameters
     * @returns This server instance for method chaining
     *
     * @example
     * ```typescript
     * // File resource template
     * server.resourceTemplate({
     *   name: 'files',
     *   uriTemplate: 'file:///{path}',
     *   description: 'Read files by path'
     * }, async (uri, params) => {
     *   const content = await fs.readFile(params.path, 'utf-8');
     *   return text(content);
     * });
     * ```
     *
     * @example
     * ```typescript
     * // Database record template
     * server.resourceTemplate({
     *   name: 'users',
     *   uriTemplate: 'db://users/{id}',
     *   mimeType: 'application/json'
     * }, async (uri, params) => {
     *   const user = await db.users.get(params.id);
     *   return text(JSON.stringify(user));
     * });
     * ```
     *
     * @see {@link ResourceTemplateDefinition} for all configuration options
     * @see {@link resource} for static resources
     */
    resourceTemplate: (templateDefinition: ResourceTemplateDefinition<HasOAuth> | import("./types/index.js").ResourceTemplateDefinitionWithoutCallback | import("./types/index.js").FlatResourceTemplateDefinition<HasOAuth> | import("./types/index.js").FlatResourceTemplateDefinitionWithoutCallback, callback?: ReadResourceTemplateCallback<HasOAuth>) => this;
    /**
     * Registers a prompt template that clients can use.
     *
     * Prompts are reusable templates that help structure conversations with
     * language models. They can accept parameters and return formatted messages
     * ready to send to an LLM.
     *
     * @param promptDefinition - Prompt configuration object
     * @param promptDefinition.name - Unique prompt name
     * @param promptDefinition.description - Human-readable description
     * @param promptDefinition.schema - Zod schema for prompt arguments
     * @param callback - Callback that returns prompt messages
     * @returns This server instance for method chaining
     *
     * @example
     * ```typescript
     * // Simple prompt
     * server.prompt({
     *   name: 'greeting',
     *   description: 'Generate a greeting message'
     * }, async () => {
     *   return {
     *     messages: [
     *       { role: 'user', content: { type: 'text', text: 'Hello!' } }
     *     ]
     *   };
     * });
     * ```
     *
     * @example
     * ```typescript
     * // Parameterized prompt
     * server.prompt({
     *   name: 'code-review',
     *   description: 'Review code with specific focus',
     *   schema: z.object({
     *     code: z.string(),
     *     focus: z.enum(['security', 'performance', 'style'])
     *   })
     * }, async ({ code, focus }) => {
     *   return {
     *     messages: [
     *       {
     *         role: 'user',
     *         content: {
     *           type: 'text',
     *           text: `Review this code focusing on ${focus}:\n\n${code}`
     *         }
     *       }
     *     ]
     *   };
     * });
     * ```
     *
     * @see {@link PromptDefinition} for all configuration options
     */
    prompt: <T extends PromptDefinition<any, HasOAuth> | import("./types/index.js").PromptDefinitionWithoutCallback>(promptDefinition: T & (PromptDefinition<any, HasOAuth> | import("./types/index.js").PromptDefinitionWithoutCallback), callback?: PromptCallback<InferPromptInput<T>, HasOAuth>) => this;
    /**
     * Gets all active client sessions.
     *
     * @returns Array of active session IDs
     *
     * @example
     * ```typescript
     * const sessions = server.getActiveSessions();
     * console.log(`Active sessions: ${sessions.length}`);
     * ```
     */
    getActiveSessions: typeof getActiveSessions;
    /**
     * Sends a notification to all connected clients.
     *
     * @param method - Notification method name
     * @param params - Notification parameters
     *
     * @example
     * ```typescript
     * await server.sendNotification('custom/event', { data: 'value' });
     * ```
     */
    sendNotification: typeof sendNotification;
    /**
     * Sends a notification to a specific client session.
     *
     * @param sessionId - Target session ID
     * @param method - Notification method name
     * @param params - Notification parameters
     *
     * @example
     * ```typescript
     * await server.sendNotificationToSession('session-123', 'custom/event', { data: 'value' });
     * ```
     */
    sendNotificationToSession: typeof sendNotificationToSession;
    /**
     * Notifies all clients that the tools list has changed.
     * Clients should refresh their tools list.
     *
     * @example
     * ```typescript
     * server.tool({ name: 'new-tool', description: 'New tool' }, handler);
     * await server.sendToolsListChanged();
     * ```
     */
    sendToolsListChanged: typeof sendToolsListChanged;
    /**
     * Notifies all clients that the resources list has changed.
     * Clients should refresh their resources list.
     *
     * @example
     * ```typescript
     * server.resource({ name: 'new-resource', uri: 'new://' }, handler);
     * await server.sendResourcesListChanged();
     * ```
     */
    sendResourcesListChanged: typeof sendResourcesListChanged;
    /**
     * Notifies all clients that the prompts list has changed.
     * Clients should refresh their prompts list.
     *
     * @example
     * ```typescript
     * server.prompt({ name: 'new-prompt', description: 'New prompt' }, handler);
     * await server.sendPromptsListChanged();
     * ```
     */
    sendPromptsListChanged: typeof sendPromptsListChanged;
    /**
     * Notify subscribed clients that a resource has been updated
     *
     * This method sends a `notifications/resources/updated` notification to all
     * sessions that have subscribed to the specified resource URI.
     *
     * @param uri - The URI of the resource that changed
     * @returns Promise that resolves when all notifications have been sent
     *
     * @example
     * ```typescript
     * // After updating a resource, notify subscribers
     * await server.notifyResourceUpdated("file:///path/to/resource.txt");
     * ```
     */
    notifyResourceUpdated(uri: string): Promise<void>;
    /**
     * Registers a UI resource for interactive widgets.
     *
     * UI resources allow serving interactive components that can be displayed
     * in compatible MCP clients (like ChatGPT with Apps SDK).
     *
     * @param definition - UI resource definition
     * @returns This server instance for method chaining
     *
     * @example
     * ```typescript
     * server.uiResource({
     *   name: 'chart-viewer',
     *   uri: 'ui://chart',
     *   html: '<div>Chart goes here</div>'
     * });
     * ```
     *
     * @see {@link UIResourceDefinition} for configuration options
     */
    uiResource: (definition: Parameters<typeof uiResourceRegistration>[1]) => any;
    /**
     * Mount MCP server endpoints at /mcp and /sse
     *
     * Sets up the HTTP transport layer for the MCP server, creating endpoints for
     * Server-Sent Events (SSE) streaming, POST message handling, and DELETE session cleanup.
     * The transport manages multiple sessions through a single server instance.
     *
     * This method is called automatically when the server starts listening and ensures
     * that MCP clients can communicate with the server over HTTP.
     *
     * @private
     * @returns Promise that resolves when MCP endpoints are successfully mounted
     *
     * @example
     * Endpoints created:
     * - GET /mcp, GET /sse - SSE streaming endpoint for real-time communication
     * - POST /mcp, POST /sse - Message handling endpoint for MCP protocol messages
     * - DELETE /mcp, DELETE /sse - Session cleanup endpoint
     */
    private mountMcp;
    /**
     * Starts the HTTP server and begins listening for connections.
     *
     * This method is the primary way to run an MCP server as a standalone HTTP service.
     * It performs the following initialization:
     * 1. Mounts MCP protocol endpoints at `/mcp` and `/sse`
     * 2. Mounts inspector UI at `/inspector` (if available)
     * 3. Mounts widget serving routes
     * 4. Sets up OAuth routes (if configured)
     * 5. Starts the HTTP server on the specified port
     *
     * Port resolution (in order of priority):
     * 1. `port` parameter
     * 2. `--port` CLI argument
     * 3. `PORT` environment variable
     * 4. Default: 3000
     *
     * Host configuration:
     * - Uses `config.host` or `HOST` environment variable
     * - Defaults to "localhost"
     *
     * Base URL:
     * - Uses `config.baseUrl` or `MCP_URL` environment variable
     * - Falls back to `http://${host}:${port}`
     *
     * @param port - Optional port number to listen on
     * @returns Promise that resolves when the server is listening
     *
     * @example
     * ```typescript
     * // Basic usage
     * const server = new MCPServer({ name: 'my-server', version: '1.0.0' });
     * server.tool({ name: 'hello', description: 'Say hello' }, async () => {
     *   return text('Hello, world!');
     * });
     * await server.listen(3000);
     * // Server running at: http://localhost:3000
     * // MCP endpoint: http://localhost:3000/mcp
     * // Inspector UI: http://localhost:3000/inspector
     * ```
     *
     * @example
     * ```typescript
     * // Using environment variables
     * // PORT=8080 HOST=0.0.0.0 node server.js
     * await server.listen(); // Listens on 0.0.0.0:8080
     * ```
     *
     * @example
     * ```typescript
     * // With custom base URL (e.g., behind reverse proxy)
     * const server = new MCPServer({
     *   name: 'my-server',
     *   version: '1.0.0',
     *   baseUrl: 'https://api.example.com'
     * });
     * await server.listen(3000);
     * // Server listens on port 3000 but generates URLs with https://api.example.com
     * ```
     *
     * @example
     * ```typescript
     * // Command-line usage
     * // node server.js --port 8080
     * await server.listen(); // Uses port from CLI argument
     * ```
     *
     * @see {@link getHandler} for serverless deployment without listen()
     */
    /**
     * Logs registered tools, prompts, and resources to console.
     * @internal
     */
    private logRegisteredItems;
    /**
     * Gets the build identifier for cache busting.
     *
     * @returns Build ID string or undefined
     * @internal
     */
    getBuildId(): string | undefined;
    /**
     * Gets the port number the server is listening on.
     *
     * @returns Port number (defaults to 3000 if not yet listening)
     *
     * @example
     * ```typescript
     * await server.listen(8080);
     * console.log(`Server port: ${server.getServerPort()}`); // 8080
     * ```
     */
    getServerPort(): number;
    /**
     * Creates a message using sampling (LLM completion).
     *
     * This method delegates to the native SDK server to handle sampling requests.
     * Sampling allows tools to ask the LLM to generate responses, enabling
     * agent-like behavior where tools can request LLM assistance.
     *
     * @param params - Message creation parameters
     * @param options - Optional request options
     * @returns Message creation result from the LLM
     *
     * @example
     * ```typescript
     * // In a tool callback with sampling capability
     * const result = await server.createMessage({
     *   messages: [
     *     { role: 'user', content: { type: 'text', text: 'Explain MCP' } }
     *   ],
     *   maxTokens: 100
     * });
     * ```
     */
    createMessage(params: CreateMessageRequest["params"], options?: any): Promise<CreateMessageResult>;
    listen(port?: number): Promise<void>;
    private _trackServerRun;
    /**
     * Get the fetch handler for the server after mounting all endpoints
     *
     * This method prepares the server by mounting MCP endpoints, widgets, and inspector
     * (if available), then returns the fetch handler. This is useful for integrating
     * with external server frameworks like Supabase Edge Functions, Cloudflare Workers,
     * or other platforms that handle the server lifecycle themselves.
     *
     * Unlike `listen()`, this method does not start a server - it only prepares the
     * routes and returns the handler function that can be used with external servers.
     *
     * @param options - Optional configuration for the handler
     * @param options.provider - Platform provider (e.g., 'supabase') to handle platform-specific path rewriting
     * @returns Promise that resolves to the fetch handler function
     *
     * @example
     * ```typescript
     * // For Supabase Edge Functions (handles path rewriting automatically)
     * const server = new MCPServer({ name: 'my-server', version: '1.0.0' });
     * server.tool({ ... });
     * const handler = await server.getHandler({ provider: 'supabase' });
     * Deno.serve(handler);
     * ```
     *
     * @example
     * ```typescript
     * // For Cloudflare Workers
     * const server = new MCPServer({ name: 'my-server', version: '1.0.0' });
     * server.tool({ ... });
     * const handler = await server.getHandler();
     * export default { fetch: handler };
     * ```
     */
    getHandler(options?: {
        provider?: "supabase" | "cloudflare" | "deno-deploy";
    }): Promise<(req: Request) => Promise<Response>>;
    /**
     * Registers a callback for when client roots change.
     *
     * Roots represent directories or files that the client has access to.
     * This callback is invoked when a client updates its root list.
     *
     * @param callback - Function to call when roots change
     *
     * @example
     * ```typescript
     * server.onRootsChanged((roots) => {
     *   console.log(`Client roots updated: ${roots.length} roots`);
     *   roots.forEach(root => console.log(`  - ${root.uri}`));
     * });
     * ```
     */
    onRootsChanged: typeof onRootsChanged;
    /**
     * Lists the current roots from connected clients.
     *
     * @returns Promise resolving to array of Root objects
     *
     * @example
     * ```typescript
     * const roots = await server.listRoots();
     * console.log(`Current roots: ${roots.map(r => r.uri).join(', ')}`);
     * ```
     */
    listRoots: typeof listRoots;
    /**
     * Mount MCP Inspector UI at /inspector
     *
     * Dynamically loads and mounts the MCP Inspector UI package if available, providing
     * a web-based interface for testing and debugging MCP servers. The inspector
     * automatically connects to the local MCP server endpoints.
     *
     * This method gracefully handles cases where the inspector package is not installed,
     * allowing the server to function without the inspector in production environments.
     *
     * @private
     * @returns void
     *
     * @example
     * If @mcp-use/inspector is installed:
     * - Inspector UI available at http://localhost:PORT/inspector
     * - Automatically connects to http://localhost:PORT/mcp (or /sse)
     *
     * If not installed:
     * - Server continues to function normally
     * - No inspector UI available
     */
    private mountInspector;
}
export type McpServerInstance<HasOAuth extends boolean = false> = MCPServerClass<HasOAuth> & HonoType;
export type MCPServer<HasOAuth extends boolean = false> = MCPServerClass<HasOAuth>;
export interface MCPServerConstructor {
    new (config: ServerConfig & {
        oauth: NonNullable<ServerConfig["oauth"]>;
    }): McpServerInstance<true>;
    new (config: ServerConfig): McpServerInstance<false>;
    prototype: MCPServerClass<boolean>;
}
export declare const MCPServer: MCPServerConstructor;
/**
 * Create a new MCP server instance
 *
 * @param name - Server name
 * @param config - Optional server configuration
 * @param config.version - Server version (defaults to '1.0.0')
 * @param config.description - Server description
 * @param config.host - Hostname for widget URLs and server endpoints (defaults to 'localhost')
 * @param config.baseUrl - Full base URL (e.g., 'https://myserver.com') - overrides host:port for widget URLs
 * @param config.allowedOrigins - Allowed origins for DNS rebinding host validation (global when configured)
 *   - If not set: host validation is disabled
 *   - If set: host validation is enabled for all routes
 *   - See {@link ServerConfig.allowedOrigins} for detailed documentation
 * @param config.sessionIdleTimeoutMs - Idle timeout for sessions in milliseconds (default: 86400000 = 1 day)
 * @returns McpServerInstance with both MCP and Hono methods
 *
 * @example
 * ```typescript
 * // Recommended: Use class constructor (matches MCPClient/MCPAgent pattern)
 * const server = new MCPServer({
 *   name: 'my-server',
 *   version: '1.0.0',
 *   description: 'My MCP server'
 * })
 *
 * // Legacy: Factory function (still supported for backward compatibility)
 * const server = createMCPServer('my-server', {
 *   version: '1.0.0',
 *   description: 'My MCP server'
 * })
 *
 * // Production mode with explicit allowed origins
 * const server = new MCPServer({
 *   name: 'my-server',
 *   version: '1.0.0',
 *   allowedOrigins: [
 *     'https://myapp.com',
 *     'https://app.myapp.com'
 *   ]
 * })
 *
 * // With custom host (e.g., for Docker or remote access)
 * const server = new MCPServer({
 *   name: 'my-server',
 *   version: '1.0.0',
 *   host: '0.0.0.0' // or 'myserver.com'
 * })
 *
 * // With full base URL (e.g., behind a proxy or custom domain)
 * const server = new MCPServer({
 *   name: 'my-server',
 *   version: '1.0.0',
 *   baseUrl: 'https://myserver.com' // or process.env.MCP_URL
 * })
 * ```
 */
/**
 * @deprecated Use `new MCPServer({ name, ... })` instead. This factory function is maintained for backward compatibility.
 *
 * @example
 * ```typescript
 * // Old (deprecated)
 * const server = createMCPServer('my-server', { version: '1.0.0' })
 *
 * // New (recommended)
 * const server = new MCPServer({ name: 'my-server', version: '1.0.0' })
 * ```
 */
export declare function createMCPServer(name: string, config: Partial<ServerConfig> & {
    oauth: NonNullable<ServerConfig["oauth"]>;
}): McpServerInstance<true>;
export declare function createMCPServer(name: string, config?: Partial<ServerConfig>): McpServerInstance<false>;
//# sourceMappingURL=mcp-server.d.ts.map