/**
 * Generic HMR (Hot Module Replacement) synchronization for MCP primitives.
 * Handles tools, prompts, resources, and resource templates with consistent logic.
 */
/**
 * Normalize handler function to a comparable string
 */
export declare function normalizeHandler(handler: unknown): string;
/**
 * Registration entry with config and handler
 */
export interface Registration<TConfig, THandler> {
    config: TConfig;
    handler: THandler;
}
/**
 * Registered reference that can be updated or removed
 */
export interface RegisteredRef {
    update?: (updates: any) => void;
    remove: () => void;
}
/**
 * Session context for HMR operations
 */
export interface SessionContext {
    sessionId: string;
    /** Get the refs map for this primitive type */
    getRefs: () => Map<string, any> | undefined;
    /** Register a new item on this session, returns the ref */
    register: (name: string, config: unknown, handler: unknown) => any | null;
}
/**
 * Changes detected during sync
 */
export interface SyncChanges {
    added: string[];
    removed: string[];
    updated: string[];
}
/**
 * Options for syncing a primitive type
 */
export interface SyncOptions<TConfig, THandler> {
    /** Name of the primitive type for logging */
    primitiveName: string;
    /** Current registrations map */
    currentRegistrations: Map<string, Registration<TConfig, THandler>>;
    /** New registrations map from reloaded module */
    newRegistrations: Map<string, Registration<TConfig, THandler>>;
    /** Session contexts for injecting into active sessions */
    sessions: SessionContext[];
    /** Whether this primitive supports in-place updates via ref.update() */
    supportsInPlaceUpdate?: boolean;
    /** Custom key extractor (defaults to using the map key) */
    getKey?: (name: string, reg: Registration<TConfig, THandler>) => string;
    /** Custom rename handler for primitives that need order-preserving renames (e.g., tools) */
    onRename?: (session: SessionContext, oldKey: string, newKey: string, newConfig: TConfig, newHandler: THandler) => void;
    /** Custom update handler for primitives that need order-preserving updates (e.g., tools) */
    onUpdate?: (session: SessionContext, key: string, newConfig: TConfig, newHandler: THandler) => void;
    /**
     * Optional predicate to prevent removal of specific items.
     * When provided, items that return false will be preserved during sync
     * even if they're not in the new registrations.
     * This is used to protect widget-registered tools from being removed
     * when index.ts HMR sync runs (widgets are registered separately by the file watcher).
     */
    shouldRemove?: (key: string, reg: Registration<TConfig, THandler>) => boolean;
}
/**
 * Result of syncing a primitive type
 */
export interface SyncResult<TConfig, THandler> {
    changes: SyncChanges;
    updatedRegistrations: Map<string, Registration<TConfig, THandler>>;
}
/**
 * Generic sync function for any MCP primitive type.
 * Handles rename detection, updates, additions, and session injection.
 */
export declare function syncPrimitive<TConfig, THandler>(options: SyncOptions<TConfig, THandler>): SyncResult<TConfig, THandler>;
/**
 * Log changes for a primitive type
 */
export declare function logChanges(primitiveName: string, changes: SyncChanges): void;
/**
 * Count total changes across all primitives
 */
export declare function countChanges(...allChanges: SyncChanges[]): number;
//# sourceMappingURL=hmr-sync.d.ts.map