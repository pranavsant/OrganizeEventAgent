/**
 * Redis Session Store
 *
 * Production-ready session storage using Redis for persistence across restarts
 * and distributed deployments.
 *
 * **Note:** Redis is an optional dependency. Install it with:
 * ```bash
 * npm install redis
 * # or
 * pnpm add redis
 * ```
 *
 * If Redis is not installed, importing this module will throw an error at runtime
 * when attempting to use RedisSessionStore. Use dynamic imports with error handling
 * if you want to gracefully fall back when Redis is not available.
 *
 * Supports:
 * - Session persistence across server restarts
 * - Distributed session sharing (load balancing)
 * - Automatic TTL-based expiration
 * - Connection pooling and error handling
 */
import type { SessionStore } from "./index.js";
import type { SessionMetadata } from "../session-manager.js";
/**
 * Check if Redis is available as an optional dependency
 * @returns true if Redis can be imported, false otherwise
 */
export declare function isRedisAvailable(): Promise<boolean>;
/**
 * Redis client interface - compatible with node-redis v5+ and ioredis
 */
export interface RedisClient {
    get(key: string): Promise<string | null>;
    set(key: string, value: string, options?: any): Promise<string | null>;
    setEx?(key: string, seconds: number, value: string): Promise<string | null>;
    setex?(key: string, seconds: number, value: string): Promise<string | null>;
    del(key: string | string[]): Promise<number>;
    exists(key: string | string[]): Promise<number>;
    keys(pattern: string): Promise<string[]>;
    expire?(key: string, seconds: number): Promise<boolean | number>;
    sAdd?(key: string, ...members: string[]): Promise<number>;
    sRem?(key: string, ...members: string[]): Promise<number>;
    sMembers?(key: string): Promise<string[]>;
    publish?(channel: string, message: string): Promise<number>;
    subscribe?(channel: string, callback: (message: string) => void): Promise<number | void>;
    unsubscribe?(channel: string): Promise<number | void>;
    quit(): Promise<string | "OK">;
}
/**
 * Configuration for Redis session store
 */
export interface RedisSessionStoreConfig {
    /**
     * Redis client instance (node-redis or ioredis)
     * Must be already connected
     */
    client: RedisClient;
    /**
     * Key prefix for session storage (default: "mcp:session:")
     */
    prefix?: string;
    /**
     * Default TTL in seconds for sessions (default: 3600 = 1 hour)
     */
    defaultTTL?: number;
    /**
     * Whether to serialize/deserialize session data (default: true)
     */
    serialize?: boolean;
}
/**
 * Redis-backed session metadata storage
 *
 * Stores ONLY serializable metadata (client capabilities, log level, timestamps).
 * For managing active SSE streams, use RedisStreamManager.
 *
 * Suitable for:
 * - Production deployments requiring session persistence
 * - Distributed/clustered applications
 * - Load-balanced environments
 * - Horizontal scaling scenarios
 *
 * @example
 * ```typescript
 * import { MCPServer, RedisSessionStore, RedisStreamManager } from 'mcp-use/server';
 * import { createClient } from 'redis';
 *
 * // Create Redis clients (two needed for Pub/Sub)
 * const redis = createClient({ url: process.env.REDIS_URL });
 * const pubSubRedis = redis.duplicate();
 *
 * await redis.connect();
 * await pubSubRedis.connect();
 *
 * // Create stores
 * const sessionStore = new RedisSessionStore({ client: redis });
 * const streamManager = new RedisStreamManager({
 *   client: redis,
 *   pubSubClient: pubSubRedis
 * });
 *
 * // Use with MCP server
 * const server = new MCPServer({
 *   name: 'my-server',
 *   version: '1.0.0',
 *   sessionStore,
 *   streamManager
 * });
 * ```
 */
export declare class RedisSessionStore implements SessionStore {
    private client;
    private prefix;
    private defaultTTL;
    constructor(config: RedisSessionStoreConfig);
    /**
     * Get full Redis key for a session ID
     */
    private getKey;
    /**
     * Retrieve session metadata by ID
     */
    get(sessionId: string): Promise<SessionMetadata | null>;
    /**
     * Store or update session metadata
     */
    set(sessionId: string, data: SessionMetadata): Promise<void>;
    /**
     * Delete a session
     */
    delete(sessionId: string): Promise<void>;
    /**
     * Check if a session exists
     */
    has(sessionId: string): Promise<boolean>;
    /**
     * List all session IDs
     *
     * WARNING: Uses KEYS command which blocks Redis. For production systems with
     * many sessions, consider using SCAN instead or maintaining a separate SET of
     * active session IDs.
     */
    keys(): Promise<string[]>;
    /**
     * Store session metadata with custom TTL (time-to-live)
     */
    setWithTTL(sessionId: string, data: SessionMetadata, ttlMs: number): Promise<void>;
    /**
     * Close Redis connection
     * Should be called when shutting down the server
     */
    close(): Promise<void>;
    /**
     * Clear all sessions (useful for testing)
     * WARNING: This will delete all sessions with the configured prefix
     *
     * NOTE: Uses KEYS command which blocks Redis. This is acceptable for testing
     * but should be avoided in production with large datasets.
     */
    clear(): Promise<void>;
}
//# sourceMappingURL=redis.d.ts.map