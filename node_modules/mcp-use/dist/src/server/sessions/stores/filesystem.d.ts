/**
 * FileSystem Session Store
 *
 * Development-friendly session storage that persists to disk.
 * Sessions survive server hot reloads, eliminating the need for client re-initialization.
 *
 * Designed for:
 * - Development environments with hot reload (tsx, nodemon, etc.)
 * - Single-instance deployments requiring session persistence
 * - Testing scenarios where session state needs to persist
 *
 * Not suitable for:
 * - Production deployments (use InMemorySessionStore or RedisSessionStore)
 * - Distributed/clustered deployments (use RedisSessionStore)
 * - High-throughput scenarios (frequent disk I/O may impact performance)
 */
import type { SessionMetadata } from "../session-manager.js";
import type { SessionStore } from "./index.js";
/**
 * Configuration for FileSystem session store
 */
export interface FileSystemSessionStoreConfig {
    /**
     * Path to the session file (default: .mcp-use/sessions.json in project root)
     */
    path?: string;
    /**
     * Debounce delay in milliseconds for write operations (default: 100)
     * Reduces disk I/O by batching rapid consecutive writes
     */
    debounceMs?: number;
    /**
     * Maximum session age in milliseconds (default: 24 hours)
     * Sessions older than this are cleaned up on load
     */
    maxAgeMs?: number;
}
/**
 * FileSystem-based session storage (default for development mode)
 *
 * Persists session metadata to a JSON file on disk, enabling sessions to survive
 * server restarts during hot reload. Uses atomic writes and debouncing for reliability.
 *
 * @example
 * ```typescript
 * import { MCPServer, FileSystemSessionStore } from 'mcp-use/server';
 *
 * const server = new MCPServer({
 *   name: 'dev-server',
 *   version: '1.0.0',
 *   sessionStore: new FileSystemSessionStore({
 *     path: '.mcp-use/sessions.json'
 *   })
 * });
 * ```
 */
export declare class FileSystemSessionStore implements SessionStore {
    private sessions;
    private readonly filePath;
    private readonly debounceMs;
    private readonly maxAgeMs;
    private saveTimer;
    private saving;
    private pendingSave;
    constructor(config?: FileSystemSessionStoreConfig);
    /**
     * Load sessions from file synchronously during construction
     * This ensures sessions are available immediately when the server starts
     */
    private loadSessionsSync;
    /**
     * Retrieve session metadata by ID
     */
    get(sessionId: string): Promise<SessionMetadata | null>;
    /**
     * Store or update session metadata
     * Uses debouncing to batch rapid consecutive writes
     */
    set(sessionId: string, data: SessionMetadata): Promise<void>;
    /**
     * Delete session metadata
     */
    delete(sessionId: string): Promise<void>;
    /**
     * Check if session exists
     */
    has(sessionId: string): Promise<boolean>;
    /**
     * List all session IDs
     */
    keys(): Promise<string[]>;
    /**
     * Store session metadata with TTL
     * Note: TTL is enforced on load, not with timers (simple implementation)
     */
    setWithTTL(sessionId: string, data: SessionMetadata, ttlMs: number): Promise<void>;
    /**
     * Get the number of active sessions
     */
    get size(): number;
    /**
     * Clear all sessions
     */
    clear(): Promise<void>;
    /**
     * Schedule a save operation with debouncing
     * Prevents excessive disk I/O from rapid consecutive writes
     */
    private scheduleSave;
    /**
     * Perform the actual save operation with atomic writes
     * Uses write-to-temp-then-rename pattern to prevent corruption
     */
    private performSave;
    /**
     * Force an immediate save (bypasses debouncing)
     * Useful for ensuring persistence before process exit
     */
    flush(): Promise<void>;
}
//# sourceMappingURL=filesystem.d.ts.map