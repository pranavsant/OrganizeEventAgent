import {
  generateToolRegistryTypes
} from "../../chunk-N7W3V5JK.js";
import {
  convertToolResultToPromptResult
} from "../../chunk-SI7MJ4BP.js";
import {
  getRequestContext,
  hasRequestContext,
  runWithContext
} from "../../chunk-LWVK6RXA.js";
import {
  createEnhancedContext,
  findSessionContext,
  isValidLogLevel
} from "../../chunk-3UOJPO3S.js";
import {
  convertToolResultToResourceResult
} from "../../chunk-362PI25Z.js";
import {
  sendNotificationToAll,
  sendNotificationToSession
} from "../../chunk-MTYDDD6G.js";
import {
  applyDefaultProps,
  buildWidgetUrl,
  convertPropsToInputs,
  createExternalUrlResource,
  createMcpAppsResource,
  createRawHtmlResource,
  createRemoteDomResource,
  createUIResourceFromDefinition,
  createWidgetUIResource,
  generateWidgetUri,
  getContentType,
  processWidgetHtml,
  readBuildManifest,
  registerWidgetFromTemplate,
  setupFaviconRoute,
  setupPublicRoutes
} from "../../chunk-RAFD62SE.js";
import {
  fsHelpers,
  generateUUID,
  getCwd,
  getEnv,
  isDeno,
  pathHelpers
} from "../../chunk-MTHLLDCX.js";
import {
  AppsSdkAdapter,
  McpAppsAdapter,
  buildDualProtocolMetadata,
  buildResourceUiMeta,
  generateToolOutput,
  getBuildIdPart
} from "../../chunk-4IVVK2XN.js";
import "../../chunk-KUEVOU4M.js";
import {
  createRequest
} from "../../chunk-K4JZBXZM.js";
import {
  Telemetry,
  VERSION,
  getPackageVersion
} from "../../chunk-YEK7642C.js";
import "../../chunk-QWQYAQCK.js";
import {
  __name
} from "../../chunk-3GQAWCBQ.js";

// src/server/mcp-server.ts
import {
  McpServer as OfficialMcpServer,
  ResourceTemplate as ResourceTemplate2
} from "@modelcontextprotocol/sdk/server/mcp.js";
import { ErrorCode, McpError } from "@modelcontextprotocol/sdk/types.js";
import { z as z3 } from "zod";

// src/server/hmr-sync.ts
function normalizeHandler(handler) {
  if (typeof handler === "function") {
    return handler.toString().replace(/\s+/g, " ").trim();
  }
  return String(handler);
}
__name(normalizeHandler, "normalizeHandler");
function isDebugLoggingEnabled() {
  const debugValue = globalThis.process?.env?.DEBUG;
  return !!(debugValue && debugValue !== "0" && debugValue.toLowerCase() !== "false");
}
__name(isDebugLoggingEnabled, "isDebugLoggingEnabled");
function syncPrimitive(options) {
  const {
    primitiveName,
    currentRegistrations,
    newRegistrations,
    sessions,
    supportsInPlaceUpdate = false,
    getKey: _getKey = /* @__PURE__ */ __name((name) => name, "_getKey"),
    onRename,
    onUpdate
  } = options;
  const debugEnabled = isDebugLoggingEnabled();
  const changes = {
    added: [],
    removed: [],
    updated: []
  };
  const oldKeys = new Set(currentRegistrations.keys());
  const newKeys = new Set(newRegistrations.keys());
  const potentiallyRemoved = [...oldKeys].filter((k) => !newKeys.has(k));
  const potentiallyAdded = [...newKeys].filter((k) => !oldKeys.has(k));
  const oldHandlerToKey = /* @__PURE__ */ new Map();
  for (const oldKey of potentiallyRemoved) {
    const oldReg = currentRegistrations.get(oldKey);
    if (oldReg) {
      oldHandlerToKey.set(normalizeHandler(oldReg.handler), oldKey);
    }
  }
  const renames = /* @__PURE__ */ new Map();
  for (const newKey of potentiallyAdded) {
    const newReg = newRegistrations.get(newKey);
    if (newReg) {
      const normalized = normalizeHandler(newReg.handler);
      const oldKey = oldHandlerToKey.get(normalized);
      if (oldKey) {
        renames.set(newKey, oldKey);
      }
    }
  }
  const updatedRegistrations = new Map(currentRegistrations);
  for (const [newKey, oldKey] of renames) {
    const newReg = newRegistrations.get(newKey);
    const rebuiltMap = /* @__PURE__ */ new Map();
    for (const [key, value] of updatedRegistrations) {
      if (key === oldKey) {
        rebuiltMap.set(newKey, newReg);
      } else {
        rebuiltMap.set(key, value);
      }
    }
    updatedRegistrations.clear();
    for (const [k, v] of rebuiltMap) {
      updatedRegistrations.set(k, v);
    }
    for (const session of sessions) {
      try {
        if (onRename) {
          onRename(session, oldKey, newKey, newReg.config, newReg.handler);
        } else {
          const refs = session.getRefs();
          const oldRef = refs?.get(oldKey);
          if (oldRef) {
            oldRef.remove();
            refs?.delete(oldKey);
          }
          const newRef = session.register(
            newKey,
            newReg.config,
            newReg.handler
          );
          if (refs && newRef) {
            refs.set(newKey, newRef);
          }
        }
      } catch (error2) {
        console.error(
          `[HMR] Failed to rename ${primitiveName} "${oldKey}" to "${newKey}" in session ${session.sessionId}:`,
          error2 instanceof Error ? error2.message : String(error2)
        );
      }
    }
    changes.removed.push(`${oldKey} (renamed to ${newKey})`);
    changes.added.push(newKey);
    const idx = potentiallyAdded.indexOf(newKey);
    if (idx !== -1) potentiallyAdded.splice(idx, 1);
  }
  const { shouldRemove } = options;
  const trulyRemoved = potentiallyRemoved.filter((oldKey) => {
    if (Array.from(renames.values()).includes(oldKey)) return false;
    if (shouldRemove) {
      const reg = currentRegistrations.get(oldKey);
      if (reg && !shouldRemove(oldKey, reg)) return false;
    }
    return true;
  });
  for (const removedKey of trulyRemoved) {
    updatedRegistrations.delete(removedKey);
    for (const session of sessions) {
      try {
        const refs = session.getRefs();
        const oldRef = refs?.get(removedKey);
        if (oldRef) {
          oldRef.remove();
          refs?.delete(removedKey);
        }
      } catch (error2) {
        console.error(
          `[HMR] Failed to remove ${primitiveName} "${removedKey}" in session ${session.sessionId}:`,
          error2 instanceof Error ? error2.message : String(error2)
        );
      }
    }
    changes.removed.push(removedKey);
  }
  for (const newKey of potentiallyAdded) {
    const newReg = newRegistrations.get(newKey);
    updatedRegistrations.set(newKey, newReg);
    for (const session of sessions) {
      try {
        const newRef = session.register(newKey, newReg.config, newReg.handler);
        const refs = session.getRefs();
        if (refs && newRef) {
          refs.set(newKey, newRef);
        }
      } catch (error2) {
        console.error(
          `[HMR] Failed to add ${primitiveName} "${newKey}" in session ${session.sessionId}:`,
          error2 instanceof Error ? error2.message : String(error2)
        );
      }
    }
    changes.added.push(newKey);
  }
  for (const key of newKeys) {
    if (renames.has(key)) continue;
    if (!oldKeys.has(key)) continue;
    const oldReg = currentRegistrations.get(key);
    const newReg = newRegistrations.get(key);
    const oldNormalized = normalizeHandler(oldReg.handler);
    const newNormalized = normalizeHandler(newReg.handler);
    const configChanged = JSON.stringify(oldReg.config) !== JSON.stringify(newReg.config);
    const handlerChanged = oldNormalized !== newNormalized;
    if (configChanged || handlerChanged) {
      if (debugEnabled) {
        console.debug(
          `[HMR] ${primitiveName} "${key}" changed:` + (configChanged ? " config" : "") + (handlerChanged ? " handler" : "")
        );
        if (handlerChanged) {
          const previewLength = 80;
          console.debug(
            `[HMR]   old handler: ${oldNormalized.slice(0, previewLength)}${oldNormalized.length > previewLength ? "..." : ""}`
          );
          console.debug(
            `[HMR]   new handler: ${newNormalized.slice(0, previewLength)}${newNormalized.length > previewLength ? "..." : ""}`
          );
        }
      }
      updatedRegistrations.set(key, newReg);
      for (const session of sessions) {
        try {
          const refs = session.getRefs();
          const existingRef = refs?.get(key);
          if (onUpdate) {
            onUpdate(session, key, newReg.config, newReg.handler);
          } else if (supportsInPlaceUpdate && existingRef?.update && !configChanged) {
            existingRef.update(newReg.handler);
          } else {
            if (existingRef) {
              existingRef.remove();
              refs?.delete(key);
            }
            const newRef = session.register(key, newReg.config, newReg.handler);
            if (refs && newRef) {
              refs.set(key, newRef);
            }
          }
        } catch (error2) {
          console.error(
            `[HMR] Failed to update ${primitiveName} "${key}" in session ${session.sessionId}:`,
            error2 instanceof Error ? error2.message : String(error2)
          );
        }
      }
      changes.updated.push(key);
    } else if (debugEnabled) {
      console.debug(
        `[HMR] ${primitiveName} "${key}" unchanged (config and handler identical)`
      );
    }
  }
  return { changes, updatedRegistrations };
}
__name(syncPrimitive, "syncPrimitive");
function logChanges(primitiveName, changes) {
  if (changes.added.length) {
    console.log(`  + ${primitiveName}: ${changes.added.join(", ")}`);
  }
  if (changes.removed.length) {
    console.log(`  - ${primitiveName}: ${changes.removed.join(", ")}`);
  }
  if (changes.updated.length) {
    console.log(`  ~ ${primitiveName}: ${changes.updated.join(", ")}`);
  }
}
__name(logChanges, "logChanges");
function countChanges(...allChanges) {
  return allChanges.reduce(
    (total, changes) => total + changes.added.length + changes.removed.length + changes.updated.length,
    0
  );
}
__name(countChanges, "countChanges");

// src/server/utils/response-helpers.ts
function text(content) {
  return {
    content: [
      {
        type: "text",
        text: content
      }
    ],
    _meta: {
      mimeType: "text/plain"
    }
  };
}
__name(text, "text");
function image(data, mimeType = "image/png") {
  return {
    content: [
      {
        type: "image",
        data,
        mimeType
      }
    ],
    _meta: {
      mimeType,
      isImage: true
    }
  };
}
__name(image, "image");
function getAudioMimeType(filename) {
  const ext = filename.split(".").pop()?.toLowerCase();
  switch (ext) {
    case "wav":
      return "audio/wav";
    case "mp3":
      return "audio/mpeg";
    case "ogg":
      return "audio/ogg";
    case "m4a":
      return "audio/mp4";
    case "webm":
      return "audio/webm";
    case "flac":
      return "audio/flac";
    case "aac":
      return "audio/aac";
    default:
      return "audio/wav";
  }
}
__name(getAudioMimeType, "getAudioMimeType");
function arrayBufferToBase64(buffer) {
  if (isDeno) {
    const bytes = new Uint8Array(buffer);
    let binary2 = "";
    for (let i = 0; i < bytes.length; i++) {
      binary2 += String.fromCharCode(bytes[i]);
    }
    return btoa(binary2);
  } else {
    return Buffer.from(buffer).toString("base64");
  }
}
__name(arrayBufferToBase64, "arrayBufferToBase64");
function audio(dataOrPath, mimeType) {
  const isFilePath = dataOrPath.includes("/") || dataOrPath.includes("\\") || dataOrPath.includes(".");
  if (isFilePath && dataOrPath.length < 1e3) {
    return (async () => {
      const buffer = await fsHelpers.readFile(dataOrPath);
      const base64Data = arrayBufferToBase64(buffer);
      const inferredMimeType = mimeType || getAudioMimeType(dataOrPath);
      return {
        content: [
          {
            type: "audio",
            data: base64Data,
            mimeType: inferredMimeType
          }
        ],
        _meta: {
          mimeType: inferredMimeType,
          isAudio: true
        }
      };
    })();
  }
  const finalMimeType = mimeType || "audio/wav";
  return {
    content: [
      {
        type: "audio",
        data: dataOrPath,
        mimeType: finalMimeType
      }
    ],
    _meta: {
      mimeType: finalMimeType,
      isAudio: true
    }
  };
}
__name(audio, "audio");
function resource(uri, mimeTypeOrContent, text2) {
  if (typeof mimeTypeOrContent === "object" && mimeTypeOrContent !== null && "content" in mimeTypeOrContent) {
    const contentResult = mimeTypeOrContent;
    let extractedText;
    let extractedMimeType;
    if (contentResult._meta && typeof contentResult._meta === "object") {
      const meta = contentResult._meta;
      if (meta.mimeType && typeof meta.mimeType === "string") {
        extractedMimeType = meta.mimeType;
      }
    }
    if (contentResult.content && contentResult.content.length > 0) {
      const firstContent = contentResult.content[0];
      if (firstContent.type === "text" && "text" in firstContent) {
        extractedText = firstContent.text;
      }
    }
    const resourceContent2 = {
      type: "resource",
      resource: {
        uri,
        ...extractedMimeType && { mimeType: extractedMimeType },
        ...extractedText && { text: extractedText }
      }
    };
    return {
      content: [resourceContent2]
    };
  }
  const mimeType = mimeTypeOrContent;
  const resourceContent = {
    type: "resource",
    resource: {
      uri,
      ...mimeType && { mimeType },
      ...text2 && { text: text2 }
    }
  };
  return {
    content: [resourceContent]
  };
}
__name(resource, "resource");
function error(message) {
  return {
    isError: true,
    content: [
      {
        type: "text",
        text: message
      }
    ]
  };
}
__name(error, "error");
function object(data) {
  return Array.isArray(data) ? array(data) : {
    content: [
      {
        type: "text",
        text: JSON.stringify(data, null, 2)
      }
    ],
    structuredContent: data,
    _meta: {
      mimeType: "application/json"
    }
  };
}
__name(object, "object");
function array(data) {
  return {
    content: [
      {
        type: "text",
        text: JSON.stringify(data, null, 2)
      }
    ],
    structuredContent: { data }
  };
}
__name(array, "array");
function html(content) {
  return {
    content: [
      {
        type: "text",
        text: content
      }
    ],
    _meta: {
      mimeType: "text/html"
    }
  };
}
__name(html, "html");
function markdown(content) {
  return {
    content: [
      {
        type: "text",
        text: content
      }
    ],
    _meta: {
      mimeType: "text/markdown"
    }
  };
}
__name(markdown, "markdown");
function xml(content) {
  return {
    content: [
      {
        type: "text",
        text: content
      }
    ],
    _meta: {
      mimeType: "text/xml"
    }
  };
}
__name(xml, "xml");
function css(content) {
  return {
    content: [
      {
        type: "text",
        text: content
      }
    ],
    _meta: {
      mimeType: "text/css"
    }
  };
}
__name(css, "css");
function javascript(content) {
  return {
    content: [
      {
        type: "text",
        text: content
      }
    ],
    _meta: {
      mimeType: "text/javascript"
    }
  };
}
__name(javascript, "javascript");
function binary(base64Data, mimeType) {
  return {
    content: [
      {
        type: "text",
        text: base64Data
      }
    ],
    _meta: {
      mimeType,
      isBinary: true
    }
  };
}
__name(binary, "binary");
function widget(config) {
  const props = config.props || config.data || {};
  const { output, message, metadata } = config;
  const finalContent = message ? [{ type: "text", text: message }] : Array.isArray(output?.content) && output.content.length > 0 ? output.content : [{ type: "text", text: "" }];
  const result = {
    content: finalContent
  };
  if (metadata && Object.keys(metadata).length > 0) {
    result._meta = metadata;
  }
  if (output?.structuredContent) {
    result.structuredContent = output.structuredContent;
  } else if (Object.keys(props).length > 0) {
    result.structuredContent = props;
  }
  return result;
}
__name(widget, "widget");
function mix(...results) {
  const structuredContent = results.find((result) => result.structuredContent) && results.filter((result) => result.structuredContent).map((result) => result.structuredContent).reduce(
    (acc, result) => {
      return { ...acc, ...result };
    },
    {}
  );
  const _meta = results.find((result) => result._meta) && results.filter((result) => result._meta).map((result) => result._meta).reduce(
    (acc, result) => {
      return { ...acc, ...result };
    },
    {}
  );
  return {
    content: results.flatMap((result) => result.content),
    ...structuredContent && { structuredContent },
    ..._meta && { _meta }
  };
}
__name(mix, "mix");

// src/server/utils/server-helpers.ts
import { Hono } from "hono";
import { cors } from "hono/cors";

// src/server/middleware/host-validation.ts
function createJsonRpcErrorResponse(c, message) {
  return c.json(
    {
      jsonrpc: "2.0",
      error: {
        code: -32e3,
        message
      },
      id: null
    },
    403
  );
}
__name(createJsonRpcErrorResponse, "createJsonRpcErrorResponse");
function parseHostnameFromHostHeader(hostHeader) {
  try {
    return new URL(`http://${hostHeader}`).hostname;
  } catch {
    return null;
  }
}
__name(parseHostnameFromHostHeader, "parseHostnameFromHostHeader");
function hostHeaderValidation(allowedHostnames) {
  const normalizedAllowedHostnames = allowedHostnames.map(
    (hostname) => hostname.toLowerCase()
  );
  return async (c, next) => {
    const hostHeader = c.req.header("Host");
    if (!hostHeader) {
      return createJsonRpcErrorResponse(c, "Missing Host header");
    }
    const hostname = parseHostnameFromHostHeader(hostHeader);
    if (!hostname) {
      return createJsonRpcErrorResponse(
        c,
        `Invalid Host header: ${hostHeader}`
      );
    }
    if (!normalizedAllowedHostnames.includes(hostname.toLowerCase())) {
      return createJsonRpcErrorResponse(c, `Invalid Host: ${hostname}`);
    }
    await next();
  };
}
__name(hostHeaderValidation, "hostHeaderValidation");

// src/server/utils/server-helpers.ts
function getDefaultCorsOptions() {
  return {
    origin: "*",
    allowMethods: ["GET", "HEAD", "POST", "PUT", "DELETE", "OPTIONS"],
    allowHeaders: [
      "Content-Type",
      "Accept",
      "Authorization",
      "mcp-protocol-version",
      "mcp-session-id",
      "X-Proxy-Token",
      "X-Target-URL"
    ],
    // Expose mcp-session-id so browser clients can read it from responses
    exposeHeaders: ["mcp-session-id"]
  };
}
__name(getDefaultCorsOptions, "getDefaultCorsOptions");
function parseAllowedHostname(value) {
  const trimmedValue = value.trim();
  if (!trimmedValue) {
    return null;
  }
  try {
    return new URL(trimmedValue).hostname.toLowerCase();
  } catch {
    try {
      return new URL(`http://${trimmedValue}`).hostname.toLowerCase();
    } catch {
      return null;
    }
  }
}
__name(parseAllowedHostname, "parseAllowedHostname");
function getAllowedHostnames(allowedOrigins) {
  if (!allowedOrigins || allowedOrigins.length === 0) {
    return [];
  }
  const hostnames = allowedOrigins.map((origin) => parseAllowedHostname(origin)).filter((hostname) => Boolean(hostname));
  return [...new Set(hostnames)];
}
__name(getAllowedHostnames, "getAllowedHostnames");
function createHonoApp(requestLogger2, options = {}) {
  const app = new Hono();
  const allowedHostnames = getAllowedHostnames(options.allowedOrigins);
  if (allowedHostnames.length > 0) {
    app.use("*", hostHeaderValidation(allowedHostnames));
  }
  app.use(
    "*",
    cors(
      options.cors ?? getDefaultCorsOptions()
    )
  );
  app.use("*", requestLogger2);
  app.use("*", async (c, next) => {
    await next();
    c.res.headers.delete("X-Frame-Options");
  });
  return app;
}
__name(createHonoApp, "createHonoApp");
function normalizeUrlHost(url) {
  return url.replace(/\/\/0\.0\.0\.0(:|\/|$)/, "//localhost$1");
}
__name(normalizeUrlHost, "normalizeUrlHost");
function getServerBaseUrl(serverBaseUrl, serverHost, serverPort) {
  let url;
  if (serverBaseUrl) {
    url = serverBaseUrl;
  } else {
    const mcpUrl = getEnv("MCP_URL");
    if (mcpUrl) {
      url = mcpUrl;
    } else {
      url = `http://${serverHost}:${serverPort}`;
    }
  }
  return normalizeUrlHost(url);
}
__name(getServerBaseUrl, "getServerBaseUrl");
function getCSPUrls() {
  const cspUrlsEnv = getEnv("CSP_URLS");
  if (!cspUrlsEnv) {
    console.log("[CSP] No CSP_URLS environment variable found");
    return [];
  }
  const urls = cspUrlsEnv.split(",").map((url) => url.trim()).filter((url) => url.length > 0);
  console.log("[CSP] Parsed CSP URLs:", urls);
  return urls;
}
__name(getCSPUrls, "getCSPUrls");
function logRegisteredItems(registeredTools, registeredPrompts, registeredResources) {
  console.log("\n\u{1F4CB} Server exposes:");
  console.log(`   Tools: ${registeredTools.length}`);
  if (registeredTools.length > 0) {
    registeredTools.forEach((name) => {
      console.log(`      - ${name}`);
    });
  }
  console.log(`   Prompts: ${registeredPrompts.length}`);
  if (registeredPrompts.length > 0) {
    registeredPrompts.forEach((name) => {
      console.log(`      - ${name}`);
    });
  }
  console.log(`   Resources: ${registeredResources.length}`);
  if (registeredResources.length > 0) {
    registeredResources.forEach((name) => {
      console.log(`      - ${name}`);
    });
  }
  console.log("");
}
__name(logRegisteredItems, "logRegisteredItems");
function parseTemplateUri(template, uri) {
  const params = {};
  let regexPattern = template.replace(/[.*+?^$()[\]\\|]/g, "\\$&");
  const paramNames = [];
  regexPattern = regexPattern.replace(/\{([^}]+)\}/g, (_, paramName) => {
    paramNames.push(paramName);
    return "([^/]+)";
  });
  const regex = new RegExp(`^${regexPattern}$`);
  const match = uri.match(regex);
  if (match) {
    paramNames.forEach((paramName, index) => {
      params[paramName] = match[index + 1];
    });
  }
  return params;
}
__name(parseTemplateUri, "parseTemplateUri");

// src/server/utils/server-lifecycle.ts
function isProductionMode() {
  return getEnv("NODE_ENV") === "production";
}
__name(isProductionMode, "isProductionMode");
function getDenoCorsHeaders() {
  return {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type"
  };
}
__name(getDenoCorsHeaders, "getDenoCorsHeaders");
function applyDenoCorsHeaders(response) {
  const corsHeaders = getDenoCorsHeaders();
  const newHeaders = new Headers(response.headers);
  Object.entries(corsHeaders).forEach(([key, value]) => {
    newHeaders.set(key, value);
  });
  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers: newHeaders
  });
}
__name(applyDenoCorsHeaders, "applyDenoCorsHeaders");
function createSupabasePathRewriter() {
  return (pathname) => {
    let newPathname = pathname;
    const functionsMatch = pathname.match(/^\/functions\/v1\/[^/]+(\/.*)?$/);
    if (functionsMatch) {
      newPathname = functionsMatch[1] || "/";
    } else {
      const functionNameMatch = pathname.match(/^\/([^/]+)(\/.*)?$/);
      if (functionNameMatch && functionNameMatch[2]) {
        newPathname = functionNameMatch[2] || "/";
      }
    }
    return newPathname;
  };
}
__name(createSupabasePathRewriter, "createSupabasePathRewriter");
function rewriteSupabaseRequest(req) {
  const url = new URL(req.url);
  const pathname = url.pathname;
  const rewriter = createSupabasePathRewriter();
  const newPathname = rewriter(pathname);
  if (newPathname !== pathname) {
    const newUrl = new URL(newPathname + url.search, url.origin);
    return new Request(newUrl, {
      method: req.method,
      headers: req.headers,
      body: req.body,
      redirect: req.redirect
    });
  }
  return req;
}
__name(rewriteSupabaseRequest, "rewriteSupabaseRequest");
async function startServer(app, port, host, options) {
  if (isDeno) {
    const corsHeaders = getDenoCorsHeaders();
    globalThis.Deno.serve(
      { port, hostname: host },
      async (req) => {
        if (req.method === "OPTIONS") {
          return new Response("ok", { headers: corsHeaders });
        }
        let finalReq = req;
        if (options?.onDenoRequest) {
          finalReq = await options.onDenoRequest(req);
        }
        let response = await app.fetch(finalReq);
        if (options?.onDenoResponse) {
          response = await options.onDenoResponse(response);
        } else {
          response = applyDenoCorsHeaders(response);
        }
        return response;
      }
    );
    console.log(`[SERVER] Listening`);
  } else {
    const { serve } = await import("@hono/node-server");
    const server = serve(
      {
        fetch: app.fetch,
        port,
        hostname: host
      },
      (_info) => {
        console.log(`[SERVER] Listening on http://${host}:${port}`);
        console.log(`[MCP] Endpoints: http://${host}:${port}/mcp`);
      }
    );
    const wsProxySetup = app.__viteWsProxy;
    if (wsProxySetup && server) {
      wsProxySetup(server);
    }
  }
}
__name(startServer, "startServer");

// src/server/connect-adapter.ts
function isExpressMiddleware(middleware) {
  if (!middleware || typeof middleware !== "function") {
    return false;
  }
  const paramCount = middleware.length;
  if (paramCount === 3 || paramCount === 4) {
    return true;
  }
  if (paramCount === 2) {
    const fnString = middleware.toString();
    const expressPatterns = [
      /\bres\.(send|json|status|end|redirect|render|sendFile|download)\b/,
      /\breq\.(body|params|query|cookies|session)\b/,
      /\breq\.get\s*\(/,
      /\bres\.set\s*\(/
    ];
    const hasExpressPattern = expressPatterns.some(
      (pattern) => pattern.test(fnString)
    );
    if (hasExpressPattern) {
      return true;
    }
    return false;
  }
  return false;
}
__name(isExpressMiddleware, "isExpressMiddleware");
async function adaptMiddleware(middleware, middlewarePath = "*") {
  if (isExpressMiddleware(middleware)) {
    return adaptConnectMiddleware(middleware, middlewarePath);
  }
  return middleware;
}
__name(adaptMiddleware, "adaptMiddleware");
async function adaptConnectMiddleware(connectMiddleware, middlewarePath) {
  const { createRequest: createRequest2, createResponse } = await import("node-mocks-http");
  let normalizedPath = middlewarePath;
  if (normalizedPath.endsWith("*")) {
    normalizedPath = normalizedPath.slice(0, -1);
  }
  if (normalizedPath.endsWith("/")) {
    normalizedPath = normalizedPath.slice(0, -1);
  }
  const honoMiddleware = /* @__PURE__ */ __name(async (c, next) => {
    const request = c.req.raw;
    const parsedURL = new URL(request.url, "http://localhost");
    const query = {};
    for (const [key, value] of parsedURL.searchParams.entries()) {
      query[key] = value;
    }
    let middlewarePathname = parsedURL.pathname;
    if (normalizedPath && middlewarePathname.startsWith(normalizedPath)) {
      middlewarePathname = middlewarePathname.substring(normalizedPath.length);
      if (middlewarePathname === "") {
        middlewarePathname = "/";
      } else if (!middlewarePathname.startsWith("/")) {
        middlewarePathname = "/" + middlewarePathname;
      }
    }
    const mockRequest = createRequest2({
      method: request.method.toUpperCase(),
      url: middlewarePathname + parsedURL.search,
      headers: request.headers && typeof request.headers.entries === "function" ? Object.fromEntries(request.headers.entries()) : request.headers,
      query,
      ...request.body && { body: request.body }
    });
    const mockResponse = createResponse();
    let responseResolved = false;
    const res = await new Promise((resolve) => {
      const originalEnd = mockResponse.end.bind(mockResponse);
      mockResponse.end = (...args) => {
        const result = originalEnd(...args);
        if (!responseResolved && mockResponse.writableEnded) {
          responseResolved = true;
          const statusCode = mockResponse.statusCode;
          const noBodyStatuses = [204, 304];
          const responseBody = noBodyStatuses.includes(statusCode) ? null : mockResponse._getData() || mockResponse._getBuffer() || null;
          const connectResponse = new Response(responseBody, {
            status: statusCode,
            statusText: mockResponse.statusMessage,
            headers: mockResponse.getHeaders()
          });
          resolve(connectResponse);
        }
        return result;
      };
      connectMiddleware(mockRequest, mockResponse, () => {
        if (!responseResolved && !mockResponse.writableEnded) {
          responseResolved = true;
          const statusCode = mockResponse.statusCode;
          const noBodyStatuses = [204, 304];
          const responseBody = noBodyStatuses.includes(statusCode) ? null : mockResponse._getData() || mockResponse._getBuffer() || null;
          const preparedHeaders = c.newResponse(null, 204, {}).headers;
          for (const key of [...preparedHeaders.keys()]) {
            if (preparedHeaders.has(key)) {
              c.header(key, void 0);
            }
            if (c.res && c.res.headers.has(key)) {
              c.res.headers.delete(key);
            }
          }
          const connectHeaders = mockResponse.getHeaders();
          for (const [key, value] of Object.entries(connectHeaders)) {
            if (value !== void 0) {
              c.header(
                key,
                Array.isArray(value) ? value.join(", ") : String(value)
              );
            }
          }
          c.status(statusCode);
          if (noBodyStatuses.includes(statusCode)) {
            resolve(c.newResponse(null, statusCode));
          } else if (responseBody) {
            resolve(c.body(responseBody));
          } else {
            resolve(void 0);
          }
        }
      });
    });
    if (res) {
      c.res = res;
      return res;
    }
    await next();
  }, "honoMiddleware");
  return honoMiddleware;
}
__name(adaptConnectMiddleware, "adaptConnectMiddleware");

// src/server/utils/hono-proxy.ts
var HMR_HTTP_METHODS = /* @__PURE__ */ new Set([
  "get",
  "post",
  "put",
  "delete",
  "patch",
  "all"
]);
function installCustomRoutesMiddleware(app, customRoutes) {
  app.all("*", async (c, next) => {
    const method = c.req.method.toLowerCase();
    const path = c.req.path;
    const key = `${method}:${path}`;
    const allKey = `all:${path}`;
    const handlers = customRoutes.get(key) || customRoutes.get(allKey);
    if (handlers && handlers.length > 0) {
      return handlers[handlers.length - 1](c, next);
    }
    return next();
  });
}
__name(installCustomRoutesMiddleware, "installCustomRoutesMiddleware");
function createHonoProxy(target, app) {
  return new Proxy(target, {
    get(target2, prop) {
      if (prop === "use") {
        return async (...args) => {
          const hasPath = typeof args[0] === "string";
          const path = hasPath ? args[0] : "*";
          const handlers = hasPath ? args.slice(1) : args;
          const adaptedHandlers = handlers.map((handler) => {
            if (isExpressMiddleware(handler)) {
              return { __isExpressMiddleware: true, handler, path };
            }
            return handler;
          });
          const hasExpressMiddleware = adaptedHandlers.some(
            (h) => h.__isExpressMiddleware
          );
          if (hasExpressMiddleware) {
            await Promise.all(
              adaptedHandlers.map(async (h) => {
                if (h.__isExpressMiddleware) {
                  const adapted = await adaptConnectMiddleware(
                    h.handler,
                    h.path
                  );
                  if (hasPath) {
                    app.use(path, adapted);
                  } else {
                    app.use(adapted);
                  }
                } else {
                  if (hasPath) {
                    app.use(path, h);
                  } else {
                    app.use(h);
                  }
                }
              })
            );
            return target2;
          }
          return app.use(...args);
        };
      }
      if (typeof prop === "string" && HMR_HTTP_METHODS.has(prop)) {
        return (path, ...handlers) => {
          const customRoutes = target2._customRoutes;
          if (!customRoutes) {
            return app[prop](path, ...handlers);
          }
          const key = `${prop}:${path}`;
          customRoutes.set(key, handlers);
          return target2;
        };
      }
      if (prop in target2) {
        return target2[prop];
      }
      const value = app[prop];
      return typeof value === "function" ? value.bind(app) : value;
    }
  });
}
__name(createHonoProxy, "createHonoProxy");

// src/server/utils/completion-helpers.ts
import {
  completable as sdkCompletable
} from "@modelcontextprotocol/sdk/server/completable.js";
function completable(schema, complete) {
  let callback;
  if (Array.isArray(complete)) {
    callback = /* @__PURE__ */ __name(async (value) => {
      const prefix = (value ?? "").toString().trim().toLowerCase();
      const filtered = complete.filter((item) => {
        return String(item).toLowerCase().startsWith(prefix);
      });
      return filtered;
    }, "callback");
  } else {
    callback = /* @__PURE__ */ __name(async (value, context) => {
      return await complete(value, context);
    }, "callback");
  }
  return sdkCompletable(schema, callback);
}
__name(completable, "completable");
function toResourceTemplateCompleteCallbacks(completes) {
  if (!completes) {
    return {};
  }
  const normalized = {};
  for (const key of Object.keys(completes)) {
    const complete = completes[key];
    if (Array.isArray(complete)) {
      const callback = /* @__PURE__ */ __name(async (value) => {
        const prefix = (value ?? "").toString().trim().toLowerCase();
        const filtered = complete.filter((item) => {
          return String(item).toLowerCase().startsWith(prefix);
        });
        return filtered;
      }, "callback");
      normalized[key] = callback;
    } else {
      normalized[key] = complete;
    }
  }
  return normalized;
}
__name(toResourceTemplateCompleteCallbacks, "toResourceTemplateCompleteCallbacks");

// src/server/utils/elicitation-helpers.ts
function untitledEnum(values) {
  return {
    type: "string",
    enum: [...values]
  };
}
__name(untitledEnum, "untitledEnum");
function titledEnum(options) {
  return {
    type: "string",
    oneOf: options.map((option) => ({
      const: option.value,
      title: option.title
    }))
  };
}
__name(titledEnum, "titledEnum");
function legacyEnum(options) {
  return {
    type: "string",
    enum: options.map((option) => option.value),
    enumNames: options.map((option) => option.name)
  };
}
__name(legacyEnum, "legacyEnum");
function untitledMultiEnum(values) {
  return {
    type: "array",
    items: {
      type: "string",
      enum: [...values]
    }
  };
}
__name(untitledMultiEnum, "untitledMultiEnum");
function titledMultiEnum(options) {
  return {
    type: "array",
    items: {
      anyOf: options.map((option) => ({
        const: option.value,
        title: option.title
      }))
    }
  };
}
__name(titledMultiEnum, "titledMultiEnum");
function enumSchema(fields) {
  return {
    type: "object",
    properties: fields
  };
}
__name(enumSchema, "enumSchema");

// src/server/widgets/mount-widgets-dev.ts
var TMP_MCP_USE_DIR = ".mcp-use";
var DEFAULT_HMR_PORT = 24678;
async function findAvailablePort(startPort) {
  const net = await import("net");
  return new Promise((resolve) => {
    const server = net.createServer();
    server.listen(startPort, () => {
      const port = server.address().port;
      server.close(() => resolve(port));
    });
    server.on("error", () => {
      findAvailablePort(startPort + 1).then(resolve);
    });
  });
}
__name(findAvailablePort, "findAvailablePort");
async function mountWidgetsDev(app, serverConfig, registerWidget, updateWidgetTool, removeWidgetTool, options) {
  const { promises: fs } = await import("fs");
  const baseRoute = options?.baseRoute || "/mcp-use/widgets";
  const resourcesDir = options?.resourcesDir || "resources";
  const srcDir = pathHelpers.join(getCwd(), resourcesDir);
  try {
    await fs.access(srcDir);
  } catch {
    console.log(
      `[WIDGETS] No ${resourcesDir}/ directory found - creating it for widget watching`
    );
    await fs.mkdir(srcDir, { recursive: true });
  }
  const entries = [];
  try {
    const files = await fs.readdir(srcDir, { withFileTypes: true });
    for (const dirent of files) {
      if (dirent.name.startsWith("._") || dirent.name.startsWith(".DS_Store")) {
        continue;
      }
      if (dirent.isFile() && (dirent.name.endsWith(".tsx") || dirent.name.endsWith(".ts"))) {
        entries.push({
          name: dirent.name.replace(/\.tsx?$/, ""),
          path: pathHelpers.join(srcDir, dirent.name)
        });
      } else if (dirent.isDirectory()) {
        const widgetPath = pathHelpers.join(srcDir, dirent.name, "widget.tsx");
        try {
          await fs.access(widgetPath);
          entries.push({
            name: dirent.name,
            path: widgetPath
          });
        } catch {
        }
      }
    }
  } catch (error2) {
    console.log(`[WIDGETS] No widgets found in ${resourcesDir}/ directory`);
    return;
  }
  if (entries.length === 0) {
    console.log(
      `[WIDGETS] No widgets found in ${resourcesDir}/ directory yet - watching for new widgets...`
    );
  }
  const tempDir = pathHelpers.join(getCwd(), TMP_MCP_USE_DIR);
  try {
    await fs.access(tempDir);
    const currentWidgetNames = new Set(entries.map((e) => e.name));
    const existingDirs = await fs.readdir(tempDir, { withFileTypes: true });
    for (const dirent of existingDirs) {
      if (dirent.isDirectory() && !currentWidgetNames.has(dirent.name)) {
        const staleDir = pathHelpers.join(tempDir, dirent.name);
        await fs.rm(staleDir, { recursive: true, force: true });
        console.log(`[WIDGETS] Cleaned up stale widget: ${dirent.name}`);
      }
    }
  } catch {
  }
  await fs.mkdir(tempDir, { recursive: true }).catch(() => {
  });
  let createServer;
  let react;
  let tailwindcss;
  try {
    const { createRequire } = await import("module");
    const { pathToFileURL } = await import("url");
    const userProjectRequire = createRequire(
      pathToFileURL(pathHelpers.join(getCwd(), "package.json")).href
    );
    const vitePath = userProjectRequire.resolve("vite");
    const reactPluginPath = userProjectRequire.resolve("@vitejs/plugin-react");
    const tailwindPath = userProjectRequire.resolve("@tailwindcss/vite");
    const viteModule = await import(vitePath);
    createServer = viteModule.createServer;
    const reactModule = await import(reactPluginPath);
    react = reactModule.default;
    const tailwindModule = await import(tailwindPath);
    tailwindcss = tailwindModule.default;
  } catch (error2) {
    throw new Error(
      "\u274C Widget dependencies not installed!\n\nTo use MCP widgets with resources folder, you need to install the required dependencies:\n\n  npm install vite @vitejs/plugin-react @tailwindcss/vite\n  # or\n  pnpm add vite @vitejs/plugin-react @tailwindcss/vite\n\nThese dependencies are automatically included in projects created with 'create-mcp-use-app'.\nFor production, pre-build your widgets using 'mcp-use build'."
    );
  }
  const widgets = entries.map((entry) => {
    return {
      name: entry.name,
      description: `Widget: ${entry.name}`,
      entry: entry.path
    };
  });
  const { slugifyWidgetName: slugifyWidgetName2 } = await import("../../widget-helpers-4TKHDNQP.js");
  for (const widget2 of widgets) {
    const slugifiedName = slugifyWidgetName2(widget2.name);
    const widgetTempDir = pathHelpers.join(tempDir, slugifiedName);
    await fs.mkdir(widgetTempDir, { recursive: true });
    const resourcesPath = pathHelpers.join(getCwd(), resourcesDir);
    const relativeResourcesPath = pathHelpers.relative(widgetTempDir, resourcesPath).replace(/\\/g, "/");
    const mcpUsePath = pathHelpers.join(getCwd(), "node_modules", "mcp-use");
    const relativeMcpUsePath = pathHelpers.relative(widgetTempDir, mcpUsePath).replace(/\\/g, "/");
    const cssContent = `@import "tailwindcss";

/* Configure Tailwind to scan the resources directory and mcp-use package */
@source "${relativeResourcesPath}";
@source "${relativeMcpUsePath}/**/*.{ts,tsx,js,jsx}";
`;
    await fs.writeFile(
      pathHelpers.join(widgetTempDir, "styles.css"),
      cssContent,
      "utf8"
    );
    const entryContent = `import React from 'react'
import { createRoot } from 'react-dom/client'
import './styles.css'
import Component from '${widget2.entry}'

const container = document.getElementById('widget-root')
if (container && Component) {
  const root = createRoot(container)
  root.render(<Component />)
  
  // Signal to parent that widget has mounted (after a brief delay for initial render)
  setTimeout(() => {
    window.parent.postMessage({ type: 'mcp-inspector:widget:ready' }, '*')
  }, 100)
}
`;
    const fullBaseUrl = `${serverConfig.serverBaseUrl}${baseRoute}`;
    const htmlContent = `<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>${widget2.name} Widget</title>${serverConfig.favicon ? `
    <link rel="icon" href="${serverConfig.serverBaseUrl.replace(/\/$/, "")}/mcp-use/public/${serverConfig.favicon}" />` : ""}
    <script type="module" src="${fullBaseUrl}/@vite/client"></script>
    <script type="module">
      import RefreshRuntime from '${fullBaseUrl}/@react-refresh';
      RefreshRuntime.injectIntoGlobalHook(window);
      window.$RefreshReg$ = () => {};
      window.$RefreshSig$ = () => (type) => type;
      window.__vite_plugin_react_preamble_installed__ = true;
    </script>
  </head>
  <body>
    <div id="widget-root"></div>
    <script type="module" src="${fullBaseUrl}/${slugifiedName}/entry.tsx"></script>
  </body>
</html>`;
    await fs.writeFile(
      pathHelpers.join(widgetTempDir, "entry.tsx"),
      entryContent,
      "utf8"
    );
    await fs.writeFile(
      pathHelpers.join(widgetTempDir, "index.html"),
      htmlContent,
      "utf8"
    );
  }
  console.log(
    `[WIDGETS] Serving ${entries.length} widget(s) with shared Vite dev server and HMR`
  );
  const ssrCssPlugin = {
    name: "ssr-css-handler",
    enforce: "pre",
    resolveId(id, importer, options2) {
      if (options2 && options2.ssr === true && (id.endsWith(".css") || id.endsWith(".module.css"))) {
        return "\0ssr-css:" + id;
      }
      return null;
    },
    load(id, options2) {
      if (options2 && options2.ssr === true && id.startsWith("\0ssr-css:")) {
        return "export default {}";
      }
      return null;
    }
  };
  const watchResourcesPlugin = {
    name: "watch-resources",
    configureServer(server) {
      const resourcesPath = pathHelpers.join(getCwd(), resourcesDir);
      server.watcher.add(resourcesPath);
      console.log(`[WIDGETS] Watching resources directory: ${resourcesPath}`);
      server.watcher.on("unlink", async (filePath) => {
        const relativePath = pathHelpers.relative(resourcesPath, filePath);
        const { slugifyWidgetName: slugifyWidgetName3 } = await import("../../widget-helpers-4TKHDNQP.js");
        if ((relativePath.endsWith(".tsx") || relativePath.endsWith(".ts")) && !relativePath.includes("/")) {
          const widgetName = relativePath.replace(/\.tsx?$/, "");
          const slugifiedName = slugifyWidgetName3(widgetName);
          const widgetDir = pathHelpers.join(tempDir, slugifiedName);
          const widgetIdx = widgets.findIndex((w) => w.name === widgetName);
          if (widgetIdx !== -1) {
            widgets.splice(widgetIdx, 1);
          }
          removeWidgetTool(widgetName);
          try {
            await fs.access(widgetDir);
            await fs.rm(widgetDir, { recursive: true, force: true });
            console.log(
              `[WIDGETS] Removed widget (file deleted): ${widgetName}`
            );
          } catch {
          }
        } else if (relativePath.endsWith("widget.tsx")) {
          const parts = relativePath.split("/");
          if (parts.length === 2) {
            const widgetName = parts[0];
            const slugifiedName = slugifyWidgetName3(widgetName);
            const widgetDir = pathHelpers.join(tempDir, slugifiedName);
            const widgetIdx = widgets.findIndex((w) => w.name === widgetName);
            if (widgetIdx !== -1) {
              widgets.splice(widgetIdx, 1);
            }
            removeWidgetTool(widgetName);
            try {
              await fs.access(widgetDir);
              await fs.rm(widgetDir, { recursive: true, force: true });
              console.log(
                `[WIDGETS] Removed widget (file deleted): ${widgetName}`
              );
            } catch {
            }
          }
        }
      });
      server.watcher.on("unlinkDir", async (dirPath) => {
        const relativePath = pathHelpers.relative(resourcesPath, dirPath);
        const { slugifyWidgetName: slugifyWidgetName3 } = await import("../../widget-helpers-4TKHDNQP.js");
        if (relativePath && !relativePath.includes("/")) {
          const widgetName = relativePath;
          const slugifiedName = slugifyWidgetName3(widgetName);
          const widgetDir = pathHelpers.join(tempDir, slugifiedName);
          const widgetIdx = widgets.findIndex((w) => w.name === widgetName);
          if (widgetIdx !== -1) {
            widgets.splice(widgetIdx, 1);
          }
          removeWidgetTool(widgetName);
          try {
            await fs.access(widgetDir);
            await fs.rm(widgetDir, { recursive: true, force: true });
            console.log(
              `[WIDGETS] Removed widget (directory deleted): ${widgetName}`
            );
          } catch {
          }
        }
      });
      const createWidgetTempFiles = /* @__PURE__ */ __name(async (widgetName, entryPath) => {
        const { slugifyWidgetName: slugifyWidgetName3 } = await import("../../widget-helpers-4TKHDNQP.js");
        const slugifiedName = slugifyWidgetName3(widgetName);
        const widgetTempDir = pathHelpers.join(tempDir, slugifiedName);
        await fs.mkdir(widgetTempDir, { recursive: true });
        const relativeResourcesPath = pathHelpers.relative(widgetTempDir, resourcesPath).replace(/\\/g, "/");
        const mcpUsePath = pathHelpers.join(
          getCwd(),
          "node_modules",
          "mcp-use"
        );
        const relativeMcpUsePath = pathHelpers.relative(widgetTempDir, mcpUsePath).replace(/\\/g, "/");
        const cssContent = `@import "tailwindcss";

/* Configure Tailwind to scan the resources directory and mcp-use package */
@source "${relativeResourcesPath}";
@source "${relativeMcpUsePath}/**/*.{ts,tsx,js,jsx}";
`;
        await fs.writeFile(
          pathHelpers.join(widgetTempDir, "styles.css"),
          cssContent,
          "utf8"
        );
        const entryContent = `import React from 'react'
import { createRoot } from 'react-dom/client'
import './styles.css'
import Component from '${entryPath}'

const container = document.getElementById('widget-root')
if (container && Component) {
  const root = createRoot(container)
  root.render(<Component />)
}
`;
        const fullBaseUrl = `${serverConfig.serverBaseUrl}${baseRoute}`;
        const htmlContent = `<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>${widgetName} Widget</title>${serverConfig.favicon ? `
    <link rel="icon" href="${serverConfig.serverBaseUrl.replace(/\/$/, "")}/mcp-use/public/${serverConfig.favicon}" />` : ""}
    <script type="module" src="${fullBaseUrl}/@vite/client"></script>
    <script type="module">
      import RefreshRuntime from '${fullBaseUrl}/@react-refresh';
      RefreshRuntime.injectIntoGlobalHook(window);
      window.$RefreshReg$ = () => {};
      window.$RefreshSig$ = () => (type) => type;
      window.__vite_plugin_react_preamble_installed__ = true;
    </script>
  </head>
  <body>
    <div id="widget-root"></div>
    <script type="module" src="${fullBaseUrl}/${slugifiedName}/entry.tsx"></script>
  </body>
</html>`;
        await fs.writeFile(
          pathHelpers.join(widgetTempDir, "entry.tsx"),
          entryContent,
          "utf8"
        );
        await fs.writeFile(
          pathHelpers.join(widgetTempDir, "index.html"),
          htmlContent,
          "utf8"
        );
      }, "createWidgetTempFiles");
      const extractAndRegisterWidget = /* @__PURE__ */ __name(async (widgetName, entryPath, changedFilePath, isHmrUpdate = false) => {
        if (changedFilePath) {
          server.moduleGraph.onFileChange(changedFilePath);
        }
        const entryMod = server.moduleGraph.getModuleById(entryPath);
        if (entryMod) {
          server.moduleGraph.invalidateModule(entryMod);
        }
        const mod = await server.ssrLoadModule(entryPath);
        let metadata = {};
        if (mod.widgetMetadata) {
          metadata = mod.widgetMetadata;
          const schemaField = metadata.props || metadata.inputs;
          if (schemaField) {
            try {
              metadata.props = schemaField;
              if (!metadata.inputs) {
                metadata.inputs = schemaField;
              }
            } catch (error2) {
              console.warn(
                `[WIDGET] Failed to extract schema for ${widgetName}:`,
                error2
              );
            }
          }
        }
        const serverOrigin = serverConfig.serverBaseUrl ? new URL(serverConfig.serverBaseUrl).origin : null;
        let enrichedCspMetadata = metadata.metadata;
        if (serverOrigin) {
          const csp = enrichedCspMetadata?.csp ? { ...enrichedCspMetadata.csp } : {};
          for (const field of [
            "connectDomains",
            "resourceDomains",
            "baseUriDomains"
          ]) {
            if (csp[field] && !csp[field].includes(serverOrigin)) {
              csp[field] = [...csp[field], serverOrigin];
            } else if (!csp[field]) {
              csp[field] = [serverOrigin];
            }
          }
          const wsOrigin = serverOrigin.replace(/^http/, "ws");
          if (!csp.connectDomains?.includes(wsOrigin)) {
            csp.connectDomains = [...csp.connectDomains || [], wsOrigin];
          }
          const unsafeEval = "'unsafe-eval'";
          if (!csp.scriptDirectives?.includes(unsafeEval)) {
            csp.scriptDirectives = [
              ...csp.scriptDirectives || [],
              unsafeEval
            ];
          }
          enrichedCspMetadata = { ...enrichedCspMetadata, csp };
        }
        if (isHmrUpdate) {
          const schemaField = metadata.props || metadata.inputs;
          const { slugifyWidgetName: slugifyWidgetName4, processWidgetHtml: processWidgetHtml2 } = await import("../../widget-helpers-4TKHDNQP.js");
          const { buildDualProtocolMetadata: buildDualProtocolMetadata2, getBuildIdPart: getBuildIdPart2 } = await import("../../protocol-helpers-MHXDBHQ7.js");
          const widgetType = metadata.appsSdkMetadata && !metadata.metadata ? "appsSdk" : "mcpApps";
          const slugifiedName2 = slugifyWidgetName4(widgetName);
          const description = metadata.description || `Widget: ${widgetName}`;
          const htmlPath = pathHelpers.join(
            tempDir,
            slugifiedName2,
            "index.html"
          );
          let html2 = "";
          try {
            html2 = await fsHelpers.readFileSync(htmlPath);
            html2 = processWidgetHtml2(
              html2,
              widgetName,
              serverConfig.serverBaseUrl
            );
          } catch (e) {
            console.warn(
              `[WIDGET-HMR] Failed to read HTML for ${widgetName}:`,
              e
            );
          }
          const buildIdPart = getBuildIdPart2(void 0);
          const resourceUri = `ui://widget/${widgetName}${buildIdPart}.html`;
          const hmrDefinition = {
            name: widgetName,
            type: widgetType,
            description,
            metadata: enrichedCspMetadata
          };
          const dualProtocolMeta = buildDualProtocolMetadata2(
            hmrDefinition,
            resourceUri
          );
          const fullMeta = {
            "mcp-use/widget": {
              name: widgetName,
              slugifiedName: slugifiedName2,
              title: metadata.title || widgetName,
              description,
              type: widgetType,
              props: schemaField,
              html: html2,
              dev: true,
              exposeAsTool: metadata.exposeAsTool ?? false
            },
            ui: {},
            // mcp-use private extension: props schema for inspector PropsConfigDialog.
            // Not part of SEP-1865; other hosts will ignore this key.
            ...schemaField ? { "mcp-use/propsSchema": schemaField } : {},
            ...dualProtocolMeta
          };
          const updated = updateWidgetTool(widgetName, {
            description,
            schema: schemaField,
            _meta: fullMeta
          });
          if (updated) {
            return;
          }
          console.log(
            `[WIDGET-HMR] Tool ${widgetName} not found, falling back to full registration`
          );
        }
        const { slugifyWidgetName: slugifyWidgetName3 } = await import("../../widget-helpers-4TKHDNQP.js");
        const slugifiedName = slugifyWidgetName3(widgetName);
        const metadataToRegister = {
          ...metadata,
          metadata: enrichedCspMetadata ?? metadata.metadata,
          ...metadata.description ? {} : { description: `Widget: ${widgetName}` }
        };
        await registerWidgetFromTemplate(
          widgetName,
          pathHelpers.join(tempDir, slugifiedName, "index.html"),
          metadataToRegister,
          serverConfig,
          registerWidget,
          true
          // isDev
        );
      }, "extractAndRegisterWidget");
      server.watcher.on("change", async (filePath) => {
        const relativePath = pathHelpers.relative(resourcesPath, filePath);
        let isWidgetFile = false;
        let widgetName = "";
        if ((relativePath.endsWith(".tsx") || relativePath.endsWith(".ts")) && !relativePath.includes("/")) {
          isWidgetFile = true;
          widgetName = relativePath.replace(/\.tsx?$/, "");
        } else if (relativePath.includes("/")) {
          const parts = relativePath.split("/");
          const potentialWidgetName = parts[0];
          const widget2 = widgets.find((w) => w.name === potentialWidgetName);
          if (widget2) {
            isWidgetFile = true;
            widgetName = potentialWidgetName;
          }
        }
        if (isWidgetFile) {
          const widget2 = widgets.find((w) => w.name === widgetName);
          if (widget2) {
            try {
              await extractAndRegisterWidget(
                widget2.name,
                widget2.entry,
                filePath,
                true
                // isHmrUpdate
              );
              console.log(`[WIDGETS] Reloaded metadata for ${widget2.name}`);
              import("../../tool-registry-generator-HW3KH4GR.js").then(
                ({ generateToolRegistryTypes: generateToolRegistryTypes2 }) => generateToolRegistryTypes2(server.registrations.tools)
              ).catch(() => {
              });
            } catch (error2) {
              console.warn(
                `[WIDGET] Failed to reload metadata for ${widget2.name}:`,
                error2
              );
            }
          }
        }
      });
      server.watcher.on("add", async (filePath) => {
        const relativePath = pathHelpers.relative(resourcesPath, filePath);
        if ((relativePath.endsWith(".tsx") || relativePath.endsWith(".ts")) && !relativePath.includes("/")) {
          const widgetName = relativePath.replace(/\.tsx?$/, "");
          if (!widgets.find((w) => w.name === widgetName)) {
            try {
              widgets.push({
                name: widgetName,
                description: `Widget: ${widgetName}`,
                entry: filePath
              });
              await createWidgetTempFiles(widgetName, filePath);
              await extractAndRegisterWidget(widgetName, filePath);
              console.log(`[WIDGETS] New widget added: ${widgetName}`);
              import("../../tool-registry-generator-HW3KH4GR.js").then(
                ({ generateToolRegistryTypes: generateToolRegistryTypes2 }) => generateToolRegistryTypes2(server.registrations.tools)
              ).catch(() => {
              });
            } catch (error2) {
              console.warn(
                `[WIDGET] Failed to add new widget ${widgetName}:`,
                error2
              );
              const idx = widgets.findIndex((w) => w.name === widgetName);
              if (idx !== -1) widgets.splice(idx, 1);
            }
          }
        } else if (relativePath.endsWith("widget.tsx")) {
          const parts = relativePath.split("/");
          if (parts.length === 2) {
            const widgetName = parts[0];
            if (!widgets.find((w) => w.name === widgetName)) {
              try {
                widgets.push({
                  name: widgetName,
                  description: `Widget: ${widgetName}`,
                  entry: filePath
                });
                await createWidgetTempFiles(widgetName, filePath);
                await extractAndRegisterWidget(widgetName, filePath);
                console.log(`[WIDGETS] New widget added: ${widgetName}`);
                import("../../tool-registry-generator-HW3KH4GR.js").then(
                  ({ generateToolRegistryTypes: generateToolRegistryTypes2 }) => generateToolRegistryTypes2(server.registrations.tools)
                ).catch(() => {
                });
              } catch (error2) {
                console.warn(
                  `[WIDGET] Failed to add new widget ${widgetName}:`,
                  error2
                );
                const idx = widgets.findIndex((w) => w.name === widgetName);
                if (idx !== -1) widgets.splice(idx, 1);
              }
            }
          }
        }
      });
    }
  };
  const nodeStubsPlugin = {
    name: "node-stubs",
    enforce: "pre",
    resolveId(id) {
      if (id === "posthog-node" || id.startsWith("posthog-node/")) {
        return "\0virtual:posthog-node-stub";
      }
      return null;
    },
    load(id) {
      if (id === "\0virtual:posthog-node-stub") {
        return `
export class PostHog {
  constructor() {}
  capture() {}
  identify() {}
  alias() {}
  flush() { return Promise.resolve(); }
  shutdown() { return Promise.resolve(); }
}
export default PostHog;
`;
      }
      return null;
    }
  };
  const zodJitlessPlugin = {
    name: "zod-jitless",
    enforce: "pre",
    transform(code, id) {
      if (!id.includes("zod") || !id.includes("core")) {
        return null;
      }
      const zodConfigPatterns = [
        /export\s+const\s+globalConfig\s*=\s*\{\s*\}/g,
        /const\s+globalConfig\s*=\s*\{\s*\}/g
      ];
      let transformed = code;
      let patched = false;
      for (const pattern of zodConfigPatterns) {
        pattern.lastIndex = 0;
        if (pattern.test(transformed)) {
          pattern.lastIndex = 0;
          transformed = transformed.replace(
            pattern,
            (match) => match.replace(/=\s*\{\s*\}/, "={ jitless: true }")
          );
          patched = true;
        }
      }
      return patched ? transformed : null;
    }
  };
  const widgetHmrPlugin = {
    name: "widget-hmr-compat",
    enforce: "pre",
    transform(code, id, options2) {
      if (options2?.ssr) return null;
      const cleanId = id.replace(/[?#].*$/, "");
      if (!cleanId.endsWith(".tsx") && !cleanId.endsWith(".ts")) return null;
      if (!code.includes("widgetMetadata")) return null;
      let result = code;
      result = result.replace(
        /export\s+(const|let|var)\s+widgetMetadata\b/g,
        "const _widgetMetadata"
      );
      result = result.replace(
        /export\s*\{[^}]*\bwidgetMetadata\b[^}]*\}/g,
        (match) => {
          const cleaned = match.replace(/\bwidgetMetadata\b\s*(as\s+\w+)?\s*,?\s*/g, "").replace(/,\s*\}/, " }").replace(/\{\s*\}/, "{ /* stripped */ }");
          return cleaned.includes("{ /* stripped */ }") ? "" : cleaned;
        }
      );
      if (!result.includes("import.meta.hot")) {
        result += "\nif (import.meta.hot) { import.meta.hot.accept(); }\n";
      }
      return result;
    }
  };
  const suppressFullReloadPlugin = {
    name: "suppress-widget-full-reload",
    configureServer(srv) {
      const channels = [];
      if (srv.ws) channels.push(srv.ws);
      if (srv.hot) channels.push(srv.hot);
      if (srv.environments?.client?.hot)
        channels.push(srv.environments.client.hot);
      for (const channel of channels) {
        if (!channel?.send) continue;
        const origSend = channel.send.bind(channel);
        channel.send = (...args) => {
          const msg = args[0];
          if (msg && typeof msg === "object" && msg.type === "full-reload" || typeof msg === "string" && msg.includes('"type":"full-reload"')) {
            return;
          }
          return origSend(...args);
        };
      }
    },
    handleHotUpdate({ file }) {
      if (file.endsWith(".html")) return [];
      return void 0;
    }
  };
  const widgetSourceEntries = widgets.map((w) => w.entry);
  const coreDeps = [
    "react",
    "react/jsx-runtime",
    "react/jsx-dev-runtime",
    "react-dom",
    "react-dom/client",
    "mcp-use/react"
  ];
  const hmrPort = await findAvailablePort(DEFAULT_HMR_PORT);
  const viteServer = await createServer({
    root: tempDir,
    base: baseRoute + "/",
    plugins: [
      zodJitlessPlugin,
      nodeStubsPlugin,
      ssrCssPlugin,
      widgetHmrPlugin,
      suppressFullReloadPlugin,
      watchResourcesPlugin,
      tailwindcss(),
      react()
    ],
    resolve: {
      dedupe: ["react", "react-dom"],
      alias: {
        "@": pathHelpers.join(getCwd(), resourcesDir)
      }
    },
    build: {
      // Disable source maps to avoid CSP eval violations
      // Source maps can use eval-based mappings which violate strict CSP
      sourcemap: false,
      // Minify for production builds
      minify: "esbuild"
    },
    server: {
      middlewareMode: true,
      // NOTE: We intentionally do NOT set `origin` here.
      // Setting origin to a localhost URL (e.g., "http://localhost:3000") causes Vite
      // to hardcode absolute URLs for all module imports (@fs/, @vite/client, etc.).
      // When the server runs behind a reverse proxy (ngrok, E2B, Cloudflare tunnels),
      // the browser can't access localhost, breaking all dynamic module loading.
      // Without `origin`, Vite generates relative URLs that resolve against the
      // document origin, which works both locally and behind proxies.
      //
      // Allow all hosts so the Vite middleware works behind reverse proxies
      // Without this, Vite returns 403 for requests with non-localhost Host headers
      allowedHosts: true,
      hmr: {
        // Explicitly set the internal HMR WebSocket port so we can proxy to it.
        // In middleware mode, Vite creates a standalone WebSocket server.
        // We need to know this port to forward upgrade requests from the main server.
        // Port is chosen dynamically so multiple dev servers can run (e.g. 24678, 24679, ...).
        port: hmrPort,
        // Configure the CLIENT to connect to the main server port instead of Vite's
        // standalone port. Our WebSocket proxy on the main server forwards
        // to Vite's internal port. This enables HMR through reverse proxies.
        // - Behind HTTPS proxy (ngrok/E2B): client connects to wss://host:443/...
        //    proxy  port 3000  our WS proxy  Vite WS on port 24678
        // - Local: client connects to ws://localhost:3000/...
        //    our WS proxy  Vite WS on port 24678
        clientPort: serverConfig.serverBaseUrl.startsWith("https:") ? 443 : Number(serverConfig.serverPort) || 3e3
      },
      watch: {
        // Watch the resources directory for HMR to work
        // This ensures changes to widget source files trigger hot reload
        ignored: ["**/node_modules/**", "**/.git/**"],
        // Enable polling on Linux where file watching may not work reliably
        // (especially in Docker, WSL, VMs, or network filesystems)
        usePolling: process.platform === "linux",
        // If polling is enabled, check every 100ms (reasonable default)
        interval: 100
      }
    },
    // Explicitly tell Vite to watch files outside root
    // This is needed because widget entry files import from resources directory
    optimizeDeps: {
      // Scan widget source files at startup so all deps are pre-bundled
      // before any browser connects. Avoids mid-session "optimized
      // dependencies changed" reloads that create duplicate React instances.
      entries: widgetSourceEntries,
      include: coreDeps,
      // Exclude Node.js-only packages from browser bundling
      exclude: ["posthog-node"]
    },
    ssr: {
      // Force Vite to transform these packages in SSR instead of using external requires
      noExternal: ["@openai/apps-sdk-ui", "react-router"],
      // Mark Node.js-only packages as external in SSR mode
      external: ["posthog-node"]
    },
    define: {
      // Define process.env for SSR context
      "process.env.NODE_ENV": JSON.stringify(
        process.env.NODE_ENV || "development"
      ),
      "import.meta.env.DEV": true,
      "import.meta.env.PROD": false,
      "import.meta.env.MODE": JSON.stringify("development"),
      "import.meta.env.SSR": true
    }
  });
  const viteHmrPort = viteServer.config.server.hmr?.port ?? DEFAULT_HMR_PORT;
  if (viteHmrPort) {
    console.log(
      `[WIDGETS] Vite HMR WebSocket on port ${viteHmrPort}, setting up proxy on main server`
    );
    const hmrPort2 = viteHmrPort;
    const widgetRoute = baseRoute;
    const netModule = await import("net");
    const setupWsProxy = /* @__PURE__ */ __name((httpServer) => {
      httpServer.on("upgrade", (req, socket, head) => {
        if (req.url?.startsWith(`${widgetRoute}/`) || req.url === widgetRoute) {
          const upstream = netModule.createConnection(
            { port: hmrPort2, host: "localhost" },
            () => {
              const rawRequest = `${req.method} ${req.url} HTTP/${req.httpVersion}\r
` + Object.entries(req.headers).map(([k, v]) => `${k}: ${v}`).join("\r\n") + "\r\n\r\n";
              upstream.write(rawRequest);
              if (head.length > 0) upstream.write(head);
              socket.pipe(upstream);
              upstream.pipe(socket);
            }
          );
          upstream.on("error", () => socket.destroy());
          socket.on("error", () => upstream.destroy());
        }
      });
    }, "setupWsProxy");
    app.__viteWsProxy = setupWsProxy;
  }
  app.use(`${baseRoute}/*`, async (c, next) => {
    const url = new URL(c.req.url);
    const pathname = url.pathname;
    const widgetMatch = pathname.replace(baseRoute, "").match(/^\/([^/]+)/);
    if (widgetMatch) {
      const slugifiedNameFromUrl = widgetMatch[1];
      const { slugifyWidgetName: slugifyWidgetName3 } = await import("../../widget-helpers-4TKHDNQP.js");
      const widget2 = widgets.find(
        (w) => slugifyWidgetName3(w.name) === slugifiedNameFromUrl
      );
      if (widget2) {
        const relativePath = pathname.replace(baseRoute, "");
        if (relativePath === `/${slugifiedNameFromUrl}` || relativePath === `/${slugifiedNameFromUrl}/`) {
          const newUrl = new URL(c.req.url);
          newUrl.pathname = `${baseRoute}/${slugifiedNameFromUrl}/index.html`;
          const newRequest = new Request(newUrl.toString(), c.req.raw);
          Object.defineProperty(c, "req", {
            value: {
              ...c.req,
              url: newUrl.toString(),
              raw: newRequest
            },
            writable: false,
            configurable: true
          });
        }
      }
    }
    await next();
  });
  const viteMiddleware = await adaptConnectMiddleware(
    viteServer.middlewares,
    `${baseRoute}/*`
  );
  app.use(`${baseRoute}/*`, viteMiddleware);
  if (!serverConfig.publicRoutesMode) {
    setupPublicRoutes(app, false);
    setupFaviconRoute(app, serverConfig.favicon, false);
  }
  app.use(`${baseRoute}/*`, async (c) => {
    const url = new URL(c.req.url);
    const isAsset = url.pathname.match(
      /\.(js|css|png|jpg|jpeg|svg|json|ico|woff2?|tsx?)$/i
    );
    const message = isAsset ? "Widget asset not found" : "Widget not found";
    return c.text(message, 404);
  });
  for (const widget2 of widgets) {
    const slugifiedName = slugifyWidgetName2(widget2.name);
    console.log(
      `[WIDGET] ${widget2.name} mounted at ${baseRoute}/${slugifiedName}`
    );
  }
  for (const widget2 of widgets) {
    let metadata = {};
    try {
      const mod = await viteServer.ssrLoadModule(widget2.entry);
      if (mod.widgetMetadata) {
        metadata = mod.widgetMetadata;
        const schemaField = metadata.props || metadata.inputs;
        if (schemaField) {
          try {
            metadata.props = schemaField;
            if (!metadata.inputs) {
              metadata.inputs = schemaField;
            }
          } catch (error2) {
            console.warn(
              `[WIDGET] Failed to extract schema for ${widget2.name}:`,
              error2
            );
          }
        }
      }
    } catch (error2) {
      console.warn(
        `[WIDGET] Failed to load metadata for ${widget2.name}:`,
        error2
      );
    }
    let enrichedCspMetadata = metadata.metadata;
    const serverOrigin = serverConfig.serverBaseUrl ? new URL(serverConfig.serverBaseUrl).origin : null;
    if (serverOrigin) {
      const csp = enrichedCspMetadata?.csp ? { ...enrichedCspMetadata.csp } : {};
      for (const field of [
        "connectDomains",
        "resourceDomains",
        "baseUriDomains"
      ]) {
        if (csp[field] && !csp[field].includes(serverOrigin)) {
          csp[field] = [...csp[field], serverOrigin];
        } else if (!csp[field]) {
          csp[field] = [serverOrigin];
        }
      }
      const wsOrigin = serverOrigin.replace(/^http/, "ws");
      if (!csp.connectDomains?.includes(wsOrigin)) {
        csp.connectDomains = [...csp.connectDomains || [], wsOrigin];
      }
      const unsafeEval = "'unsafe-eval'";
      if (!csp.scriptDirectives?.includes(unsafeEval)) {
        csp.scriptDirectives = [...csp.scriptDirectives || [], unsafeEval];
      }
      enrichedCspMetadata = { ...enrichedCspMetadata, csp };
    }
    const metadataToRegister = {
      ...metadata,
      metadata: enrichedCspMetadata ?? metadata.metadata,
      ...metadata.description ? {} : { description: widget2.description }
    };
    const slugifiedName = slugifyWidgetName2(widget2.name);
    await registerWidgetFromTemplate(
      widget2.name,
      pathHelpers.join(tempDir, slugifiedName, "index.html"),
      metadataToRegister,
      serverConfig,
      registerWidget,
      true
      // isDev
    );
  }
}
__name(mountWidgetsDev, "mountWidgetsDev");

// src/server/widgets/mount-widgets-production.ts
async function mountWidgetsProduction(app, serverConfig, registerWidget, options) {
  const baseRoute = options?.baseRoute || "/mcp-use/widgets";
  const widgetsDir = pathHelpers.join(
    isDeno ? "." : getCwd(),
    "dist",
    "resources",
    "widgets"
  );
  console.log("widgetsDir", widgetsDir);
  const manifestPath = "./dist/mcp-use.json";
  let widgets = [];
  let widgetsMetadata = {};
  try {
    const manifestContent = await fsHelpers.readFileSync(manifestPath, "utf8");
    const manifest = JSON.parse(manifestContent);
    if (manifest.buildId && typeof manifest.buildId === "string") {
      serverConfig.buildId = manifest.buildId;
      console.log(`[WIDGETS] Build ID: ${manifest.buildId}`);
    }
    if (manifest.widgets && typeof manifest.widgets === "object" && !Array.isArray(manifest.widgets)) {
      widgets = Object.keys(manifest.widgets);
      widgetsMetadata = manifest.widgets;
      console.log(`[WIDGETS] Loaded ${widgets.length} widget(s) from manifest`);
    } else if (manifest.widgets && Array.isArray(manifest.widgets)) {
      widgets = manifest.widgets;
      console.log(
        `[WIDGETS] Loaded ${widgets.length} widget(s) from manifest (legacy format)`
      );
    } else {
      console.log("[WIDGETS] No widgets found in manifest");
    }
  } catch (error2) {
    console.log(
      "[WIDGETS] Could not read manifest file, falling back to directory listing:",
      error2
    );
    try {
      const allEntries = await fsHelpers.readdirSync(widgetsDir);
      for (const name of allEntries) {
        const widgetPath = pathHelpers.join(widgetsDir, name);
        const indexPath = pathHelpers.join(widgetPath, "index.html");
        if (await fsHelpers.existsSync(indexPath)) {
          widgets.push(name);
        }
      }
    } catch (dirError) {
      console.log("[WIDGETS] Directory listing also failed:", dirError);
    }
  }
  if (widgets.length === 0) {
    console.log("[WIDGETS] No built widgets found");
    return;
  }
  console.log(
    `[WIDGETS] Serving ${widgets.length} pre-built widget(s) from dist/resources/widgets/`
  );
  for (const widgetName of widgets) {
    const widgetPath = pathHelpers.join(widgetsDir, widgetName);
    const indexPath = pathHelpers.join(widgetPath, "index.html");
    const metadata = widgetsMetadata[widgetName] || {};
    const mcp_connect_domain = serverConfig.serverBaseUrl ? new URL(serverConfig.serverBaseUrl || "").origin : null;
    console.log("[CSP] mcp_connect_domain", mcp_connect_domain);
    console.log("[CSP] cspUrls", serverConfig.cspUrls);
    console.log("[CSP] metadata.appsSdkMetadata", metadata.appsSdkMetadata);
    console.log("[CSP] metadata._meta", metadata._meta);
    await registerWidgetFromTemplate(
      widgetName,
      indexPath,
      metadata,
      serverConfig,
      registerWidget,
      false
      // isDev
    );
    console.log(`[WIDGET] ${widgetName} mounted at ${baseRoute}/${widgetName}`);
  }
}
__name(mountWidgetsProduction, "mountWidgetsProduction");

// src/server/widgets/setup-widget-routes.ts
function setupWidgetRoutes(app, serverConfig) {
  app.get("/mcp-use/widgets/:widget/assets/*", async (c) => {
    const widget2 = c.req.param("widget");
    const assetFile = c.req.path.split("/assets/")[1];
    const assetPath = pathHelpers.join(
      getCwd(),
      "dist",
      "resources",
      "widgets",
      widget2,
      "assets",
      assetFile
    );
    try {
      if (await fsHelpers.existsSync(assetPath)) {
        const content = await fsHelpers.readFile(assetPath);
        const contentType = getContentType(assetFile);
        return new Response(content, {
          status: 200,
          headers: { "Content-Type": contentType }
        });
      }
      return c.notFound();
    } catch {
      return c.notFound();
    }
  });
  app.get("/mcp-use/widgets/assets/*", async (c) => {
    const assetFile = c.req.path.split("/assets/")[1];
    const widgetsDir = pathHelpers.join(
      getCwd(),
      "dist",
      "resources",
      "widgets"
    );
    try {
      const widgets = await fsHelpers.readdirSync(widgetsDir);
      for (const widget2 of widgets) {
        const assetPath = pathHelpers.join(
          widgetsDir,
          widget2,
          "assets",
          assetFile
        );
        if (await fsHelpers.existsSync(assetPath)) {
          const content = await fsHelpers.readFile(assetPath);
          const contentType = getContentType(assetFile);
          return new Response(content, {
            status: 200,
            headers: { "Content-Type": contentType }
          });
        }
      }
      return c.notFound();
    } catch {
      return c.notFound();
    }
  });
  app.get("/mcp-use/widgets/:widget", async (c) => {
    const widget2 = c.req.param("widget");
    const filePath = pathHelpers.join(
      getCwd(),
      "dist",
      "resources",
      "widgets",
      widget2,
      "index.html"
    );
    try {
      let html2 = await fsHelpers.readFileSync(filePath, "utf8");
      html2 = processWidgetHtml(html2, widget2, serverConfig.serverBaseUrl);
      return c.html(html2);
    } catch {
      return c.notFound();
    }
  });
  setupPublicRoutes(app, true);
  setupFaviconRoute(app, serverConfig.favicon, true);
}
__name(setupWidgetRoutes, "setupWidgetRoutes");

// src/server/widgets/ui-resource-registration.ts
import z from "zod";
function enrichDefinitionWithServerOrigin(definition, serverOrigin) {
  if (!serverOrigin || definition.type !== "mcpApps") {
    return definition;
  }
  const enrichedMetadata = definition.metadata ? { ...definition.metadata } : {};
  if (!enrichedMetadata.csp) {
    enrichedMetadata.csp = {};
  } else {
    enrichedMetadata.csp = { ...enrichedMetadata.csp };
  }
  if (!enrichedMetadata.csp.resourceDomains) {
    enrichedMetadata.csp.resourceDomains = [serverOrigin];
  } else if (!enrichedMetadata.csp.resourceDomains.includes(serverOrigin)) {
    enrichedMetadata.csp.resourceDomains = [
      ...enrichedMetadata.csp.resourceDomains,
      serverOrigin
    ];
  }
  if (!enrichedMetadata.csp.connectDomains) {
    enrichedMetadata.csp.connectDomains = [serverOrigin];
  } else if (!enrichedMetadata.csp.connectDomains.includes(serverOrigin)) {
    enrichedMetadata.csp.connectDomains = [
      ...enrichedMetadata.csp.connectDomains,
      serverOrigin
    ];
  }
  if (!enrichedMetadata.csp.baseUriDomains) {
    enrichedMetadata.csp.baseUriDomains = [serverOrigin];
  } else if (!enrichedMetadata.csp.baseUriDomains.includes(serverOrigin)) {
    enrichedMetadata.csp.baseUriDomains = [
      ...enrichedMetadata.csp.baseUriDomains,
      serverOrigin
    ];
  }
  return {
    ...definition,
    metadata: enrichedMetadata
  };
}
__name(enrichDefinitionWithServerOrigin, "enrichDefinitionWithServerOrigin");
function uiResourceRegistration(server, definition) {
  const displayName = definition.title || definition.name;
  const serverOrigin = server.serverBaseUrl ? new URL(server.serverBaseUrl).origin : null;
  const enrichedDefinition = enrichDefinitionWithServerOrigin(
    definition,
    serverOrigin
  );
  const isUpdate = server.widgetDefinitions.has(enrichedDefinition.name);
  if (enrichedDefinition.type === "appsSdk" || enrichedDefinition.type === "mcpApps") {
    server.widgetDefinitions.set(enrichedDefinition.name, {
      widgetType: enrichedDefinition.type,
      metadata: enrichedDefinition.type === "mcpApps" ? enrichedDefinition.metadata : void 0
    });
    if (enrichedDefinition.type === "mcpApps" && server.registrations?.tools) {
      for (const [, toolReg] of server.registrations.tools) {
        const widgetConfig = toolReg.config.widget;
        if (widgetConfig?.name === enrichedDefinition.name) {
          const buildIdPart = getBuildIdPart(server.buildId);
          const outputTemplate = `ui://widget/${enrichedDefinition.name}${buildIdPart}.html`;
          toolReg.config._meta = buildDualProtocolMetadata(
            enrichedDefinition,
            outputTemplate,
            toolReg.config._meta
          );
        }
      }
    }
  }
  let resourceUri;
  let mimeType;
  switch (enrichedDefinition.type) {
    case "externalUrl":
      resourceUri = generateWidgetUri(
        enrichedDefinition.widget,
        server.buildId
      );
      mimeType = "text/uri-list";
      break;
    case "rawHtml":
      resourceUri = generateWidgetUri(enrichedDefinition.name, server.buildId);
      mimeType = "text/html";
      break;
    case "remoteDom":
      resourceUri = generateWidgetUri(enrichedDefinition.name, server.buildId);
      mimeType = "application/vnd.mcp-ui.remote-dom+javascript";
      break;
    case "appsSdk":
      resourceUri = generateWidgetUri(
        enrichedDefinition.name,
        server.buildId,
        ".html"
      );
      mimeType = "text/html+skybridge";
      break;
    case "mcpApps":
      resourceUri = generateWidgetUri(
        enrichedDefinition.name,
        server.buildId,
        ".html"
      );
      mimeType = "text/html;profile=mcp-app";
      break;
    default:
      throw new Error(
        `Unsupported UI resource type. Must be one of: externalUrl, rawHtml, remoteDom, appsSdk, mcpApps`
      );
  }
  const serverConfig = {
    serverHost: server.serverHost,
    serverPort: server.serverPort || 3e3,
    serverBaseUrl: server.serverBaseUrl,
    buildId: server.buildId
  };
  const resourceUiMeta = enrichedDefinition.type === "mcpApps" ? buildResourceUiMeta(enrichedDefinition) : void 0;
  const defMeta = enrichedDefinition._meta;
  const defMetaPublic = defMeta ? Object.fromEntries(
    Object.entries(defMeta).filter(
      ([k]) => k !== "mcp-use/widget" && k !== "ui"
    )
  ) : {};
  const listingUi = resourceUiMeta || {};
  const resourceMeta = {
    ...defMetaPublic,
    ...Object.keys(listingUi).length > 0 ? { ui: listingUi } : {}
  };
  const getLatestDefinition = /* @__PURE__ */ __name(() => {
    const stored = server.widgetDefinitions.get(enrichedDefinition.name);
    const full = stored?.["mcp-use/fullDefinition"];
    return full ?? enrichedDefinition;
  }, "getLatestDefinition");
  const resourceReadCallback = /* @__PURE__ */ __name(async () => {
    const latestDef = getLatestDefinition();
    const params = latestDef.type === "externalUrl" ? applyDefaultProps(latestDef.props) : {};
    const uiResource = await createWidgetUIResource(
      latestDef,
      params,
      serverConfig
    );
    uiResource.resource.uri = resourceUri;
    return {
      contents: [uiResource.resource]
    };
  }, "resourceReadCallback");
  const templateReadCallback = /* @__PURE__ */ __name(async (uri, _params) => {
    const latestDef = getLatestDefinition();
    const uiResource = await createWidgetUIResource(
      latestDef,
      {},
      serverConfig
    );
    uiResource.resource.uri = uri.toString();
    return {
      contents: [uiResource.resource]
    };
  }, "templateReadCallback");
  if (!isUpdate) {
    server.resource({
      name: enrichedDefinition.name,
      uri: resourceUri,
      title: enrichedDefinition.title,
      description: enrichedDefinition.description,
      mimeType,
      _meta: resourceMeta,
      annotations: enrichedDefinition.annotations,
      readCallback: resourceReadCallback
    });
    if (enrichedDefinition.type === "appsSdk" || enrichedDefinition.type === "mcpApps") {
      const buildIdPart = server.buildId ? `-${server.buildId}` : "";
      const uriTemplate = `ui://widget/${enrichedDefinition.name}${buildIdPart}-{id}.html`;
      server.resourceTemplate({
        name: `${enrichedDefinition.name}-dynamic`,
        resourceTemplate: {
          uriTemplate,
          name: enrichedDefinition.title || enrichedDefinition.name,
          description: enrichedDefinition.description,
          mimeType
        },
        _meta: resourceMeta,
        title: enrichedDefinition.title,
        description: enrichedDefinition.description,
        annotations: enrichedDefinition.annotations,
        readCallback: templateReadCallback
      });
    }
  } else if (server.registrations) {
    const resourceKey = `${enrichedDefinition.name}:${resourceUri}`;
    const existingResource = server.registrations.resources?.get(resourceKey);
    if (existingResource) {
      existingResource.config = {
        ...existingResource.config,
        _meta: resourceMeta
      };
      existingResource.handler = resourceReadCallback;
    }
    const resourceTemplateKey = `${enrichedDefinition.name}-dynamic`;
    const existingTemplate = server.registrations.resourceTemplates?.get(resourceTemplateKey);
    if (existingTemplate) {
      existingTemplate.config = {
        ...existingTemplate.config,
        _meta: resourceMeta
      };
      existingTemplate.handler = templateReadCallback;
    }
  }
  const widgetMetadata = enrichedDefinition._meta?.["mcp-use/widget"];
  const exposeAsTool = enrichedDefinition.exposeAsTool ?? widgetMetadata?.exposeAsTool ?? false;
  if (!isUpdate && server.sessions && typeof server.propagateWidgetResourcesToSessions === "function") {
    server.propagateWidgetResourcesToSessions(enrichedDefinition.name);
  }
  if (exposeAsTool) {
    const toolMetadata = {};
    if (enrichedDefinition.type === "appsSdk" && enrichedDefinition.appsSdkMetadata) {
      toolMetadata["openai/outputTemplate"] = resourceUri;
      const toolMetadataFields = [
        "openai/toolInvocation/invoking",
        "openai/toolInvocation/invoked",
        "openai/widgetAccessible",
        "openai/resultCanProduceWidget"
      ];
      for (const field of toolMetadataFields) {
        if (enrichedDefinition.appsSdkMetadata[field] !== void 0) {
          toolMetadata[field] = enrichedDefinition.appsSdkMetadata[field];
        }
      }
    } else if (enrichedDefinition.type === "mcpApps") {
      Object.assign(
        toolMetadata,
        buildDualProtocolMetadata(enrichedDefinition, resourceUri, toolMetadata)
      );
    }
    const widgetMetadataSchema = enrichedDefinition._meta?.["mcp-use/widget"];
    const propsOrSchema = enrichedDefinition.props || widgetMetadataSchema?.props || widgetMetadataSchema?.inputs || widgetMetadataSchema?.schema;
    const isZodSchema = propsOrSchema && typeof propsOrSchema === "object" && propsOrSchema instanceof z.ZodObject;
    let isJsonSchema = false;
    if (propsOrSchema && typeof propsOrSchema === "object" && !isZodSchema) {
      const hasSchemaKey = Object.prototype.hasOwnProperty.call(
        propsOrSchema,
        "$schema"
      );
      const hasTypeObject = propsOrSchema.type === "object" && Object.prototype.hasOwnProperty.call(propsOrSchema, "properties");
      isJsonSchema = hasSchemaKey || hasTypeObject;
    }
    const toolDefinition = {
      name: enrichedDefinition.name,
      title: enrichedDefinition.title,
      description: enrichedDefinition.description,
      annotations: enrichedDefinition.toolAnnotations,
      _meta: Object.keys(toolMetadata).length > 0 ? toolMetadata : void 0
    };
    if (isZodSchema) {
      toolDefinition.schema = propsOrSchema;
    } else if (isJsonSchema) {
      const jsonSchema = propsOrSchema;
      if (jsonSchema.properties) {
        const requiredFields = new Set(jsonSchema.required || []);
        toolDefinition.inputs = Object.entries(jsonSchema.properties).map(
          ([name, prop]) => ({
            name,
            type: prop.type || "string",
            description: prop.description,
            required: requiredFields.has(name),
            default: prop.default
          })
        );
      }
    } else if (propsOrSchema) {
      toolDefinition.inputs = convertPropsToInputs(
        propsOrSchema
      );
    }
    const toolCallback = /* @__PURE__ */ __name(async (params) => {
      if (enrichedDefinition.type === "appsSdk" || enrichedDefinition.type === "mcpApps") {
        const toolOutputResult = enrichedDefinition.toolOutput ? typeof enrichedDefinition.toolOutput === "function" ? enrichedDefinition.toolOutput(params) : enrichedDefinition.toolOutput : generateToolOutput(enrichedDefinition, params, displayName);
        const content = toolOutputResult?.content || [
          { type: "text", text: displayName }
        ];
        const contentArray = Array.isArray(content) ? content : [content];
        return {
          content: contentArray,
          structuredContent: toolOutputResult?.structuredContent ?? params
        };
      }
      const uiResource = await createWidgetUIResource(
        enrichedDefinition,
        params,
        serverConfig
      );
      return {
        content: [
          {
            type: "text",
            text: `Displaying ${displayName}`,
            description: `Show MCP-UI widget for ${displayName}`
          },
          uiResource
        ]
      };
    }, "toolCallback");
    if (isUpdate && server.registrations?.tools) {
      const existingTool = server.registrations.tools.get(
        enrichedDefinition.name
      );
      if (existingTool) {
        existingTool.config = {
          ...existingTool.config,
          title: toolDefinition.title,
          description: toolDefinition.description,
          annotations: toolDefinition.annotations,
          _meta: toolDefinition._meta,
          inputs: toolDefinition.inputs,
          schema: toolDefinition.schema
        };
        existingTool.handler = toolCallback;
        if (server.sessions) {
          for (const [, session] of server.sessions) {
            if (session.server?.sendToolListChanged) {
              try {
                session.server.sendToolListChanged();
              } catch {
              }
            }
          }
        }
      }
    } else {
      console.log(
        `[UI Registration] Registering new tool: ${enrichedDefinition.name}`
      );
      if (typeof server.addWidgetTool === "function") {
        server.addWidgetTool(toolDefinition, toolCallback);
      } else {
        server.tool(toolDefinition, toolCallback);
        setTimeout(() => {
          if (server.sessions) {
            for (const [sessionId, session] of server.sessions) {
              if (session.server?.sendToolListChanged) {
                try {
                  session.server.sendToolListChanged();
                } catch (error2) {
                  console.debug(
                    `Failed to send notification to session ${sessionId}`
                  );
                }
              }
            }
          }
        }, 50);
      }
    }
  }
  return server;
}
__name(uiResourceRegistration, "uiResourceRegistration");

// src/server/widgets/index.ts
async function mountWidgets(server, options) {
  const serverConfig = {
    serverBaseUrl: server.serverBaseUrl || `http://${server.serverHost}:${server.serverPort || 3e3}`,
    serverPort: server.serverPort || 3e3,
    cspUrls: getCSPUrls(),
    buildId: server.buildId,
    favicon: server.favicon,
    publicRoutesMode: server.publicRoutesMode,
    /** Pre-created HTTP server for Vite HMR WebSocket support */
    httpServer: server._httpServer
  };
  const registerWidget = /* @__PURE__ */ __name((widgetDef) => {
    server.uiResource(widgetDef);
  }, "registerWidget");
  const updateWidgetTool = /* @__PURE__ */ __name((toolName, updates) => {
    return server.updateWidgetToolInPlace(toolName, updates);
  }, "updateWidgetTool");
  const removeWidgetTool = /* @__PURE__ */ __name((toolName) => {
    server.removeWidgetTool(toolName);
  }, "removeWidgetTool");
  const app = server.app;
  if (isProductionMode() || isDeno) {
    console.log("[WIDGETS] Mounting widgets in production mode");
    setupWidgetRoutes(app, serverConfig);
    server.publicRoutesMode = "production";
    await mountWidgetsProduction(app, serverConfig, registerWidget, options);
  } else {
    console.log("[WIDGETS] Mounting widgets in development mode");
    await mountWidgetsDev(
      app,
      serverConfig,
      registerWidget,
      updateWidgetTool,
      removeWidgetTool,
      options
    );
    if (!serverConfig.publicRoutesMode) {
      server.publicRoutesMode = "dev";
    }
  }
}
__name(mountWidgets, "mountWidgets");

// src/server/inspector/mount.ts
async function mountInspectorUI(app, serverHost, serverPort, isProduction) {
  if (isProduction) {
    const manifest = await readBuildManifest();
    if (!manifest?.includeInspector) {
      console.log(
        "[INSPECTOR] Skipped in production (use --with-inspector flag during build)"
      );
      return false;
    }
  }
  try {
    const { mountInspector } = await import("@mcp-use/inspector");
    const mcpUrl = `http://${serverHost}:${serverPort}/mcp`;
    const autoConnectConfig = JSON.stringify({
      url: mcpUrl,
      name: "Local MCP Server",
      transportType: "sse",
      connectionType: "Direct"
    });
    mountInspector(app, {
      autoConnectUrl: autoConnectConfig,
      // In dev mode, tell the inspector to use same-origin for MCP Apps sandbox.
      // This avoids requiring a sandbox-{hostname} subdomain that doesn't exist
      // behind reverse proxies (ngrok, E2B, etc.)
      devMode: !isProduction
    });
    console.log(
      `[INSPECTOR] UI available at http://${serverHost}:${serverPort}/inspector`
    );
    return true;
  } catch {
    return false;
  }
}
__name(mountInspectorUI, "mountInspectorUI");

// src/server/prompts/index.ts
function registerPrompt(promptDefinition, callback) {
  const actualCallback = callback || promptDefinition.cb;
  if (!actualCallback) {
    throw new Error(
      `Prompt '${promptDefinition.name}' must have either a cb property or a callback parameter`
    );
  }
  let argsSchema;
  if (promptDefinition.schema) {
    argsSchema = this.convertZodSchemaToParams(
      promptDefinition.schema
    );
  } else if (promptDefinition.args && promptDefinition.args.length > 0) {
    argsSchema = this.createParamsSchema(promptDefinition.args);
  } else {
    argsSchema = void 0;
  }
  const wrappedCallback = /* @__PURE__ */ __name(async (params, extra) => {
    const { getRequestContext: getRequestContext2, runWithContext: runWithContext2 } = await import("../../context-storage-NA4MHWOZ.js");
    const { findSessionContext: findSessionContext2 } = await import("../../tool-execution-helpers-WYL6GS5L.js");
    const initialRequestContext = getRequestContext2();
    const sessions = this.sessions || /* @__PURE__ */ new Map();
    const { requestContext } = findSessionContext2(
      sessions,
      initialRequestContext,
      void 0,
      void 0
    );
    const enhancedContext = requestContext || {};
    const executeCallback = /* @__PURE__ */ __name(async () => {
      if (actualCallback.length >= 2) {
        return await actualCallback(params, enhancedContext);
      }
      return await actualCallback(params);
    }, "executeCallback");
    const result = requestContext ? await runWithContext2(requestContext, executeCallback) : await executeCallback();
    if ("messages" in result && Array.isArray(result.messages)) {
      return result;
    }
    return convertToolResultToPromptResult(result);
  }, "wrappedCallback");
  this.server.registerPrompt(
    promptDefinition.name,
    {
      title: promptDefinition.title,
      description: promptDefinition.description ?? "",
      argsSchema
      // Type assertion for Zod v4 compatibility
    },
    wrappedCallback
  );
  this.registeredPrompts.push(promptDefinition.name);
  return this;
}
__name(registerPrompt, "registerPrompt");

// src/server/resources/index.ts
import { ResourceTemplate } from "@modelcontextprotocol/sdk/server/mcp.js";

// src/server/resources/subscriptions.ts
import {
  SubscribeRequestSchema,
  UnsubscribeRequestSchema
} from "@modelcontextprotocol/sdk/types.js";
var ResourceSubscriptionManager = class {
  static {
    __name(this, "ResourceSubscriptionManager");
  }
  /**
   * Tracks resource subscriptions per session
   * Map structure: uri -> Set<sessionId>
   */
  subscriptions = /* @__PURE__ */ new Map();
  /**
   * Register subscription handlers with an MCP server instance
   *
   * @param server - The native MCP server instance
   * @param sessions - Map of active sessions
   */
  registerHandlers(server, sessions) {
    server.server.setRequestHandler(
      SubscribeRequestSchema,
      async (request) => {
        const { uri } = request.params;
        const sessionId = this.getSessionIdFromContext(sessions, server);
        if (!sessionId) {
          console.warn(
            `[MCP] Could not determine session ID for resource subscription to ${uri}`
          );
          return {};
        }
        if (!this.subscriptions.has(uri)) {
          this.subscriptions.set(uri, /* @__PURE__ */ new Set());
        }
        this.subscriptions.get(uri).add(sessionId);
        console.log(
          `[MCP] Session ${sessionId} subscribed to resource: ${uri}`
        );
        return {};
      }
    );
    server.server.setRequestHandler(
      UnsubscribeRequestSchema,
      async (request) => {
        const { uri } = request.params;
        const sessionId = this.getSessionIdFromContext(sessions, server);
        if (!sessionId) {
          console.warn(
            `[MCP] Could not determine session ID for resource unsubscribe from ${uri}`
          );
          return {};
        }
        const subscribers = this.subscriptions.get(uri);
        if (subscribers) {
          subscribers.delete(sessionId);
          if (subscribers.size === 0) {
            this.subscriptions.delete(uri);
          }
          console.log(
            `[MCP] Session ${sessionId} unsubscribed from resource: ${uri}`
          );
        }
        return {};
      }
    );
  }
  /**
   * Get session ID from request context or sessions map
   *
   * @param sessions - Map of active sessions
   * @param server - The server instance to match against
   * @returns The session ID, or undefined if not found
   */
  getSessionIdFromContext(sessions, server) {
    const requestContext = getRequestContext();
    let sessionId;
    if (requestContext) {
      sessionId = requestContext.req.header("mcp-session-id");
    }
    if (!sessionId) {
      for (const [sid, session] of sessions.entries()) {
        if (session.server === server) {
          sessionId = sid;
          break;
        }
      }
    }
    return sessionId;
  }
  /**
   * Notify subscribed clients that a resource has been updated
   *
   * This method sends a `notifications/resources/updated` notification to all
   * sessions that have subscribed to the specified resource URI.
   *
   * @param uri - The URI of the resource that changed
   * @param sessions - Map of active sessions
   * @returns Promise that resolves when all notifications have been sent
   */
  async notifyResourceUpdated(uri, sessions) {
    const subscribers = this.subscriptions.get(uri);
    if (!subscribers || subscribers.size === 0) {
      return;
    }
    console.log(
      `[MCP] Notifying ${subscribers.size} subscriber(s) of resource update: ${uri}`
    );
    for (const sessionId of subscribers) {
      const session = sessions.get(sessionId);
      if (session?.server) {
        try {
          await session.server.server.sendResourceUpdated({ uri });
          console.log(
            `[MCP] Sent resource update notification to session ${sessionId}`
          );
        } catch (error2) {
          console.error(
            `[MCP] Failed to send resource update notification to session ${sessionId}:`,
            error2
          );
        }
      }
    }
  }
  /**
   * Clean up resource subscriptions for a closed session
   *
   * This method is called automatically when a session is closed to remove
   * all resource subscriptions associated with that session.
   *
   * @param sessionId - The session ID to clean up
   */
  cleanupSession(sessionId) {
    for (const [uri, subscribers] of this.subscriptions) {
      subscribers.delete(sessionId);
      if (subscribers.size === 0) {
        this.subscriptions.delete(uri);
      }
    }
    console.log(
      `[MCP] Cleaned up resource subscriptions for session ${sessionId}`
    );
  }
};

// src/server/resources/index.ts
function registerResource(resourceDefinition, callback) {
  const actualCallback = callback || resourceDefinition.readCallback;
  if (!actualCallback) {
    throw new Error(
      `Resource '${resourceDefinition.name}' must have either a readCallback property or a callback parameter`
    );
  }
  const explicitMimeType = resourceDefinition.mimeType;
  const wrappedCallback = /* @__PURE__ */ __name(async () => {
    const { getRequestContext: getRequestContext2, runWithContext: runWithContext2 } = await import("../../context-storage-NA4MHWOZ.js");
    const { findSessionContext: findSessionContext2 } = await import("../../tool-execution-helpers-WYL6GS5L.js");
    const initialRequestContext = getRequestContext2();
    const sessions = this.sessions || /* @__PURE__ */ new Map();
    const { requestContext } = findSessionContext2(
      sessions,
      initialRequestContext,
      void 0,
      void 0
    );
    const enhancedContext = requestContext || {};
    const executeCallback = /* @__PURE__ */ __name(async () => {
      if (actualCallback.length >= 1) {
        return await actualCallback(enhancedContext);
      }
      return await actualCallback();
    }, "executeCallback");
    const result = requestContext ? await runWithContext2(requestContext, executeCallback) : await executeCallback();
    if ("contents" in result && Array.isArray(result.contents)) {
      return result;
    }
    return convertToolResultToResourceResult(
      resourceDefinition.uri,
      result
    );
  }, "wrappedCallback");
  const registrationMimeType = explicitMimeType || "text/plain";
  this.server.registerResource(
    resourceDefinition.name,
    resourceDefinition.uri,
    {
      title: resourceDefinition.title,
      description: resourceDefinition.description,
      mimeType: registrationMimeType,
      _meta: resourceDefinition._meta
    },
    wrappedCallback
  );
  this.registeredResources.push(resourceDefinition.name);
  return this;
}
__name(registerResource, "registerResource");
function registerResourceTemplate(resourceTemplateDefinition, callback) {
  const actualCallback = callback || resourceTemplateDefinition.readCallback;
  if (!actualCallback) {
    throw new Error(
      `Resource template '${resourceTemplateDefinition.name}' must have either a readCallback property or a callback parameter`
    );
  }
  const isFlatStructure = "uriTemplate" in resourceTemplateDefinition;
  const uriTemplate = isFlatStructure ? resourceTemplateDefinition.uriTemplate : resourceTemplateDefinition.resourceTemplate.uriTemplate;
  const mimeType = isFlatStructure ? resourceTemplateDefinition.mimeType : resourceTemplateDefinition.resourceTemplate.mimeType;
  const templateDescription = isFlatStructure ? void 0 : resourceTemplateDefinition.resourceTemplate.description;
  const resourceCallbacks = isFlatStructure ? resourceTemplateDefinition.callbacks : resourceTemplateDefinition.resourceTemplate.callbacks;
  console.log("resourceCallbacks", resourceCallbacks);
  const template = new ResourceTemplate(uriTemplate, {
    complete: toResourceTemplateCompleteCallbacks(resourceCallbacks?.complete),
    // Optional: callback for auto-completion
    list: void 0
    // Optional: callback to list all matching resources
  });
  const metadata = {};
  if (resourceTemplateDefinition.title) {
    metadata.title = resourceTemplateDefinition.title;
  }
  if (resourceTemplateDefinition.description || templateDescription) {
    metadata.description = resourceTemplateDefinition.description || templateDescription;
  }
  if (mimeType) {
    metadata.mimeType = mimeType;
  }
  if (resourceTemplateDefinition.annotations) {
    metadata.annotations = resourceTemplateDefinition.annotations;
  }
  this.server.registerResource(
    resourceTemplateDefinition.name,
    template,
    metadata,
    async (uri) => {
      const params = this.parseTemplateUri(uriTemplate, uri.toString());
      const { getRequestContext: getRequestContext2, runWithContext: runWithContext2 } = await import("../../context-storage-NA4MHWOZ.js");
      const { findSessionContext: findSessionContext2 } = await import("../../tool-execution-helpers-WYL6GS5L.js");
      const initialRequestContext = getRequestContext2();
      const sessions = this.sessions || /* @__PURE__ */ new Map();
      const { requestContext } = findSessionContext2(
        sessions,
        initialRequestContext,
        void 0,
        void 0
      );
      const enhancedContext = requestContext || {};
      const executeCallback = /* @__PURE__ */ __name(async () => {
        if (actualCallback.length >= 3) {
          return await actualCallback(uri, params, enhancedContext);
        } else if (actualCallback.length === 2) {
          return await actualCallback(uri, params);
        } else if (actualCallback.length === 1) {
          return await actualCallback(uri);
        }
        return await actualCallback();
      }, "executeCallback");
      const result = requestContext ? await runWithContext2(requestContext, executeCallback) : await executeCallback();
      if ("contents" in result && Array.isArray(result.contents)) {
        return result;
      }
      return convertToolResultToResourceResult(
        uri.toString(),
        result
      );
    }
  );
  this.registeredResources.push(resourceTemplateDefinition.name);
  return this;
}
__name(registerResourceTemplate, "registerResourceTemplate");

// src/server/tools/schema-helpers.ts
import { z as z2 } from "zod";
function convertZodSchemaToParams(zodSchema) {
  const hasZodObjectStructure = zodSchema && typeof zodSchema === "object" && "_def" in zodSchema && zodSchema._def?.typeName === "ZodObject";
  if (!hasZodObjectStructure && !(zodSchema instanceof z2.ZodObject)) {
    throw new Error("schema must be a Zod object schema (z.object({...}))");
  }
  const shape = zodSchema.shape;
  const params = {};
  for (const [key, value] of Object.entries(shape)) {
    params[key] = value;
  }
  return params;
}
__name(convertZodSchemaToParams, "convertZodSchemaToParams");
function createParamsSchema(inputs) {
  const schema = {};
  inputs.forEach((input) => {
    let zodType;
    switch (input.type) {
      case "string":
        zodType = z2.string();
        break;
      case "number":
        zodType = z2.number();
        break;
      case "boolean":
        zodType = z2.boolean();
        break;
      case "object":
        zodType = z2.object({});
        break;
      case "array":
        zodType = z2.array(z2.any());
        break;
      default:
        zodType = z2.any();
    }
    if (input.description) {
      zodType = zodType.describe(input.description);
    }
    if (!input.required) {
      zodType = zodType.optional();
    }
    schema[input.name] = zodType;
  });
  return schema;
}
__name(createParamsSchema, "createParamsSchema");

// src/server/tools/tool-registration.ts
function toolRegistration(toolDefinition, callback) {
  const actualCallback = callback || toolDefinition.cb;
  if (!actualCallback) {
    throw new Error(
      `Tool '${toolDefinition.name}' must have either a cb property or a callback parameter`
    );
  }
  let inputSchema;
  if (toolDefinition.schema) {
    inputSchema = toolDefinition.schema;
  } else if (toolDefinition.inputs && toolDefinition.inputs.length > 0) {
    inputSchema = this.createParamsSchema(toolDefinition.inputs);
  } else {
    inputSchema = {};
  }
  this.server.registerTool(
    toolDefinition.name,
    {
      title: toolDefinition.title,
      description: toolDefinition.description ?? "",
      inputSchema,
      annotations: toolDefinition.annotations,
      _meta: toolDefinition._meta
    },
    async (params, extra) => {
      const initialRequestContext = getRequestContext();
      const extraProgressToken = extra?._meta?.progressToken;
      const extraSendNotification = extra?.sendNotification;
      const { requestContext, session, progressToken, sendNotification: sendNotification2 } = findSessionContext(
        this.sessions,
        initialRequestContext,
        extraProgressToken,
        extraSendNotification
      );
      let sessionId;
      if (session) {
        for (const [sid, s] of this.sessions.entries()) {
          if (s === session) {
            sessionId = sid;
            break;
          }
        }
      }
      const enhancedContext = createEnhancedContext(
        requestContext,
        this.createMessage.bind(this),
        this.server.server.elicitInput.bind(this.server.server),
        progressToken,
        sendNotification2,
        session?.logLevel,
        session?.clientCapabilities,
        sessionId,
        this.sessions
      );
      const executeCallback = /* @__PURE__ */ __name(async () => {
        if (actualCallback.length >= 2) {
          return await actualCallback(params, enhancedContext);
        }
        return await actualCallback(params);
      }, "executeCallback");
      if (requestContext) {
        return await runWithContext(requestContext, executeCallback);
      }
      return await executeCallback();
    }
  );
  this.registeredTools.push(toolDefinition.name);
  return this;
}
__name(toolRegistration, "toolRegistration");

// src/server/endpoints/mount-mcp.ts
import { join as join2 } from "path";

// src/server/landing.ts
function sanitizeServerName(name) {
  return name.replace(/[^a-zA-Z0-9-_]/g, "_").toLowerCase();
}
__name(sanitizeServerName, "sanitizeServerName");
function generateCursorDeepLink(url, name) {
  const config = { url };
  const configJson = JSON.stringify(config);
  const base64Config = typeof Buffer !== "undefined" ? Buffer.from(configJson).toString("base64") : btoa(configJson);
  const sanitizedName = sanitizeServerName(name);
  return `cursor://anysphere.cursor-deeplink/mcp/install?config=${base64Config}&name=${encodeURIComponent(sanitizedName)}`;
}
__name(generateCursorDeepLink, "generateCursorDeepLink");
function generateVSCodeDeepLink(url, name) {
  const config = {
    url,
    name: sanitizeServerName(name),
    type: "http"
  };
  const configJson = JSON.stringify(config);
  const urlEncodedConfig = encodeURIComponent(configJson);
  return `vscode:mcp/install?${urlEncodedConfig}`;
}
__name(generateVSCodeDeepLink, "generateVSCodeDeepLink");
function generateVSCodeInsidersDeepLink(url, name) {
  const config = {
    url,
    name: sanitizeServerName(name),
    type: "http"
  };
  const configJson = JSON.stringify(config);
  const urlEncodedConfig = encodeURIComponent(configJson);
  return `vscode-insiders:mcp/install?${urlEncodedConfig}`;
}
__name(generateVSCodeInsidersDeepLink, "generateVSCodeInsidersDeepLink");
function generateClaudeCommand(url, name) {
  const sanitizedName = sanitizeServerName(name);
  return `claude mcp add --transport http "${sanitizedName}" ${url}`;
}
__name(generateClaudeCommand, "generateClaudeCommand");
function generateLandingPage(name, version, url, description, tools) {
  const cursorDeepLink = generateCursorDeepLink(url, name);
  const vscodeDeepLink = generateVSCodeDeepLink(url, name);
  const vscodeInsidersDeepLink = generateVSCodeInsidersDeepLink(url, name);
  const claudeCommand = generateClaudeCommand(url, name);
  return `<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>${name}</title>
<style>
* {
  font-family: monospace;
  font-size: 14px;
  font-weight: normal;
  color: #333;
  line-height: 1.5;
}
body {
  margin: 20px;
}
h1 {
  font-size: 18px;
  font-weight: bold;
  margin: 20px 0 10px 0;
}
h2 {
  font-size: 14px;
  font-weight: normal;
  margin: 20px 0 10px 0;
}
p, pre, ol, li, ul {
  margin: 5px 0;
}
a {
  color: #333;
  text-decoration: underline;
}
pre {
  margin: 10px 0;
  white-space: pre-wrap;
}
ol, ul {
  padding-left: 20px;
}
.description {
  margin: 10px 0;
  color: #666;
}
.tools {
  margin: 15px 0;
}
</style>
</head>
<body>
<h1>${name} (v${version})</h1>

${description ? `<p class="description">${description}</p>` : ""}

${tools && tools.length > 0 ? `<div class="tools">
<strong>Available Tools:</strong>
<ul>
${tools.map((tool) => `<li>${tool}</li>`).join("\n")}
</ul>
</div>` : ""}

<p>URL: ${url}</p>

<h2>Connect with Claude Code</h2>
<pre>${claudeCommand}</pre>

<h2>Connect with Cursor</h2>
<p><a href="${cursorDeepLink}">${cursorDeepLink}</a></p>

<h2>Connect with VS Code</h2>
<p><a href="${vscodeDeepLink}">${vscodeDeepLink}</a></p>

<h2>Connect with VS Code Insiders</h2>
<p><a href="${vscodeInsidersDeepLink}">${vscodeInsidersDeepLink}</a></p>

<h2>Connect with ChatGPT</h2>
<ol>
<li>Enable Developer Mode:<br>Settings \u2192 Connectors \u2192 Advanced \u2192 Developer mode</li>
<li>Import this MCP server:<br>Go to Connectors tab and add: ${url}</li>
<li>Use in conversations:<br>Choose the MCP server from the Plus menu</li>
</ol>
</body>
</html>`;
}
__name(generateLandingPage, "generateLandingPage");

// src/server/sessions/session-manager.ts
function startIdleCleanup(sessions, idleTimeoutMs, transports, mcpServerInstance) {
  if (idleTimeoutMs <= 0) {
    return void 0;
  }
  return setInterval(() => {
    const now = Date.now();
    const expiredSessions = [];
    for (const [sessionId, session] of sessions.entries()) {
      if (now - session.lastAccessedAt > idleTimeoutMs) {
        expiredSessions.push(sessionId);
      }
    }
    if (expiredSessions.length > 0) {
      console.log(
        `[MCP] Cleaning up ${expiredSessions.length} idle session(s)`
      );
      for (const sessionId of expiredSessions) {
        const transport = transports?.get(sessionId);
        if (transport?.close) {
          Promise.resolve(transport.close()).catch((e) => {
            console.warn(
              `[MCP] Error closing transport for session ${sessionId}:`,
              e
            );
          });
        }
        transports?.delete(sessionId);
        sessions.delete(sessionId);
        mcpServerInstance?.cleanupSessionSubscriptions?.(sessionId);
        console.log(
          `[MCP] Cleaned up resource subscriptions for session ${sessionId}`
        );
      }
    }
  }, 6e4);
}
__name(startIdleCleanup, "startIdleCleanup");

// src/server/sessions/stores/memory.ts
var InMemorySessionStore = class {
  static {
    __name(this, "InMemorySessionStore");
  }
  /**
   * Internal map storing session metadata
   * Key: sessionId, Value: SessionMetadata
   */
  sessions = /* @__PURE__ */ new Map();
  /**
   * Retrieve session metadata by ID
   */
  async get(sessionId) {
    const data = this.sessions.get(sessionId);
    return data ?? null;
  }
  /**
   * Store or update session metadata
   */
  async set(sessionId, data) {
    this.sessions.set(sessionId, data);
  }
  /**
   * Delete session metadata
   */
  async delete(sessionId) {
    this.sessions.delete(sessionId);
  }
  /**
   * Check if session exists
   */
  async has(sessionId) {
    return this.sessions.has(sessionId);
  }
  /**
   * List all session IDs
   */
  async keys() {
    return Array.from(this.sessions.keys());
  }
  /**
   * Store session metadata with TTL (time-to-live)
   *
   * Note: In-memory implementation uses setTimeout for TTL.
   * For production TTL support, use Redis or another store with native TTL.
   */
  async setWithTTL(sessionId, data, ttlMs) {
    this.sessions.set(sessionId, data);
    setTimeout(() => {
      this.sessions.delete(sessionId);
      console.log(`[MCP] Session ${sessionId} expired after ${ttlMs}ms`);
    }, ttlMs);
  }
  /**
   * Get the number of active sessions
   * Useful for monitoring and debugging
   */
  get size() {
    return this.sessions.size;
  }
  /**
   * Clear all sessions
   * Useful for testing and manual cleanup
   */
  async clear() {
    this.sessions.clear();
  }
};

// src/server/sessions/stores/redis.ts
var RedisSessionStore = class {
  static {
    __name(this, "RedisSessionStore");
  }
  client;
  prefix;
  defaultTTL;
  constructor(config) {
    this.client = config.client;
    this.prefix = config.prefix ?? "mcp:session:";
    this.defaultTTL = config.defaultTTL ?? 3600;
  }
  /**
   * Get full Redis key for a session ID
   */
  getKey(sessionId) {
    return `${this.prefix}${sessionId}`;
  }
  /**
   * Retrieve session metadata by ID
   */
  async get(sessionId) {
    try {
      const key = this.getKey(sessionId);
      const data = await this.client.get(key);
      if (!data) {
        return null;
      }
      return JSON.parse(data);
    } catch (error2) {
      console.error(
        `[RedisSessionStore] Error getting session ${sessionId}:`,
        error2
      );
      return null;
    }
  }
  /**
   * Store or update session metadata
   */
  async set(sessionId, data) {
    try {
      const key = this.getKey(sessionId);
      const value = JSON.stringify(data);
      if (this.client.setEx) {
        await this.client.setEx(key, this.defaultTTL, value);
      } else if (this.client.setex) {
        await this.client.setex(key, this.defaultTTL, value);
      } else {
        await this.client.set(key, value, { EX: this.defaultTTL });
      }
    } catch (error2) {
      console.error(
        `[RedisSessionStore] Error setting session ${sessionId}:`,
        error2
      );
      throw error2;
    }
  }
  /**
   * Delete a session
   */
  async delete(sessionId) {
    try {
      const key = this.getKey(sessionId);
      await this.client.del(key);
    } catch (error2) {
      console.error(
        `[RedisSessionStore] Error deleting session ${sessionId}:`,
        error2
      );
      throw error2;
    }
  }
  /**
   * Check if a session exists
   */
  async has(sessionId) {
    try {
      const key = this.getKey(sessionId);
      const exists = await this.client.exists(key);
      return exists === 1;
    } catch (error2) {
      console.error(
        `[RedisSessionStore] Error checking session ${sessionId}:`,
        error2
      );
      return false;
    }
  }
  /**
   * List all session IDs
   *
   * WARNING: Uses KEYS command which blocks Redis. For production systems with
   * many sessions, consider using SCAN instead or maintaining a separate SET of
   * active session IDs.
   */
  async keys() {
    try {
      const pattern = `${this.prefix}*`;
      const keys = await this.client.keys(pattern);
      return keys.map((key) => key.substring(this.prefix.length));
    } catch (error2) {
      console.error("[RedisSessionStore] Error listing session keys:", error2);
      return [];
    }
  }
  /**
   * Store session metadata with custom TTL (time-to-live)
   */
  async setWithTTL(sessionId, data, ttlMs) {
    try {
      const key = this.getKey(sessionId);
      const value = JSON.stringify(data);
      const ttlSeconds = Math.ceil(ttlMs / 1e3);
      if (this.client.setEx) {
        await this.client.setEx(key, ttlSeconds, value);
      } else if (this.client.setex) {
        await this.client.setex(key, ttlSeconds, value);
      } else {
        await this.client.set(key, value, { EX: ttlSeconds });
      }
    } catch (error2) {
      console.error(
        `[RedisSessionStore] Error setting session ${sessionId} with TTL:`,
        error2
      );
      throw error2;
    }
  }
  /**
   * Close Redis connection
   * Should be called when shutting down the server
   */
  async close() {
    try {
      await this.client.quit();
    } catch (error2) {
      console.error(
        "[RedisSessionStore] Error closing Redis connection:",
        error2
      );
      throw error2;
    }
  }
  /**
   * Clear all sessions (useful for testing)
   * WARNING: This will delete all sessions with the configured prefix
   *
   * NOTE: Uses KEYS command which blocks Redis. This is acceptable for testing
   * but should be avoided in production with large datasets.
   */
  async clear() {
    try {
      const pattern = `${this.prefix}*`;
      const keys = await this.client.keys(pattern);
      if (keys.length > 0) {
        await this.client.del(keys);
      }
    } catch (error2) {
      console.error("[RedisSessionStore] Error clearing sessions:", error2);
      throw error2;
    }
  }
};

// src/server/sessions/stores/filesystem.ts
import { existsSync, readFileSync } from "fs";
import { mkdir, rename, unlink, writeFile } from "fs/promises";
import { dirname, join } from "path";
var FileSystemSessionStore = class {
  static {
    __name(this, "FileSystemSessionStore");
  }
  sessions = /* @__PURE__ */ new Map();
  filePath;
  debounceMs;
  maxAgeMs;
  saveTimer = null;
  saving = false;
  pendingSave = false;
  constructor(config = {}) {
    this.filePath = config.path ?? join(process.cwd(), ".mcp-use", "sessions.json");
    this.debounceMs = config.debounceMs ?? 100;
    this.maxAgeMs = config.maxAgeMs ?? 24 * 60 * 60 * 1e3;
    this.loadSessionsSync();
  }
  /**
   * Load sessions from file synchronously during construction
   * This ensures sessions are available immediately when the server starts
   */
  loadSessionsSync() {
    try {
      if (!existsSync(this.filePath)) {
        console.log(
          `[FileSystemSessionStore] No session file found at ${this.filePath}, starting fresh`
        );
        return;
      }
      const data = readFileSync(this.filePath, "utf-8");
      const parsed = JSON.parse(data);
      const now = Date.now();
      for (const [sessionId, metadata] of Object.entries(parsed)) {
        const sessionMetadata = metadata;
        const age = now - sessionMetadata.lastAccessedAt;
        if (age > this.maxAgeMs) {
          continue;
        }
        this.sessions.set(sessionId, sessionMetadata);
      }
    } catch (error2) {
      if (error2.code === "ENOENT") {
        console.log(`[FileSystemSessionStore] No existing sessions file`);
      } else if (error2 instanceof SyntaxError) {
        console.warn(
          `[FileSystemSessionStore] Corrupted session file, starting fresh:`,
          error2.message
        );
      } else {
        console.warn(
          `[FileSystemSessionStore] Error loading sessions, starting fresh:`,
          error2.message
        );
      }
    }
  }
  /**
   * Retrieve session metadata by ID
   */
  async get(sessionId) {
    const data = this.sessions.get(sessionId);
    return data ?? null;
  }
  /**
   * Store or update session metadata
   * Uses debouncing to batch rapid consecutive writes
   */
  async set(sessionId, data) {
    this.sessions.set(sessionId, data);
    await this.scheduleSave();
  }
  /**
   * Delete session metadata
   */
  async delete(sessionId) {
    this.sessions.delete(sessionId);
    await this.scheduleSave();
  }
  /**
   * Check if session exists
   */
  async has(sessionId) {
    return this.sessions.has(sessionId);
  }
  /**
   * List all session IDs
   */
  async keys() {
    return Array.from(this.sessions.keys());
  }
  /**
   * Store session metadata with TTL
   * Note: TTL is enforced on load, not with timers (simple implementation)
   */
  async setWithTTL(sessionId, data, ttlMs) {
    const metadataWithExpiry = {
      ...data,
      lastAccessedAt: Date.now()
    };
    this.sessions.set(sessionId, metadataWithExpiry);
    await this.scheduleSave();
    setTimeout(() => {
      this.sessions.delete(sessionId);
      this.scheduleSave();
    }, ttlMs);
  }
  /**
   * Get the number of active sessions
   */
  get size() {
    return this.sessions.size;
  }
  /**
   * Clear all sessions
   */
  async clear() {
    this.sessions.clear();
    await this.scheduleSave();
  }
  /**
   * Schedule a save operation with debouncing
   * Prevents excessive disk I/O from rapid consecutive writes
   */
  async scheduleSave() {
    if (this.saving) {
      this.pendingSave = true;
      return;
    }
    if (this.saveTimer) {
      clearTimeout(this.saveTimer);
    }
    this.saveTimer = setTimeout(() => {
      this.performSave();
    }, this.debounceMs);
  }
  /**
   * Perform the actual save operation with atomic writes
   * Uses write-to-temp-then-rename pattern to prevent corruption
   */
  async performSave() {
    this.saveTimer = null;
    this.saving = true;
    this.pendingSave = false;
    try {
      const dir = dirname(this.filePath);
      await mkdir(dir, { recursive: true });
      const data = {};
      for (const [sessionId, metadata] of Array.from(this.sessions.entries())) {
        data[sessionId] = metadata;
      }
      const tempPath = `${this.filePath}.tmp`;
      await writeFile(tempPath, JSON.stringify(data, null, 2), "utf-8");
      await rename(tempPath, this.filePath);
    } catch (error2) {
      console.error(
        `[FileSystemSessionStore] Error saving sessions:`,
        error2.message
      );
      try {
        const tempPath = `${this.filePath}.tmp`;
        if (existsSync(tempPath)) {
          await unlink(tempPath);
        }
      } catch {
      }
    } finally {
      this.saving = false;
      if (this.pendingSave) {
        await this.scheduleSave();
      }
    }
  }
  /**
   * Force an immediate save (bypasses debouncing)
   * Useful for ensuring persistence before process exit
   */
  async flush() {
    if (this.saveTimer) {
      clearTimeout(this.saveTimer);
      this.saveTimer = null;
    }
    await this.performSave();
  }
};

// src/server/sessions/streams/memory.ts
var InMemoryStreamManager = class {
  static {
    __name(this, "InMemoryStreamManager");
  }
  /**
   * Map of active SSE stream controllers
   * Key: sessionId, Value: ReadableStreamDefaultController
   */
  streams = /* @__PURE__ */ new Map();
  /**
   * Text encoder for converting strings to Uint8Array
   */
  textEncoder = new TextEncoder();
  /**
   * Register an active SSE stream controller
   */
  async create(sessionId, controller) {
    this.streams.set(sessionId, controller);
  }
  /**
   * Send data to active SSE streams
   *
   * Directly enqueues data to in-memory controllers.
   * For distributed deployments, use RedisStreamManager instead.
   */
  async send(sessionIds, data) {
    const encoded = this.textEncoder.encode(data);
    if (!sessionIds) {
      for (const [_id, controller] of this.streams.entries()) {
        try {
          controller.enqueue(encoded);
        } catch (error2) {
          console.warn(
            `[InMemoryStreamManager] Failed to send to session ${_id}:`,
            error2
          );
        }
      }
    } else {
      for (const sessionId of sessionIds) {
        const controller = this.streams.get(sessionId);
        if (controller) {
          try {
            controller.enqueue(encoded);
          } catch (error2) {
            console.warn(
              `[InMemoryStreamManager] Failed to send to session ${sessionId}:`,
              error2
            );
          }
        }
      }
    }
  }
  /**
   * Remove an active SSE stream
   */
  async delete(sessionId) {
    const controller = this.streams.get(sessionId);
    if (controller) {
      try {
        controller.close();
      } catch (error2) {
        console.debug(
          `[InMemoryStreamManager] Controller already closed for session ${sessionId}`
        );
      }
      this.streams.delete(sessionId);
    }
  }
  /**
   * Check if an active stream exists
   */
  async has(sessionId) {
    return this.streams.has(sessionId);
  }
  /**
   * Close all active streams
   */
  async close() {
    for (const [sessionId, controller] of this.streams.entries()) {
      try {
        controller.close();
      } catch (error2) {
        console.debug(
          `[InMemoryStreamManager] Error closing stream for ${sessionId}:`,
          error2
        );
      }
    }
    this.streams.clear();
  }
  /**
   * Get the number of active streams
   * Useful for monitoring
   */
  get size() {
    return this.streams.size;
  }
};

// src/server/sessions/streams/redis.ts
var RedisStreamManager = class {
  static {
    __name(this, "RedisStreamManager");
  }
  pubSubClient;
  client;
  prefix;
  heartbeatInterval;
  textEncoder = new TextEncoder();
  /**
   * Map of local controllers (only on this server instance)
   * Key: sessionId, Value: controller
   */
  localControllers = /* @__PURE__ */ new Map();
  /**
   * Map of heartbeat intervals for keeping sessions alive
   * Key: sessionId, Value: interval timer
   */
  heartbeats = /* @__PURE__ */ new Map();
  constructor(config) {
    this.pubSubClient = config.pubSubClient;
    this.client = config.client;
    this.prefix = config.prefix ?? "mcp:stream:";
    this.heartbeatInterval = config.heartbeatInterval ?? 10;
  }
  /**
   * Get the Redis channel name for a session
   */
  getChannel(sessionId) {
    return `${this.prefix}${sessionId}`;
  }
  /**
   * Get the Redis key for tracking active sessions
   */
  getAvailableKey(sessionId) {
    return `available:${this.prefix}${sessionId}`;
  }
  /**
   * Get the Redis key for the active sessions SET
   */
  getActiveSessionsKey() {
    return `${this.prefix}active`;
  }
  /**
   * Register an active SSE stream and subscribe to Redis channel
   */
  async create(sessionId, controller) {
    try {
      this.localControllers.set(sessionId, controller);
      const availableKey = this.getAvailableKey(sessionId);
      await this.client.set(availableKey, "active");
      if (this.client.expire) {
        await this.client.expire(availableKey, this.heartbeatInterval * 2);
      }
      const activeSessionsKey = this.getActiveSessionsKey();
      if (this.client.sAdd) {
        await this.client.sAdd(activeSessionsKey, sessionId);
        if (this.client.expire) {
          await this.client.expire(
            activeSessionsKey,
            this.heartbeatInterval * 2
          );
        }
      }
      const heartbeat = setInterval(async () => {
        try {
          if (this.client.expire) {
            await this.client.expire(availableKey, this.heartbeatInterval * 2);
            const activeSessionsKey2 = this.getActiveSessionsKey();
            await this.client.expire(
              activeSessionsKey2,
              this.heartbeatInterval * 2
            );
          }
        } catch (error2) {
          console.warn(
            `[RedisStreamManager] Heartbeat failed for session ${sessionId}:`,
            error2
          );
        }
      }, this.heartbeatInterval * 1e3);
      this.heartbeats.set(sessionId, heartbeat);
      const channel = this.getChannel(sessionId);
      if (!this.pubSubClient.subscribe) {
        throw new Error(
          "[RedisStreamManager] Redis client does not support subscribe method"
        );
      }
      await this.pubSubClient.subscribe(channel, (message) => {
        const localController = this.localControllers.get(sessionId);
        if (localController) {
          try {
            localController.enqueue(this.textEncoder.encode(message));
          } catch (error2) {
            console.warn(
              `[RedisStreamManager] Failed to enqueue message for ${sessionId}:`,
              error2
            );
          }
        }
      });
      const deleteChannel = `delete:${this.getChannel(sessionId)}`;
      await this.pubSubClient.subscribe(deleteChannel, async () => {
        await this.delete(sessionId);
      });
      console.log(
        `[RedisStreamManager] Created stream for session ${sessionId}`
      );
    } catch (error2) {
      console.error(
        `[RedisStreamManager] Error creating stream for ${sessionId}:`,
        error2
      );
      throw error2;
    }
  }
  /**
   * Send data to sessions via Redis Pub/Sub
   *
   * This works across distributed servers - any server with an active
   * SSE connection for the target session will receive and forward the message.
   *
   * Note: Uses the regular client (not pubSubClient) for publishing.
   * In node-redis v5+, clients in subscriber mode cannot publish.
   */
  async send(sessionIds, data) {
    try {
      if (!sessionIds) {
        const activeSessionsKey = this.getActiveSessionsKey();
        if (this.client.sMembers) {
          const sessionIds2 = await this.client.sMembers(activeSessionsKey);
          for (const sessionId of sessionIds2) {
            const channel = this.getChannel(sessionId);
            if (!this.client.publish) {
              throw new Error(
                "[RedisStreamManager] Redis client does not support publish method"
              );
            }
            await this.client.publish(channel, data);
          }
        } else {
          const pattern = `available:${this.prefix}*`;
          const keys = await this.client.keys(pattern);
          for (const key of keys) {
            const sessionId = key.replace(`available:${this.prefix}`, "");
            const channel = this.getChannel(sessionId);
            if (!this.client.publish) {
              throw new Error(
                "[RedisStreamManager] Redis client does not support publish method"
              );
            }
            await this.client.publish(channel, data);
          }
        }
      } else {
        for (const sessionId of sessionIds) {
          const channel = this.getChannel(sessionId);
          if (!this.client.publish) {
            throw new Error(
              "[RedisStreamManager] Redis client does not support publish method"
            );
          }
          await this.client.publish(channel, data);
        }
      }
    } catch (error2) {
      console.error(`[RedisStreamManager] Error sending to sessions:`, error2);
      throw error2;
    }
  }
  /**
   * Remove an active SSE stream
   */
  async delete(sessionId) {
    try {
      const heartbeat = this.heartbeats.get(sessionId);
      if (heartbeat) {
        clearInterval(heartbeat);
        this.heartbeats.delete(sessionId);
      }
      const channel = this.getChannel(sessionId);
      const deleteChannel = `delete:${channel}`;
      if (!this.pubSubClient.unsubscribe) {
        throw new Error(
          "[RedisStreamManager] Redis client does not support unsubscribe method"
        );
      }
      await this.pubSubClient.unsubscribe(channel);
      await this.pubSubClient.unsubscribe(deleteChannel);
      if (!this.client.publish) {
        throw new Error(
          "[RedisStreamManager] Redis client does not support publish method"
        );
      }
      await this.client.publish(deleteChannel, "");
      await this.client.del(this.getAvailableKey(sessionId));
      const activeSessionsKey = this.getActiveSessionsKey();
      if (this.client.sRem) {
        await this.client.sRem(activeSessionsKey, sessionId);
      }
      const controller = this.localControllers.get(sessionId);
      if (controller) {
        try {
          controller.close();
        } catch (error2) {
          console.debug(
            `[RedisStreamManager] Controller already closed for ${sessionId}`
          );
        }
        this.localControllers.delete(sessionId);
      }
      console.log(
        `[RedisStreamManager] Deleted stream for session ${sessionId}`
      );
    } catch (error2) {
      console.error(
        `[RedisStreamManager] Error deleting stream for ${sessionId}:`,
        error2
      );
      throw error2;
    }
  }
  /**
   * Check if a session has an active stream (on ANY server)
   */
  async has(sessionId) {
    try {
      const availableKey = this.getAvailableKey(sessionId);
      const exists = await this.client.exists(availableKey);
      return exists === 1;
    } catch (error2) {
      console.error(
        `[RedisStreamManager] Error checking session ${sessionId}:`,
        error2
      );
      return false;
    }
  }
  /**
   * Close all connections and cleanup
   */
  async close() {
    try {
      for (const heartbeat of this.heartbeats.values()) {
        clearInterval(heartbeat);
      }
      this.heartbeats.clear();
      const activeSessionsKey = this.getActiveSessionsKey();
      const sessionIdsToCleanup = Array.from(this.localControllers.keys());
      for (const sessionId of sessionIdsToCleanup) {
        await this.client.del(this.getAvailableKey(sessionId));
        if (this.client.sRem) {
          await this.client.sRem(activeSessionsKey, sessionId);
        }
      }
      for (const controller of this.localControllers.values()) {
        try {
          controller.close();
        } catch (error2) {
        }
      }
      this.localControllers.clear();
      console.log(`[RedisStreamManager] Closed all streams`);
    } catch (error2) {
      console.error(`[RedisStreamManager] Error during close:`, error2);
      throw error2;
    }
  }
  /**
   * Get count of active local streams on this server instance
   */
  get localSize() {
    return this.localControllers.size;
  }
};

// src/server/endpoints/mount-mcp.ts
async function mountMcp(app, mcpServerInstance, sessions, config, isProductionMode2) {
  const { WebStandardStreamableHTTPServerTransport } = await import("@modelcontextprotocol/sdk/server/webStandardStreamableHttp.js");
  const idleTimeoutMs = config.sessionIdleTimeoutMs ?? 864e5;
  const sessionStore = config.sessionStore ?? (isProductionMode2 ? new InMemorySessionStore() : new FileSystemSessionStore({
    path: join2(process.cwd(), ".mcp-use", "sessions.json")
  }));
  const streamManager = config.streamManager ?? new InMemoryStreamManager();
  const transports = /* @__PURE__ */ new Map();
  if (config.autoCreateSessionOnInvalidId !== void 0) {
    console.warn(
      "[MCP] WARNING: 'autoCreateSessionOnInvalidId' is deprecated and will be removed in a future version.\nThe MCP specification requires clients to send a new InitializeRequest when receiving a 404 for stale sessions.\nModern MCP clients handle this correctly. For session persistence across restarts, use the 'sessionStore' option.\nSee: https://modelcontextprotocol.io/specification/2025-11-25/basic/transports#session-management"
    );
  }
  let idleCleanupInterval;
  if (!config.stateless && idleTimeoutMs > 0) {
    idleCleanupInterval = startIdleCleanup(
      sessions,
      idleTimeoutMs,
      transports,
      mcpServerInstance
    );
  }
  const getFullUrl = /* @__PURE__ */ __name((c) => {
    const proto = c.req.header("X-Forwarded-Proto") || c.req.header("X-Forwarded-Protocol") || new URL(c.req.url).protocol.replace(":", "");
    const host = c.req.header("X-Forwarded-Host") || c.req.header("Host") || new URL(c.req.url).host;
    const path = c.req.path;
    return `${proto}://${host}${path}`;
  }, "getFullUrl");
  const handleRequest = /* @__PURE__ */ __name(async (c) => {
    if (c.req.method === "GET") {
      const acceptHeader2 = c.req.header("Accept") || "";
      const isBrowser = acceptHeader2.includes("text/html") || !acceptHeader2.includes("application/json") && !acceptHeader2.includes("text/event-stream");
      if (isBrowser) {
        const fullUrl = getFullUrl(c);
        const landingPage = generateLandingPage(
          config.name,
          config.version,
          fullUrl,
          config.description
        );
        return new Response(landingPage, {
          status: 200,
          headers: { "Content-Type": "text/html; charset=utf-8" }
        });
      }
    }
    const acceptHeader = c.req.header("Accept") || c.req.header("accept") || "";
    const clientSupportsSSE = acceptHeader.includes("text/event-stream");
    const useStatelessMode = config.stateless || !clientSupportsSSE;
    if (useStatelessMode) {
      if (c.req.method === "HEAD") {
        return new Response(null, { status: 200 });
      }
      const server = mcpServerInstance.getServerForSession();
      const transport = new WebStandardStreamableHTTPServerTransport({
        sessionIdGenerator: void 0,
        // No session tracking
        // IMPORTANT: Always use JSON responses in stateless mode
        // Edge runtimes (Deno, Cloudflare Workers, Supabase) cannot maintain long-lived SSE streams
        // Even if client supports SSE, we must use request-response JSON in stateless environments
        enableJsonResponse: true
      });
      try {
        await server.connect(transport);
        const request = c.req.raw;
        if (!clientSupportsSSE) {
          const modifiedRequest = new Request(request.url, {
            method: request.method,
            headers: {
              ...Object.fromEntries(request.headers.entries()),
              Accept: "application/json, text/event-stream"
            },
            body: request.body,
            ...request.body && { duplex: "half" }
          });
          return await transport.handleRequest(modifiedRequest);
        }
        return await transport.handleRequest(request);
      } catch (error2) {
        console.error("[MCP] Stateless request error:", error2);
        transport.close();
        server.close();
        throw error2;
      }
    } else {
      const sessionId = c.req.header("mcp-session-id");
      if (c.req.method === "HEAD") {
        if (sessionId && await sessionStore.has(sessionId)) {
          const session = await sessionStore.get(sessionId);
          if (session) {
            session.lastAccessedAt = Date.now();
            await sessionStore.set(sessionId, session);
          }
          const sessionData = sessions.get(sessionId);
          if (sessionData) {
            sessionData.lastAccessedAt = Date.now();
          }
        }
        return new Response(null, { status: 200 });
      }
      if (sessionId && await sessionStore.has(sessionId) && !transports.has(sessionId)) {
        console.log(
          `[MCP] Session metadata found but transport lost (likely hot reload): ${sessionId} - recreating transport`
        );
        const server2 = mcpServerInstance.getServerForSession(sessionId);
        const transport2 = new WebStandardStreamableHTTPServerTransport({
          sessionIdGenerator: /* @__PURE__ */ __name(() => sessionId, "sessionIdGenerator"),
          // Reuse existing session ID
          onsessioninitialized: /* @__PURE__ */ __name(async (sid) => {
            console.log(`[MCP] Session reconnected: ${sid}`);
            transports.set(sid, transport2);
            const metadata = await sessionStore.get(sid);
            const sessionData = {
              transport: transport2,
              server: server2,
              lastAccessedAt: Date.now(),
              context: c,
              honoContext: c,
              ...metadata || {}
            };
            sessions.set(sid, sessionData);
            server2.server.oninitialized = async () => {
              const clientCapabilities = server2.server.getClientCapabilities();
              const clientInfo = server2.server.getClientInfo?.() || {};
              const protocolVersion = server2.server.getProtocolVersion?.() || "unknown";
              const metadata2 = await sessionStore.get(sid);
              if (metadata2) {
                metadata2.clientCapabilities = clientCapabilities;
                metadata2.clientInfo = clientInfo;
                metadata2.protocolVersion = String(protocolVersion);
                await sessionStore.set(sid, metadata2);
              }
              const sessionData2 = sessions.get(sid);
              if (sessionData2) {
                sessionData2.clientCapabilities = clientCapabilities;
              }
              Telemetry.getInstance().trackServerInitialize({
                protocolVersion: String(protocolVersion),
                clientInfo: clientInfo || {},
                clientCapabilities: clientCapabilities || {},
                sessionId: sid
              }).catch(
                (e) => console.debug(`Failed to track server initialize: ${e}`)
              );
              if (!isProductionMode2) {
                console.log(
                  `[MCP] Development mode: Sending list_changed notifications to reconnected session ${sid}`
                );
                try {
                  const { sendNotificationToSession: sendNotificationToSession3 } = await import("../../notifications-NTU5YS6H.js");
                  await sendNotificationToSession3(
                    sessions,
                    sid,
                    "notifications/tools/list_changed"
                  );
                  await sendNotificationToSession3(
                    sessions,
                    sid,
                    "notifications/resources/list_changed"
                  );
                  await sendNotificationToSession3(
                    sessions,
                    sid,
                    "notifications/prompts/list_changed"
                  );
                } catch (err) {
                  console.debug(
                    `[MCP] Failed to send list_changed notification:`,
                    err
                  );
                }
              }
            };
          }, "onsessioninitialized"),
          onsessionclosed: /* @__PURE__ */ __name(async (sid) => {
            console.log(`[MCP] Session closed: ${sid}`);
            transports.delete(sid);
            await streamManager.delete(sid);
            await sessionStore.delete(sid);
            sessions.delete(sid);
            mcpServerInstance.cleanupSessionSubscriptions?.(sid);
            mcpServerInstance.cleanupSessionRefs?.(sid);
          }, "onsessionclosed")
        });
        await server2.connect(transport2);
        return transport2.handleRequest(c.req.raw);
      }
      if (sessionId && !await sessionStore.has(sessionId)) {
        console.log(
          `[MCP] Session not found: ${sessionId} - returning 404 (client should re-initialize)`
        );
        return c.json(
          {
            jsonrpc: "2.0",
            error: { code: -32001, message: "Session not found" },
            id: null
          },
          404
        );
      }
      if (sessionId && transports.has(sessionId)) {
        const transport2 = transports.get(sessionId);
        const metadata = await sessionStore.get(sessionId);
        if (metadata) {
          metadata.lastAccessedAt = Date.now();
          await sessionStore.set(sessionId, metadata);
        }
        const sessionData = sessions.get(sessionId);
        if (sessionData) {
          sessionData.lastAccessedAt = Date.now();
          sessionData.context = c;
          sessionData.honoContext = c;
        }
        return transport2.handleRequest(c.req.raw);
      }
      const newSessionId = generateUUID();
      const server = mcpServerInstance.getServerForSession(newSessionId);
      const transport = new WebStandardStreamableHTTPServerTransport({
        sessionIdGenerator: /* @__PURE__ */ __name(() => newSessionId, "sessionIdGenerator"),
        onsessioninitialized: /* @__PURE__ */ __name(async (sid) => {
          console.log(`[MCP] Session initialized: ${sid}`);
          transports.set(sid, transport);
          const sessionData = {
            transport,
            server,
            lastAccessedAt: Date.now(),
            context: c,
            honoContext: c
          };
          sessions.set(sid, sessionData);
          await sessionStore.set(sid, {
            lastAccessedAt: Date.now()
          });
          server.server.oninitialized = async () => {
            const clientCapabilities = server.server.getClientCapabilities();
            const clientInfo = server.server.getClientInfo?.() || {};
            const protocolVersion = server.server.getProtocolVersion?.() || "unknown";
            const metadata = await sessionStore.get(sid);
            if (metadata) {
              metadata.clientCapabilities = clientCapabilities;
              metadata.clientInfo = clientInfo;
              metadata.protocolVersion = String(protocolVersion);
              await sessionStore.set(sid, metadata);
              const debugEnv = process.env.DEBUG;
              const isDebug = debugEnv != null && debugEnv !== "" && debugEnv !== "0" && debugEnv.toLowerCase() !== "false";
              if (isDebug) {
                console.log(
                  `[MCP] Captured client capabilities for session ${sid}:`,
                  clientCapabilities ? Object.keys(clientCapabilities) : "none"
                );
              }
            }
            const sessionData2 = sessions.get(sid);
            if (sessionData2) {
              sessionData2.clientCapabilities = clientCapabilities;
            }
            Telemetry.getInstance().trackServerInitialize({
              protocolVersion: String(protocolVersion),
              clientInfo: clientInfo || {},
              clientCapabilities: clientCapabilities || {},
              sessionId: sid
            }).catch(
              (e) => console.debug(`Failed to track server initialize: ${e}`)
            );
          };
        }, "onsessioninitialized"),
        onsessionclosed: /* @__PURE__ */ __name(async (sid) => {
          console.log(`[MCP] Session closed: ${sid}`);
          transports.delete(sid);
          await streamManager.delete(sid);
          await sessionStore.delete(sid);
          sessions.delete(sid);
          mcpServerInstance.cleanupSessionSubscriptions?.(sid);
          mcpServerInstance.cleanupSessionRefs?.(sid);
        }, "onsessionclosed")
      });
      await server.connect(transport);
      return transport.handleRequest(c.req.raw);
    }
  }, "handleRequest");
  for (const endpoint of ["/mcp", "/sse"]) {
    app.on(["GET", "POST", "DELETE", "HEAD"], endpoint, handleRequest);
  }
  console.log(
    `[MCP] Server mounted at /mcp and /sse (${config.stateless ? "stateless" : "stateful"} mode)`
  );
  return { mcpMounted: true, idleCleanupInterval };
}
__name(mountMcp, "mountMcp");

// src/server/logging.ts
function isDebugMode() {
  const debugEnv = getEnv("DEBUG");
  return debugEnv !== void 0 && debugEnv !== "" && debugEnv !== "0" && debugEnv.toLowerCase() !== "false";
}
__name(isDebugMode, "isDebugMode");
function formatForLogging(obj) {
  function truncate(val) {
    if (typeof val === "string" && val.length > 100) {
      return val.slice(0, 100) + "...";
    } else if (Array.isArray(val)) {
      return val.map(truncate);
    } else if (val && typeof val === "object") {
      const result = {};
      for (const key in val) {
        if (Object.prototype.hasOwnProperty.call(val, key)) {
          result[key] = truncate(val[key]);
        }
      }
      return result;
    }
    return val;
  }
  __name(truncate, "truncate");
  try {
    return JSON.stringify(truncate(obj), null, 2);
  } catch {
    return String(obj);
  }
}
__name(formatForLogging, "formatForLogging");
async function requestLogger(c, next) {
  const timestamp = (/* @__PURE__ */ new Date()).toISOString().substring(11, 23);
  const method = c.req.method;
  const url = c.req.url;
  const debugMode = isDebugMode();
  const pathname = new URL(url).pathname;
  const noisyPaths = [
    "/inspector/api/tel/",
    // Telemetry endpoints (posthog, scarf)
    "/inspector/api/rpc/stream",
    // RPC stream (SSE)
    "/inspector/api/rpc/log",
    // RPC log endpoint
    "/inspector",
    // Inspector UI and static assets
    "/mcp-use/widgets/",
    // Dev widget Vite proxy and assets
    "/mcp-use/public/"
    // Public static files
  ];
  const isNoisyGet = method === "GET" && (pathname === "/mcp" || pathname.startsWith("/inspector/api/") || pathname.startsWith("/mcp-use/"));
  if (noisyPaths.some((noisyPath) => pathname.startsWith(noisyPath)) || isNoisyGet) {
    await next();
    return;
  }
  let requestBody = null;
  let requestHeaders = {};
  if (debugMode) {
    const allHeaders = c.req.header();
    if (allHeaders) {
      requestHeaders = allHeaders;
    }
  }
  if (method !== "GET" && method !== "HEAD") {
    try {
      const clonedRequest = c.req.raw.clone();
      requestBody = await clonedRequest.json().catch(() => {
        return clonedRequest.text().catch(() => null);
      });
    } catch {
    }
  }
  await next();
  const statusCode = c.res.status;
  let statusColor = "";
  if (statusCode >= 200 && statusCode < 300) {
    statusColor = "\x1B[32m";
  } else if (statusCode >= 300 && statusCode < 400) {
    statusColor = "\x1B[33m";
  } else if (statusCode >= 400 && statusCode < 500) {
    statusColor = "\x1B[31m";
  } else if (statusCode >= 500) {
    statusColor = "\x1B[35m";
  }
  let logMessage = `[${timestamp}] ${method} \x1B[1m${new URL(url).pathname}\x1B[0m`;
  if (method === "POST" && url.includes("/mcp") && requestBody?.method) {
    logMessage += ` \x1B[1m[${requestBody.method}]\x1B[0m`;
  }
  logMessage += ` ${statusColor}${statusCode}\x1B[0m`;
  console.log(logMessage);
  if (debugMode) {
    console.log("\n\x1B[36m" + "=".repeat(80) + "\x1B[0m");
    console.log("\x1B[1m\x1B[36m[DEBUG] Request Details\x1B[0m");
    console.log("\x1B[36m" + "-".repeat(80) + "\x1B[0m");
    if (Object.keys(requestHeaders).length > 0) {
      console.log("\x1B[33mRequest Headers:\x1B[0m");
      console.log(formatForLogging(requestHeaders));
    }
    if (requestBody !== null) {
      console.log("\x1B[33mRequest Body:\x1B[0m");
      if (typeof requestBody === "string") {
        console.log(requestBody);
      } else {
        console.log(formatForLogging(requestBody));
      }
    }
    const responseHeaders = {};
    c.res.headers.forEach((value, key) => {
      responseHeaders[key] = value;
    });
    if (Object.keys(responseHeaders).length > 0) {
      console.log("\x1B[33mResponse Headers:\x1B[0m");
      console.log(formatForLogging(responseHeaders));
    }
    try {
      if (c.res.body !== null && c.res.body !== void 0) {
        try {
          const clonedResponse = c.res.clone();
          const responseBody = await clonedResponse.text().catch(() => null);
          if (responseBody !== null && responseBody.length > 0) {
            console.log("\x1B[33mResponse Body:\x1B[0m");
            try {
              const jsonBody = JSON.parse(responseBody);
              console.log(formatForLogging(jsonBody));
            } catch {
              const maxLength = 1e4;
              if (responseBody.length > maxLength) {
                console.log(
                  responseBody.substring(0, maxLength) + `
... (truncated, ${responseBody.length - maxLength} more characters)`
                );
              } else {
                console.log(responseBody);
              }
            }
          } else {
            console.log("\x1B[33mResponse Body:\x1B[0m (empty)");
          }
        } catch (cloneError) {
          console.log("\x1B[33mResponse Body:\x1B[0m (unable to clone/read)");
        }
      } else {
        console.log("\x1B[33mResponse Body:\x1B[0m (no body)");
      }
    } catch (error2) {
      console.log("\x1B[33mResponse Body:\x1B[0m (unable to read)");
    }
    console.log("\x1B[36m" + "=".repeat(80) + "\x1B[0m\n");
  }
}
__name(requestLogger, "requestLogger");

// src/server/notifications/notification-registration.ts
function getActiveSessions() {
  return Array.from(this.sessions.keys());
}
__name(getActiveSessions, "getActiveSessions");
async function sendNotification(method, params) {
  await sendNotificationToAll(this.sessions, method, params);
}
__name(sendNotification, "sendNotification");
async function sendNotificationToSession2(sessionId, method, params) {
  return await sendNotificationToSession(
    this.sessions,
    sessionId,
    method,
    params
  );
}
__name(sendNotificationToSession2, "sendNotificationToSession");
async function sendToolsListChanged() {
  await sendNotificationToAll(
    this.sessions,
    "notifications/tools/list_changed"
  );
}
__name(sendToolsListChanged, "sendToolsListChanged");
async function sendResourcesListChanged() {
  await sendNotificationToAll(
    this.sessions,
    "notifications/resources/list_changed"
  );
}
__name(sendResourcesListChanged, "sendResourcesListChanged");
async function sendPromptsListChanged() {
  await sendNotificationToAll(
    this.sessions,
    "notifications/prompts/list_changed"
  );
}
__name(sendPromptsListChanged, "sendPromptsListChanged");

// src/server/oauth/routes.ts
import { cors as cors2 } from "hono/cors";
function setupOAuthRoutes(app, provider, baseUrl) {
  const mode = provider.getMode?.() || "proxy";
  app.use(
    "/.well-known/*",
    cors2({
      origin: "*",
      // Allow all origins for metadata discovery
      allowMethods: ["GET", "OPTIONS"],
      allowHeaders: ["Content-Type", "Authorization"],
      exposeHeaders: ["Content-Type"],
      maxAge: 86400
      // Cache preflight for 24 hours
    })
  );
  if (mode === "proxy") {
    app.use(
      "/authorize",
      cors2({
        origin: "*",
        allowMethods: ["GET", "POST", "OPTIONS"],
        allowHeaders: ["Content-Type", "Authorization"],
        maxAge: 86400
      })
    );
    app.use(
      "/token",
      cors2({
        origin: "*",
        allowMethods: ["POST", "OPTIONS"],
        allowHeaders: ["Content-Type", "Authorization"],
        maxAge: 86400
      })
    );
  }
  if (mode === "proxy") {
    const handleAuthorize = /* @__PURE__ */ __name(async (c) => {
      const params = c.req.method === "POST" ? await c.req.parseBody() : c.req.query();
      const clientId = params.client_id;
      const redirectUri = params.redirect_uri;
      const responseType = params.response_type;
      const codeChallenge = params.code_challenge;
      const codeChallengeMethod = params.code_challenge_method;
      const state = params.state;
      const scope = params.scope;
      const audience = params.audience;
      if (!clientId || !redirectUri || !responseType || !codeChallenge) {
        return c.json(
          {
            error: "invalid_request",
            error_description: "Missing required parameters"
          },
          400
        );
      }
      const authUrl = new URL(provider.getAuthEndpoint());
      authUrl.searchParams.set("client_id", clientId);
      authUrl.searchParams.set("redirect_uri", redirectUri);
      authUrl.searchParams.set("response_type", responseType);
      authUrl.searchParams.set("code_challenge", codeChallenge);
      authUrl.searchParams.set(
        "code_challenge_method",
        codeChallengeMethod || "S256"
      );
      if (state) authUrl.searchParams.set("state", state);
      if (scope) authUrl.searchParams.set("scope", scope);
      if (audience) authUrl.searchParams.set("audience", audience);
      return c.redirect(authUrl.toString(), 302);
    }, "handleAuthorize");
    app.get("/authorize", handleAuthorize);
    app.post("/authorize", handleAuthorize);
    app.post("/token", async (c) => {
      try {
        const body = await c.req.parseBody();
        const response = await fetch(provider.getTokenEndpoint(), {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: new URLSearchParams(body).toString()
        });
        const data = await response.json();
        if (!response.ok) {
          return c.json(data, response.status);
        }
        return c.json(data);
      } catch (error2) {
        return c.json(
          {
            error: "server_error",
            error_description: `Token exchange failed: ${error2}`
          },
          500
        );
      }
    });
  }
  const handleAuthorizationServerMetadata = /* @__PURE__ */ __name(async (c) => {
    const requestPath = new URL(c.req.url).pathname;
    console.log(`[OAuth] Metadata request: ${requestPath} (mode: ${mode})`);
    if (mode === "direct") {
      try {
        const metadataUrl = `${provider.getIssuer()}/.well-known/oauth-authorization-server`;
        console.log(`[OAuth] Fetching metadata from provider: ${metadataUrl}`);
        const response = await fetch(metadataUrl);
        if (!response.ok) {
          console.error(
            `[OAuth] Failed to fetch provider metadata: ${response.status}`
          );
          return c.json(
            {
              error: "server_error",
              error_description: `Failed to fetch provider metadata: ${response.status}`
            },
            500
          );
        }
        const metadata = await response.json();
        const hasRegisteredClient = provider.getRegistrationEndpoint && provider.config?.clientId;
        if (hasRegisteredClient) {
          console.log(
            `[OAuth] Provider has pre-registered client - removing DCR endpoint`
          );
          delete metadata.registration_endpoint;
        }
        console.log(`[OAuth] Provider metadata retrieved successfully`);
        console.log(`[OAuth]   - Issuer: ${metadata.issuer}`);
        console.log(
          `[OAuth]   - Registration endpoint: ${metadata.registration_endpoint || "not available (using pre-registered client)"}`
        );
        return c.json(metadata);
      } catch (error2) {
        console.error(`[OAuth] Error fetching provider metadata:`, error2);
        return c.json(
          {
            error: "server_error",
            error_description: `Failed to fetch provider metadata: ${error2}`
          },
          500
        );
      }
    } else {
      console.log(`[OAuth] Returning proxy mode metadata`);
      return c.json({
        issuer: provider.getIssuer(),
        authorization_endpoint: `${baseUrl}/authorize`,
        token_endpoint: `${baseUrl}/token`,
        response_types_supported: ["code"],
        grant_types_supported: provider.getGrantTypesSupported(),
        code_challenge_methods_supported: ["S256"],
        token_endpoint_auth_methods_supported: [
          "client_secret_post",
          "client_secret_basic",
          "none"
        ],
        scopes_supported: provider.getScopesSupported()
      });
    }
  }, "handleAuthorizationServerMetadata");
  app.get(
    "/.well-known/oauth-authorization-server",
    handleAuthorizationServerMetadata
  );
  app.get(
    "/.well-known/openid-configuration",
    handleAuthorizationServerMetadata
  );
  app.get("/.well-known/oauth-protected-resource", (c) => {
    console.log(`[OAuth] Protected resource metadata request (mode: ${mode})`);
    console.log(`[OAuth]   - Resource: ${baseUrl}`);
    console.log(`[OAuth]   - Authorization server: ${provider.getIssuer()}`);
    return c.json({
      resource: baseUrl,
      authorization_servers: [provider.getIssuer()],
      bearer_methods_supported: ["header"],
      resource_documentation: mode === "direct" ? "This resource uses direct OAuth flow. Clients communicate directly with the authorization server." : void 0
    });
  });
  app.get("/.well-known/oauth-protected-resource/mcp", (c) => {
    return c.json({
      resource: `${baseUrl}/mcp`,
      authorization_servers: [provider.getIssuer()],
      bearer_methods_supported: ["header"]
    });
  });
}
__name(setupOAuthRoutes, "setupOAuthRoutes");

// src/server/oauth/middleware.ts
function createBearerAuthMiddleware(provider, baseUrl) {
  return async (c, next) => {
    if (c.req.method === "HEAD") {
      return next();
    }
    const authHeader = c.req.header("Authorization");
    const getWWWAuthenticateHeader = /* @__PURE__ */ __name(() => {
      const base = baseUrl || new URL(c.req.url).origin;
      const parts = [
        'Bearer error="unauthorized"',
        'error_description="Authorization needed"'
      ];
      parts.push(
        `resource_metadata="${base}/.well-known/oauth-protected-resource"`
      );
      return parts.join(", ");
    }, "getWWWAuthenticateHeader");
    if (!authHeader) {
      c.header("WWW-Authenticate", getWWWAuthenticateHeader());
      return c.json({ error: "Missing Authorization header" }, 401);
    }
    const [type, token] = authHeader.split(" ");
    if (type.toLowerCase() !== "bearer" || !token) {
      c.header("WWW-Authenticate", getWWWAuthenticateHeader());
      return c.json(
        {
          error: 'Invalid Authorization header format, expected "Bearer TOKEN"'
        },
        401
      );
    }
    try {
      const result = await provider.verifyToken(token);
      const payload = result.payload;
      const user = provider.getUserInfo(payload);
      const scope = payload.scope;
      const authInfo = {
        user,
        payload,
        accessToken: token,
        // Extract scopes from scope claim (OAuth standard)
        scopes: scope ? scope.split(" ") : [],
        // Extract permissions (Auth0 style, or custom)
        permissions: payload.permissions || []
      };
      c.set("auth", authInfo);
      c.auth = authInfo;
      c.set("user", user);
      c.set("payload", payload);
      c.set("accessToken", token);
      await next();
    } catch (error2) {
      c.header("WWW-Authenticate", getWWWAuthenticateHeader());
      return c.json({ error: `Invalid token: ${error2}` }, 401);
    }
  };
}
__name(createBearerAuthMiddleware, "createBearerAuthMiddleware");

// src/server/oauth/setup.ts
async function setupOAuthForServer(app, oauthProvider, baseUrl, state) {
  if (state.complete) {
    return state;
  }
  console.log(`[OAuth] OAuth provider initialized`);
  const middleware = createBearerAuthMiddleware(oauthProvider, baseUrl);
  setupOAuthRoutes(app, oauthProvider, baseUrl);
  const mode = oauthProvider.getMode?.() || "proxy";
  if (mode === "direct") {
    console.log(
      "[OAuth] Direct mode: Clients will authenticate with provider directly"
    );
    console.log("[OAuth] Metadata endpoints: /.well-known/*");
  } else {
    console.log(
      "[OAuth] Proxy mode: Routes at /authorize, /token, /.well-known/*"
    );
  }
  app.use("/mcp/*", middleware);
  console.log("[OAuth] Bearer authentication enabled on /mcp routes");
  return {
    provider: oauthProvider,
    middleware,
    complete: true
  };
}
__name(setupOAuthForServer, "setupOAuthForServer");

// src/server/roots/roots-registration.ts
function onRootsChanged(callback) {
  this.onRootsChangedCallback = callback;
  return this;
}
__name(onRootsChanged, "onRootsChanged");
async function listRoots(sessionId) {
  const session = this.sessions.get(sessionId);
  if (!session) {
    return null;
  }
  try {
    const request = createRequest(generateUUID(), "roots/list", {});
    const response = await session.transport.send(request);
    if (response && typeof response === "object" && "roots" in response) {
      return response.roots;
    }
    return [];
  } catch (error2) {
    console.warn(
      `[MCP] Failed to list roots from session ${sessionId}:`,
      error2
    );
    return null;
  }
}
__name(listRoots, "listRoots");

// src/server/mcp-server.ts
function isSafePropertyKey(key) {
  return key !== "__proto__" && key !== "constructor" && key !== "prototype";
}
__name(isSafePropertyKey, "isSafePropertyKey");
function selectFaviconFromIcons(icons) {
  const icoIcon = icons.find((icon) => icon.src.endsWith(".ico"));
  if (icoIcon) return icoIcon.src;
  const smallPng = icons.find(
    (icon) => icon.src.endsWith(".png") && icon.sizes?.some((size) => size === "16x16" || size === "32x32")
  );
  if (smallPng) return smallPng.src;
  const pngIcon = icons.find((icon) => icon.src.endsWith(".png"));
  if (pngIcon) return pngIcon.src;
  return icons[0].src;
}
__name(selectFaviconFromIcons, "selectFaviconFromIcons");
var MCPServerClass = class {
  static {
    __name(this, "MCPServerClass");
  }
  /**
   * Gets the mcp-use package version.
   *
   * @returns The package version string (e.g., "1.13.2")
   *
   * @example
   * ```typescript
   * console.log(`Server version: ${MCPServer.getPackageVersion()}`);
   * ```
   */
  static getPackageVersion() {
    return getPackageVersion();
  }
  /**
   * Native MCP server instance from the official SDK.
   *
   * This is the underlying server from `@modelcontextprotocol/sdk` that handles
   * the MCP protocol. Exposed publicly for advanced use cases that need direct
   * access to SDK functionality.
   *
   * @example
   * ```typescript
   * // Access native SDK methods
   * server.nativeServer.server.setRequestHandler(...);
   * ```
   */
  nativeServer;
  /**
   * @deprecated Use {@link nativeServer} instead.
   * Kept for backward compatibility with older code.
   */
  get server() {
    return this.nativeServer;
  }
  /**
   * Server configuration including name, version, OAuth settings, etc.
   */
  config;
  /**
   * Hono application instance.
   *
   * The underlying Hono app that handles HTTP routing and middleware.
   * Can be used to add custom routes and middleware alongside MCP endpoints.
   *
   * @example
   * ```typescript
   * // Add custom HTTP endpoint
   * server.app.get('/health', (c) => c.json({ status: 'ok' }));
   * ```
   */
  app;
  /** @internal Whether MCP endpoints have been mounted */
  mcpMounted = false;
  /** @internal Whether inspector UI has been mounted */
  inspectorMounted = false;
  /** @internal Whether public routes have been set up and in what mode */
  publicRoutesMode = null;
  /**
   * @internal Mutable registry of custom HTTP route handlers for HMR support.
   * Key format: "METHOD:PATH" (e.g., "get:/api/fruits")
   * Handlers are stored here so they can be swapped during HMR without
   * re-registering routes on the immutable Hono router.
   */
  _customRoutes = /* @__PURE__ */ new Map();
  /**
   * Port number the server is listening on (set after calling {@link listen}).
   */
  serverPort;
  /**
   * Hostname the server is bound to (default: "localhost").
   */
  serverHost;
  /**
   * Full base URL for the server (e.g., "https://example.com").
   * Used for generating widget URLs and OAuth callbacks.
   */
  serverBaseUrl;
  /**
   * Optional favicon URL to display in inspector and documentation.
   */
  favicon;
  /**
   * List of registered tool names.
   */
  registeredTools = [];
  /**
   * List of registered prompt names.
   */
  registeredPrompts = [];
  /**
   * List of registered resource URIs.
   */
  registeredResources = [];
  /**
   * Optional build identifier for cache busting widget URLs.
   * @internal
   */
  buildId;
  /**
   * Map of active client sessions.
   * Each session represents a connected MCP client with its own server instance.
   */
  sessions = /* @__PURE__ */ new Map();
  idleCleanupInterval;
  oauthSetupState = {
    complete: false,
    provider: void 0,
    middleware: void 0
  };
  oauthProvider;
  oauthMiddleware;
  /**
   * Storage for registrations that can be replayed on new server instances
   * Following the official SDK pattern where each session gets its own server instance
   * @internal Exposed for telemetry purposes
   */
  registrations = {
    tools: /* @__PURE__ */ new Map(),
    prompts: /* @__PURE__ */ new Map(),
    resources: /* @__PURE__ */ new Map(),
    resourceTemplates: /* @__PURE__ */ new Map()
  };
  /**
   * Storage for widget definitions, used to inject metadata into tool responses
   * when using the widget() helper with returnsWidget option
   */
  widgetDefinitions = /* @__PURE__ */ new Map();
  /**
   * Storage for SDK-registered tool/prompt/resource references per session.
   * These refs have update() and remove() methods for hot reloading.
   * @internal Used for HMR in development mode
   */
  sessionRegisteredRefs = /* @__PURE__ */ new Map();
  /**
   * Resource subscription manager for tracking and notifying resource updates
   */
  subscriptionManager = new ResourceSubscriptionManager();
  /**
   * Clean up resource subscriptions for a closed session
   *
   * This method is called automatically when a session is closed to remove
   * all resource subscriptions associated with that session.
   *
   * @param sessionId - The session ID to clean up
   * @internal
   */
  cleanupSessionSubscriptions(sessionId) {
    this.subscriptionManager.cleanupSession(sessionId);
  }
  /**
   * Clean up registered refs for a closed session
   *
   * This method is called automatically when a session is closed to remove
   * all registered tool/prompt/resource refs associated with that session.
   *
   * @param sessionId - The session ID to clean up
   * @internal
   */
  cleanupSessionRefs(sessionId) {
    this.sessionRegisteredRefs.delete(sessionId);
  }
  /**
   * Add a new widget tool directly to all active sessions (for HMR)
   *
   * This method adds a widget tool to all active sessions' internal state
   * immediately, ensuring the tool is queryable before notifications are sent.
   * This prevents race conditions where clients fetch tools before registration completes.
   *
   * Also registers the associated widget resources (static and template) for Apps SDK widgets.
   *
   * @param toolDefinition - The tool definition
   * @param toolCallback - The tool callback function
   * @internal
   */
  addWidgetTool(toolDefinition, toolCallback) {
    if (!isSafePropertyKey(toolDefinition.name)) {
      console.warn(
        `[MCP-Server] Rejected potentially malicious tool name: ${toolDefinition.name}`
      );
      return;
    }
    console.log(
      `[MCP-Server] Adding widget tool directly to sessions: ${toolDefinition.name}`
    );
    this.tool(toolDefinition, toolCallback);
    const widgetName = toolDefinition.name;
    const resourceUri = generateWidgetUri(widgetName, this.buildId, ".html");
    const resourceTemplateUri = generateWidgetUri(
      widgetName,
      this.buildId,
      ".html",
      "{id}"
    );
    const resourceKey = `${widgetName}:${resourceUri}`;
    const resourceTemplateKey = `${widgetName}-dynamic`;
    const resourceReg = this.registrations.resources.get(resourceKey);
    const resourceTemplateReg = this.registrations.resourceTemplates.get(resourceTemplateKey);
    for (const [sessionId, session] of this.sessions) {
      if (!session.server) continue;
      const nativeServer = session.server;
      const registration = this.registrations.tools.get(toolDefinition.name);
      if (!registration) {
        console.warn(
          `[MCP-Server] Tool ${toolDefinition.name} not found in wrapper registrations!`
        );
        continue;
      }
      let inputSchema;
      if (registration.config.schema) {
        try {
          inputSchema = this.convertZodSchemaToParams(
            registration.config.schema
          );
        } catch (e) {
          console.warn(
            `[MCP-Server] Failed to convert schema for ${toolDefinition.name}`
          );
          inputSchema = {};
        }
      } else if (registration.config.inputs && registration.config.inputs.length > 0) {
        inputSchema = this.createParamsSchema(
          registration.config.inputs
        );
      } else {
        inputSchema = {};
      }
      const toolEntry = {
        title: registration.config.title,
        description: registration.config.description ?? "",
        inputSchema,
        outputSchema: void 0,
        annotations: registration.config.annotations,
        execution: { taskSupport: "forbidden" },
        _meta: registration.config._meta,
        handler: registration.handler,
        enabled: true,
        disable: /* @__PURE__ */ __name(function() {
          this.enabled = false;
        }, "disable"),
        enable: /* @__PURE__ */ __name(function() {
          this.enabled = true;
        }, "enable"),
        remove: /* @__PURE__ */ __name(() => {
          if (!isSafePropertyKey(toolDefinition.name)) {
            console.warn(
              `[MCP-Server] Rejected potentially malicious tool name in remove: ${toolDefinition.name}`
            );
            return;
          }
          delete nativeServer._registeredTools[toolDefinition.name];
        }, "remove"),
        update: /* @__PURE__ */ __name(function(updates) {
          Object.assign(this, updates);
        }, "update")
      };
      if (nativeServer._registeredTools) {
        nativeServer._registeredTools[toolDefinition.name] = toolEntry;
        console.log(
          `[MCP-Server] Added tool ${toolDefinition.name} to session ${sessionId}'s _registeredTools`
        );
      }
      const sessionRefs = this.sessionRegisteredRefs.get(sessionId);
      if (resourceReg && session.server) {
        if (sessionRefs?.resources?.has(resourceKey)) {
        } else {
          try {
            const registered = session.server.registerResource(
              resourceReg.config.name,
              resourceReg.config.uri,
              {
                title: resourceReg.config.title,
                description: resourceReg.config.description,
                mimeType: resourceReg.config.mimeType || "text/html+skybridge"
              },
              resourceReg.handler
            );
            if (sessionRefs?.resources) {
              sessionRefs.resources.set(resourceKey, registered);
            }
            console.log(
              `[MCP-Server] Added resource ${resourceUri} to session ${sessionId}`
            );
          } catch (e) {
            console.warn(
              `[MCP-Server] Failed to register resource ${resourceUri} for session ${sessionId}:`,
              e
            );
          }
        }
      }
      if (resourceTemplateReg && session.server) {
        if (sessionRefs?.resourceTemplates?.has(resourceTemplateKey)) {
        } else {
          try {
            const uriTemplate = resourceTemplateReg.config.resourceTemplate.uriTemplate;
            const resourceCallbacks = resourceTemplateReg.config.resourceTemplate.callbacks;
            const template = new ResourceTemplate2(uriTemplate, {
              list: void 0,
              complete: toResourceTemplateCompleteCallbacks(
                resourceCallbacks?.complete
              )
            });
            const registered = session.server.registerResource(
              resourceTemplateReg.config.name,
              template,
              {
                title: resourceTemplateReg.config.title,
                description: resourceTemplateReg.config.description,
                mimeType: resourceTemplateReg.config.resourceTemplate.mimeType || "text/html+skybridge"
              },
              resourceTemplateReg.handler
            );
            if (sessionRefs?.resourceTemplates) {
              sessionRefs.resourceTemplates.set(
                resourceTemplateKey,
                registered
              );
            }
            console.log(
              `[MCP-Server] Added resource template ${resourceTemplateUri} to session ${sessionId}`
            );
          } catch (e) {
            console.warn(
              `[MCP-Server] Failed to register resource template ${resourceTemplateUri} for session ${sessionId}:`,
              e
            );
          }
        }
      }
    }
    for (const [sessionId, session] of this.sessions) {
      if (session.server?.sendToolListChanged) {
        try {
          session.server.sendToolListChanged();
          console.log(
            `[MCP-Server] Sent tools notification to session ${sessionId}`
          );
        } catch (e) {
          console.debug(
            `[MCP-Server] Session ${sessionId}: Failed to send tools notification`
          );
        }
      }
      if ((resourceReg || resourceTemplateReg) && session.server?.sendResourceListChanged) {
        try {
          session.server.sendResourceListChanged();
          console.log(
            `[MCP-Server] Sent resources notification to session ${sessionId}`
          );
        } catch (e) {
          console.debug(
            `[MCP-Server] Session ${sessionId}: Failed to send resources notification`
          );
        }
      }
    }
  }
  /**
   * Propagate widget resources (static + template) to all existing sessions.
   *
   * Called from uiResourceRegistration after resource/resourceTemplate have been
   * added to wrapper-level registrations. This ensures existing sessions see
   * newly discovered widgets without requiring a reconnect, even when the widget
   * does not expose an auto-generated tool (exposeAsTool=false).
   *
   * @param widgetName - Name of the widget whose resources should be pushed
   * @internal
   */
  propagateWidgetResourcesToSessions(widgetName) {
    const resourceUri = generateWidgetUri(widgetName, this.buildId, ".html");
    const resourceKey = `${widgetName}:${resourceUri}`;
    const resourceReg = this.registrations.resources.get(resourceKey);
    const resourceTemplateUri = generateWidgetUri(
      widgetName,
      this.buildId,
      ".html",
      "{id}"
    );
    const resourceTemplateKey = `${widgetName}-dynamic`;
    const resourceTemplateReg = this.registrations.resourceTemplates.get(resourceTemplateKey);
    if (!resourceReg && !resourceTemplateReg) return;
    for (const [sessionId, session] of this.sessions) {
      if (!session.server) continue;
      const sessionRefs = this.sessionRegisteredRefs.get(sessionId);
      if (resourceReg) {
        try {
          const registered = session.server.registerResource(
            resourceReg.config.name,
            resourceReg.config.uri,
            {
              title: resourceReg.config.title,
              description: resourceReg.config.description,
              mimeType: resourceReg.config.mimeType || "text/html+skybridge"
            },
            resourceReg.handler
          );
          if (sessionRefs?.resources) {
            sessionRefs.resources.set(resourceKey, registered);
          }
          console.log(
            `[MCP-Server] Propagated resource ${resourceUri} to session ${sessionId}`
          );
        } catch (_e) {
        }
      }
      if (resourceTemplateReg) {
        try {
          const uriTemplate = resourceTemplateReg.config.resourceTemplate.uriTemplate;
          const resourceCallbacks = resourceTemplateReg.config.resourceTemplate.callbacks;
          const template = new ResourceTemplate2(uriTemplate, {
            list: void 0,
            complete: toResourceTemplateCompleteCallbacks(
              resourceCallbacks?.complete
            )
          });
          const registered = session.server.registerResource(
            resourceTemplateReg.config.name,
            template,
            {
              title: resourceTemplateReg.config.title,
              description: resourceTemplateReg.config.description,
              mimeType: resourceTemplateReg.config.resourceTemplate.mimeType || "text/html+skybridge"
            },
            resourceTemplateReg.handler
          );
          if (sessionRefs?.resourceTemplates) {
            sessionRefs.resourceTemplates.set(
              resourceTemplateKey,
              registered
            );
          }
          console.log(
            `[MCP-Server] Propagated resource template ${resourceTemplateUri} to session ${sessionId}`
          );
        } catch (_e) {
        }
      }
      if (session.server?.sendResourceListChanged) {
        try {
          session.server.sendResourceListChanged();
        } catch (_e) {
        }
      }
    }
  }
  /**
   * Update a widget tool's configuration in place (for HMR)
   *
   * This method updates a widget tool's metadata (description, schema) without
   * re-registering it. It updates both the wrapper's registrations and the SDK's
   * internal state, then sends notifications to all connected clients.
   *
   * @param toolName - The name of the tool to update
   * @param updates - The updated tool configuration
   * @internal
   */
  updateWidgetToolInPlace(toolName, updates) {
    if (!isSafePropertyKey(toolName)) {
      console.warn(
        `[MCP-Server] Rejected potentially malicious tool name: ${toolName}`
      );
      return false;
    }
    let inputSchema;
    if ("schema" in updates) {
      try {
        inputSchema = this.convertZodSchemaToParams(updates.schema);
      } catch (e) {
        console.warn(
          `[WIDGET-HMR] Failed to convert schema for ${toolName}:`,
          e instanceof Error ? e.message : String(e)
        );
      }
    }
    const registration = this.registrations.tools.get(toolName);
    if (!registration) {
      return false;
    }
    if (updates.description !== void 0) {
      registration.config.description = updates.description;
    }
    if (updates._meta !== void 0) {
      const existingMeta = registration.config._meta || {};
      const incomingMeta = updates._meta;
      const mergedUi = existingMeta.ui || incomingMeta.ui ? {
        ...existingMeta.ui,
        ...incomingMeta.ui
      } : void 0;
      registration.config._meta = {
        ...existingMeta,
        ...incomingMeta,
        ...mergedUi !== void 0 ? { ui: mergedUi } : {}
      };
    }
    if ("schema" in updates) {
      registration.config.schema = updates.schema;
    }
    for (const [, session] of this.sessions) {
      if (!session.server) continue;
      const nativeServer = session.server;
      const toolEntry = nativeServer._registeredTools?.[toolName];
      if (toolEntry) {
        if (updates.description !== void 0) {
          toolEntry.description = updates.description;
        }
        if (updates._meta !== void 0) {
          const existingEntryMeta = toolEntry._meta || {};
          const incomingEntryMeta = updates._meta;
          const mergedEntryUi = existingEntryMeta.ui || incomingEntryMeta.ui ? {
            ...existingEntryMeta.ui,
            ...incomingEntryMeta.ui
          } : void 0;
          toolEntry._meta = {
            ...existingEntryMeta,
            ...incomingEntryMeta,
            ...mergedEntryUi !== void 0 ? { ui: mergedEntryUi } : {}
          };
        }
        if ("schema" in updates) {
          if (inputSchema !== void 0) {
            toolEntry.inputSchema = inputSchema;
          } else {
            delete toolEntry.inputSchema;
          }
        }
      }
    }
    for (const [sessionId, session] of this.sessions) {
      if (session.server?.sendToolListChanged) {
        try {
          session.server.sendToolListChanged();
        } catch (e) {
          console.debug(
            `[WIDGET-HMR] Session ${sessionId}: Failed to send tools/list_changed:`,
            e instanceof Error ? e.message : String(e)
          );
        }
      }
    }
    return true;
  }
  /**
   * Remove a widget tool and its associated resources (for HMR)
   *
   * This method removes a widget's tool and resource registrations when
   * the widget is deleted or renamed. It updates both the wrapper's
   * registrations and the SDK's internal state, then sends notifications.
   *
   * @param toolName - The name of the tool/widget to remove
   * @internal
   */
  removeWidgetTool(toolName) {
    if (!isSafePropertyKey(toolName)) {
      console.warn(
        `[MCP-Server] Rejected potentially malicious tool name: ${toolName}`
      );
      return;
    }
    this.widgetDefinitions.delete(toolName);
    const resourceUri = generateWidgetUri(toolName, this.buildId, ".html");
    const resourceTemplateUri = generateWidgetUri(
      toolName,
      this.buildId,
      ".html",
      "{id}"
    );
    const resourceKey = `${toolName}:${resourceUri}`;
    const resourceTemplateKey = `${toolName}-dynamic`;
    this.registrations.tools.delete(toolName);
    this.registrations.resources.delete(resourceKey);
    this.registrations.resourceTemplates.delete(resourceTemplateKey);
    const rootNativeServer = this.nativeServer;
    if (rootNativeServer._registeredTools?.[toolName]) {
      delete rootNativeServer._registeredTools[toolName];
    }
    if (rootNativeServer._registeredResources?.[resourceUri]) {
      delete rootNativeServer._registeredResources[resourceUri];
    }
    if (rootNativeServer._registeredResources?.[resourceTemplateUri]) {
      delete rootNativeServer._registeredResources[resourceTemplateUri];
    }
    if (rootNativeServer._registeredResourceTemplates?.[resourceTemplateKey]) {
      delete rootNativeServer._registeredResourceTemplates[resourceTemplateKey];
    }
    if (rootNativeServer._registeredResourceTemplateNames && typeof rootNativeServer._registeredResourceTemplateNames.delete === "function") {
      rootNativeServer._registeredResourceTemplateNames.delete(
        resourceTemplateKey
      );
    }
    for (const [, session] of this.sessions) {
      if (!session.server) continue;
      const nativeServer = session.server;
      if (nativeServer._registeredTools?.[toolName]) {
        delete nativeServer._registeredTools[toolName];
      }
      if (nativeServer._registeredResources?.[resourceUri]) {
        delete nativeServer._registeredResources[resourceUri];
      }
      if (nativeServer._registeredResources?.[resourceTemplateUri]) {
        delete nativeServer._registeredResources[resourceTemplateUri];
      }
      if (nativeServer._registeredResourceTemplates?.[resourceTemplateKey]) {
        delete nativeServer._registeredResourceTemplates[resourceTemplateKey];
      }
      if (nativeServer._registeredResourceTemplateNames && typeof nativeServer._registeredResourceTemplateNames.delete === "function") {
        nativeServer._registeredResourceTemplateNames.delete(
          resourceTemplateKey
        );
      }
    }
    for (const [, refs] of this.sessionRegisteredRefs) {
      refs.tools.delete(toolName);
      refs.resources.delete(resourceKey);
      refs.resourceTemplates.delete(resourceTemplateKey);
    }
    for (const [sessionId, session] of this.sessions) {
      if (session.server?.sendToolListChanged) {
        try {
          session.server.sendToolListChanged();
        } catch (e) {
          console.debug(
            `[WIDGET-HMR] Session ${sessionId}: Failed to send tools/list_changed:`,
            e instanceof Error ? e.message : String(e)
          );
        }
      }
      if (session.server?.sendResourceListChanged) {
        try {
          session.server.sendResourceListChanged();
        } catch (e) {
          console.debug(
            `[WIDGET-HMR] Session ${sessionId}: Failed to send resources/list_changed:`,
            e instanceof Error ? e.message : String(e)
          );
        }
      }
    }
  }
  /**
   * Sync registrations from another MCPServer instance (for hot reload)
   *
   * This method compares the current registrations with another server instance's
   * registrations and updates existing sessions accordingly:
   * - Removes tools/prompts/resources that no longer exist
   * - Adds new tools/prompts/resources
   * - Updates changed tools/prompts/resources
   *
   * After syncing, sends list_changed notifications to all connected clients.
   *
   * @param other - Another MCPServer instance with updated registrations
   *
   * @example
   * ```typescript
   * // In CLI dev mode, after re-importing the server module
   * const newServer = await import('./server.ts?t=' + Date.now());
   * runningServer.syncRegistrationsFrom(newServer.server);
   * ```
   */
  syncRegistrationsFrom(other) {
    const sessionContexts = Array.from(this.sessions.entries()).map(
      ([sessionId, session]) => ({
        sessionId,
        session,
        refs: this.sessionRegisteredRefs.get(sessionId)
      })
    );
    const wrapHandler = /* @__PURE__ */ __name((rawHandler, session) => {
      const sessions = this.sessions;
      const createMessageFn = this.createMessage.bind(this);
      const actualCallback = rawHandler;
      return async (params, extra) => {
        const initialRequestContext = getRequestContext();
        const extraProgressToken = extra?._meta?.progressToken;
        const extraSendNotification = extra?.sendNotification;
        const {
          requestContext,
          session: foundSession,
          progressToken,
          sendNotification: sendNotification2
        } = findSessionContext(
          sessions,
          initialRequestContext,
          extraProgressToken,
          extraSendNotification
        );
        const nativeServer = session.server;
        const enhancedContext = createEnhancedContext(
          requestContext,
          createMessageFn,
          nativeServer?.server?.elicitInput?.bind(nativeServer.server) ?? (async () => ({ action: "decline" })),
          progressToken,
          sendNotification2,
          foundSession?.logLevel,
          foundSession?.clientCapabilities
        );
        const executeCallback = /* @__PURE__ */ __name(async () => {
          if (actualCallback.length >= 2) {
            return await actualCallback(params, enhancedContext);
          }
          return await actualCallback(params);
        }, "executeCallback");
        if (requestContext) {
          return await runWithContext(requestContext, executeCallback);
        }
        return await executeCallback();
      };
    }, "wrapHandler");
    const createToolEntry = /* @__PURE__ */ __name((name, config, handler, nativeServer, session) => {
      let inputSchema;
      if (config.schema) {
        inputSchema = config.schema;
      } else if (config.inputs && config.inputs.length > 0) {
        inputSchema = this.createParamsSchema(config.inputs);
      } else {
        inputSchema = z3.object({});
      }
      const wrappedHandler = session?.server ? wrapHandler(handler, session) : handler;
      return {
        title: config.title,
        description: config.description ?? "",
        inputSchema,
        outputSchema: void 0,
        annotations: config.annotations,
        execution: { taskSupport: "forbidden" },
        _meta: config._meta,
        handler: wrappedHandler,
        enabled: true,
        disable: /* @__PURE__ */ __name(function() {
          this.enabled = false;
        }, "disable"),
        enable: /* @__PURE__ */ __name(function() {
          this.enabled = true;
        }, "enable"),
        remove: /* @__PURE__ */ __name(() => {
          if (!isSafePropertyKey(name)) {
            console.warn(
              `[MCP-Server] Rejected potentially malicious tool name in remove: ${name}`
            );
            return;
          }
          delete nativeServer._registeredTools[name];
        }, "remove"),
        update: /* @__PURE__ */ __name(function(updates) {
          Object.assign(this, updates);
        }, "update")
      };
    }, "createToolEntry");
    const toolsResult = syncPrimitive({
      primitiveName: "Tools",
      currentRegistrations: this.registrations.tools,
      newRegistrations: other.registrations.tools,
      // Don't remove widget-registered tools during index.ts HMR sync.
      // Widget tools are managed by the Vite file watcher, not by index.ts.
      shouldRemove: /* @__PURE__ */ __name((_key, reg) => {
        const meta = reg.config?._meta;
        const hasWidgetConfig = !!reg.config?.widget;
        const hasUiResourceUri = !!meta?.ui?.resourceUri;
        return !hasWidgetConfig && !hasUiResourceUri;
      }, "shouldRemove"),
      sessions: sessionContexts.map(({ sessionId, session, refs }) => ({
        sessionId,
        getRefs: /* @__PURE__ */ __name(() => refs?.tools, "getRefs"),
        register: /* @__PURE__ */ __name((name, config, handler) => {
          if (!session.server) return null;
          if (!isSafePropertyKey(name)) {
            console.warn(
              `[MCP-Server] Rejected potentially malicious tool name: ${name}`
            );
            return null;
          }
          const nativeServer = session.server;
          const toolEntry = createToolEntry(
            name,
            config,
            handler,
            nativeServer
          );
          nativeServer._registeredTools[name] = toolEntry;
          if (typeof nativeServer.setToolRequestHandlers === "function") {
            nativeServer.setToolRequestHandlers();
          }
          return toolEntry;
        }, "register")
      })),
      supportsInPlaceUpdate: true,
      // Order-preserving rename for tools
      onRename: /* @__PURE__ */ __name((sessionCtx, oldKey, newKey, config, handler) => {
        const { session, refs } = sessionContexts.find(
          (s) => s.sessionId === sessionCtx.sessionId
        );
        if (!session.server) return;
        if (!isSafePropertyKey(oldKey) || !isSafePropertyKey(newKey)) {
          console.warn(
            `[MCP-Server] Rejected potentially malicious tool name in rename: ${oldKey} -> ${newKey}`
          );
          return;
        }
        const nativeServer = session.server;
        const oldTools = nativeServer._registeredTools;
        const newTools = {};
        for (const key of Object.keys(oldTools)) {
          if (key === oldKey) {
            newTools[newKey] = createToolEntry(
              newKey,
              config,
              handler,
              nativeServer
            );
          } else {
            newTools[key] = oldTools[key];
          }
        }
        nativeServer._registeredTools = newTools;
        if (refs?.tools) {
          const newRefs = /* @__PURE__ */ new Map();
          for (const [k, v] of refs.tools) {
            if (k === oldKey) {
              newRefs.set(newKey, newTools[newKey]);
            } else {
              newRefs.set(k, v);
            }
          }
          refs.tools.clear();
          for (const [k, v] of newRefs) refs.tools.set(k, v);
        }
      }, "onRename"),
      // Order-preserving update for tools (schema/description changes)
      onUpdate: /* @__PURE__ */ __name((sessionCtx, key, config, handler) => {
        const { session, refs } = sessionContexts.find(
          (s) => s.sessionId === sessionCtx.sessionId
        );
        if (!session.server) return;
        if (!isSafePropertyKey(key)) {
          console.warn(
            `[MCP-Server] Rejected potentially malicious tool name: ${key}`
          );
          return;
        }
        const nativeServer = session.server;
        if (nativeServer._registeredTools?.[key]) {
          let enrichedConfig = config;
          const isWidgetTool = !!config?.widget;
          const oldEntry = nativeServer._registeredTools?.[key];
          if (isWidgetTool && oldEntry?._meta) {
            const oldMeta = oldEntry._meta || {};
            const newMeta = enrichedConfig._meta || {};
            const mergedMeta = {
              ...oldMeta,
              // Keep all dual-protocol metadata
              ...newMeta,
              // Update with new basic metadata
              // Deep merge the ui object specifically to preserve both old and new fields
              ui: {
                ...oldMeta.ui || {},
                ...newMeta.ui || {}
              }
            };
            config._meta = mergedMeta;
            enrichedConfig = config;
          }
          const newEntry = createToolEntry(
            key,
            enrichedConfig,
            handler,
            nativeServer,
            session
          );
          nativeServer._registeredTools[key] = newEntry;
          if (refs?.tools) {
            refs.tools.set(key, newEntry);
          }
        }
      }, "onUpdate")
    });
    this.registrations.tools = toolsResult.updatedRegistrations;
    const registerPromptOnSession = /* @__PURE__ */ __name((server, name, config, handler) => {
      let argsSchema;
      if (config.schema) {
        argsSchema = this.convertZodSchemaToParams(config.schema);
      } else if (config.args && config.args.length > 0) {
        argsSchema = this.createParamsSchema(config.args);
      }
      const wrappedHandler = /* @__PURE__ */ __name(async (...args) => {
        const result = await handler(...args);
        if ("messages" in result && Array.isArray(result.messages)) {
          return result;
        }
        const { convertToolResultToPromptResult: convertToolResultToPromptResult2 } = await import("../../conversion-DN5J4QL5.js");
        return convertToolResultToPromptResult2(result);
      }, "wrappedHandler");
      return server.registerPrompt(
        name,
        {
          title: config.title,
          description: config.description ?? "",
          argsSchema
        },
        wrappedHandler
      );
    }, "registerPromptOnSession");
    const promptsResult = syncPrimitive({
      primitiveName: "Prompts",
      currentRegistrations: this.registrations.prompts,
      newRegistrations: other.registrations.prompts,
      sessions: sessionContexts.map(({ sessionId, session, refs }) => ({
        sessionId,
        getRefs: /* @__PURE__ */ __name(() => refs?.prompts, "getRefs"),
        register: /* @__PURE__ */ __name((name, config, handler) => {
          if (!session.server) return null;
          if (!isSafePropertyKey(name)) {
            console.warn(
              `[MCP-Server] Rejected potentially malicious prompt name: ${name}`
            );
            return null;
          }
          return registerPromptOnSession(
            session.server,
            name,
            config,
            handler
          );
        }, "register")
      })),
      supportsInPlaceUpdate: true,
      // Order-preserving rename for prompts
      onRename: /* @__PURE__ */ __name((sessionCtx, oldKey, newKey, config, handler) => {
        const { session, refs } = sessionContexts.find(
          (s) => s.sessionId === sessionCtx.sessionId
        );
        if (!session.server) return;
        if (!isSafePropertyKey(oldKey) || !isSafePropertyKey(newKey)) {
          console.warn(
            `[MCP-Server] Rejected potentially malicious prompt name in rename: ${oldKey} -> ${newKey}`
          );
          return;
        }
        const nativeServer = session.server;
        const oldPrompts = nativeServer._registeredPrompts || {};
        const newPrompts = {};
        for (const key of Object.keys(oldPrompts)) {
          if (key === oldKey) {
            const registered = registerPromptOnSession(
              session.server,
              newKey,
              config,
              handler
            );
            delete nativeServer._registeredPrompts[newKey];
            newPrompts[newKey] = registered;
          } else {
            newPrompts[key] = oldPrompts[key];
          }
        }
        nativeServer._registeredPrompts = newPrompts;
        if (refs?.prompts) {
          const newRefs = /* @__PURE__ */ new Map();
          for (const [k, v] of refs.prompts) {
            if (k === oldKey) {
              newRefs.set(newKey, newPrompts[newKey]);
            } else {
              newRefs.set(k, v);
            }
          }
          refs.prompts.clear();
          for (const [k, v] of newRefs) refs.prompts.set(k, v);
        }
      }, "onRename"),
      // Order-preserving update for prompts - use SDK's update method
      onUpdate: /* @__PURE__ */ __name((sessionCtx, key, config, handler) => {
        if (!isSafePropertyKey(key)) {
          console.warn(
            `[MCP-Server] Rejected potentially malicious prompt name: ${key}`
          );
          return;
        }
        const { refs } = sessionContexts.find(
          (s) => s.sessionId === sessionCtx.sessionId
        );
        const promptRef = refs?.prompts.get(key);
        if (promptRef) {
          const newReg = config;
          let argsSchema;
          if (newReg.schema) {
            argsSchema = this.convertZodSchemaToParams(newReg.schema);
          } else if (newReg.args && newReg.args.length > 0) {
            argsSchema = this.createParamsSchema(newReg.args);
          }
          const wrappedHandler = /* @__PURE__ */ __name(async (params, extra) => {
            const result = await handler(params, extra);
            if ("messages" in result && Array.isArray(result.messages)) {
              return result;
            }
            const { convertToolResultToPromptResult: convertToolResultToPromptResult2 } = await import("../../conversion-DN5J4QL5.js");
            return convertToolResultToPromptResult2(result);
          }, "wrappedHandler");
          promptRef.update({
            title: newReg.title,
            description: newReg.description,
            argsSchema,
            callback: wrappedHandler
          });
        }
      }, "onUpdate")
    });
    this.registrations.prompts = promptsResult.updatedRegistrations;
    const registerResourceOnSession = /* @__PURE__ */ __name((server, name, config, handler) => {
      const wrappedHandler = /* @__PURE__ */ __name(async (extra) => {
        const result = await handler(extra);
        if ("contents" in result && Array.isArray(result.contents)) {
          return result;
        }
        const { convertToolResultToResourceResult: convertToolResultToResourceResult2 } = await import("../../conversion-5MA4VY3B.js");
        return convertToolResultToResourceResult2(config.uri, result);
      }, "wrappedHandler");
      return server.registerResource(
        config.name || name,
        config.uri,
        {
          title: config.title,
          description: config.description,
          mimeType: config.mimeType || "text/plain"
        },
        wrappedHandler
      );
    }, "registerResourceOnSession");
    for (const [key, registration] of this.registrations.resources) {
      const uri = registration.config.uri;
      if (uri && uri.startsWith("ui://widget/")) {
        other.registrations.resources.set(key, registration);
      }
    }
    for (const [key, registration] of this.registrations.resourceTemplates) {
      const uriTemplate = registration.config.resourceTemplate?.uriTemplate;
      if (uriTemplate && uriTemplate.startsWith("ui://widget/")) {
        other.registrations.resourceTemplates.set(key, registration);
      }
    }
    const resourcesResult = syncPrimitive({
      primitiveName: "Resources",
      currentRegistrations: this.registrations.resources,
      newRegistrations: other.registrations.resources,
      sessions: sessionContexts.map(({ sessionId, session, refs }) => ({
        sessionId,
        getRefs: /* @__PURE__ */ __name(() => refs?.resources, "getRefs"),
        register: /* @__PURE__ */ __name((name, config, handler) => {
          if (!session.server) return null;
          if (!isSafePropertyKey(name)) {
            console.warn(
              `[MCP-Server] Rejected potentially malicious resource name: ${name}`
            );
            return null;
          }
          return registerResourceOnSession(
            session.server,
            name,
            config,
            handler
          );
        }, "register")
      })),
      supportsInPlaceUpdate: true,
      // Order-preserving rename for resources
      onRename: /* @__PURE__ */ __name((sessionCtx, oldKey, newKey, config, handler) => {
        const { session, refs } = sessionContexts.find(
          (s) => s.sessionId === sessionCtx.sessionId
        );
        if (!session.server) return;
        if (!isSafePropertyKey(oldKey) || !isSafePropertyKey(newKey)) {
          console.warn(
            `[MCP-Server] Rejected potentially malicious resource name in rename: ${oldKey} -> ${newKey}`
          );
          return;
        }
        const nativeServer = session.server;
        const oldResources = nativeServer._registeredResources || {};
        const newResources = {};
        for (const key of Object.keys(oldResources)) {
          if (key === oldKey) {
            const registered = registerResourceOnSession(
              session.server,
              newKey,
              config,
              handler
            );
            delete nativeServer._registeredResources[newKey];
            newResources[newKey] = registered;
          } else {
            newResources[key] = oldResources[key];
          }
        }
        nativeServer._registeredResources = newResources;
        if (refs?.resources) {
          const newRefs = /* @__PURE__ */ new Map();
          for (const [k, v] of refs.resources) {
            if (k === oldKey) {
              newRefs.set(newKey, newResources[newKey]);
            } else {
              newRefs.set(k, v);
            }
          }
          refs.resources.clear();
          for (const [k, v] of newRefs) refs.resources.set(k, v);
        }
      }, "onRename"),
      // Order-preserving update for resources - use SDK's update method
      onUpdate: /* @__PURE__ */ __name((sessionCtx, key, config, handler) => {
        if (!isSafePropertyKey(key)) {
          console.warn(
            `[MCP-Server] Rejected potentially malicious resource name: ${key}`
          );
          return;
        }
        const { refs } = sessionContexts.find(
          (s) => s.sessionId === sessionCtx.sessionId
        );
        const resourceRef = refs?.resources.get(key);
        if (resourceRef) {
          const newReg = config;
          const wrappedHandler = /* @__PURE__ */ __name(async (extra) => {
            const result = await handler(extra);
            if ("contents" in result && Array.isArray(result.contents)) {
              return result;
            }
            const { convertToolResultToResourceResult: convertToolResultToResourceResult2 } = await import("../../conversion-5MA4VY3B.js");
            return convertToolResultToResourceResult2(newReg.uri, result);
          }, "wrappedHandler");
          resourceRef.update({
            metadata: {
              title: newReg.title,
              description: newReg.description,
              mimeType: newReg.mimeType || "text/plain"
            },
            callback: wrappedHandler
          });
        }
      }, "onUpdate")
    });
    this.registrations.resources = resourcesResult.updatedRegistrations;
    const registerTemplateOnSession = /* @__PURE__ */ __name((server, name, config, handler) => {
      const isFlatStructure = "uriTemplate" in config;
      const uriTemplate = isFlatStructure ? config.uriTemplate : config.resourceTemplate.uriTemplate;
      const mimeType = isFlatStructure ? config.mimeType : config.resourceTemplate.mimeType;
      const templateDescription = isFlatStructure ? void 0 : config.resourceTemplate.description;
      const resourceCallbacks = isFlatStructure ? config.callbacks : config.resourceTemplate.callbacks;
      const template = new ResourceTemplate2(uriTemplate, {
        list: void 0,
        complete: toResourceTemplateCompleteCallbacks(
          resourceCallbacks?.complete
        )
      });
      const metadata = {};
      if (config.title) metadata.title = config.title;
      if (config.description || templateDescription)
        metadata.description = config.description || templateDescription;
      if (mimeType) metadata.mimeType = mimeType;
      if (config.annotations) metadata.annotations = config.annotations;
      const wrappedHandler = /* @__PURE__ */ __name(async (uri, extra) => {
        const result = await handler(uri, extra);
        if ("contents" in result && Array.isArray(result.contents)) {
          return result;
        }
        const { convertToolResultToResourceResult: convertToolResultToResourceResult2 } = await import("../../conversion-5MA4VY3B.js");
        return convertToolResultToResourceResult2(uri.toString(), result);
      }, "wrappedHandler");
      return server.registerResource(
        name,
        template,
        metadata,
        wrappedHandler
      );
    }, "registerTemplateOnSession");
    const templatesResult = syncPrimitive({
      primitiveName: "Resource Templates",
      currentRegistrations: this.registrations.resourceTemplates,
      newRegistrations: other.registrations.resourceTemplates,
      sessions: sessionContexts.map(({ sessionId, session, refs }) => ({
        sessionId,
        getRefs: /* @__PURE__ */ __name(() => refs?.resourceTemplates, "getRefs"),
        register: /* @__PURE__ */ __name((name, config, handler) => {
          if (!session.server) return null;
          if (!isSafePropertyKey(name)) {
            console.warn(
              `[MCP-Server] Rejected potentially malicious resource template name: ${name}`
            );
            return null;
          }
          return registerTemplateOnSession(
            session.server,
            name,
            config,
            handler
          );
        }, "register")
      })),
      supportsInPlaceUpdate: false,
      // Templates require full re-registration
      // Order-preserving rename for resource templates
      onRename: /* @__PURE__ */ __name((sessionCtx, oldKey, newKey, config, handler) => {
        const { session, refs } = sessionContexts.find(
          (s) => s.sessionId === sessionCtx.sessionId
        );
        if (!session.server) return;
        if (!isSafePropertyKey(oldKey) || !isSafePropertyKey(newKey)) {
          console.warn(
            `[MCP-Server] Rejected potentially malicious resource template name in rename: ${oldKey} -> ${newKey}`
          );
          return;
        }
        const nativeServer = session.server;
        const oldResources = nativeServer._registeredResources || {};
        const newResources = {};
        for (const key of Object.keys(oldResources)) {
          if (key === oldKey) {
            const registered = registerTemplateOnSession(
              session.server,
              newKey,
              config,
              handler
            );
            delete nativeServer._registeredResources[newKey];
            newResources[newKey] = registered;
          } else {
            newResources[key] = oldResources[key];
          }
        }
        nativeServer._registeredResources = newResources;
        if (refs?.resourceTemplates) {
          const newRefs = /* @__PURE__ */ new Map();
          for (const [k, v] of refs.resourceTemplates) {
            if (k === oldKey) {
              newRefs.set(newKey, newResources[newKey]);
            } else {
              newRefs.set(k, v);
            }
          }
          refs.resourceTemplates.clear();
          for (const [k, v] of newRefs) refs.resourceTemplates.set(k, v);
        }
      }, "onRename"),
      // Order-preserving update for resource templates - need full re-registration
      // since templates are complex, but we rebuild the object to preserve order
      onUpdate: /* @__PURE__ */ __name((sessionCtx, key, config, handler) => {
        if (!isSafePropertyKey(key)) {
          console.warn(
            `[MCP-Server] Rejected potentially malicious resource template name: ${key}`
          );
          return;
        }
        const { session, refs } = sessionContexts.find(
          (s) => s.sessionId === sessionCtx.sessionId
        );
        if (!session.server) return;
        const nativeServer = session.server;
        const originalKeys = Object.keys(
          nativeServer._registeredResources || {}
        );
        const oldRef = refs?.resourceTemplates.get(key);
        if (oldRef) oldRef.remove();
        const registered = registerTemplateOnSession(
          session.server,
          key,
          config,
          handler
        );
        const current = nativeServer._registeredResources || {};
        const newResources = {};
        for (const k of originalKeys) {
          if (current[k]) {
            newResources[k] = current[k];
          }
        }
        for (const k of Object.keys(current)) {
          if (!newResources[k]) {
            newResources[k] = current[k];
          }
        }
        nativeServer._registeredResources = newResources;
        if (refs?.resourceTemplates && registered) {
          refs.resourceTemplates.set(key, registered);
        }
      }, "onUpdate")
    });
    this.registrations.resourceTemplates = templatesResult.updatedRegistrations;
    for (const [widgetName, widgetDef] of other.widgetDefinitions) {
      this.widgetDefinitions.set(widgetName, widgetDef);
    }
    for (const [widgetName, widgetDef] of this.widgetDefinitions) {
      if (!other.widgetDefinitions.has(widgetName)) {
        other.widgetDefinitions.set(widgetName, widgetDef);
      }
    }
    for (const [, toolReg] of this.registrations.tools) {
      const config = toolReg.config;
      const widgetConfig = config?.widget;
      const widgetName = widgetConfig?.name;
      if (!widgetConfig || !widgetName || !config._meta) continue;
      if (config._meta.ui?.resourceUri) continue;
      const widgetDef = this.widgetDefinitions.get(widgetName);
      const widgetType = widgetDef?.widgetType;
      if (widgetType !== "mcpApps") continue;
      const outputTemplate = config._meta["openai/outputTemplate"];
      if (!outputTemplate) continue;
      const adapterDef = {
        type: "mcpApps",
        name: widgetName,
        metadata: widgetDef?.metadata
      };
      const dualMeta = buildDualProtocolMetadata(
        adapterDef,
        outputTemplate
      );
      Object.assign(config._meta, dualMeta);
    }
    this.registeredTools = Array.from(this.registrations.tools.keys());
    this.registeredPrompts = Array.from(this.registrations.prompts.keys());
    this.registeredResources = Array.from(this.registrations.resources.keys());
    if (process.env.NODE_ENV !== "production" && (toolsResult.changes.added.length || toolsResult.changes.removed.length || toolsResult.changes.updated.length)) {
      import("../../tool-registry-generator-HW3KH4GR.js").then(
        ({ generateToolRegistryTypes: generateToolRegistryTypes2 }) => generateToolRegistryTypes2(this.registrations.tools)
      ).catch((error2) => {
        console.debug(
          "[TypeGen] Failed to regenerate tool registry:",
          error2 instanceof Error ? error2.message : String(error2)
        );
      });
    }
    if (other._customRoutes.size > 0) {
      for (const [key, handlers] of other._customRoutes) {
        this._customRoutes.set(key, handlers);
      }
    }
    for (const key of this._customRoutes.keys()) {
      if (!other._customRoutes.has(key)) {
        this._customRoutes.delete(key);
      }
    }
    const allChanges = [
      toolsResult.changes,
      promptsResult.changes,
      resourcesResult.changes,
      templatesResult.changes
    ];
    const totalChanges = countChanges(...allChanges);
    if (totalChanges > 0) {
      console.log("[HMR] Registration changes:");
      logChanges("Tools", toolsResult.changes);
      logChanges("Prompts", promptsResult.changes);
      logChanges("Resources", resourcesResult.changes);
      logChanges("Resource Templates", templatesResult.changes);
      for (const [sessionId, session] of this.sessions) {
        if (session.server) {
          try {
            if (toolsResult.changes.added.length || toolsResult.changes.removed.length || toolsResult.changes.updated.length) {
              session.server.sendToolListChanged();
            }
          } catch (e) {
            console.debug(
              `[HMR] Session ${sessionId}: Failed to send tools/list_changed:`,
              e instanceof Error ? e.message : String(e)
            );
          }
          try {
            if (promptsResult.changes.added.length || promptsResult.changes.removed.length || promptsResult.changes.updated.length) {
              session.server.sendPromptListChanged();
            }
          } catch (e) {
            console.debug(
              `[HMR] Session ${sessionId}: Failed to send prompts/list_changed:`,
              e instanceof Error ? e.message : String(e)
            );
          }
          try {
            if (resourcesResult.changes.added.length || resourcesResult.changes.removed.length || resourcesResult.changes.updated.length || templatesResult.changes.added.length || templatesResult.changes.removed.length || templatesResult.changes.updated.length) {
              session.server.sendResourceListChanged();
            }
          } catch (e) {
            console.debug(
              `[HMR] Session ${sessionId}: Failed to send resources/list_changed:`,
              e instanceof Error ? e.message : String(e)
            );
          }
        }
      }
    } else {
      console.log("[HMR] No registration changes detected");
    }
    return {
      totalChanges,
      tools: {
        added: toolsResult.changes.added.length,
        removed: toolsResult.changes.removed.length,
        updated: toolsResult.changes.updated.length
      },
      prompts: {
        added: promptsResult.changes.added.length,
        removed: promptsResult.changes.removed.length,
        updated: promptsResult.changes.updated.length
      },
      resources: {
        added: resourcesResult.changes.added.length + templatesResult.changes.added.length,
        removed: resourcesResult.changes.removed.length + templatesResult.changes.removed.length,
        updated: resourcesResult.changes.updated.length + templatesResult.changes.updated.length
      }
    };
  }
  /**
   * Get the most recently created MCPServer instance.
   * Used by CLI dev mode for hot reload support.
   * Uses globalThis to work across ESM module boundaries.
   * @internal
   */
  static getLastCreatedInstance() {
    return globalThis.__mcpUseLastServer || null;
  }
  /**
   * Creates a new MCP server instance with Hono integration.
   *
   * Initializes the server with the provided configuration, sets up the native MCP
   * server from the official SDK, creates a Hono application for HTTP handling,
   * and configures the environment for serving MCP protocol over HTTP.
   *
   * The constructor automatically:
   * - Creates the native MCP server with protocol capabilities
   * - Initializes the Hono web framework
   * - Sets up OAuth if configured
   * - Configures session management (stateful or stateless)
   * - Wraps registration methods for multi-session support
   * - Returns a proxy that supports both MCP and Hono methods
   *
   * @param config - Server configuration object
   * @param config.name - Server name (displayed to clients)
   * @param config.version - Server version string (default: "1.0.0")
   * @param config.description - Optional server description
   * @param config.host - Hostname for URLs (default: "localhost")
   * @param config.baseUrl - Full base URL (overrides host:port for public URLs)
   * @param config.favicon - Optional favicon URL
   * @param config.oauth - Optional OAuth provider configuration
   * @param config.stateless - Whether to use stateless mode (auto-detected for Deno)
   * @param config.sessionIdleTimeoutMs - Session idle timeout (default: 86400000 = 1 day)
   * @param config.cors - Optional CORS configuration overrides
   * @param config.allowedOrigins - Allowed origins for DNS rebinding host validation
   *
   * @returns Proxied server instance supporting both MCP and Hono methods
   *
   * @example
   * ```typescript
   * // Minimal configuration
   * const server = new MCPServer({
   *   name: 'my-server',
   *   version: '1.0.0'
   * });
   * ```
   *
   * @example
   * ```typescript
   * // With custom host and description
   * const server = new MCPServer({
   *   name: 'api-server',
   *   version: '2.0.0',
   *   description: 'API integration server',
   *   host: '0.0.0.0', // Listen on all interfaces
   *   baseUrl: 'https://api.example.com' // Public URL
   * });
   * ```
   *
   * @example
   * ```typescript
   * // With OAuth authentication
   * const server = new MCPServer({
   *   name: 'secure-server',
   *   version: '1.0.0',
   *   oauth: oauthWorkOSProvider({
   *     clientId: process.env.WORKOS_CLIENT_ID!,
   *     clientSecret: process.env.WORKOS_CLIENT_SECRET!,
   *     apiKey: process.env.WORKOS_API_KEY!
   *   })
   * });
   * ```
   *
   * @example
   * ```typescript
   * // Stateless mode (for serverless platforms)
   * const server = new MCPServer({
   *   name: 'edge-server',
   *   version: '1.0.0',
   *   stateless: true // No session storage
   * });
   * ```
   *
   * @see {@link ServerConfig} for detailed configuration options
   * @see {@link listen} for starting the HTTP server
   * @see {@link getHandler} for serverless deployment
   */
  constructor(config) {
    this.config = config;
    globalThis.__mcpUseLastServer = this;
    if (this.config.stateless === void 0) {
      this.config.stateless = isDeno;
      if (this.config.stateless) {
        console.log("[MCP] Deno detected - using stateless mode (no sessions)");
      }
    }
    this.serverHost = config.host || "localhost";
    this.serverBaseUrl = config.baseUrl;
    if (config.favicon) {
      this.favicon = config.favicon;
    } else if (config.icons && config.icons.length > 0) {
      this.favicon = selectFaviconFromIcons(config.icons);
      console.log(`[MCP] Auto-selected favicon from icons: ${this.favicon}`);
    }
    const processIconUrls = /* @__PURE__ */ __name((icons, baseUrl) => {
      if (!icons || !baseUrl) return icons;
      return icons.map((icon) => ({
        ...icon,
        src: icon.src.startsWith("http") ? icon.src : `${baseUrl}/mcp-use/public/${icon.src}`
      }));
    }, "processIconUrls");
    this.nativeServer = new OfficialMcpServer(
      {
        name: config.name,
        version: config.version,
        description: config.description,
        title: config.title,
        websiteUrl: config.websiteUrl,
        icons: processIconUrls(config.icons, config.baseUrl)
      },
      {
        capabilities: {
          logging: {},
          completions: {},
          tools: {
            listChanged: true
          },
          prompts: {
            listChanged: true
          },
          resources: {
            subscribe: true,
            listChanged: true
          }
        }
      }
    );
    this.app = createHonoApp(requestLogger, {
      cors: this.config.cors,
      allowedOrigins: this.config.allowedOrigins
    });
    installCustomRoutesMiddleware(this.app, this._customRoutes);
    if ((this.favicon || this.config.icons) && !isProductionMode() && !isDeno) {
      setupPublicRoutes(this.app, false);
      setupFaviconRoute(this.app, this.favicon, false);
      this.publicRoutesMode = "dev";
    }
    this.oauthProvider = config.oauth;
    this.wrapRegistrationMethods();
    return createHonoProxy(this, this.app);
  }
  /**
   * Wrap registration methods to capture registrations following official SDK pattern.
   * Each session will get a fresh server instance with all registrations replayed.
   */
  wrapRegistrationMethods() {
    const originalTool = toolRegistration;
    const originalPrompt = registerPrompt;
    const originalResource = registerResource;
    const originalResourceTemplate = registerResourceTemplate;
    const self = this;
    this.tool = ((toolDefinition, callback) => {
      const widgetConfig = toolDefinition.widget;
      const widgetName = widgetConfig?.name;
      if (widgetConfig && widgetName) {
        const buildIdPart = self.buildId ? `-${self.buildId}` : "";
        const outputTemplate = `ui://widget/${widgetName}${buildIdPart}.html`;
        const widgetDef = self.widgetDefinitions.get(widgetName);
        const widgetType = widgetDef?.widgetType;
        if (widgetType === "mcpApps") {
          const adapterDef = {
            type: "mcpApps",
            name: widgetName,
            metadata: widgetDef?.metadata
          };
          const dualMeta = buildDualProtocolMetadata(
            adapterDef,
            outputTemplate,
            toolDefinition._meta
          );
          toolDefinition._meta = {
            ...dualMeta,
            "openai/toolInvocation/invoking": widgetConfig.invoking ?? `Loading ${widgetName}...`,
            "openai/toolInvocation/invoked": widgetConfig.invoked ?? `${widgetName} ready`,
            "openai/widgetAccessible": widgetConfig.widgetAccessible ?? true,
            "openai/resultCanProduceWidget": widgetConfig.resultCanProduceWidget ?? true
          };
        } else {
          toolDefinition._meta = {
            ...toolDefinition._meta,
            "openai/outputTemplate": outputTemplate,
            "openai/toolInvocation/invoking": widgetConfig.invoking ?? `Loading ${widgetName}...`,
            "openai/toolInvocation/invoked": widgetConfig.invoked ?? `${widgetName} ready`,
            "openai/widgetAccessible": widgetConfig.widgetAccessible ?? true,
            "openai/resultCanProduceWidget": widgetConfig.resultCanProduceWidget ?? true
          };
        }
      }
      let actualCallback = callback || toolDefinition.cb;
      if (widgetConfig && widgetName && actualCallback) {
        const originalCallback = actualCallback;
        actualCallback = /* @__PURE__ */ __name((async (params, ctx) => {
          const result = await originalCallback(params, ctx);
          if (result && typeof result === "object") {
            if (result.content?.[0]?.type === "text" && !result.content[0].text) {
              result.content[0].text = `Displaying ${widgetName}`;
            }
          }
          return result;
        }), "actualCallback");
      }
      if (actualCallback) {
        self.registrations.tools.set(toolDefinition.name, {
          config: toolDefinition,
          handler: actualCallback
        });
      }
      return originalTool.call(self, toolDefinition, actualCallback);
    });
    this.prompt = ((promptDefinition, callback) => {
      const result = originalPrompt.call(
        self,
        promptDefinition,
        callback
      );
      const actualCallback = callback || promptDefinition.cb;
      if (actualCallback && !self.isReplaying) {
        self.registrations.prompts.set(promptDefinition.name, {
          config: promptDefinition,
          handler: actualCallback
        });
      }
      return result;
    });
    this.resource = ((resourceDefinition, callback) => {
      const actualCallback = callback || resourceDefinition.readCallback;
      if (actualCallback) {
        const resourceKey = `${resourceDefinition.name}:${resourceDefinition.uri}`;
        self.registrations.resources.set(resourceKey, {
          config: resourceDefinition,
          handler: actualCallback
        });
      }
      return originalResource.call(self, resourceDefinition, callback);
    });
    this.resourceTemplate = ((templateDefinition, callback) => {
      const actualCallback = callback || templateDefinition.readCallback;
      if (actualCallback) {
        self.registrations.resourceTemplates.set(templateDefinition.name, {
          config: templateDefinition,
          handler: actualCallback
        });
      }
      return originalResourceTemplate.call(
        self,
        templateDefinition,
        callback
      );
    });
  }
  /**
   * Create a new server instance for a session following official SDK pattern.
   * This is called for each initialize request to create an isolated server.
   *
   * @param sessionId - Optional session ID to store registered refs for hot reload support
   */
  getServerForSession(sessionId) {
    const processIconUrls = /* @__PURE__ */ __name((icons, baseUrl) => {
      if (!icons || !baseUrl) return icons;
      return icons.map((icon) => ({
        ...icon,
        src: icon.src.startsWith("http") ? icon.src : `${baseUrl}/mcp-use/public/${icon.src}`
      }));
    }, "processIconUrls");
    const newServer = new OfficialMcpServer(
      {
        name: this.config.name,
        version: this.config.version,
        description: this.config.description,
        title: this.config.title,
        websiteUrl: this.config.websiteUrl,
        icons: processIconUrls(this.config.icons, this.serverBaseUrl)
      },
      {
        capabilities: {
          logging: {},
          completions: {},
          tools: {
            listChanged: true
          },
          prompts: {
            listChanged: true
          },
          resources: {
            subscribe: true,
            listChanged: true
          }
        }
      }
    );
    const serverAny = newServer;
    if (typeof serverAny.setToolRequestHandlers === "function") {
      serverAny.setToolRequestHandlers();
    }
    if (typeof serverAny.setPromptRequestHandlers === "function") {
      serverAny.setPromptRequestHandlers();
    }
    if (typeof serverAny.setResourceRequestHandlers === "function") {
      serverAny.setResourceRequestHandlers();
    }
    const sessionRefs = {
      tools: /* @__PURE__ */ new Map(),
      prompts: /* @__PURE__ */ new Map(),
      resources: /* @__PURE__ */ new Map(),
      resourceTemplates: /* @__PURE__ */ new Map()
    };
    for (const [name, registration] of this.registrations.tools) {
      const { config, handler: actualCallback } = registration;
      let inputSchema;
      if (config.schema) {
        inputSchema = this.convertZodSchemaToParams(config.schema);
      } else if (config.inputs && config.inputs.length > 0) {
        inputSchema = this.createParamsSchema(config.inputs);
      } else {
        inputSchema = {};
      }
      const wrappedHandler = /* @__PURE__ */ __name(async (params, extra) => {
        const initialRequestContext = getRequestContext();
        const extraProgressToken = extra?._meta?.progressToken;
        const extraSendNotification = extra?.sendNotification;
        const { requestContext, session, progressToken, sendNotification: sendNotification2 } = findSessionContext(
          this.sessions,
          initialRequestContext,
          extraProgressToken,
          extraSendNotification
        );
        let sessionId2;
        if (session) {
          for (const [id, s] of this.sessions.entries()) {
            if (s === session) {
              sessionId2 = id;
              break;
            }
          }
        }
        const createMessageWithLogging = /* @__PURE__ */ __name(async (params2, options) => {
          console.log("[createMessage] About to call server.createMessage");
          console.log("[createMessage] Has server:", !!newServer);
          try {
            const result = await newServer.server.createMessage(
              params2,
              options
            );
            console.log("[createMessage] Got result successfully");
            return result;
          } catch (err) {
            const error2 = err;
            console.error(
              "[createMessage] Error:",
              error2.message,
              "Code:",
              error2.code
            );
            throw err;
          }
        }, "createMessageWithLogging");
        const enhancedContext = createEnhancedContext(
          requestContext,
          createMessageWithLogging,
          newServer.server.elicitInput.bind(newServer.server),
          progressToken,
          sendNotification2,
          session?.logLevel,
          session?.clientCapabilities,
          sessionId2,
          this.sessions
        );
        const executeCallback = /* @__PURE__ */ __name(async () => {
          if (actualCallback.length >= 2) {
            return await actualCallback(params, enhancedContext);
          }
          return await actualCallback(params);
        }, "executeCallback");
        const startTime = Date.now();
        let success = true;
        let errorType = null;
        try {
          const result = requestContext ? await runWithContext(requestContext, executeCallback) : await executeCallback();
          return result;
        } catch (err) {
          success = false;
          errorType = err instanceof Error ? err.name : "unknown_error";
          throw err;
        } finally {
          const executionTimeMs = Date.now() - startTime;
          Telemetry.getInstance().trackServerToolCall({
            toolName: name,
            lengthInputArgument: JSON.stringify(params).length,
            success,
            errorType,
            executionTimeMs
          }).catch((e) => console.debug(`Failed to track tool call: ${e}`));
        }
      }, "wrappedHandler");
      const registeredTool = newServer.registerTool(
        name,
        {
          title: config.title,
          description: config.description ?? "",
          inputSchema,
          annotations: config.annotations,
          _meta: config._meta
        },
        wrappedHandler
      );
      sessionRefs.tools.set(name, registeredTool);
    }
    for (const [name, registration] of this.registrations.prompts) {
      const { config, handler } = registration;
      let argsSchema;
      if (config.schema) {
        argsSchema = this.convertZodSchemaToParams(config.schema);
      } else if (config.args && config.args.length > 0) {
        argsSchema = this.createParamsSchema(config.args);
      } else {
        argsSchema = void 0;
      }
      const wrappedHandler = /* @__PURE__ */ __name(async (params, extra) => {
        let success = true;
        let errorType = null;
        try {
          const result = await handler(params, extra);
          if ("messages" in result && Array.isArray(result.messages)) {
            return result;
          }
          const { convertToolResultToPromptResult: convertToolResultToPromptResult2 } = await import("../../conversion-DN5J4QL5.js");
          return convertToolResultToPromptResult2(result);
        } catch (err) {
          success = false;
          errorType = err instanceof Error ? err.name : "unknown_error";
          throw err;
        } finally {
          Telemetry.getInstance().trackServerPromptCall({
            name,
            description: config.description ?? null,
            success,
            errorType
          }).catch((e) => console.debug(`Failed to track prompt call: ${e}`));
        }
      }, "wrappedHandler");
      const registeredPrompt = newServer.registerPrompt(
        name,
        {
          title: config.title,
          description: config.description ?? "",
          argsSchema
        },
        wrappedHandler
      );
      sessionRefs.prompts.set(name, registeredPrompt);
    }
    for (const [_key, registration] of this.registrations.resources) {
      const { config, handler } = registration;
      const wrappedHandler = /* @__PURE__ */ __name(async (extra) => {
        let success = true;
        let errorType = null;
        let contents = [];
        try {
          const result = await handler(extra);
          if ("contents" in result && Array.isArray(result.contents)) {
            contents = result.contents;
            return result;
          }
          const { convertToolResultToResourceResult: convertToolResultToResourceResult2 } = await import("../../conversion-5MA4VY3B.js");
          const converted = convertToolResultToResourceResult2(
            config.uri,
            result
          );
          contents = converted.contents || [];
          return converted;
        } catch (err) {
          success = false;
          errorType = err instanceof Error ? err.name : "unknown_error";
          throw err;
        } finally {
          Telemetry.getInstance().trackServerResourceCall({
            name: config.name,
            description: config.description ?? null,
            contents: contents.map((c) => ({
              mime_type: c.mimeType ?? null,
              text: c.text ? `[text: ${c.text.length} chars]` : null,
              blob: c.blob ? `[blob: ${c.blob.length} bytes]` : null
            })),
            success,
            errorType
          }).catch((e) => console.debug(`Failed to track resource call: ${e}`));
        }
      }, "wrappedHandler");
      const registeredResource = newServer.registerResource(
        config.name,
        config.uri,
        {
          title: config.title,
          description: config.description,
          mimeType: config.mimeType || "text/plain"
        },
        wrappedHandler
      );
      const resourceKey = `${config.name}:${config.uri}`;
      sessionRefs.resources.set(resourceKey, registeredResource);
    }
    for (const [_name, registration] of this.registrations.resourceTemplates) {
      const { config, handler } = registration;
      const isFlatStructure = "uriTemplate" in config;
      const uriTemplate = isFlatStructure ? config.uriTemplate : config.resourceTemplate.uriTemplate;
      const mimeType = isFlatStructure ? config.mimeType : config.resourceTemplate.mimeType;
      const templateDescription = isFlatStructure ? void 0 : config.resourceTemplate.description;
      const resourceCallbacks = isFlatStructure ? config.callbacks : config.resourceTemplate.callbacks;
      const template = new ResourceTemplate2(uriTemplate, {
        list: void 0,
        complete: toResourceTemplateCompleteCallbacks(
          resourceCallbacks?.complete
        )
      });
      const metadata = {};
      if (config.title) {
        metadata.title = config.title;
      }
      if (config.description || templateDescription) {
        metadata.description = config.description || templateDescription;
      }
      if (mimeType) {
        metadata.mimeType = mimeType;
      }
      if (config.annotations) {
        metadata.annotations = config.annotations;
      }
      const registeredResourceTemplate = newServer.registerResource(
        config.name,
        template,
        metadata,
        async (uri, extra) => {
          let success = true;
          let errorType = null;
          let contents = [];
          try {
            const params = this.parseTemplateUri(uriTemplate, uri.toString());
            const result = await handler(uri, params, extra);
            if ("contents" in result && Array.isArray(result.contents)) {
              contents = result.contents;
              return result;
            }
            const { convertToolResultToResourceResult: convertToolResultToResourceResult2 } = await import("../../conversion-5MA4VY3B.js");
            const converted = convertToolResultToResourceResult2(
              uri.toString(),
              result
            );
            contents = converted.contents || [];
            return converted;
          } catch (err) {
            success = false;
            errorType = err instanceof Error ? err.name : "unknown_error";
            throw err;
          } finally {
            Telemetry.getInstance().trackServerResourceCall({
              name: config.name,
              description: config.description ?? null,
              contents: contents.map((c) => ({
                mimeType: c.mimeType ?? null,
                text: c.text ? `[text: ${c.text.length} chars]` : null,
                blob: c.blob ? `[blob: ${c.blob.length} bytes]` : null
              })),
              success,
              errorType
            }).catch(
              (e) => console.debug(`Failed to track resource template call: ${e}`)
            );
          }
        }
      );
      sessionRefs.resourceTemplates.set(
        config.name,
        registeredResourceTemplate
      );
    }
    newServer.server.setRequestHandler(
      z3.object({ method: z3.literal("logging/setLevel") }).passthrough(),
      (async (request, extra) => {
        const level = request.params?.level;
        if (!level) {
          throw new McpError(
            ErrorCode.InvalidParams,
            "Missing 'level' parameter"
          );
        }
        if (!isValidLogLevel(level)) {
          throw new McpError(
            ErrorCode.InvalidParams,
            `Invalid log level '${level}'. Must be one of: debug, info, notice, warning, error, critical, alert, emergency`
          );
        }
        const requestContext = getRequestContext();
        if (requestContext) {
          const sessionId2 = requestContext.req.header("mcp-session-id");
          if (sessionId2 && this.sessions.has(sessionId2)) {
            const session = this.sessions.get(sessionId2);
            session.logLevel = level;
            console.log(
              `[MCP] Set log level to '${level}' for session ${sessionId2}`
            );
            return {};
          }
        }
        for (const [sessionId2, session] of this.sessions.entries()) {
          if (session.server === newServer) {
            session.logLevel = level;
            console.log(
              `[MCP] Set log level to '${level}' for session ${sessionId2}`
            );
            return {};
          }
        }
        console.warn(
          "[MCP] Could not find session for logging/setLevel request"
        );
        throw new McpError(ErrorCode.InternalError, "Could not find session");
      })
    );
    this.subscriptionManager.registerHandlers(newServer, this.sessions);
    if (sessionId) {
      this.sessionRegisteredRefs.set(sessionId, sessionRefs);
    }
    return newServer;
  }
  /**
   * Gets the server base URL with fallback to host:port if not configured
   * @returns The complete base URL for the server
   */
  getServerBaseUrl() {
    return getServerBaseUrl(
      this.serverBaseUrl,
      this.serverHost,
      this.serverPort
    );
  }
  /**
   * Registers a tool that can be called by MCP clients.
   *
   * Tools are executable functions that clients can invoke to perform actions
   * like reading files, making API calls, running commands, etc. Each tool has
   * a name, description, input schema, and callback function.
   *
   * @param toolDefinition - Tool configuration object
   * @param toolDefinition.name - Unique tool name (used by clients to call it)
   * @param toolDefinition.description - Human-readable description of what the tool does
   * @param toolDefinition.schema - Zod schema for validating input parameters
   * @param toolDefinition.cb - Optional callback function (can also be second parameter)
   * @param callback - Optional callback function (alternative to toolDefinition.cb)
   * @returns This server instance for method chaining
   *
   * @example
   * ```typescript
   * // Basic tool
   * server.tool({
   *   name: 'get-time',
   *   description: 'Get current time'
   * }, async () => {
   *   return text(new Date().toISOString());
   * });
   * ```
   *
   * @example
   * ```typescript
   * // Tool with parameters
   * server.tool({
   *   name: 'add',
   *   description: 'Add two numbers',
   *   schema: z.object({
   *     a: z.number(),
   *     b: z.number()
   *   })
   * }, async ({ a, b }) => {
   *   return text(String(a + b));
   * });
   * ```
   *
   * @example
   * ```typescript
   * // Tool with context (for OAuth)
   * server.tool({
   *   name: 'user-info',
   *   description: 'Get user information'
   * }, async (params, ctx) => {
   *   if (!ctx.auth) {
   *     return error('Not authenticated');
   *   }
   *   return text(`User: ${ctx.auth.user.email}`);
   * });
   * ```
   *
   * @see {@link ToolDefinition} for all configuration options
   * @see {@link ToolCallback} for callback signature
   */
  tool;
  /**
   * Converts a Zod schema to MCP parameter format.
   * @internal Used internally by tool registration
   */
  convertZodSchemaToParams = convertZodSchemaToParams;
  /**
   * Creates parameter schema from input definitions.
   * @internal Used internally by tool registration
   */
  createParamsSchema = createParamsSchema;
  /**
   * Parses URI parameters from resource template URIs.
   * @internal Used internally by resource templates
   */
  parseTemplateUri = parseTemplateUri;
  /**
   * Registers a resource that can be read by MCP clients.
   *
   * Resources represent data or content that clients can access, such as
   * files, database records, API responses, etc. Each resource has a unique
   * URI and returns content when read.
   *
   * @param resourceDefinition - Resource configuration object
   * @param resourceDefinition.name - Resource display name
   * @param resourceDefinition.uri - Unique resource URI (e.g., "file:///path/to/file")
   * @param resourceDefinition.description - Human-readable description
   * @param resourceDefinition.mimeType - MIME type of content (default: "text/plain")
   * @param callback - Callback function that returns resource content
   * @returns This server instance for method chaining
   *
   * @example
   * ```typescript
   * // Static resource
   * server.resource({
   *   name: 'config',
   *   uri: 'app://config',
   *   description: 'Application configuration'
   * }, async () => {
   *   return text(JSON.stringify(config, null, 2));
   * });
   * ```
   *
   * @example
   * ```typescript
   * // Dynamic resource
   * server.resource({
   *   name: 'system-status',
   *   uri: 'system://status',
   *   mimeType: 'application/json'
   * }, async () => {
   *   const status = await getSystemStatus();
   *   return text(JSON.stringify(status));
   * });
   * ```
   *
   * @see {@link ResourceDefinition} for all configuration options
   * @see {@link resourceTemplate} for parameterized resources
   */
  resource;
  /**
   * Registers a resource template for parameterized resources.
   *
   * Resource templates allow clients to read resources with dynamic URIs
   * by providing a URI template with parameters (e.g., "file:///{path}").
   * When a client reads a URI matching the template, the parameters are
   * extracted and passed to the callback.
   *
   * @param templateDefinition - Resource template configuration
   * @param templateDefinition.name - Template display name
   * @param templateDefinition.uriTemplate - URI template with parameters (e.g., "files:///{id}")
   * @param templateDefinition.description - Human-readable description
   * @param templateDefinition.mimeType - MIME type of content
   * @param callback - Callback receiving URI and extracted parameters
   * @returns This server instance for method chaining
   *
   * @example
   * ```typescript
   * // File resource template
   * server.resourceTemplate({
   *   name: 'files',
   *   uriTemplate: 'file:///{path}',
   *   description: 'Read files by path'
   * }, async (uri, params) => {
   *   const content = await fs.readFile(params.path, 'utf-8');
   *   return text(content);
   * });
   * ```
   *
   * @example
   * ```typescript
   * // Database record template
   * server.resourceTemplate({
   *   name: 'users',
   *   uriTemplate: 'db://users/{id}',
   *   mimeType: 'application/json'
   * }, async (uri, params) => {
   *   const user = await db.users.get(params.id);
   *   return text(JSON.stringify(user));
   * });
   * ```
   *
   * @see {@link ResourceTemplateDefinition} for all configuration options
   * @see {@link resource} for static resources
   */
  resourceTemplate;
  /**
   * Registers a prompt template that clients can use.
   *
   * Prompts are reusable templates that help structure conversations with
   * language models. They can accept parameters and return formatted messages
   * ready to send to an LLM.
   *
   * @param promptDefinition - Prompt configuration object
   * @param promptDefinition.name - Unique prompt name
   * @param promptDefinition.description - Human-readable description
   * @param promptDefinition.schema - Zod schema for prompt arguments
   * @param callback - Callback that returns prompt messages
   * @returns This server instance for method chaining
   *
   * @example
   * ```typescript
   * // Simple prompt
   * server.prompt({
   *   name: 'greeting',
   *   description: 'Generate a greeting message'
   * }, async () => {
   *   return {
   *     messages: [
   *       { role: 'user', content: { type: 'text', text: 'Hello!' } }
   *     ]
   *   };
   * });
   * ```
   *
   * @example
   * ```typescript
   * // Parameterized prompt
   * server.prompt({
   *   name: 'code-review',
   *   description: 'Review code with specific focus',
   *   schema: z.object({
   *     code: z.string(),
   *     focus: z.enum(['security', 'performance', 'style'])
   *   })
   * }, async ({ code, focus }) => {
   *   return {
   *     messages: [
   *       {
   *         role: 'user',
   *         content: {
   *           type: 'text',
   *           text: `Review this code focusing on ${focus}:\n\n${code}`
   *         }
   *       }
   *     ]
   *   };
   * });
   * ```
   *
   * @see {@link PromptDefinition} for all configuration options
   */
  prompt;
  /**
   * Gets all active client sessions.
   *
   * @returns Array of active session IDs
   *
   * @example
   * ```typescript
   * const sessions = server.getActiveSessions();
   * console.log(`Active sessions: ${sessions.length}`);
   * ```
   */
  getActiveSessions = getActiveSessions;
  /**
   * Sends a notification to all connected clients.
   *
   * @param method - Notification method name
   * @param params - Notification parameters
   *
   * @example
   * ```typescript
   * await server.sendNotification('custom/event', { data: 'value' });
   * ```
   */
  sendNotification = sendNotification;
  /**
   * Sends a notification to a specific client session.
   *
   * @param sessionId - Target session ID
   * @param method - Notification method name
   * @param params - Notification parameters
   *
   * @example
   * ```typescript
   * await server.sendNotificationToSession('session-123', 'custom/event', { data: 'value' });
   * ```
   */
  sendNotificationToSession = sendNotificationToSession2;
  /**
   * Notifies all clients that the tools list has changed.
   * Clients should refresh their tools list.
   *
   * @example
   * ```typescript
   * server.tool({ name: 'new-tool', description: 'New tool' }, handler);
   * await server.sendToolsListChanged();
   * ```
   */
  sendToolsListChanged = sendToolsListChanged;
  /**
   * Notifies all clients that the resources list has changed.
   * Clients should refresh their resources list.
   *
   * @example
   * ```typescript
   * server.resource({ name: 'new-resource', uri: 'new://' }, handler);
   * await server.sendResourcesListChanged();
   * ```
   */
  sendResourcesListChanged = sendResourcesListChanged;
  /**
   * Notifies all clients that the prompts list has changed.
   * Clients should refresh their prompts list.
   *
   * @example
   * ```typescript
   * server.prompt({ name: 'new-prompt', description: 'New prompt' }, handler);
   * await server.sendPromptsListChanged();
   * ```
   */
  sendPromptsListChanged = sendPromptsListChanged;
  /**
   * Notify subscribed clients that a resource has been updated
   *
   * This method sends a `notifications/resources/updated` notification to all
   * sessions that have subscribed to the specified resource URI.
   *
   * @param uri - The URI of the resource that changed
   * @returns Promise that resolves when all notifications have been sent
   *
   * @example
   * ```typescript
   * // After updating a resource, notify subscribers
   * await server.notifyResourceUpdated("file:///path/to/resource.txt");
   * ```
   */
  async notifyResourceUpdated(uri) {
    return this.subscriptionManager.notifyResourceUpdated(uri, this.sessions);
  }
  /**
   * Registers a UI resource for interactive widgets.
   *
   * UI resources allow serving interactive components that can be displayed
   * in compatible MCP clients (like ChatGPT with Apps SDK).
   *
   * @param definition - UI resource definition
   * @returns This server instance for method chaining
   *
   * @example
   * ```typescript
   * server.uiResource({
   *   name: 'chart-viewer',
   *   uri: 'ui://chart',
   *   html: '<div>Chart goes here</div>'
   * });
   * ```
   *
   * @see {@link UIResourceDefinition} for configuration options
   */
  uiResource = /* @__PURE__ */ __name((definition) => {
    return uiResourceRegistration(this, definition);
  }, "uiResource");
  /**
   * Mount MCP server endpoints at /mcp and /sse
   *
   * Sets up the HTTP transport layer for the MCP server, creating endpoints for
   * Server-Sent Events (SSE) streaming, POST message handling, and DELETE session cleanup.
   * The transport manages multiple sessions through a single server instance.
   *
   * This method is called automatically when the server starts listening and ensures
   * that MCP clients can communicate with the server over HTTP.
   *
   * @private
   * @returns Promise that resolves when MCP endpoints are successfully mounted
   *
   * @example
   * Endpoints created:
   * - GET /mcp, GET /sse - SSE streaming endpoint for real-time communication
   * - POST /mcp, POST /sse - Message handling endpoint for MCP protocol messages
   * - DELETE /mcp, DELETE /sse - Session cleanup endpoint
   */
  async mountMcp() {
    if (this.mcpMounted) return;
    const result = await mountMcp(
      this.app,
      this,
      // Pass the MCPServer instance so mountMcp can call getServerForSession()
      this.sessions,
      this.config,
      isProductionMode()
    );
    this.mcpMounted = result.mcpMounted;
  }
  /**
   * Starts the HTTP server and begins listening for connections.
   *
   * This method is the primary way to run an MCP server as a standalone HTTP service.
   * It performs the following initialization:
   * 1. Mounts MCP protocol endpoints at `/mcp` and `/sse`
   * 2. Mounts inspector UI at `/inspector` (if available)
   * 3. Mounts widget serving routes
   * 4. Sets up OAuth routes (if configured)
   * 5. Starts the HTTP server on the specified port
   *
   * Port resolution (in order of priority):
   * 1. `port` parameter
   * 2. `--port` CLI argument
   * 3. `PORT` environment variable
   * 4. Default: 3000
   *
   * Host configuration:
   * - Uses `config.host` or `HOST` environment variable
   * - Defaults to "localhost"
   *
   * Base URL:
   * - Uses `config.baseUrl` or `MCP_URL` environment variable
   * - Falls back to `http://${host}:${port}`
   *
   * @param port - Optional port number to listen on
   * @returns Promise that resolves when the server is listening
   *
   * @example
   * ```typescript
   * // Basic usage
   * const server = new MCPServer({ name: 'my-server', version: '1.0.0' });
   * server.tool({ name: 'hello', description: 'Say hello' }, async () => {
   *   return text('Hello, world!');
   * });
   * await server.listen(3000);
   * // Server running at: http://localhost:3000
   * // MCP endpoint: http://localhost:3000/mcp
   * // Inspector UI: http://localhost:3000/inspector
   * ```
   *
   * @example
   * ```typescript
   * // Using environment variables
   * // PORT=8080 HOST=0.0.0.0 node server.js
   * await server.listen(); // Listens on 0.0.0.0:8080
   * ```
   *
   * @example
   * ```typescript
   * // With custom base URL (e.g., behind reverse proxy)
   * const server = new MCPServer({
   *   name: 'my-server',
   *   version: '1.0.0',
   *   baseUrl: 'https://api.example.com'
   * });
   * await server.listen(3000);
   * // Server listens on port 3000 but generates URLs with https://api.example.com
   * ```
   *
   * @example
   * ```typescript
   * // Command-line usage
   * // node server.js --port 8080
   * await server.listen(); // Uses port from CLI argument
   * ```
   *
   * @see {@link getHandler} for serverless deployment without listen()
   */
  /**
   * Logs registered tools, prompts, and resources to console.
   * @internal
   */
  logRegisteredItems() {
    logRegisteredItems(
      this.registeredTools,
      this.registeredPrompts,
      this.registeredResources
    );
  }
  /**
   * Gets the build identifier for cache busting.
   *
   * @returns Build ID string or undefined
   * @internal
   */
  getBuildId() {
    return this.buildId;
  }
  /**
   * Gets the port number the server is listening on.
   *
   * @returns Port number (defaults to 3000 if not yet listening)
   *
   * @example
   * ```typescript
   * await server.listen(8080);
   * console.log(`Server port: ${server.getServerPort()}`); // 8080
   * ```
   */
  getServerPort() {
    return this.serverPort || 3e3;
  }
  /**
   * Creates a message using sampling (LLM completion).
   *
   * This method delegates to the native SDK server to handle sampling requests.
   * Sampling allows tools to ask the LLM to generate responses, enabling
   * agent-like behavior where tools can request LLM assistance.
   *
   * @param params - Message creation parameters
   * @param options - Optional request options
   * @returns Message creation result from the LLM
   *
   * @example
   * ```typescript
   * // In a tool callback with sampling capability
   * const result = await server.createMessage({
   *   messages: [
   *     { role: 'user', content: { type: 'text', text: 'Explain MCP' } }
   *   ],
   *   maxTokens: 100
   * });
   * ```
   */
  async createMessage(params, options) {
    return await this.nativeServer.server.createMessage(params, options);
  }
  async listen(port) {
    if (globalThis.__mcpUseHmrMode) {
      return;
    }
    const portEnv = getEnv("PORT");
    let cliPort;
    if (typeof process !== "undefined" && Array.isArray(process.argv)) {
      const portArgIndex = process.argv.indexOf("--port");
      if (portArgIndex !== -1 && portArgIndex + 1 < process.argv.length) {
        const portValue = parseInt(process.argv[portArgIndex + 1], 10);
        if (!isNaN(portValue)) {
          cliPort = portValue;
        }
      }
    }
    this.serverPort = port || cliPort || (portEnv ? parseInt(portEnv, 10) : 3e3);
    const hostEnv = getEnv("HOST");
    if (hostEnv) {
      this.serverHost = hostEnv;
    }
    this.serverBaseUrl = getServerBaseUrl(
      this.serverBaseUrl,
      this.serverHost,
      this.serverPort
    );
    if (this.oauthProvider && !this.oauthSetupState.complete) {
      await setupOAuthForServer(
        this.app,
        this.oauthProvider,
        this.getServerBaseUrl(),
        this.oauthSetupState
      );
    }
    await mountWidgets(this, {
      baseRoute: "/mcp-use/widgets",
      resourcesDir: "resources"
    });
    await this.mountMcp();
    await this.mountInspector();
    this.logRegisteredItems();
    if (process.env.NODE_ENV !== "production") {
      try {
        const { generateToolRegistryTypes: generateToolRegistryTypes2 } = await import("../../tool-registry-generator-HW3KH4GR.js");
        await generateToolRegistryTypes2(this.registrations.tools);
      } catch (error2) {
        console.debug(
          "[TypeGen] Failed to generate tool registry:",
          error2 instanceof Error ? error2.message : String(error2)
        );
      }
    }
    this._trackServerRun("http");
    await startServer(this.app, this.serverPort, this.serverHost, {
      onDenoRequest: rewriteSupabaseRequest
    });
  }
  _trackServerRun(transport) {
    Telemetry.getInstance().trackServerRunFromServer(this, transport).catch((e) => console.debug(`Failed to track server run: ${e}`));
  }
  /**
   * Get the fetch handler for the server after mounting all endpoints
   *
   * This method prepares the server by mounting MCP endpoints, widgets, and inspector
   * (if available), then returns the fetch handler. This is useful for integrating
   * with external server frameworks like Supabase Edge Functions, Cloudflare Workers,
   * or other platforms that handle the server lifecycle themselves.
   *
   * Unlike `listen()`, this method does not start a server - it only prepares the
   * routes and returns the handler function that can be used with external servers.
   *
   * @param options - Optional configuration for the handler
   * @param options.provider - Platform provider (e.g., 'supabase') to handle platform-specific path rewriting
   * @returns Promise that resolves to the fetch handler function
   *
   * @example
   * ```typescript
   * // For Supabase Edge Functions (handles path rewriting automatically)
   * const server = new MCPServer({ name: 'my-server', version: '1.0.0' });
   * server.tool({ ... });
   * const handler = await server.getHandler({ provider: 'supabase' });
   * Deno.serve(handler);
   * ```
   *
   * @example
   * ```typescript
   * // For Cloudflare Workers
   * const server = new MCPServer({ name: 'my-server', version: '1.0.0' });
   * server.tool({ ... });
   * const handler = await server.getHandler();
   * export default { fetch: handler };
   * ```
   */
  async getHandler(options) {
    if (this.oauthProvider && !this.oauthSetupState.complete) {
      await setupOAuthForServer(
        this.app,
        this.oauthProvider,
        this.getServerBaseUrl(),
        this.oauthSetupState
      );
    }
    console.log("[MCP] Mounting widgets");
    await mountWidgets(this, {
      baseRoute: "/mcp-use/widgets",
      resourcesDir: "resources"
    });
    console.log("[MCP] Mounted widgets");
    await this.mountMcp();
    console.log("[MCP] Mounted MCP");
    console.log("[MCP] Mounting inspector");
    await this.mountInspector();
    console.log("[MCP] Mounted inspector");
    const provider = options?.provider || "fetch";
    this._trackServerRun(provider);
    const fetchHandler = this.app.fetch.bind(this.app);
    if (options?.provider === "supabase") {
      return async (req) => {
        const corsHeaders = getDenoCorsHeaders();
        if (req.method === "OPTIONS") {
          return new Response("ok", { headers: corsHeaders });
        }
        const rewrittenReq = rewriteSupabaseRequest(req);
        const result = await fetchHandler(rewrittenReq);
        return applyDenoCorsHeaders(result);
      };
    }
    return async (req) => {
      const result = await fetchHandler(req);
      return result;
    };
  }
  /**
   * Registers a callback for when client roots change.
   *
   * Roots represent directories or files that the client has access to.
   * This callback is invoked when a client updates its root list.
   *
   * @param callback - Function to call when roots change
   *
   * @example
   * ```typescript
   * server.onRootsChanged((roots) => {
   *   console.log(`Client roots updated: ${roots.length} roots`);
   *   roots.forEach(root => console.log(`  - ${root.uri}`));
   * });
   * ```
   */
  onRootsChanged = onRootsChanged.bind(this);
  /**
   * Lists the current roots from connected clients.
   *
   * @returns Promise resolving to array of Root objects
   *
   * @example
   * ```typescript
   * const roots = await server.listRoots();
   * console.log(`Current roots: ${roots.map(r => r.uri).join(', ')}`);
   * ```
   */
  listRoots = listRoots.bind(this);
  /**
   * Mount MCP Inspector UI at /inspector
   *
   * Dynamically loads and mounts the MCP Inspector UI package if available, providing
   * a web-based interface for testing and debugging MCP servers. The inspector
   * automatically connects to the local MCP server endpoints.
   *
   * This method gracefully handles cases where the inspector package is not installed,
   * allowing the server to function without the inspector in production environments.
   *
   * @private
   * @returns void
   *
   * @example
   * If @mcp-use/inspector is installed:
   * - Inspector UI available at http://localhost:PORT/inspector
   * - Automatically connects to http://localhost:PORT/mcp (or /sse)
   *
   * If not installed:
   * - Server continues to function normally
   * - No inspector UI available
   */
  async mountInspector() {
    if (this.inspectorMounted) return;
    const mounted = await mountInspectorUI(
      this.app,
      this.serverHost,
      this.serverPort,
      isProductionMode()
    );
    if (mounted) {
      this.inspectorMounted = true;
    }
  }
};
var MCPServer = MCPServerClass;
function createMCPServer(name, config = {}) {
  const instance = new MCPServerClass({
    name,
    version: config.version || "1.0.0",
    description: config.description,
    title: config.title,
    websiteUrl: config.websiteUrl,
    icons: config.icons,
    host: config.host,
    baseUrl: config.baseUrl,
    allowedOrigins: config.allowedOrigins,
    sessionIdleTimeoutMs: config.sessionIdleTimeoutMs,
    autoCreateSessionOnInvalidId: config.autoCreateSessionOnInvalidId,
    oauth: config.oauth,
    favicon: config.favicon
  });
  return instance;
}
__name(createMCPServer, "createMCPServer");

// src/server/oauth/providers/supabase.ts
import {
  jwtVerify,
  createRemoteJWKSet,
  decodeProtectedHeader,
  decodeJwt
} from "jose";
var SupabaseOAuthProvider = class {
  static {
    __name(this, "SupabaseOAuthProvider");
  }
  config;
  supabaseUrl;
  supabaseAuthUrl;
  issuer;
  jwks = null;
  constructor(config) {
    this.config = config;
    this.supabaseUrl = `https://${config.projectId}.supabase.co`;
    this.supabaseAuthUrl = `${this.supabaseUrl}/auth/v1`;
    this.issuer = `${this.supabaseUrl}/auth/v1`;
  }
  getJWKS() {
    if (!this.jwks) {
      this.jwks = createRemoteJWKSet(
        new URL(`${this.issuer}/.well-known/jwks.json`)
      );
    }
    return this.jwks;
  }
  async verifyToken(token) {
    if (this.config.skipVerification) {
      console.warn(
        "[Supabase OAuth] \u26A0\uFE0F  SKIPPING VERIFICATION (DEVELOPMENT MODE)"
      );
      console.warn(
        "[Supabase OAuth]     This is NOT secure! Only use for testing!"
      );
      const payload = decodeJwt(token);
      return { payload, protectedHeader: decodeProtectedHeader(token) };
    }
    try {
      const header = decodeProtectedHeader(token);
      if (header.alg === "HS256") {
        if (!this.config.jwtSecret) {
          throw new Error(
            "JWT Secret is required for HS256 tokens. Get it from: Supabase Dashboard \u2192 Project Settings \u2192 API \u2192 JWT Settings"
          );
        }
        const secret = new TextEncoder().encode(this.config.jwtSecret);
        const result = await jwtVerify(token, secret, {
          issuer: this.issuer,
          audience: "authenticated"
        });
        return result;
      } else if (header.alg === "ES256") {
        const result = await jwtVerify(token, this.getJWKS(), {
          issuer: this.issuer,
          audience: "authenticated"
        });
        return result;
      } else {
        throw new Error(`Unsupported algorithm: ${header.alg}`);
      }
    } catch (error2) {
      throw new Error(`Supabase JWT verification failed: ${error2}`);
    }
  }
  getUserInfo(payload) {
    const userMetadata = payload.user_metadata;
    return {
      userId: payload.sub || payload.user_id,
      email: payload.email,
      name: userMetadata?.name || userMetadata?.full_name,
      username: userMetadata?.username,
      picture: userMetadata?.avatar_url,
      roles: payload.role ? [payload.role] : [],
      permissions: payload.aal ? [`aal:${payload.aal}`] : [],
      // Include Supabase-specific claims
      aal: payload.aal,
      // Authentication Assurance Level
      amr: payload.amr,
      // Authentication Methods References
      session_id: payload.session_id
    };
  }
  getIssuer() {
    return this.issuer;
  }
  getAuthEndpoint() {
    return `${this.supabaseAuthUrl}/authorize`;
  }
  getTokenEndpoint() {
    return `${this.supabaseAuthUrl}/token`;
  }
  getScopesSupported() {
    return [];
  }
  getGrantTypesSupported() {
    return ["authorization_code", "refresh_token"];
  }
};

// src/server/oauth/providers/auth0.ts
import { jwtVerify as jwtVerify2, createRemoteJWKSet as createRemoteJWKSet2 } from "jose";
var Auth0OAuthProvider = class {
  static {
    __name(this, "Auth0OAuthProvider");
  }
  config;
  issuer;
  jwks = null;
  constructor(config) {
    this.config = config;
    this.issuer = `https://${config.domain}`;
  }
  getJWKS() {
    if (!this.jwks) {
      this.jwks = createRemoteJWKSet2(
        new URL(`${this.issuer}/.well-known/jwks.json`)
      );
    }
    return this.jwks;
  }
  async verifyToken(token) {
    if (this.config.verifyJwt === false) {
      console.warn("[Auth0 OAuth] \u26A0\uFE0F  JWT verification is disabled");
      console.warn("[Auth0 OAuth]     Enable verifyJwt: true for production");
      const parts = token.split(".");
      if (parts.length !== 3) {
        throw new Error("Invalid JWT format");
      }
      const payload = JSON.parse(
        Buffer.from(parts[1], "base64url").toString("utf8")
      );
      return { payload };
    }
    try {
      const result = await jwtVerify2(token, this.getJWKS(), {
        issuer: this.issuer,
        audience: this.config.audience
      });
      return result;
    } catch (error2) {
      throw new Error(`Auth0 JWT verification failed: ${error2}`);
    }
  }
  getUserInfo(payload) {
    const scope = payload.scope;
    return {
      userId: payload.sub,
      email: payload.email,
      name: payload.name,
      username: payload.username,
      nickname: payload.nickname,
      picture: payload.picture,
      // Auth0 includes permissions directly in the token
      permissions: payload.permissions || [],
      // Auth0 can include roles (if configured)
      roles: payload.roles || payload["https://your-app.com/roles"] || [],
      // Include scope as well
      scopes: scope ? scope.split(" ") : [],
      // Additional Auth0-specific claims
      email_verified: payload.email_verified,
      updated_at: payload.updated_at
    };
  }
  getIssuer() {
    return this.issuer;
  }
  getAuthEndpoint() {
    return `${this.issuer}/authorize`;
  }
  getTokenEndpoint() {
    return `${this.issuer}/oauth/token`;
  }
  getScopesSupported() {
    return ["openid", "profile", "email", "offline_access"];
  }
  getGrantTypesSupported() {
    return ["authorization_code", "refresh_token"];
  }
};

// src/server/oauth/providers/keycloak.ts
import { jwtVerify as jwtVerify3, createRemoteJWKSet as createRemoteJWKSet3 } from "jose";
var KeycloakOAuthProvider = class {
  static {
    __name(this, "KeycloakOAuthProvider");
  }
  config;
  issuer;
  jwks = null;
  constructor(config) {
    this.config = config;
    const serverUrl = config.serverUrl.replace(/\/$/, "");
    this.issuer = `${serverUrl}/realms/${config.realm}`;
  }
  getJWKS() {
    if (!this.jwks) {
      this.jwks = createRemoteJWKSet3(
        new URL(`${this.issuer}/protocol/openid-connect/certs`)
      );
    }
    return this.jwks;
  }
  async verifyToken(token) {
    if (this.config.verifyJwt === false) {
      console.warn("[Keycloak OAuth] \u26A0\uFE0F  JWT verification is disabled");
      console.warn(
        "[Keycloak OAuth]     Enable verifyJwt: true for production"
      );
      const parts = token.split(".");
      if (parts.length !== 3) {
        throw new Error("Invalid JWT format");
      }
      const payload = JSON.parse(
        Buffer.from(parts[1], "base64url").toString("utf8")
      );
      return { payload };
    }
    try {
      const result = await jwtVerify3(token, this.getJWKS(), {
        issuer: this.issuer,
        // Don't verify audience if not specified
        ...this.config.clientId && { audience: this.config.clientId }
      });
      return result;
    } catch (error2) {
      throw new Error(`Keycloak JWT verification failed: ${error2}`);
    }
  }
  getUserInfo(payload) {
    const realmAccess = payload.realm_access;
    const realmRoles = realmAccess?.roles || [];
    const resourceAccess = payload.resource_access;
    const clientRoles = this.config.clientId && (resourceAccess?.[this.config.clientId]?.roles || []) || [];
    const allRoles = [...realmRoles, ...clientRoles];
    const permissions = [];
    if (payload.resource_access) {
      Object.entries(payload.resource_access).forEach(
        ([resource2, access]) => {
          if (access.roles) {
            access.roles.forEach((role) => {
              permissions.push(`${resource2}:${role}`);
            });
          }
        }
      );
    }
    const scope = payload.scope;
    return {
      userId: payload.sub,
      email: payload.email,
      name: payload.name,
      username: payload.preferred_username,
      nickname: payload.preferred_username,
      picture: payload.picture,
      roles: allRoles,
      permissions,
      // Include scope as well
      scopes: scope ? scope.split(" ") : [],
      // Keycloak-specific claims
      email_verified: payload.email_verified,
      given_name: payload.given_name,
      family_name: payload.family_name,
      realm_access: payload.realm_access,
      resource_access: payload.resource_access
    };
  }
  getIssuer() {
    return this.issuer;
  }
  getAuthEndpoint() {
    return `${this.issuer}/protocol/openid-connect/auth`;
  }
  getTokenEndpoint() {
    return `${this.issuer}/protocol/openid-connect/token`;
  }
  getScopesSupported() {
    return ["openid", "profile", "email", "offline_access", "roles"];
  }
  getGrantTypesSupported() {
    return ["authorization_code", "refresh_token", "client_credentials"];
  }
};

// src/server/oauth/providers/workos.ts
import { jwtVerify as jwtVerify4, createRemoteJWKSet as createRemoteJWKSet4, decodeJwt as decodeJwt2 } from "jose";
var WorkOSOAuthProvider = class {
  static {
    __name(this, "WorkOSOAuthProvider");
  }
  config;
  issuer;
  jwks = null;
  constructor(config) {
    this.config = config;
    this.issuer = `https://${config.subdomain}`;
  }
  getJWKS() {
    if (!this.jwks) {
      this.jwks = createRemoteJWKSet4(new URL(`${this.issuer}/oauth2/jwks`));
    }
    return this.jwks;
  }
  async verifyToken(token) {
    if (this.config.verifyJwt === false) {
      console.warn("[WorkOS OAuth] \u26A0\uFE0F  JWT verification is disabled");
      console.warn("[WorkOS OAuth]     Enable verifyJwt: true for production");
      const parts = token.split(".");
      if (parts.length !== 3) {
        throw new Error("Invalid JWT format");
      }
      const payload = decodeJwt2(token);
      return { payload };
    }
    try {
      const result = await jwtVerify4(token, this.getJWKS(), {
        issuer: this.issuer
      });
      return result;
    } catch (error2) {
      throw new Error(`WorkOS JWT verification failed: ${error2}`);
    }
  }
  getUserInfo(payload) {
    return {
      userId: payload.sub,
      email: payload.email,
      name: payload.name,
      username: payload.preferred_username,
      picture: payload.picture,
      // WorkOS includes permissions and roles in token
      permissions: payload.permissions || [],
      roles: payload.roles || [],
      // Include scope as well
      scopes: payload.scope ? payload.scope.split(" ") : [],
      // Additional WorkOS-specific claims
      email_verified: payload.email_verified,
      organization_id: payload.org_id,
      sid: payload.sid
      // Session ID
    };
  }
  getIssuer() {
    return this.issuer;
  }
  getAuthEndpoint() {
    return `${this.issuer}/oauth2/authorize`;
  }
  getTokenEndpoint() {
    return `${this.issuer}/oauth2/token`;
  }
  getScopesSupported() {
    return ["email", "offline_access", "openid", "profile"];
  }
  getGrantTypesSupported() {
    return ["authorization_code", "refresh_token"];
  }
  getMode() {
    return "proxy";
  }
  getRegistrationEndpoint() {
    if (this.config.clientId) {
      return void 0;
    }
    return `${this.issuer}/oauth2/register`;
  }
};

// src/server/oauth/providers/custom.ts
var CustomOAuthProvider = class {
  static {
    __name(this, "CustomOAuthProvider");
  }
  config;
  constructor(config) {
    this.config = config;
  }
  async verifyToken(token) {
    try {
      const result = await this.config.verifyToken(token);
      return result;
    } catch (error2) {
      throw new Error(`Custom OAuth verification failed: ${error2}`);
    }
  }
  getUserInfo(payload) {
    if (this.config.getUserInfo) {
      return this.config.getUserInfo(payload);
    }
    const scope = payload.scope;
    const roles = payload.roles;
    const permissions = payload.permissions;
    return {
      userId: payload.sub || payload.user_id || payload.id,
      email: payload.email ? payload.email : void 0,
      name: payload.name ? payload.name : void 0,
      username: payload.username || payload.preferred_username ? payload.username || payload.preferred_username : void 0,
      nickname: payload.nickname ? payload.nickname : void 0,
      picture: payload.picture || payload.avatar_url ? payload.picture || payload.avatar_url : void 0,
      roles: Array.isArray(roles) ? roles : [],
      permissions: Array.isArray(permissions) ? permissions : [],
      scopes: scope ? scope.split(" ") : []
    };
  }
  getIssuer() {
    return this.config.issuer;
  }
  getAuthEndpoint() {
    return this.config.authEndpoint;
  }
  getTokenEndpoint() {
    return this.config.tokenEndpoint;
  }
  getScopesSupported() {
    return this.config.scopesSupported || ["openid", "profile", "email"];
  }
  getGrantTypesSupported() {
    return this.config.grantTypesSupported || ["authorization_code", "refresh_token"];
  }
};

// src/server/oauth/providers.ts
function oauthSupabaseProvider(config = {}) {
  const projectId = config.projectId ?? getEnv("MCP_USE_OAUTH_SUPABASE_PROJECT_ID");
  const jwtSecret = config.jwtSecret ?? getEnv("MCP_USE_OAUTH_SUPABASE_JWT_SECRET");
  if (!projectId) {
    throw new Error(
      "Supabase projectId is required. Set MCP_USE_OAUTH_SUPABASE_PROJECT_ID environment variable or pass projectId in config."
    );
  }
  return new SupabaseOAuthProvider({
    provider: "supabase",
    projectId,
    jwtSecret,
    skipVerification: config.skipVerification
  });
}
__name(oauthSupabaseProvider, "oauthSupabaseProvider");
function oauthAuth0Provider(config = {}) {
  const domain = config.domain ?? getEnv("MCP_USE_OAUTH_AUTH0_DOMAIN");
  const audience = config.audience ?? getEnv("MCP_USE_OAUTH_AUTH0_AUDIENCE");
  if (!domain) {
    throw new Error(
      "Auth0 domain is required. Set MCP_USE_OAUTH_AUTH0_DOMAIN environment variable or pass domain in config."
    );
  }
  if (!audience) {
    throw new Error(
      "Auth0 audience is required. Set MCP_USE_OAUTH_AUTH0_AUDIENCE environment variable or pass audience in config."
    );
  }
  return new Auth0OAuthProvider({
    provider: "auth0",
    domain,
    audience,
    verifyJwt: config.verifyJwt
  });
}
__name(oauthAuth0Provider, "oauthAuth0Provider");
function oauthKeycloakProvider(config = {}) {
  const serverUrl = config.serverUrl ?? getEnv("MCP_USE_OAUTH_KEYCLOAK_SERVER_URL");
  const realm = config.realm ?? getEnv("MCP_USE_OAUTH_KEYCLOAK_REALM");
  const clientId = config.clientId ?? getEnv("MCP_USE_OAUTH_KEYCLOAK_CLIENT_ID");
  if (!serverUrl) {
    throw new Error(
      "Keycloak serverUrl is required. Set MCP_USE_OAUTH_KEYCLOAK_SERVER_URL environment variable or pass serverUrl in config."
    );
  }
  if (!realm) {
    throw new Error(
      "Keycloak realm is required. Set MCP_USE_OAUTH_KEYCLOAK_REALM environment variable or pass realm in config."
    );
  }
  return new KeycloakOAuthProvider({
    provider: "keycloak",
    serverUrl,
    realm,
    clientId,
    verifyJwt: config.verifyJwt
  });
}
__name(oauthKeycloakProvider, "oauthKeycloakProvider");
function oauthWorkOSProvider(config = {}) {
  const subdomain = config.subdomain ?? getEnv("MCP_USE_OAUTH_WORKOS_SUBDOMAIN");
  const clientId = config.clientId ?? getEnv("MCP_USE_OAUTH_WORKOS_CLIENT_ID");
  const apiKey = config.apiKey ?? getEnv("MCP_USE_OAUTH_WORKOS_API_KEY");
  if (!subdomain) {
    throw new Error(
      "WorkOS subdomain is required. Set MCP_USE_OAUTH_WORKOS_SUBDOMAIN environment variable or pass subdomain in config."
    );
  }
  if (clientId) {
    console.log("[WorkOS OAuth] Using pre-registered OAuth client mode");
    console.log(`[WorkOS OAuth]   - Client ID: ${clientId}`);
    console.log(
      "[WorkOS OAuth]   - Make sure this client exists in WorkOS Dashboard"
    );
    console.log(
      "[WorkOS OAuth]   - Configure redirect URIs to match your MCP client"
    );
  } else {
    console.log("[WorkOS OAuth] Using Dynamic Client Registration (DCR) mode");
    console.log(
      "[WorkOS OAuth]   - MCP clients will register themselves automatically"
    );
    console.log(
      "[WorkOS OAuth]   - Make sure DCR is enabled in WorkOS Dashboard"
    );
  }
  return new WorkOSOAuthProvider({
    provider: "workos",
    subdomain,
    clientId,
    apiKey,
    verifyJwt: config.verifyJwt
  });
}
__name(oauthWorkOSProvider, "oauthWorkOSProvider");
function oauthCustomProvider(config) {
  return new CustomOAuthProvider({
    provider: "custom",
    ...config
  });
}
__name(oauthCustomProvider, "oauthCustomProvider");

// src/server/oauth/utils.ts
function getAuth(context) {
  return context.get("auth");
}
__name(getAuth, "getAuth");
function hasScope(context, needed) {
  const { scopes, permissions } = getAuth(context);
  const requiredScopes = Array.isArray(needed) ? needed : [needed];
  return requiredScopes.every(
    (scope) => scopes.includes(scope) || permissions.includes(scope)
  );
}
__name(hasScope, "hasScope");
function hasAnyScope(context, needed) {
  const { scopes, permissions } = getAuth(context);
  return needed.some(
    (scope) => scopes.includes(scope) || permissions.includes(scope)
  );
}
__name(hasAnyScope, "hasAnyScope");
function requireScope(needed) {
  return async (c, next) => {
    if (!hasScope(c, needed)) {
      const { scopes, permissions } = getAuth(c);
      const requiredScopes = Array.isArray(needed) ? needed : [needed];
      return c.json(
        {
          error: "insufficient_scope",
          required: requiredScopes,
          granted_scopes: scopes,
          granted_permissions: permissions,
          message: `Missing required scope(s): ${requiredScopes.join(", ")}`
        },
        403
      );
    }
    await next();
  };
}
__name(requireScope, "requireScope");
function requireAnyScope(needed) {
  return async (c, next) => {
    if (!hasAnyScope(c, needed)) {
      const { scopes, permissions } = getAuth(c);
      return c.json(
        {
          error: "insufficient_scope",
          required_any: needed,
          granted_scopes: scopes,
          granted_permissions: permissions,
          message: `Missing at least one required scope from: ${needed.join(", ")}`
        },
        403
      );
    }
    await next();
  };
}
__name(requireAnyScope, "requireAnyScope");

// src/server/index.ts
import {
  RESOURCE_MIME_TYPE,
  RESOURCE_URI_META_KEY
} from "@modelcontextprotocol/ext-apps/server";

// src/server/middleware/mcp-proxy.ts
import { cors as cors3 } from "hono/cors";
import { logger } from "hono/logger";
function mountMcpProxy(app, options = {}) {
  const basePath = options.path || "/mcp/proxy";
  const enableLogging = options.enableLogging !== false;
  app.use(
    `${basePath}/*`,
    cors3({
      origin: "*",
      exposeHeaders: ["*"]
      // Expose all headers including Mcp-Session-Id for FastMCP
    })
  );
  if (enableLogging) {
    app.use(`${basePath}/*`, logger());
  }
  app.all(`${basePath}/*`, async (c) => {
    try {
      if (options.authenticate) {
        const isAuthenticated = await options.authenticate(c);
        if (!isAuthenticated) {
          return c.json({ error: "Unauthorized" }, 401);
        }
      }
      const url = new URL(c.req.url);
      const targetFromQuery = url.searchParams.get("__mcp_target");
      let targetUrl;
      if (targetFromQuery) {
        const requestPath = url.pathname.replace(basePath, "");
        targetUrl = targetFromQuery + requestPath;
      } else {
        targetUrl = c.req.header("X-Target-URL");
      }
      if (!targetUrl) {
        return c.json(
          {
            error: "X-Target-URL header is required",
            usage: "Set X-Target-URL header to the MCP server URL you want to proxy to"
          },
          400
        );
      }
      if (options.validateRequest) {
        const isValid = await options.validateRequest(targetUrl, c);
        if (!isValid) {
          return c.json(
            {
              error: "Invalid target URL",
              details: "The requested target URL is not allowed"
            },
            403
          );
        }
      }
      try {
        new URL(targetUrl);
      } catch {
        return c.json(
          {
            error: "Invalid target URL format",
            details: "The X-Target-URL must be a valid HTTP/HTTPS URL"
          },
          400
        );
      }
      const method = c.req.method;
      const headers = {};
      const requestHeaders = c.req.header();
      for (const [key, value] of Object.entries(requestHeaders)) {
        const lowerKey = key.toLowerCase();
        if (!lowerKey.startsWith("x-proxy-") && !lowerKey.startsWith("x-target-") && lowerKey !== "host" && lowerKey !== "accept-encoding") {
          headers[key] = value;
        }
      }
      headers["Accept-Encoding"] = "identity";
      try {
        const targetUrlObj = new URL(targetUrl);
        headers.Host = targetUrlObj.host;
      } catch {
        return c.json({ error: "Invalid target URL" }, 400);
      }
      const body = method !== "GET" && method !== "HEAD" ? new Uint8Array(await c.req.arrayBuffer()).slice() : void 0;
      const response = await fetch(targetUrl, {
        method,
        headers,
        body,
        redirect: "manual"
      });
      if (response.status >= 300 && response.status < 400) {
        const location = response.headers.get("location");
        if (location) {
          const redirectResponse = await fetch(location, {
            method,
            headers,
            body,
            redirect: "manual"
          });
          const redirectHeaders = {};
          redirectResponse.headers.forEach((value, key) => {
            const lowerKey = key.toLowerCase();
            if (lowerKey !== "content-encoding" && lowerKey !== "transfer-encoding" && lowerKey !== "content-length") {
              redirectHeaders[key] = value;
            }
          });
          return new Response(redirectResponse.body, {
            status: redirectResponse.status,
            statusText: redirectResponse.statusText,
            headers: redirectHeaders
          });
        }
      }
      const responseHeaders = {};
      response.headers.forEach((value, key) => {
        const lowerKey = key.toLowerCase();
        if (lowerKey !== "content-encoding" && lowerKey !== "transfer-encoding" && lowerKey !== "content-length") {
          responseHeaders[key] = value;
        }
      });
      const contentType = response.headers.get("content-type") || "";
      const isOAuthDiscovery = url.pathname.includes("/.well-known/oauth") && contentType.includes("application/json");
      if (isOAuthDiscovery && response.body) {
        const bodyText = await response.text();
        try {
          const bodyJson = JSON.parse(bodyText);
          const proxyOrigin = new URL(c.req.url).origin;
          if (bodyJson.resource) {
            bodyJson.resource = `${proxyOrigin}${basePath}`;
          }
          return new Response(JSON.stringify(bodyJson), {
            status: response.status,
            statusText: response.statusText,
            headers: responseHeaders
          });
        } catch {
          return new Response(bodyText, {
            status: response.status,
            statusText: response.statusText,
            headers: responseHeaders
          });
        }
      }
      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers: responseHeaders
      });
    } catch (error2) {
      const message = error2 instanceof Error ? error2.message : "Unknown error";
      const url = new URL(c.req.url);
      const targetFromQuery = url.searchParams.get("__mcp_target");
      const targetUrl = targetFromQuery ? targetFromQuery + url.pathname.replace(basePath, "") : c.req.header("X-Target-URL");
      const isConnectionRefused = error2 instanceof Error && (error2.message.includes("ECONNREFUSED") || error2.message.includes("fetch failed"));
      if (isConnectionRefused) {
        console.warn(
          `[MCP Proxy] Connection refused to ${targetUrl || "unknown target"} - server may not be running`
        );
      } else {
        console.error(
          "[MCP Proxy] Request failed:",
          message,
          "\nTarget URL:",
          targetUrl || "unknown",
          "\nError:",
          error2
        );
      }
      return c.json(
        {
          error: "Proxy request failed",
          details: message,
          targetUrl: targetUrl || "unknown"
        },
        500
      );
    }
  });
}
__name(mountMcpProxy, "mountMcpProxy");

// src/server/oauth/proxy.ts
import { cors as cors4 } from "hono/cors";
function mountOAuthProxy(app, options = {}) {
  const {
    basePath = "/oauth",
    enableLogging = true,
    authenticate,
    validateTarget
  } = options;
  app.use(
    `${basePath}/*`,
    cors4({
      origin: "*",
      allowMethods: ["GET", "POST", "OPTIONS"],
      allowHeaders: ["*"],
      exposeHeaders: ["*"],
      maxAge: 86400
    })
  );
  app.get(`${basePath}/metadata`, async (c) => {
    try {
      if (authenticate) {
        const isAuthenticated = await authenticate(c);
        if (!isAuthenticated) {
          return c.json({ error: "Unauthorized" }, 401);
        }
      }
      const url = c.req.query("url");
      if (!url) {
        return c.json({ error: "Missing url parameter" }, 400);
      }
      let metadataUrl;
      try {
        metadataUrl = new URL(url);
        if (metadataUrl.protocol !== "https:" && metadataUrl.protocol !== "http:") {
          return c.json({ error: "Invalid protocol" }, 400);
        }
      } catch {
        return c.json({ error: "Invalid URL format" }, 400);
      }
      if (validateTarget) {
        const isValid = await validateTarget(url, c);
        if (!isValid) {
          return c.json({ error: "Target URL not allowed" }, 403);
        }
      }
      if (enableLogging) {
        console.log(`[OAuth Proxy] Fetching metadata: ${url}`);
      }
      let response = null;
      let discoveredFromWWWAuth = false;
      if (url.includes("/.well-known/oauth-protected-resource")) {
        const mcpServerUrl = c.req.query("mcp_url");
        if (mcpServerUrl) {
          try {
            if (enableLogging) {
              console.log(
                `[OAuth Proxy] Attempting metadata discovery from WWW-Authenticate header for: ${mcpServerUrl}`
              );
            }
            const mcpResponse = await fetch(mcpServerUrl, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
              },
              // Send minimal MCP request to trigger 401 with WWW-Authenticate
              body: JSON.stringify({
                jsonrpc: "2.0",
                method: "initialize",
                id: 1
              })
            });
            const wwwAuth = mcpResponse.headers.get("WWW-Authenticate");
            if (wwwAuth) {
              if (enableLogging) {
                console.log(
                  `[OAuth Proxy] WWW-Authenticate header: ${wwwAuth}`
                );
              }
              const resourceMetadataMatch = wwwAuth.match(
                /resource_metadata="([^"]+)"/
              );
              if (resourceMetadataMatch && resourceMetadataMatch[1]) {
                const discoveredMetadataUrl = resourceMetadataMatch[1];
                if (enableLogging) {
                  console.log(
                    `[OAuth Proxy] Discovered metadata URL from WWW-Authenticate: ${discoveredMetadataUrl}`
                  );
                }
                response = await fetch(discoveredMetadataUrl, {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent": "mcp-use/1.0"
                  }
                });
                if (response.ok) {
                  discoveredFromWWWAuth = true;
                  if (enableLogging) {
                    console.log(
                      `[OAuth Proxy] Successfully fetched metadata from discovered URL`
                    );
                  }
                }
              }
            }
          } catch (discoveryError) {
            if (enableLogging) {
              console.log(
                `[OAuth Proxy] WWW-Authenticate discovery failed, falling back to standard path:`,
                discoveryError instanceof Error ? discoveryError.message : discoveryError
              );
            }
          }
        }
      }
      if (!response || !response.ok) {
        if (enableLogging && !discoveredFromWWWAuth) {
          console.log(`[OAuth Proxy] Trying standard metadata path: ${url}`);
        }
        response = await fetch(metadataUrl.toString(), {
          method: "GET",
          headers: {
            Accept: "application/json",
            "User-Agent": "mcp-use/1.0"
          }
        });
      }
      if (!response.ok) {
        if (enableLogging) {
          console.error(
            `[OAuth Proxy] Metadata fetch failed: ${response.status} ${response.statusText}`
          );
        }
        return c.json(
          {
            error: `Failed to fetch OAuth metadata: ${response.status} ${response.statusText}`
          },
          response.status
        );
      }
      let metadata = await response.json();
      if (metadata.resource && metadata.authorization_servers) {
        let connectionUrl = c.req.header("X-Connection-URL");
        if (!connectionUrl) {
          const requestUrl = new URL(c.req.url);
          let clientProtocol = requestUrl.protocol.replace(":", "");
          const xForwardedProto = c.req.header("X-Forwarded-Proto");
          if (xForwardedProto) {
            clientProtocol = xForwardedProto.split(",")[0].trim();
          }
          let clientHost = requestUrl.host;
          const xForwardedHost = c.req.header("X-Forwarded-Host");
          if (xForwardedHost) {
            clientHost = xForwardedHost.split(",")[0].trim();
          }
          const pathParts = requestUrl.pathname.split("/");
          const oauthIndex = pathParts.findIndex((part) => part === "oauth");
          if (oauthIndex > 0) {
            const basePath2 = pathParts.slice(0, oauthIndex).join("/");
            connectionUrl = `${clientProtocol}://${clientHost}${basePath2}/proxy`;
          }
        }
        if (connectionUrl) {
          metadata = {
            ...metadata,
            resource: connectionUrl,
            // SDK validation requires this to match connection URL
            _original_resource: metadata.resource
            // Store original for client to use in OAuth request
          };
          if (enableLogging) {
            console.log(
              `[OAuth Proxy] Rewrote resource field to ${connectionUrl} for SDK validation (original: ${metadata._original_resource})`
            );
          }
        }
      }
      return c.json(metadata);
    } catch (error2) {
      const message = error2 instanceof Error ? error2.message : "Unknown error";
      if (enableLogging) {
        console.error("[OAuth Proxy] Metadata error:", message);
      }
      return c.json(
        {
          error: "OAuth metadata proxy failed",
          details: message
        },
        500
      );
    }
  });
  app.post(`${basePath}/proxy`, async (c) => {
    try {
      if (authenticate) {
        const isAuthenticated = await authenticate(c);
        if (!isAuthenticated) {
          return c.json({ error: "Unauthorized" }, 401);
        }
      }
      const {
        url,
        method = "GET",
        body,
        headers: customHeaders
      } = await c.req.json();
      if (!url) {
        return c.json({ error: "Missing url parameter" }, 400);
      }
      let targetUrl;
      try {
        targetUrl = new URL(url);
        if (targetUrl.protocol !== "https:" && targetUrl.protocol !== "http:") {
          return c.json({ error: "Invalid protocol" }, 400);
        }
      } catch {
        return c.json({ error: "Invalid URL format" }, 400);
      }
      if (validateTarget) {
        const isValid = await validateTarget(url, c);
        if (!isValid) {
          return c.json({ error: "Target URL not allowed" }, 403);
        }
      }
      if (enableLogging) {
        console.log(`[OAuth Proxy] ${method} ${url}`);
      }
      const requestHeaders = {
        "User-Agent": "mcp-use/1.0",
        ...customHeaders
      };
      const contentType = customHeaders?.["Content-Type"] || customHeaders?.["content-type"];
      const isFormUrlEncoded = contentType?.includes(
        "application/x-www-form-urlencoded"
      );
      if (method === "POST" && body && !contentType) {
        requestHeaders["Content-Type"] = "application/json";
      }
      const fetchOptions = {
        method,
        headers: requestHeaders
      };
      if (method === "POST" && body) {
        if (isFormUrlEncoded && typeof body === "object") {
          const params = new URLSearchParams();
          for (const [key, value] of Object.entries(body)) {
            params.append(key, String(value));
          }
          fetchOptions.body = params.toString();
        } else if (typeof body === "string") {
          fetchOptions.body = body;
        } else {
          fetchOptions.body = JSON.stringify(body);
        }
      }
      const response = await fetch(targetUrl.toString(), fetchOptions);
      const headers = {};
      response.headers.forEach((value, key) => {
        headers[key] = value;
      });
      let responseBody = null;
      const contentTypeHeader = headers["content-type"] || "";
      if (contentTypeHeader.includes("application/json")) {
        try {
          responseBody = await response.json();
        } catch {
          responseBody = await response.text();
        }
      } else {
        try {
          responseBody = await response.text();
        } catch {
          responseBody = null;
        }
      }
      return c.json({
        status: response.status,
        statusText: response.statusText,
        headers,
        body: responseBody
      });
    } catch (error2) {
      const message = error2 instanceof Error ? error2.message : "Unknown error";
      if (enableLogging) {
        console.error("[OAuth Proxy] Request error:", message);
      }
      return c.json(
        {
          error: "OAuth proxy request failed",
          details: message
        },
        500
      );
    }
  });
  if (enableLogging) {
    console.log(
      `[OAuth Proxy] Mounted OAuth proxy routes at ${basePath}/metadata and ${basePath}/proxy`
    );
  }
}
__name(mountOAuthProxy, "mountOAuthProxy");
export {
  AppsSdkAdapter,
  FileSystemSessionStore,
  InMemorySessionStore,
  InMemoryStreamManager,
  MCPServer,
  McpAppsAdapter,
  RESOURCE_MIME_TYPE,
  RESOURCE_URI_META_KEY,
  RedisSessionStore,
  RedisStreamManager,
  VERSION,
  adaptConnectMiddleware,
  adaptMiddleware,
  array,
  audio,
  binary,
  buildWidgetUrl,
  completable,
  createExternalUrlResource,
  createMCPServer,
  createMcpAppsResource,
  createRawHtmlResource,
  createRemoteDomResource,
  createUIResourceFromDefinition,
  css,
  enumSchema,
  error,
  generateLandingPage,
  generateToolRegistryTypes,
  getAuth,
  getPackageVersion,
  getRequestContext,
  hasAnyScope,
  hasRequestContext,
  hasScope,
  html,
  image,
  isExpressMiddleware,
  javascript,
  legacyEnum,
  markdown,
  mix,
  mountMcpProxy,
  mountOAuthProxy,
  oauthAuth0Provider,
  oauthCustomProvider,
  oauthKeycloakProvider,
  oauthSupabaseProvider,
  oauthWorkOSProvider,
  object,
  requireAnyScope,
  requireScope,
  resource,
  runWithContext,
  text,
  titledEnum,
  titledMultiEnum,
  untitledEnum,
  untitledMultiEnum,
  widget,
  xml
};
