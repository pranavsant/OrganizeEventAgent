import type { ResourceDefinition, ReadResourceCallback, ResourceDefinitionWithoutCallback, ResourceTemplateDefinitionWithoutCallback, FlatResourceTemplateDefinition, FlatResourceTemplateDefinitionWithoutCallback, ResourceTemplateDefinition, EnhancedResourceContext } from "../types/index.js";
import { ResourceTemplate } from "@modelcontextprotocol/sdk/server/mcp.js";
import type { ReadResourceResult, CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import type { TypedCallToolResult } from "../utils/response-helpers.js";
export { ResourceSubscriptionManager } from "./subscriptions.js";
export interface ResourceServerContext {
    server: {
        registerResource(name: string, uri: string, metadata: {
            title?: string;
            description?: string;
            mimeType: string;
            _meta?: Record<string, unknown>;
        }, readCallback: () => Promise<ReadResourceResult>): void;
    };
    registeredResources: string[];
}
/**
 * Define a static resource that can be accessed by clients
 *
 * Registers a resource with the MCP server that clients can access via HTTP.
 * Resources are static content like files, data, or pre-computed results that
 * can be retrieved by clients without requiring parameters.
 *
 * Supports two patterns:
 * 1. Old API: Single object with readCallback property
 * 2. New API: Definition object + separate callback (like tools)
 *
 * @param resourceDefinition - Configuration object containing resource metadata
 * @param resourceDefinition.name - Unique identifier for the resource
 * @param resourceDefinition.uri - URI pattern for accessing the resource
 * @param resourceDefinition.title - Optional human-readable title for the resource
 * @param resourceDefinition.description - Optional description of the resource
 * @param resourceDefinition.mimeType - MIME type (optional when using callback with response helpers)
 * @param resourceDefinition.annotations - Optional annotations (audience, priority, lastModified)
 * @param callback - Optional separate callback function (new API pattern)
 * @returns The server instance for method chaining
 *
 * @example
 * ```typescript
 * // New API: Using response helpers (recommended)
 * server.resource(
 *   { name: 'greeting', uri: 'app://greeting', title: 'Greeting' },
 *   async () => text('Hello World!')
 * )
 *
 * server.resource(
 *   { name: 'config', uri: 'config://settings' },
 *   async () => object({ theme: 'dark', version: '1.0' })
 * )
 *
 * // Old API: Still supported for backward compatibility
 * server.resource({
 *   name: 'config',
 *   uri: 'config://app-settings',
 *   mimeType: 'application/json',
 *   readCallback: async () => ({
 *     contents: [{
 *       uri: 'config://app-settings',
 *       mimeType: 'application/json',
 *       text: JSON.stringify({ theme: 'dark' })
 *     }]
 *   })
 * })
 * ```
 */
export declare function registerResource(this: ResourceServerContext, resourceDefinition: ResourceDefinition | ResourceDefinitionWithoutCallback, callback?: ReadResourceCallback): ResourceServerContext;
export interface ResourceTemplateServerContext {
    server: {
        registerResource(name: string, template: ResourceTemplate, metadata: Record<string, unknown>, readCallback: (uri: URL) => Promise<ReadResourceResult>): void;
    };
    registeredResources: string[];
    parseTemplateUri(uriTemplate: string, uri: string): Record<string, string>;
}
/**
 * Define a dynamic resource template with parameters
 *
 * Registers a parameterized resource template with the MCP server. Templates use URI
 * patterns with placeholders that can be filled in at request time, allowing dynamic
 * resource generation based on parameters.
 *
 * Supports multiple API patterns:
 * 1. Flat structure (recommended): `uriTemplate` directly on definition
 * 2. Nested structure (legacy): `resourceTemplate.uriTemplate`
 * 3. Old API: Single object with readCallback property
 * 4. New API: Definition object + separate callback (like tools)
 *
 * The callback function supports multiple signatures for flexibility:
 * - `async () => ...` - No parameters (for static templates)
 * - `async (uri) => ...` - Just the URI
 * - `async (uri, params) => ...` - URI and extracted parameters
 * - `async (uri, params, ctx) => ...` - URI, parameters, and context (with auth, request, etc.)
 *
 * @param resourceTemplateDefinition - Configuration object for the resource template
 * @param resourceTemplateDefinition.name - Unique identifier for the template
 * @param resourceTemplateDefinition.uriTemplate - URI template (flat structure, recommended)
 * @param resourceTemplateDefinition.resourceTemplate - ResourceTemplate object (nested structure, legacy)
 * @param callback - Optional separate callback function (new API pattern)
 * @returns The server instance for method chaining
 *
 * @example
 * ```typescript
 * // Flat structure (recommended)
 * server.resourceTemplate({
 *   name: 'user',
 *   uriTemplate: 'user://{id}',
 *   title: 'User Profile'
 * }, async (uri, { id }) => object(await getUserData(id)))
 *
 * // Minimal signature - no parameters
 * server.resourceTemplate({
 *   name: 'static',
 *   uriTemplate: 'app://static'
 * }, async () => text('Static content'))
 *
 * // With context for auth/request access
 * server.resourceTemplate({
 *   name: 'private',
 *   uriTemplate: 'private://{id}'
 * }, async (uri, { id }, ctx) => {
 *   const user = ctx.auth;  // Access authenticated user
 *   return object(await getPrivateData(id, user));
 * })
 *
 * // Nested structure (legacy, still supported)
 * server.resourceTemplate({
 *   name: 'user-profile',
 *   resourceTemplate: {
 *     uriTemplate: 'user://{userId}/profile',
 *     mimeType: 'application/json'
 *   }
 * }, async (uri, { userId }) => object(await getUserData(userId)))
 * ```
 */
export declare function registerResourceTemplate<HasOAuth extends boolean = false>(this: ResourceTemplateServerContext, resourceTemplateDefinition: ResourceTemplateDefinition<HasOAuth> | ResourceTemplateDefinitionWithoutCallback | FlatResourceTemplateDefinition<HasOAuth> | FlatResourceTemplateDefinitionWithoutCallback, callback: (uri: URL, params: Record<string, any>) => Promise<CallToolResult | ReadResourceResult | TypedCallToolResult<any>>): ResourceTemplateServerContext;
export declare function registerResourceTemplate<HasOAuth extends boolean = false>(this: ResourceTemplateServerContext, resourceTemplateDefinition: ResourceTemplateDefinition<HasOAuth> | ResourceTemplateDefinitionWithoutCallback | FlatResourceTemplateDefinition<HasOAuth> | FlatResourceTemplateDefinitionWithoutCallback, callback: (uri: URL, params: Record<string, any>, ctx: EnhancedResourceContext<HasOAuth>) => Promise<CallToolResult | ReadResourceResult | TypedCallToolResult<any>>): ResourceTemplateServerContext;
//# sourceMappingURL=index.d.ts.map