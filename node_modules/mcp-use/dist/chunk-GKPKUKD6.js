import {
  logger
} from "./chunk-QWQYAQCK.js";
import {
  __name
} from "./chunk-3GQAWCBQ.js";

// src/task_managers/base.ts
var ConnectionManager = class {
  static {
    __name(this, "ConnectionManager");
  }
  _readyPromise;
  _readyResolver;
  _donePromise;
  _doneResolver;
  _exception = null;
  _connection = null;
  _task = null;
  _abortController = null;
  constructor() {
    this.reset();
  }
  /**
   * Start the connection manager and establish a connection.
   *
   * @returns The established connection.
   * @throws If the connection cannot be established.
   */
  async start() {
    this.reset();
    logger.debug(`Starting ${this.constructor.name}`);
    this._task = this.connectionTask();
    await this._readyPromise;
    if (this._exception) {
      throw this._exception;
    }
    if (this._connection === null) {
      throw new Error("Connection was not established");
    }
    return this._connection;
  }
  /**
   * Stop the connection manager and close the connection.
   */
  async stop() {
    if (this._task && this._abortController) {
      logger.debug(`Cancelling ${this.constructor.name} task`);
      this._abortController.abort();
      try {
        await this._task;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError") {
          logger.debug(`${this.constructor.name} task aborted successfully`);
        } else {
          logger.warn(`Error stopping ${this.constructor.name} task: ${e}`);
        }
      }
    }
    await this._donePromise;
    logger.debug(`${this.constructor.name} task completed`);
  }
  /**
   * Reset all internal state.
   */
  reset() {
    this._readyPromise = new Promise((res) => this._readyResolver = res);
    this._donePromise = new Promise((res) => this._doneResolver = res);
    this._exception = null;
    this._connection = null;
    this._task = null;
    this._abortController = new AbortController();
  }
  /**
   * The background task responsible for establishing and maintaining the
   * connection until it is cancelled.
   */
  async connectionTask() {
    logger.debug(`Running ${this.constructor.name} task`);
    try {
      this._connection = await this.establishConnection();
      logger.debug(`${this.constructor.name} connected successfully`);
      this._readyResolver();
      await this.waitForAbort();
    } catch (err) {
      this._exception = err;
      logger.error(`Error in ${this.constructor.name} task: ${err}`);
      this._readyResolver();
    } finally {
      if (this._connection !== null) {
        try {
          await this.closeConnection(this._connection);
        } catch (closeErr) {
          logger.warn(
            `Error closing connection in ${this.constructor.name}: ${closeErr}`
          );
        }
        this._connection = null;
      }
      this._doneResolver();
    }
  }
  /**
   * Helper that returns a promise which resolves when the abort signal fires.
   */
  async waitForAbort() {
    return new Promise((_resolve, _reject) => {
      if (!this._abortController) {
        return;
      }
      const signal = this._abortController.signal;
      if (signal.aborted) {
        _resolve();
        return;
      }
      const onAbort = /* @__PURE__ */ __name(() => {
        signal.removeEventListener("abort", onAbort);
        _resolve();
      }, "onAbort");
      signal.addEventListener("abort", onAbort);
    });
  }
};

export {
  ConnectionManager
};
