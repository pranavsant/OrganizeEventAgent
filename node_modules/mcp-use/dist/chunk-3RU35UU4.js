import {
  JSONSchemaToZod
} from "./chunk-RPN2XO5I.js";
import {
  logger
} from "./chunk-QWQYAQCK.js";
import {
  __name
} from "./chunk-3GQAWCBQ.js";

// src/adapters/base.ts
var BaseAdapter = class {
  static {
    __name(this, "BaseAdapter");
  }
  /**
   * List of tool names that should not be available.
   */
  disallowedTools;
  /**
   * Internal cache that maps a connector instance to the list of tools
   * generated for it.
   */
  connectorToolMap = /* @__PURE__ */ new Map();
  constructor(disallowedTools) {
    this.disallowedTools = disallowedTools ?? [];
  }
  /**
   * Create tools from an MCPClient instance.
   *
   * This is the recommended way to create tools from an MCPClient, as it handles
   * session creation and connector extraction automatically.
   *
   * @param client          The MCPClient to extract tools from.
   * @param disallowedTools Optional list of tool names to exclude.
   * @returns               A promise that resolves with a list of converted tools.
   */
  static async createTools(client, disallowedTools) {
    const adapter = new this(disallowedTools);
    if (!client.activeSessions || Object.keys(client.activeSessions).length === 0) {
      logger.info("No active sessions found, creating new ones...");
      await client.createAllSessions();
    }
    const sessions = client.getAllActiveSessions();
    const connectors = Object.values(sessions).map(
      (session) => session.connector
    );
    return adapter.createToolsFromConnectors(connectors);
  }
  /**
   * Dynamically load tools for a specific connector.
   *
   * @param connector The connector to load tools for.
   * @returns         The list of tools that were loaded in the target framework's format.
   */
  async loadToolsForConnector(connector) {
    if (this.connectorToolMap.has(connector)) {
      const cached = this.connectorToolMap.get(connector);
      logger.debug(`Returning ${cached.length} existing tools for connector`);
      return cached;
    }
    const connectorTools = [];
    const success = await this.ensureConnectorInitialized(connector);
    if (!success) {
      return [];
    }
    for (const tool of connector.tools) {
      const converted = this.convertTool(tool, connector);
      if (converted) {
        connectorTools.push(converted);
      }
    }
    this.connectorToolMap.set(connector, connectorTools);
    logger.debug(
      `Loaded ${connectorTools.length} new tools for connector: ${connectorTools.map((t) => t?.name ?? String(t)).join(", ")}`
    );
    return connectorTools;
  }
  /**
   * Create tools from MCP tools in all provided connectors.
   *
   * @param connectors List of MCP connectors to create tools from.
   * @returns         A promise that resolves with all converted tools.
   */
  async createToolsFromConnectors(connectors) {
    const tools = [];
    for (const connector of connectors) {
      const connectorTools = await this.loadToolsForConnector(connector);
      tools.push(...connectorTools);
    }
    logger.debug(`Available tools: ${tools.length}`);
    return tools;
  }
  /**
   * Dynamically load resources for a specific connector.
   *
   * @param connector The connector to load resources for.
   * @returns         The list of resources that were loaded in the target framework's format.
   */
  async loadResourcesForConnector(connector) {
    const connectorResources = [];
    const success = await this.ensureConnectorInitialized(connector);
    if (!success) {
      return [];
    }
    try {
      const resourcesResult = await connector.listAllResources();
      const resources = resourcesResult?.resources || [];
      if (this.convertResource) {
        for (const resource of resources) {
          const converted = this.convertResource(resource, connector);
          if (converted) {
            connectorResources.push(converted);
          }
        }
      }
      logger.debug(
        `Loaded ${connectorResources.length} new resources for connector: ${connectorResources.map((r) => r?.name ?? String(r)).join(", ")}`
      );
    } catch (err) {
      logger.warn(`Error loading resources for connector: ${err}`);
    }
    return connectorResources;
  }
  /**
   * Dynamically load prompts for a specific connector.
   *
   * @param connector The connector to load prompts for.
   * @returns         The list of prompts that were loaded in the target framework's format.
   */
  async loadPromptsForConnector(connector) {
    const connectorPrompts = [];
    const success = await this.ensureConnectorInitialized(connector);
    if (!success) {
      return [];
    }
    try {
      const promptsResult = await connector.listPrompts();
      const prompts = promptsResult?.prompts || [];
      if (this.convertPrompt) {
        for (const prompt of prompts) {
          const converted = this.convertPrompt(prompt, connector);
          if (converted) {
            connectorPrompts.push(converted);
          }
        }
      }
      logger.debug(
        `Loaded ${connectorPrompts.length} new prompts for connector: ${connectorPrompts.map((p) => p?.name ?? String(p)).join(", ")}`
      );
    } catch (err) {
      logger.warn(`Error loading prompts for connector: ${err}`);
    }
    return connectorPrompts;
  }
  /**
   * Create resources from MCP resources in all provided connectors.
   *
   * @param connectors List of MCP connectors to create resources from.
   * @returns         A promise that resolves with all converted resources.
   */
  async createResourcesFromConnectors(connectors) {
    const resources = [];
    for (const connector of connectors) {
      const connectorResources = await this.loadResourcesForConnector(connector);
      resources.push(...connectorResources);
    }
    logger.debug(`Available resources: ${resources.length}`);
    return resources;
  }
  /**
   * Create prompts from MCP prompts in all provided connectors.
   *
   * @param connectors List of MCP connectors to create prompts from.
   * @returns         A promise that resolves with all converted prompts.
   */
  async createPromptsFromConnectors(connectors) {
    const prompts = [];
    for (const connector of connectors) {
      const connectorPrompts = await this.loadPromptsForConnector(connector);
      prompts.push(...connectorPrompts);
    }
    logger.debug(`Available prompts: ${prompts.length}`);
    return prompts;
  }
  /**
   * Check if a connector is initialized and has tools.
   *
   * @param connector The connector to check.
   * @returns         True if the connector is initialized and has tools, false otherwise.
   */
  checkConnectorInitialized(connector) {
    return Boolean(connector.tools && connector.tools.length);
  }
  /**
   * Ensure a connector is initialized.
   *
   * @param connector The connector to initialize.
   * @returns         True if initialization succeeded, false otherwise.
   */
  async ensureConnectorInitialized(connector) {
    if (!this.checkConnectorInitialized(connector)) {
      logger.debug("Connector doesn't have tools, initializing it");
      try {
        await connector.initialize();
        return true;
      } catch (err) {
        logger.error(`Error initializing connector: ${err}`);
        return false;
      }
    }
    return true;
  }
};

// src/adapters/langchain_adapter.ts
import { DynamicStructuredTool } from "@langchain/core/tools";
import { z } from "zod";
function schemaToZod(schema) {
  try {
    return JSONSchemaToZod.convert(schema);
  } catch (err) {
    logger.warn(`Failed to convert JSON schema to Zod: ${err}`);
    return z.any();
  }
}
__name(schemaToZod, "schemaToZod");
var LangChainAdapter = class extends BaseAdapter {
  static {
    __name(this, "LangChainAdapter");
  }
  constructor(disallowedTools = []) {
    super(disallowedTools);
  }
  /**
   * Convert a single MCP tool specification into a LangChainJS structured tool.
   */
  convertTool(mcpTool, connector) {
    if (this.disallowedTools.includes(mcpTool.name)) {
      return null;
    }
    const argsSchema = mcpTool.inputSchema ? schemaToZod(mcpTool.inputSchema) : z.object({}).optional();
    const tool = new DynamicStructuredTool({
      name: mcpTool.name ?? "NO NAME",
      description: mcpTool.description ?? "",
      // Blank is acceptable but discouraged.
      schema: argsSchema,
      func: /* @__PURE__ */ __name(async (input) => {
        logger.debug(
          `MCP tool "${mcpTool.name}" received input: ${JSON.stringify(input)}`
        );
        try {
          const result = await connector.callTool(
            mcpTool.name,
            input
          );
          return JSON.stringify(result);
        } catch (err) {
          logger.error(`Error executing MCP tool: ${err.message}`);
          return `Error executing MCP tool: ${String(err)}`;
        }
      }, "func")
    });
    return tool;
  }
  /**
   * Convert a single MCP resource into a LangChainJS structured tool.
   * Each resource becomes an async tool that returns its content when called.
   */
  convertResource(mcpResource, connector) {
    const sanitizeName = /* @__PURE__ */ __name((name) => {
      return name.replace(/[^A-Za-z0-9_]+/g, "_").toLowerCase().replace(/^_+|_+$/g, "");
    }, "sanitizeName");
    const resourceName = sanitizeName(
      mcpResource.name || `resource_${mcpResource.uri}`
    );
    const resourceUri = mcpResource.uri;
    const tool = new DynamicStructuredTool({
      name: resourceName,
      description: mcpResource.description || `Return the content of the resource located at URI ${resourceUri}.`,
      schema: z.object({}).optional(),
      // Resources take no arguments
      func: /* @__PURE__ */ __name(async () => {
        logger.debug(`Resource tool: "${resourceName}" called`);
        try {
          const result = await connector.readResource(resourceUri);
          if (result.contents && result.contents.length > 0) {
            return result.contents.map((content) => {
              if (typeof content === "string") {
                return content;
              }
              if (content.text) {
                return content.text;
              }
              if (content.uri) {
                return content.uri;
              }
              return JSON.stringify(content);
            }).join("\n");
          }
          return "Resource is empty or unavailable";
        } catch (err) {
          logger.error(`Error reading resource: ${err.message}`);
          return `Error reading resource: ${String(err)}`;
        }
      }, "func")
    });
    return tool;
  }
  /**
   * Convert a single MCP prompt into a LangChainJS structured tool.
   * The resulting tool executes getPrompt on the connector with the prompt's name
   * and the user-provided arguments (if any).
   */
  convertPrompt(mcpPrompt, connector) {
    let argsSchema = z.object({}).optional();
    if (mcpPrompt.arguments && mcpPrompt.arguments.length > 0) {
      const schemaFields = {};
      for (const arg of mcpPrompt.arguments) {
        const zodType = z.string();
        if (arg.required !== false) {
          schemaFields[arg.name] = zodType;
        } else {
          schemaFields[arg.name] = zodType.optional();
        }
      }
      argsSchema = Object.keys(schemaFields).length > 0 ? z.object(schemaFields) : z.object({}).optional();
    }
    const tool = new DynamicStructuredTool({
      name: mcpPrompt.name,
      description: mcpPrompt.description || "",
      schema: argsSchema,
      func: /* @__PURE__ */ __name(async (input) => {
        logger.debug(
          `Prompt tool: "${mcpPrompt.name}" called with args: ${JSON.stringify(input)}`
        );
        try {
          const result = await connector.getPrompt(mcpPrompt.name, input);
          if (result.messages && result.messages.length > 0) {
            return result.messages.map((msg) => {
              if (typeof msg === "string") {
                return msg;
              }
              if (msg.content) {
                return typeof msg.content === "string" ? msg.content : JSON.stringify(msg.content);
              }
              return JSON.stringify(msg);
            }).join("\n");
          }
          return "Prompt returned no messages";
        } catch (err) {
          logger.error(`Error getting prompt: ${err.message}`);
          return `Error getting prompt: ${String(err)}`;
        }
      }, "func")
    });
    return tool;
  }
};

export {
  BaseAdapter,
  LangChainAdapter
};
