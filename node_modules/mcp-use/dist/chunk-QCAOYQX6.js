import {
  BaseMCPClient,
  HttpConnector,
  normalizeClientInfo,
  resolveCallbacks
} from "./chunk-MOIY46VI.js";
import {
  Tel,
  getPackageVersion
} from "./chunk-YEK7642C.js";
import {
  logger
} from "./chunk-QWQYAQCK.js";
import {
  __name
} from "./chunk-3GQAWCBQ.js";

// src/client/browser.ts
var BrowserMCPClient = class _BrowserMCPClient extends BaseMCPClient {
  static {
    __name(this, "BrowserMCPClient");
  }
  /**
   * Get the mcp-use package version.
   * Works in all environments (Node.js, browser, Cloudflare Workers, Deno, etc.)
   */
  static getPackageVersion() {
    return getPackageVersion();
  }
  constructor(config) {
    super(config);
    this._trackClientInit();
  }
  _trackClientInit() {
    const servers = Object.keys(this.config.mcpServers ?? {});
    Tel.getInstance().trackMCPClientInit({
      codeMode: false,
      // Browser client doesn't support code mode
      sandbox: false,
      // Sandbox not supported in browser
      allCallbacks: false,
      // Will be set per-server
      verify: false,
      servers,
      numServers: servers.length,
      isBrowser: true
      // Browser MCPClient
    }).catch(
      (e) => logger.debug(`Failed to track BrowserMCPClient init: ${e}`)
    );
  }
  static fromDict(cfg) {
    return new _BrowserMCPClient(cfg);
  }
  /**
   * Create a connector from server configuration (Browser version)
   * Supports HTTP connector only
   */
  createConnectorFromConfig(serverConfig) {
    const {
      url,
      headers,
      fetch,
      authToken,
      authProvider,
      wrapTransport,
      clientOptions,
      disableSseFallback,
      preferSse,
      gatewayUrl,
      serverId
    } = serverConfig;
    if (!url) {
      throw new Error("Server URL is required");
    }
    const globalDefaults = this.config;
    const resolved = resolveCallbacks(
      serverConfig,
      globalDefaults
    );
    const clientInfo = normalizeClientInfo(
      serverConfig.clientInfo ?? this.config.clientInfo
    );
    const connectorOptions = {
      headers,
      fetch,
      authToken,
      authProvider,
      wrapTransport,
      clientOptions,
      onSampling: resolved.onSampling,
      onElicitation: resolved.onElicitation,
      onNotification: resolved.onNotification,
      disableSseFallback,
      preferSse,
      clientInfo,
      gatewayUrl,
      serverId
    };
    logger.debug(
      `[BrowserMCPClient] Connector options prepared (clientOptions: ${clientOptions ? "provided" : "none"})`
    );
    return new HttpConnector(url, connectorOptions);
  }
};

export {
  BrowserMCPClient
};
