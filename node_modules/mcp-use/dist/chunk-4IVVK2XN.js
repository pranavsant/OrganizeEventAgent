import {
  __name
} from "./chunk-3GQAWCBQ.js";

// src/server/widgets/adapters/mcp-apps.ts
import {
  RESOURCE_URI_META_KEY,
  RESOURCE_MIME_TYPE
} from "@modelcontextprotocol/ext-apps/server";

// src/server/widgets/adapters/base.ts
var BaseProtocolAdapter = class {
  static {
    __name(this, "BaseProtocolAdapter");
  }
  /**
   * Build resource metadata using shared logic
   */
  buildResourceMetadata(definition) {
    const extracted = this.extractMetadata(definition);
    const transformed = this.transformExtractedMetadata(extracted);
    const result = {
      mimeType: this.mimeType
    };
    if (Object.keys(transformed).length > 0) {
      result._meta = this.wrapResourceMetadata(transformed);
    }
    return result;
  }
  /**
   * Extract metadata from definition, checking both unified and protocol-specific sources
   */
  extractMetadata(definition) {
    const meta = {};
    if ("metadata" in definition && definition.metadata?.csp) {
      meta.csp = definition.metadata.csp;
    }
    if ("metadata" in definition && definition.metadata?.prefersBorder !== void 0) {
      meta.prefersBorder = definition.metadata.prefersBorder;
    }
    if ("metadata" in definition && definition.metadata?.domain) {
      meta.domain = definition.metadata.domain;
    }
    if ("metadata" in definition && definition.metadata) {
      for (const [key, value] of Object.entries(definition.metadata)) {
        if (!["csp", "prefersBorder", "domain"].includes(key) && value !== void 0) {
          meta[key] = value;
        }
      }
    }
    return meta;
  }
  /**
   * Transform extracted metadata to protocol-specific format
   */
  transformExtractedMetadata(meta) {
    const result = {};
    if (meta.csp) {
      const transformed = this.transformCSPBase(meta.csp);
      if (Object.keys(transformed).length > 0) {
        result[this.transformMetadataKey("csp")] = transformed;
      }
    }
    if (meta.prefersBorder !== void 0) {
      result[this.transformMetadataKey("prefersBorder")] = meta.prefersBorder;
    }
    if (meta.domain) {
      result[this.transformMetadataKey("domain")] = meta.domain;
    }
    for (const [key, value] of Object.entries(meta)) {
      if (!["csp", "prefersBorder", "domain"].includes(key)) {
        result[this.transformMetadataKey(key)] = value;
      }
    }
    return result;
  }
  /**
   * Transform CSP config using protocol-specific field naming
   */
  transformCSPBase(csp) {
    const result = {};
    const domainFields = [
      "connectDomains",
      "resourceDomains",
      "frameDomains",
      "baseUriDomains",
      "redirectDomains"
    ];
    for (const field of domainFields) {
      if (csp[field] && Array.isArray(csp[field]) && csp[field].length > 0) {
        result[this.transformCSPField(field)] = csp[field];
      }
    }
    if (csp.scriptDirectives && csp.scriptDirectives.length > 0) {
      result[this.transformCSPField("scriptDirectives")] = csp.scriptDirectives;
    }
    if (csp.styleDirectives && csp.styleDirectives.length > 0) {
      result[this.transformCSPField("styleDirectives")] = csp.styleDirectives;
    }
    for (const [key, value] of Object.entries(csp)) {
      if (![...domainFields, "scriptDirectives", "styleDirectives"].includes(
        key
      ) && value !== void 0) {
        result[this.transformCSPField(key)] = value;
      }
    }
    return result;
  }
};

// src/server/widgets/adapters/mcp-apps.ts
var McpAppsAdapter = class extends BaseProtocolAdapter {
  static {
    __name(this, "McpAppsAdapter");
  }
  mimeType = RESOURCE_MIME_TYPE;
  protocol = "mcp-apps";
  /**
   * Build tool metadata for MCP Apps protocol
   */
  buildToolMetadata(definition, uri) {
    const meta = {
      // New format (nested)
      ui: {
        resourceUri: uri
      },
      // Legacy format (flat) for backward compatibility with older clients
      [RESOURCE_URI_META_KEY]: uri
    };
    return meta;
  }
  /**
   * Transform metadata key to MCP Apps format (keep camelCase)
   */
  transformMetadataKey(key) {
    return key;
  }
  /**
   * Transform CSP field (keep camelCase)
   */
  transformCSPField(field) {
    return field;
  }
  /**
   * Wrap metadata - MCP Apps uses _meta.ui namespace
   */
  wrapResourceMetadata(meta) {
    return { ui: meta };
  }
  /**
   * Get protocol-specific metadata field name
   */
  getProtocolMetadataField() {
    return void 0;
  }
};

// src/server/widgets/adapters/apps-sdk.ts
var AppsSdkAdapter = class extends BaseProtocolAdapter {
  static {
    __name(this, "AppsSdkAdapter");
  }
  mimeType = "text/html+skybridge";
  protocol = "apps-sdk";
  /**
   * Build tool metadata for Apps SDK protocol
   */
  buildToolMetadata(definition, uri) {
    const meta = {
      "openai/outputTemplate": uri
    };
    if ("appsSdkMetadata" in definition && definition.appsSdkMetadata) {
      const appsMeta = definition.appsSdkMetadata;
      const toolFields = [
        "openai/toolInvocation/invoking",
        "openai/toolInvocation/invoked",
        "openai/widgetAccessible",
        "openai/resultCanProduceWidget"
      ];
      for (const field of toolFields) {
        if (appsMeta[field] !== void 0) {
          meta[field] = appsMeta[field];
        }
      }
    }
    if ("metadata" in definition && definition.metadata) {
      if (definition.metadata.invoking !== void 0 && !meta["openai/toolInvocation/invoking"]) {
        meta["openai/toolInvocation/invoking"] = definition.metadata.invoking;
      }
      if (definition.metadata.invoked !== void 0 && !meta["openai/toolInvocation/invoked"]) {
        meta["openai/toolInvocation/invoked"] = definition.metadata.invoked;
      }
    }
    return meta;
  }
  /**
   * Transform metadata key to Apps SDK format (openai/* prefix)
   */
  transformMetadataKey(key) {
    const keyMap = {
      csp: "openai/widgetCSP",
      prefersBorder: "openai/widgetPrefersBorder",
      domain: "openai/widgetDomain",
      widgetDescription: "openai/widgetDescription",
      widgetAccessible: "openai/widgetAccessible",
      locale: "openai/locale"
    };
    return keyMap[key] || `openai/${key}`;
  }
  /**
   * Transform CSP field to snake_case
   */
  transformCSPField(field) {
    return field.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
  }
  /**
   * Wrap metadata - Apps SDK uses flat structure with openai/* keys
   */
  wrapResourceMetadata(meta) {
    return meta;
  }
  /**
   * Get protocol-specific metadata field name
   */
  getProtocolMetadataField() {
    return "appsSdkMetadata";
  }
  /**
   * Override to add Apps SDK-specific metadata sources
   */
  buildResourceMetadata(definition) {
    const result = super.buildResourceMetadata(definition);
    if ("appsSdkMetadata" in definition && definition.appsSdkMetadata) {
      const appsMeta = definition.appsSdkMetadata;
      result._meta = result._meta || {};
      const additionalFields = [
        "openai/widgetAccessible",
        "openai/locale",
        "openai/widgetCSP",
        "openai/widgetPrefersBorder",
        "openai/widgetDomain",
        "openai/widgetDescription"
      ];
      for (const field of additionalFields) {
        if (!(field in result._meta) && appsMeta[field] !== void 0) {
          result._meta[field] = appsMeta[field];
        }
      }
    }
    return result;
  }
};

// src/server/widgets/protocol-helpers.ts
function createProtocolAdapters() {
  return {
    mcpApps: new McpAppsAdapter(),
    appsSdk: new AppsSdkAdapter()
  };
}
__name(createProtocolAdapters, "createProtocolAdapters");
function buildDualProtocolMetadata(definition, uri, existingMetadata) {
  const adapters = createProtocolAdapters();
  const mcpAppsToolMeta = adapters.mcpApps.buildToolMetadata(definition, uri);
  const appsSdkToolMeta = adapters.appsSdk.buildToolMetadata(definition, uri);
  const appsSdkResourceMeta = adapters.appsSdk.buildResourceMetadata(definition);
  return {
    ...existingMetadata,
    ...mcpAppsToolMeta,
    // ui: { resourceUri }, "ui/resourceUri"
    ...appsSdkToolMeta,
    // "openai/outputTemplate"
    ...appsSdkResourceMeta._meta || {}
    // "openai/widgetCSP", "openai/description"
  };
}
__name(buildDualProtocolMetadata, "buildDualProtocolMetadata");
function snakeCaseCspToCamelCase(wcsp) {
  if (!wcsp || typeof wcsp !== "object") return void 0;
  const result = {};
  if (Array.isArray(wcsp.connect_domains))
    result.connectDomains = wcsp.connect_domains;
  if (Array.isArray(wcsp.resource_domains))
    result.resourceDomains = wcsp.resource_domains;
  if (Array.isArray(wcsp.frame_domains))
    result.frameDomains = wcsp.frame_domains;
  if (Array.isArray(wcsp.base_uri_domains))
    result.baseUriDomains = wcsp.base_uri_domains;
  if (Array.isArray(wcsp.script_directives))
    result.scriptDirectives = wcsp.script_directives;
  if (Array.isArray(wcsp.style_directives))
    result.styleDirectives = wcsp.style_directives;
  return Object.keys(result).length > 0 ? result : void 0;
}
__name(snakeCaseCspToCamelCase, "snakeCaseCspToCamelCase");
function buildResourceUiMeta(definition) {
  const adapters = createProtocolAdapters();
  const mcpAppsResourceMeta = adapters.mcpApps.buildResourceMetadata(definition);
  let uiMeta = mcpAppsResourceMeta._meta?.ui || void 0;
  if (definition.type === "mcpApps") {
    const appsSdkResourceMeta = adapters.appsSdk.buildResourceMetadata(definition);
    const openaiWidgetCSP = appsSdkResourceMeta._meta?.["openai/widgetCSP"];
    const csp = snakeCaseCspToCamelCase(openaiWidgetCSP);
    if (csp) {
      uiMeta = { ...uiMeta || {}, csp };
    }
  }
  return uiMeta && Object.keys(uiMeta).length > 0 ? uiMeta : void 0;
}
__name(buildResourceUiMeta, "buildResourceUiMeta");
function generateUniqueWidgetUri(name, buildId, extension = ".html") {
  const randomId = Math.random().toString(36).substring(2, 15);
  const buildIdPart = buildId ? `-${buildId}` : "";
  return `ui://widget/${name}${buildIdPart}-${randomId}${extension}`;
}
__name(generateUniqueWidgetUri, "generateUniqueWidgetUri");
function generateToolOutput(definition, params, displayName) {
  const result = {
    content: [{ type: "text", text: displayName }]
  };
  if ("structuredContent" in definition && definition.structuredContent) {
    if (typeof definition.structuredContent === "function") {
      result.structuredContent = definition.structuredContent(params);
    } else {
      result.structuredContent = definition.structuredContent;
    }
  }
  return result;
}
__name(generateToolOutput, "generateToolOutput");
function getResourceUriAndMimeType(definition, buildId) {
  const buildIdPart = buildId ? `-${buildId}` : "";
  switch (definition.type) {
    case "externalUrl":
      return {
        uri: definition.href || definition.url,
        mimeType: "text/uri-list"
      };
    case "rawHtml":
      return {
        uri: `ui://widget/${definition.name}${buildIdPart}.html`,
        mimeType: "text/html"
      };
    case "remoteDom":
      return {
        uri: `ui://widget/${definition.name}${buildIdPart}.js`,
        mimeType: "application/vnd.mcp-ui.remote-dom+javascript"
      };
    case "mcpApps":
      return {
        uri: `ui://widget/${definition.name}${buildIdPart}.html`,
        mimeType: "text/html;profile=mcp-app"
      };
    default:
      throw new Error(`Unknown widget type: ${definition.type}`);
  }
}
__name(getResourceUriAndMimeType, "getResourceUriAndMimeType");
function detectSchemaType(propsOrSchema) {
  if (!propsOrSchema) {
    return { type: null, schema: null };
  }
  if (typeof propsOrSchema === "object" && propsOrSchema !== null && "_def" in propsOrSchema) {
    return { type: "zod", schema: propsOrSchema };
  }
  if (typeof propsOrSchema === "object" && propsOrSchema !== null && ("type" in propsOrSchema || "properties" in propsOrSchema)) {
    return { type: "json", schema: propsOrSchema };
  }
  if (typeof propsOrSchema === "object" && propsOrSchema !== null && !("_def" in propsOrSchema)) {
    return { type: "widgetProps", schema: propsOrSchema };
  }
  return { type: null, schema: null };
}
__name(detectSchemaType, "detectSchemaType");
function copyMetadataFields(source, target, fields) {
  if (!source) return;
  for (const field of fields) {
    if (source[field] !== void 0) {
      target[field] = source[field];
    }
  }
}
__name(copyMetadataFields, "copyMetadataFields");
function deepMergeUiMetadata(existing, incoming) {
  if (!existing && !incoming) return void 0;
  if (!existing) return incoming;
  if (!incoming) return existing;
  return {
    ...existing,
    ...incoming,
    // Deep merge nested objects if needed
    ...existing.ui && incoming.ui ? { ui: { ...existing.ui, ...incoming.ui } } : {}
  };
}
__name(deepMergeUiMetadata, "deepMergeUiMetadata");
function getBuildIdPart(buildId) {
  return buildId ? `-${buildId}` : "";
}
__name(getBuildIdPart, "getBuildIdPart");

export {
  McpAppsAdapter,
  AppsSdkAdapter,
  createProtocolAdapters,
  buildDualProtocolMetadata,
  buildResourceUiMeta,
  generateUniqueWidgetUri,
  generateToolOutput,
  getResourceUriAndMimeType,
  detectSchemaType,
  copyMetadataFields,
  deepMergeUiMetadata,
  getBuildIdPart
};
