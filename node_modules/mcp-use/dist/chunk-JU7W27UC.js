import {
  Logger
} from "./chunk-QWQYAQCK.js";
import {
  __name
} from "./chunk-3GQAWCBQ.js";

// src/react/rpc-logger.ts
var logger = Logger.get("RpcLogger");
var RpcLogStore = class {
  static {
    __name(this, "RpcLogStore");
  }
  logs = [];
  listeners = /* @__PURE__ */ new Set();
  maxLogs = 1e3;
  publish(entry) {
    logger.debug(
      "[RPC Logger] Publishing log:",
      entry.direction,
      entry.serverId,
      entry.message?.method
    );
    this.logs.push(entry);
    if (this.logs.length > this.maxLogs) {
      this.logs = this.logs.slice(-this.maxLogs);
    }
    logger.debug(
      "[RPC Logger] Total logs:",
      this.logs.length,
      "Listeners:",
      this.listeners.size
    );
    this.listeners.forEach((listener) => {
      try {
        listener(entry);
      } catch (err) {
        logger.error("[RPC Logger] Listener error:", err);
      }
    });
  }
  subscribe(listener) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }
  getLogsForServer(serverId) {
    return this.logs.filter((log) => log.serverId === serverId);
  }
  getAllLogs() {
    return [...this.logs];
  }
  clear(serverId) {
    if (serverId) {
      this.logs = this.logs.filter((log) => log.serverId !== serverId);
    } else {
      this.logs = [];
    }
  }
};
var rpcLogStore = new RpcLogStore();
function getRpcLogs(serverId) {
  return rpcLogStore.getLogsForServer(serverId);
}
__name(getRpcLogs, "getRpcLogs");
function getAllRpcLogs() {
  return rpcLogStore.getAllLogs();
}
__name(getAllRpcLogs, "getAllRpcLogs");
function subscribeToRpcLogs(listener) {
  return rpcLogStore.subscribe(listener);
}
__name(subscribeToRpcLogs, "subscribeToRpcLogs");
function clearRpcLogs(serverId) {
  rpcLogStore.clear(serverId);
}
__name(clearRpcLogs, "clearRpcLogs");
function wrapTransportForLogging(transport, serverId) {
  class LoggingTransport {
    constructor(inner) {
      this.inner = inner;
      this.inner.onmessage = (message, extra) => {
        rpcLogStore.publish({
          serverId,
          direction: "receive",
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          message
        });
        this.onmessage?.(message, extra);
      };
      this.inner.onclose = () => {
        this.onclose?.();
      };
      this.inner.onerror = (error) => {
        this.onerror?.(error);
      };
    }
    static {
      __name(this, "LoggingTransport");
    }
    onclose;
    onerror;
    onmessage;
    async start() {
      if (typeof this.inner.start === "function") {
        await this.inner.start();
      }
    }
    async send(message, options) {
      rpcLogStore.publish({
        serverId,
        direction: "send",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        message
      });
      await this.inner.send(message, options);
    }
    async close() {
      await this.inner.close();
    }
    get sessionId() {
      return this.inner.sessionId;
    }
    setProtocolVersion(version) {
      if (typeof this.inner.setProtocolVersion === "function") {
        this.inner.setProtocolVersion(version);
      }
    }
  }
  return new LoggingTransport(transport);
}
__name(wrapTransportForLogging, "wrapTransportForLogging");

export {
  getRpcLogs,
  getAllRpcLogs,
  subscribeToRpcLogs,
  clearRpcLogs,
  wrapTransportForLogging
};
