import {
  $ZodAny,
  $ZodArray,
  $ZodBase64,
  $ZodBase64URL,
  $ZodBigInt,
  $ZodBigIntFormat,
  $ZodBoolean,
  $ZodCIDRv4,
  $ZodCIDRv6,
  $ZodCUID,
  $ZodCUID2,
  $ZodCatch,
  $ZodCodec,
  $ZodCustom,
  $ZodCustomStringFormat,
  $ZodDate,
  $ZodDefault,
  $ZodDiscriminatedUnion,
  $ZodE164,
  $ZodEmail,
  $ZodEmoji,
  $ZodEnum,
  $ZodExactOptional,
  $ZodFile,
  $ZodFunction,
  $ZodGUID,
  $ZodIPv4,
  $ZodIPv6,
  $ZodISODate,
  $ZodISODateTime,
  $ZodISODuration,
  $ZodISOTime,
  $ZodIntersection,
  $ZodJWT,
  $ZodKSUID,
  $ZodLazy,
  $ZodLiteral,
  $ZodMAC,
  $ZodMap,
  $ZodNaN,
  $ZodNanoID,
  $ZodNever,
  $ZodNonOptional,
  $ZodNull,
  $ZodNullable,
  $ZodNumber,
  $ZodNumberFormat,
  $ZodObject,
  $ZodOptional,
  $ZodPipe,
  $ZodPrefault,
  $ZodPromise,
  $ZodReadonly,
  $ZodRecord,
  $ZodSet,
  $ZodString,
  $ZodStringFormat,
  $ZodSuccess,
  $ZodSymbol,
  $ZodTemplateLiteral,
  $ZodTransform,
  $ZodTuple,
  $ZodType,
  $ZodULID,
  $ZodURL,
  $ZodUUID,
  $ZodUndefined,
  $ZodUnion,
  $ZodUnknown,
  $ZodVoid,
  $ZodXID,
  $ZodXor,
  $constructor,
  _enum,
  _null,
  array,
  boolean,
  clone,
  custom,
  defineLazy,
  discriminatedUnion,
  intersection,
  iso_exports,
  literal,
  looseObject,
  number,
  object,
  optional,
  parse,
  parseAsync,
  preprocess,
  record,
  safeParse,
  safeParseAsync,
  string,
  union,
  unknown
} from "./chunk-YIV3ILH6.js";
import {
  __name,
  logger
} from "./chunk-WPXJGHMH.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/ajv/dist/compile/codegen/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s2) {
        super();
        if (!exports.IDENTIFIER.test(s2))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s2;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a16;
        return (_a16 = this._str) !== null && _a16 !== void 0 ? _a16 : this._str = this._items.reduce((s2, c2) => `${s2}${c2}`, "");
      }
      get names() {
        var _a16;
        return (_a16 = this._names) !== null && _a16 !== void 0 ? _a16 : this._names = this._items.reduce((names, c2) => {
          if (c2 instanceof Name)
            names[c2.str] = (names[c2.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a2, b2) {
      if (b2 === '""')
        return a2;
      if (a2 === '""')
        return b2;
      if (typeof a2 == "string") {
        if (b2 instanceof Name || a2[a2.length - 1] !== '"')
          return;
        if (typeof b2 != "string")
          return `${a2.slice(0, -1)}${b2}"`;
        if (b2[0] === '"')
          return a2.slice(0, -1) + b2.slice(1);
        return;
      }
      if (typeof b2 == "string" && b2[0] === '"' && !(a2 instanceof Name))
        return `"${a2}${b2.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports.strConcat = strConcat;
    function interpolate(x2) {
      return typeof x2 == "number" || typeof x2 == "boolean" || x2 === null ? x2 : safeStringify(Array.isArray(x2) ? x2.join(",") : x2);
    }
    function stringify(x2) {
      return new _Code(safeStringify(x2));
    }
    exports.stringify = stringify;
    function safeStringify(x2) {
      return JSON.stringify(x2).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports.regexpCode = regexpCode;
  }
});

// node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/ajv/dist/compile/codegen/scope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
    exports.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng2 = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng2.index++}`;
      }
      _nameGroup(prefix) {
        var _a16, _b;
        if (((_b = (_a16 = this._parent) === null || _a16 === void 0 ? void 0 : _a16._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a16;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a16 = value.key) !== null && _a16 !== void 0 ? _a16 : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s2 = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s2.length;
        s2[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c2 = valueCode(name);
            if (c2) {
              const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c2};${this.opts._n}`;
            } else if (c2 = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c2}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports.ValueScope = ValueScope;
  }
});

// node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/ajv/dist/compile/codegen/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n: _n2 }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n2;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n: _n2 }) {
        return `${this.lhs} = ${this.rhs};` + _n2;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n: _n2 }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n2;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n: _n2 }) {
        return `${this.label}:` + _n2;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n: _n2 }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n2;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n: _n2 }) {
        return `throw ${this.error};` + _n2;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n: _n2 }) {
        return `${this.code};` + _n2;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof _If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a16;
        this.else = (_a16 = this.else) === null || _a16 === void 0 ? void 0 : _a16.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to2) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to2;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to: to2 } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to2}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a16, _b;
        super.optimizeNodes();
        (_a16 = this.catch) === null || _a16 === void 0 ? void 0 : _a16.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a16, _b;
        super.optimizeNames(names, constants);
        (_a16 = this.catch) === null || _a16 === void 0 ? void 0 : _a16.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c2) {
        if (typeof c2 == "function")
          c2();
        else if (c2 !== code_1.nil)
          this._leafNode(new AnyCode(c2));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to2, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to2), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c2) => {
        if (c2 instanceof code_1.Name)
          c2 = replaceName(c2);
        if (c2 instanceof code_1._Code)
          items.push(...c2._items);
        else
          items.push(c2);
        return items;
      }, []));
      function replaceName(n) {
        const c2 = constants[n.str];
        if (c2 === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c2;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c2) => c2 instanceof code_1.Name && names[c2.str] === 1 && constants[c2.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x2) {
      return typeof x2 == "boolean" || typeof x2 == "number" || x2 === null ? !x2 : (0, code_1._)`!${par(x2)}`;
    }
    exports.not = not;
    var andCode = mappend(exports.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports.and = and;
    var orCode = mappend(exports.operators.OR);
    function or2(...args) {
      return args.reduce(orCode);
    }
    exports.or = or2;
    function mappend(op) {
      return (x2, y2) => x2 === code_1.nil ? y2 : y2 === code_1.nil ? x2 : (0, code_1._)`${par(x2)} ${op} ${par(y2)}`;
    }
    function par(x2) {
      return x2 instanceof code_1.Name ? x2 : (0, code_1._)`(${x2})`;
    }
  }
});

// node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/ajv/dist/compile/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it2, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it2, schema);
      return !schemaHasRules(schema, it2.self.RULES.all);
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it2, schema = it2.schema) {
      const { opts, self } = it2;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it2, `unknown keyword: "${key}"`);
      }
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f2) {
      if (Array.isArray(xs)) {
        for (const x2 of xs)
          f2(x2);
      } else {
        f2(xs);
      }
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues2, resultToName }) {
      return (gen, from, to2, toName) => {
        const res = to2 === void 0 ? from : to2 instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to2) : mergeToName(gen, from, to2), to2) : from instanceof codegen_1.Name ? (mergeToName(gen, to2, from), from) : mergeValues2(from, to2);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to2, true), () => gen.assign(to2, (0, codegen_1._)`${to2} || {}`).code((0, codegen_1._)`Object.assign(${to2}, ${from})`));
        }),
        mergeToName: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true`, () => {
          if (from === true) {
            gen.assign(to2, true);
          } else {
            gen.assign(to2, (0, codegen_1._)`${to2} || {}`);
            setEvaluated(gen, to2, from);
          }
        }),
        mergeValues: (from, to2) => from === true ? true : { ...from, ...to2 },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true && ${from} !== undefined`, () => gen.assign(to2, (0, codegen_1._)`${from} === true ? true : ${to2} > ${from} ? ${to2} : ${from}`)),
        mergeToName: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true`, () => gen.assign(to2, from === true ? true : (0, codegen_1._)`${to2} > ${from} ? ${to2} : ${from}`)),
        mergeValues: (from, to2) => from === true ? true : Math.max(from, to2),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p2) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p2)}`, true));
    }
    exports.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f2) {
      return gen.scopeValue("func", {
        ref: f2,
        code: snippets[f2.code] || (snippets[f2.code] = new code_1._Code(f2.code))
      });
    }
    exports.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it2, msg, mode = it2.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it2.self.logger.warn(msg);
    }
    exports.checkStrictMode = checkStrictMode;
  }
});

// node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/ajv/dist/compile/names.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports.default = names;
  }
});

// node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "node_modules/ajv/dist/compile/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
      const { it: it2 } = cxt;
      const { gen, compositeRule, allErrors } = it2;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it2, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
      const { it: it2 } = cxt;
      const { gen, compositeRule, allErrors } = it2;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it2, names_1.default.vErrors);
      }
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it: it2 }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it2.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it2.errSchemaPath}/${keyword}`);
        if (it2.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it2, errs) {
      const { gen, validateName, schemaEnv } = it2;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it2.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E2 = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it: it2 } = cxt;
      const keyValues = [
        errorInstancePath(it2, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E2.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it: it2 } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it2;
      keyValues.push([E2.keyword, keyword], [E2.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E2.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E2.schema, schemaValue], [E2.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E2.propertyName, propertyName]);
    }
  }
});

// node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/ajv/dist/compile/validate/boolSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it2) {
      const { gen, schema, validateName } = it2;
      if (schema === false) {
        falseSchemaError(it2, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it2, valid) {
      const { gen, schema } = it2;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it2);
      } else {
        gen.var(valid, true);
      }
    }
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it2, overrideAllErrors) {
      const { gen, data } = it2;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it: it2
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/ajv/dist/compile/rules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRules = exports.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x2) {
      return typeof x2 == "string" && jsonTypes.has(x2);
    }
    exports.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports.getRules = getRules;
  }
});

// node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/ajv/dist/compile/validate/applicability.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self }, type) {
      const group = self.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a16;
      return schema[rule.keyword] !== void 0 || ((_a16 = rule.definition.implements) === null || _a16 === void 0 ? void 0 : _a16.some((kwd) => schema[kwd] !== void 0));
    }
    exports.shouldUseRule = shouldUseRule;
  }
});

// node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/ajv/dist/compile/validate/dataType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it2, types) {
      const { gen, data, opts } = it2;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it2, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it2, types, coerceTo);
          else
            reportTypeError(it2);
        });
      }
      return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it2, types, coerceTo) {
      const { gen, data, opts } = it2;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it2);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it2, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it2) {
      const cxt = getTypeErrorContext(it2);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it2) {
      const { gen, data, schema } = it2;
      const schemaCode = (0, util_1.schemaRefOrVal)(it2, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it: it2
      };
    }
  }
});

// node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/ajv/dist/compile/validate/defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it2, ty) {
      const { properties, items } = it2.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it2, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it2, i, sch.default));
      }
    }
    exports.assignDefaults = assignDefaults;
    function assignDefault(it2, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it2;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it2, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it: it2 } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it2.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p2) => p2 !== "__proto__") : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it2, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p2) => !(0, util_1.alwaysValidSchema)(it2, schemaMap[p2]));
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it: it2 }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it2.parentData],
        [names_1.default.parentDataProperty, it2.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it2.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it: it2 } = cxt;
      const valid = gen.name("valid");
      if (it2.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it: it2 } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it2, sch));
      if (alwaysValid && !it2.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports.validateUnion = validateUnion;
  }
});

// node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/ajv/dist/compile/validate/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it: it2 } = cxt;
      const macroSchema = def.macro.call(it2.self, schema, parentSchema, it2);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it2.opts.validateSchema !== false)
        it2.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it2.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a16;
      const { gen, keyword, schema, parentSchema, $data, it: it2 } = cxt;
      checkAsyncKeyword(it2, def);
      const validate = !$data && def.compile ? def.compile.call(it2.self, schema, parentSchema, it2) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a16 = def.valid) !== null && _a16 !== void 0 ? _a16 : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it2.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it2.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a17;
        gen.if((0, codegen_1.not)((_a17 = def.valid) !== null && _a17 !== void 0 ? _a17 : valid), errors);
      }
    }
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it: it2 } = cxt;
      gen.if(it2.parentData, () => gen.assign(data, (0, codegen_1._)`${it2.parentData}[${it2.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st2) => st2 === "array" ? Array.isArray(schema) : st2 === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st2 || allowUndefined && typeof schema == "undefined");
    }
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/ajv/dist/compile/validate/subschema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it2, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it2.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it2.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it2.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it2, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it2;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it2;
        const nextData = gen.let("data", (0, codegen_1._)`${it2.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it2.dataLevel + 1;
        subschema.dataTypes = [];
        it2.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it2.data;
        subschema.dataNames = [...it2.dataNames, _nextData];
      }
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a2, b2) {
      if (a2 === b2) return true;
      if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
        if (a2.constructor !== b2.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a2)) {
          length = a2.length;
          if (length != b2.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a2[i], b2[i])) return false;
          return true;
        }
        if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
        if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b2.valueOf();
        if (a2.toString !== Object.prototype.toString) return a2.toString() === b2.toString();
        keys = Object.keys(a2);
        length = keys.length;
        if (length !== Object.keys(b2).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a2[key], b2[key])) return false;
        }
        return true;
      }
      return a2 !== a2 && b2 !== b2;
    };
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    var traverse = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/ajv/dist/compile/resolve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p2 = resolver.parse(id);
      return _getFullPath(resolver, p2);
    }
    exports.getFullPath = getFullPath;
    function _getFullPath(resolver, p2) {
      const serialized = resolver.serialize(p2);
      return serialized.split("#")[0] + "#";
    }
    exports._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/ajv/dist/compile/validate/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors();
    function validateFunctionCode(it2) {
      if (isSchemaObj(it2)) {
        checkKeywords(it2);
        if (schemaCxtHasRules(it2)) {
          topSchemaObjCode(it2);
          return;
        }
      }
      validateFunction(it2, () => (0, boolSchema_1.topBoolOrEmptySchema)(it2));
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it2) {
      const { schema, opts, gen } = it2;
      validateFunction(it2, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it2);
        checkNoDefault(it2);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it2);
        typeAndKeywords(it2);
        returnResults(it2);
      });
      return;
    }
    function resetEvaluated(it2) {
      const { gen, validateName } = it2;
      it2.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it2.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it2.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it2, valid) {
      if (isSchemaObj(it2)) {
        checkKeywords(it2);
        if (schemaCxtHasRules(it2)) {
          subSchemaObjCode(it2, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it2, valid);
    }
    function schemaCxtHasRules({ schema, self }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it2) {
      return typeof it2.schema != "boolean";
    }
    function subSchemaObjCode(it2, valid) {
      const { schema, gen, opts } = it2;
      if (opts.$comment && schema.$comment)
        commentKeyword(it2);
      updateContext(it2);
      checkAsyncSchema(it2);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it2, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it2) {
      (0, util_1.checkUnknownRules)(it2);
      checkRefsAndKeywords(it2);
    }
    function typeAndKeywords(it2, errsCount) {
      if (it2.opts.jtd)
        return schemaKeywords(it2, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it2.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it2, types);
      schemaKeywords(it2, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it2) {
      const { schema, errSchemaPath, opts, self } = it2;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it2) {
      const { schema, opts } = it2;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it2, "default is ignored in the schema root");
      }
    }
    function updateContext(it2) {
      const schId = it2.schema[it2.opts.schemaId];
      if (schId)
        it2.baseId = (0, resolve_1.resolveUrl)(it2.opts.uriResolver, it2.baseId, schId);
    }
    function checkAsyncSchema(it2) {
      if (it2.schema.$async && !it2.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it2) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it2;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it2);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it2, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self } = it2;
      const { RULES } = self;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it2, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it2, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it2, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it2);
          }
          gen.endIf();
        } else {
          iterateKeywords(it2, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it2, group) {
      const { gen, schema, opts: { useDefaults } } = it2;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it2, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it2, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it2, types) {
      if (it2.schemaEnv.meta || !it2.opts.strictTypes)
        return;
      checkContextTypes(it2, types);
      if (!it2.opts.allowUnionTypes)
        checkMultipleTypes(it2, types);
      checkKeywordTypes(it2, it2.dataTypes);
    }
    function checkContextTypes(it2, types) {
      if (!types.length)
        return;
      if (!it2.dataTypes.length) {
        it2.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it2.dataTypes, t)) {
          strictTypesError(it2, `type "${t}" not allowed by context "${it2.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it2, types);
    }
    function checkMultipleTypes(it2, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it2, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it2, ts) {
      const rules = it2.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it2.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it2, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it2, withTypes) {
      const ts = [];
      for (const t of it2.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it2.dataTypes = ts;
    }
    function strictTypesError(it2, msg) {
      const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it2, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it2, def, keyword);
        this.gen = it2.gen;
        this.allErrors = it2.allErrors;
        this.keyword = keyword;
        this.data = it2.data;
        this.schema = it2.schema[keyword];
        this.$data = def.$data && it2.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it2, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it2.schema;
        this.params = {};
        this.it = it2;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it2.gen.const("vSchema", getData(this.$data, it2));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it2.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it: it2 } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st2 = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st2, schemaCode, it2.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it: it2, gen } = this;
        if (!it2.opts.unevaluated)
          return;
        if (it2.props !== true && schemaCxt.props !== void 0) {
          it2.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it2.props, toName);
        }
        if (it2.items !== true && schemaCxt.items !== void 0) {
          it2.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it2.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it: it2, gen } = this;
        if (it2.opts.unevaluated && (it2.props !== true || it2.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it2, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it2, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports.getData = getData;
  }
});

// node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/ajv/dist/runtime/validation_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports.default = ValidationError;
  }
});

// node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/ajv/dist/compile/ref_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports.default = MissingRefError;
  }
});

// node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/ajv/dist/compile/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a16;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a16 = env.baseId) !== null && _a16 !== void 0 ? _a16 : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a16;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a16 = root.localRefs) === null || _a16 === void 0 ? void 0 : _a16[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p2 = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p2);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p2, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p2, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p2, schOrRef);
    }
    exports.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a16;
      if (((_a16 = parsedRef.fragment) === null || _a16 === void 0 ? void 0 : _a16[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/ajv/dist/refs/data.json"(exports, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "node_modules/fast-uri/lib/utils.js"(exports, module) {
    "use strict";
    var isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
    var isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
    function stringArrayToHexStripped(input) {
      let acc = "";
      let code = 0;
      let i = 0;
      for (i = 0; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (code === 48) {
          continue;
        }
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
        break;
      }
      for (i += 1; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
      }
      return acc;
    }
    var nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
    function consumeIsZone(buffer) {
      buffer.length = 0;
      return true;
    }
    function consumeHextets(buffer, address, output) {
      if (buffer.length) {
        const hex = stringArrayToHexStripped(buffer);
        if (hex !== "") {
          address.push(hex);
        } else {
          output.error = true;
          return false;
        }
        buffer.length = 0;
      }
      return true;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let endipv6Encountered = false;
      let endIpv6 = false;
      let consume = consumeHextets;
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume(buffer, address, output)) {
            break;
          }
          if (++tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i > 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          address.push(":");
          continue;
        } else if (cursor === "%") {
          if (!consume(buffer, address, output)) {
            break;
          }
          consume = consumeIsZone;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (consume === consumeIsZone) {
          output.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return { host: newHost, isIPV6: true, escapedHost };
      } else {
        return { host, isIPV6: false };
      }
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    function removeDotSegments(path) {
      let input = path;
      const output = [];
      let nextSlash = -1;
      let len = 0;
      while (len = input.length) {
        if (len === 1) {
          if (input === ".") {
            break;
          } else if (input === "/") {
            output.push("/");
            break;
          } else {
            output.push(input);
            break;
          }
        } else if (len === 2) {
          if (input[0] === ".") {
            if (input[1] === ".") {
              break;
            } else if (input[1] === "/") {
              input = input.slice(2);
              continue;
            }
          } else if (input[0] === "/") {
            if (input[1] === "." || input[1] === "/") {
              output.push("/");
              break;
            }
          }
        } else if (len === 3) {
          if (input === "/..") {
            if (output.length !== 0) {
              output.pop();
            }
            output.push("/");
            break;
          }
        }
        if (input[0] === ".") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(3);
              continue;
            }
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(2);
              continue;
            } else if (input[2] === ".") {
              if (input[3] === "/") {
                input = input.slice(3);
                if (output.length !== 0) {
                  output.pop();
                }
                continue;
              }
            }
          }
        }
        if ((nextSlash = input.indexOf("/", 1)) === -1) {
          output.push(input);
          break;
        } else {
          output.push(input.slice(0, nextSlash));
          input = input.slice(nextSlash);
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(component, esc) {
      const func = esc !== true ? escape : unescape;
      if (component.scheme !== void 0) {
        component.scheme = func(component.scheme);
      }
      if (component.userinfo !== void 0) {
        component.userinfo = func(component.userinfo);
      }
      if (component.host !== void 0) {
        component.host = func(component.host);
      }
      if (component.path !== void 0) {
        component.path = func(component.path);
      }
      if (component.query !== void 0) {
        component.query = func(component.query);
      }
      if (component.fragment !== void 0) {
        component.fragment = func(component.fragment);
      }
      return component;
    }
    function recomposeAuthority(component) {
      const uriTokens = [];
      if (component.userinfo !== void 0) {
        uriTokens.push(component.userinfo);
        uriTokens.push("@");
      }
      if (component.host !== void 0) {
        let host = unescape(component.host);
        if (!isIPv4(host)) {
          const ipV6res = normalizeIPv6(host);
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = component.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof component.port === "number" || typeof component.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(component.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module.exports = {
      nonSimpleDomain,
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      isIPv4,
      isUUID,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "node_modules/fast-uri/lib/schemes.js"(exports, module) {
    "use strict";
    var { isUUID } = require_utils();
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    var supportedSchemeNames = (
      /** @type {const} */
      [
        "http",
        "https",
        "ws",
        "wss",
        "urn",
        "urn:uuid"
      ]
    );
    function isValidSchemeName(name) {
      return supportedSchemeNames.indexOf(
        /** @type {*} */
        name
      ) !== -1;
    }
    function wsIsSecure(wsComponent) {
      if (wsComponent.secure === true) {
        return true;
      } else if (wsComponent.secure === false) {
        return false;
      } else if (wsComponent.scheme) {
        return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
      } else {
        return false;
      }
    }
    function httpParse(component) {
      if (!component.host) {
        component.error = component.error || "HTTP URIs must have a host.";
      }
      return component;
    }
    function httpSerialize(component) {
      const secure = String(component.scheme).toLowerCase() === "https";
      if (component.port === (secure ? 443 : 80) || component.port === "") {
        component.port = void 0;
      }
      if (!component.path) {
        component.path = "/";
      }
      return component;
    }
    function wsParse(wsComponent) {
      wsComponent.secure = wsIsSecure(wsComponent);
      wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
      wsComponent.path = void 0;
      wsComponent.query = void 0;
      return wsComponent;
    }
    function wsSerialize(wsComponent) {
      if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
        wsComponent.port = void 0;
      }
      if (typeof wsComponent.secure === "boolean") {
        wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
        wsComponent.secure = void 0;
      }
      if (wsComponent.resourceName) {
        const [path, query] = wsComponent.resourceName.split("?");
        wsComponent.path = path && path !== "/" ? path : void 0;
        wsComponent.query = query;
        wsComponent.resourceName = void 0;
      }
      wsComponent.fragment = void 0;
      return wsComponent;
    }
    function urnParse(urnComponent, options) {
      if (!urnComponent.path) {
        urnComponent.error = "URN can not be parsed";
        return urnComponent;
      }
      const matches = urnComponent.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponent.scheme || "urn";
        urnComponent.nid = matches[1].toLowerCase();
        urnComponent.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
        const schemeHandler = getSchemeHandler(urnScheme);
        urnComponent.path = void 0;
        if (schemeHandler) {
          urnComponent = schemeHandler.parse(urnComponent, options);
        }
      } else {
        urnComponent.error = urnComponent.error || "URN can not be parsed.";
      }
      return urnComponent;
    }
    function urnSerialize(urnComponent, options) {
      if (urnComponent.nid === void 0) {
        throw new Error("URN without nid cannot be serialized");
      }
      const scheme = options.scheme || urnComponent.scheme || "urn";
      const nid = urnComponent.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = getSchemeHandler(urnScheme);
      if (schemeHandler) {
        urnComponent = schemeHandler.serialize(urnComponent, options);
      }
      const uriComponent = urnComponent;
      const nss = urnComponent.nss;
      uriComponent.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponent;
    }
    function urnuuidParse(urnComponent, options) {
      const uuidComponent = urnComponent;
      uuidComponent.uuid = uuidComponent.nss;
      uuidComponent.nss = void 0;
      if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
        uuidComponent.error = uuidComponent.error || "UUID is not valid.";
      }
      return uuidComponent;
    }
    function urnuuidSerialize(uuidComponent) {
      const urnComponent = uuidComponent;
      urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
      return urnComponent;
    }
    var http = (
      /** @type {SchemeHandler} */
      {
        scheme: "http",
        domainHost: true,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var https = (
      /** @type {SchemeHandler} */
      {
        scheme: "https",
        domainHost: http.domainHost,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var ws = (
      /** @type {SchemeHandler} */
      {
        scheme: "ws",
        domainHost: true,
        parse: wsParse,
        serialize: wsSerialize
      }
    );
    var wss = (
      /** @type {SchemeHandler} */
      {
        scheme: "wss",
        domainHost: ws.domainHost,
        parse: ws.parse,
        serialize: ws.serialize
      }
    );
    var urn = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn",
        parse: urnParse,
        serialize: urnSerialize,
        skipNormalize: true
      }
    );
    var urnuuid = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn:uuid",
        parse: urnuuidParse,
        serialize: urnuuidSerialize,
        skipNormalize: true
      }
    );
    var SCHEMES = (
      /** @type {Record<SchemeName, SchemeHandler>} */
      {
        http,
        https,
        ws,
        wss,
        urn,
        "urn:uuid": urnuuid
      }
    );
    Object.setPrototypeOf(SCHEMES, null);
    function getSchemeHandler(scheme) {
      return scheme && (SCHEMES[
        /** @type {SchemeName} */
        scheme
      ] || SCHEMES[
        /** @type {SchemeName} */
        scheme.toLowerCase()
      ]) || void 0;
    }
    module.exports = {
      wsIsSecure,
      SCHEMES,
      isValidSchemeName,
      getSchemeHandler
    };
  }
});

// node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "node_modules/fast-uri/index.js"(exports, module) {
    "use strict";
    var { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils();
    var { SCHEMES, getSchemeHandler } = require_schemes();
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = /** @type {T} */
        serialize(parse2(uri, options), options);
      } else if (typeof uri === "object") {
        uri = /** @type {T} */
        parse2(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
      const resolved = resolveComponent(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true);
      schemelessOptions.skipEscape = true;
      return serialize(resolved, schemelessOptions);
    }
    function resolveComponent(base, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse2(serialize(base, options), options);
        relative = parse2(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative.path[0] === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative.path;
              } else if (!base.path) {
                target.path = relative.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse2(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse2(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const component = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
      if (component.path !== void 0) {
        if (!options.skipEscape) {
          component.path = escape(component.path);
          if (component.scheme !== void 0) {
            component.path = component.path.split("%3A").join(":");
          }
        } else {
          component.path = unescape(component.path);
        }
      }
      if (options.reference !== "suffix" && component.scheme) {
        uriTokens.push(component.scheme, ":");
      }
      const authority = recomposeAuthority(component);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (component.path && component.path[0] !== "/") {
          uriTokens.push("/");
        }
      }
      if (component.path !== void 0) {
        let s2 = component.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s2 = removeDotSegments(s2);
        }
        if (authority === void 0 && s2[0] === "/" && s2[1] === "/") {
          s2 = "/%2F" + s2.slice(2);
        }
        uriTokens.push(s2);
      }
      if (component.query !== void 0) {
        uriTokens.push("?", component.query);
      }
      if (component.fragment !== void 0) {
        uriTokens.push("#", component.fragment);
      }
      return uriTokens.join("");
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse2(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      let isIP = false;
      if (options.reference === "suffix") {
        if (options.scheme) {
          uri = options.scheme + ":" + uri;
        } else {
          uri = "//" + uri;
        }
      }
      const matches = uri.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = isIPv4(parsed.host);
          if (ipv4result === false) {
            const ipv6result = normalizeIPv6(parsed.host);
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (uri.indexOf("%") !== -1) {
            if (parsed.scheme !== void 0) {
              parsed.scheme = unescape(parsed.scheme);
            }
            if (parsed.host !== void 0) {
              parsed.host = unescape(parsed.host);
            }
          }
          if (parsed.path) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize,
      resolve,
      resolveComponent,
      equal,
      serialize,
      parse: parse2
    };
    module.exports = fastUri;
    module.exports.default = fastUri;
    module.exports.fastUri = fastUri;
  }
});

// node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/ajv/dist/runtime/uri.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = uri;
  }
});

// node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/ajv/dist/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a16, _b, _c2, _d, _e2, _f, _g2, _h, _j, _k, _l2, _m, _o2, _p, _q, _r2, _s, _t2, _u2, _v2, _w, _x, _y, _z, _0;
      const s2 = o.strict;
      const _optz = (_a16 = o.code) === null || _a16 === void 0 ? void 0 : _a16.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c2 = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c2 !== void 0 ? _c2 : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e2 = o.strictSchema) !== null && _e2 !== void 0 ? _e2 : s2) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g2 = o.strictNumbers) !== null && _g2 !== void 0 ? _g2 : s2) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s2) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l2 = o.strictTuples) !== null && _l2 !== void 0 ? _l2 : s2) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o2 = o.strictRequired) !== null && _o2 !== void 0 ? _o2 : s2) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r2 = o.loopEnum) !== null && _r2 !== void 0 ? _r2 : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t2 = o.messages) !== null && _t2 !== void 0 ? _t2 : true,
        inlineRefs: (_u2 = o.inlineRefs) !== null && _u2 !== void 0 ? _u2 : true,
        schemaId: (_v2 = o.schemaId) !== null && _v2 !== void 0 ? _v2 : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv2 = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta: meta2, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta2 && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta: meta2, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta2 == "object" ? meta2[schemaId] || meta2 : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta2) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta2);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta2);
        }
        async function _loadSchema(ref) {
          const p2 = this._loading[ref];
          if (p2)
            return p2;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k2) => addRule.call(this, k2, definition) : (k2) => definition.type.forEach((t) => addRule.call(this, k2, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta2, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta: meta2, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    exports.default = Ajv2;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger2) {
      if (logger2 === false)
        return noLogs;
      if (logger2 === void 0)
        return console;
      if (logger2.log && logger2.warn && logger2.error)
        return logger2;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a16;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a16 = definition.implements) === null || _a16 === void 0 ? void 0 : _a16.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/ref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callRef = exports.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it: it2 } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it2;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it2.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it: it2 } = cxt;
      const { allErrors, schemaEnv: env, opts } = it2;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it2.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a16;
        if (!it2.opts.unevaluated)
          return;
        const schEvaluated = (_a16 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a16 === void 0 ? void 0 : _a16.evaluated;
        if (it2.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it2.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it2.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it2.props = util_1.mergeEvaluated.props(gen, props, it2.props, codegen_1.Name);
          }
        }
        if (it2.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it2.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it2.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it2.items = util_1.mergeEvaluated.items(gen, items, it2.items, codegen_1.Name);
          }
        }
      }
    }
    exports.callRef = callRef;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports.default = core;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it: it2 } = cxt;
        const prec = it2.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/ajv/dist/runtime/ucs2length.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it: it2 } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it2.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var util_1 = require_util();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
        const u = it2.opts.unicodeRegExp ? "u" : "";
        if ($data) {
          const { regExp } = it2.opts.code;
          const regExpCode = regExp.code === "new RegExp" ? (0, codegen_1._)`new RegExp` : (0, util_1.useFunc)(gen, regExp);
          const valid = gen.let("valid");
          gen.try(() => gen.assign(valid, (0, codegen_1._)`${regExpCode}(${schemaCode}, ${u}).test(${data})`), () => gen.assign(valid, false));
          cxt.fail$data((0, codegen_1._)`!${valid}`);
        } else {
          const regExp = (0, code_1.usePattern)(cxt, schema);
          cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/required.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it: it2 } = cxt;
        const { opts } = it2;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it2.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/ajv/dist/runtime/equal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = equal;
  }
});

// node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j: j2 } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j2} and ${i} are identical)`,
      params: ({ params: { i, j: j2 } }) => (0, codegen_1._)`{i: ${i}, j: ${j2}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it: it2 } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j2 = gen.let("j");
          cxt.setParams({ i, j: j2 });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j2));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j2) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it2.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j2, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j2) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j2} = ${i}; ${j2}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j2}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it2.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports.default = validation;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it: it2 } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it2, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it: it2 } = cxt;
      it2.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it2.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it: it2 } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it2.items = true;
        if ((0, util_1.alwaysValidSchema)(it2, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it: it2 } = cxt;
      checkStrictTuple(parentSchema);
      if (it2.opts.unevaluated && schArr.length && it2.items !== true) {
        it2.items = util_1.mergeEvaluated.items(gen, schArr.length, it2.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it2, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it2;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it2, msg, opts.strictTuples);
        }
      }
    }
    exports.validateTuple = validateTuple;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it: it2 } = cxt;
        const { prefixItems } = parentSchema;
        it2.items = true;
        if ((0, util_1.alwaysValidSchema)(it2, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it: it2 } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it2.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it2, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it2, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it2, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it2.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it: it2 } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it2.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it: it2 } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it2, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it: it2 } = cxt;
        if ((0, util_1.alwaysValidSchema)(it2, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it2.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it: it2 } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it2;
        it2.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it2, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it2, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p2) => (0, codegen_1._)`${key} === ${p2}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p2) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p2)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it: it2 } = cxt;
        if (it2.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it2, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it2.definedProperties.add(prop);
        }
        if (it2.opts.unevaluated && allProps.length && it2.props !== true) {
          it2.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it2.props);
        }
        const properties = allProps.filter((p2) => !(0, util_1.alwaysValidSchema)(it2, schema[p2]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it2.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it2.opts.useDefaults && !it2.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it: it2 } = cxt;
        const { opts } = it2;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p2) => (0, util_1.alwaysValidSchema)(it2, schema[p2]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it2.opts.unevaluated || it2.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it2.props !== true && !(it2.props instanceof codegen_1.Name)) {
          it2.props = (0, util_2.evaluatedPropsToName)(gen, it2.props);
        }
        const { props } = it2;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it2.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it2, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it2.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it2.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/not.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it: it2 } = cxt;
        if ((0, util_1.alwaysValidSchema)(it2, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it: it2 } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it2.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it2, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it: it2 } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it2, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/if.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it: it2 } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it2, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it2, "then");
        const hasElse = hasSchema(it2, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it2, keyword) {
      const schema = it2.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it2, schema);
    }
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it: it2 }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it2, `"${keyword}" without "if" is ignored`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports.default = getApplicator;
  }
});

// node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/format.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it2;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var format_1 = require_format();
    var format = [format_1.default];
    exports.default = format;
  }
});

// node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/ajv/dist/vocabularies/metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/ajv/dist/vocabularies/draft7.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports.default = draft7Vocabularies;
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports.DiscrError = DiscrError = {}));
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it: it2 } = cxt;
        const { oneOf } = parentSchema;
        if (!it2.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a16;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it2.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it2.self, it2.schemaEnv.root, it2.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it2.opts.uriResolver, it2.baseId, ref);
            }
            const propSch = (_a16 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a16 === void 0 ? void 0 : _a16[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required: required2 }) {
            return Array.isArray(required2) && required2.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/ajv/dist/ajv.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv2 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports.Ajv = Ajv2;
    module.exports = exports = Ajv2;
    module.exports.Ajv = Ajv2;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv2;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "node_modules/ajv-formats/dist/formats.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
    function fmtDef(validate, compare) {
      return { validate, compare };
    }
    exports.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(getTime(true), compareTime),
      "date-time": fmtDef(getDateTime(true), compareDateTime),
      "iso-time": fmtDef(getTime(), compareIsoTime),
      "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true
    };
    exports.fastFormats = {
      ...exports.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
      "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports.formatNames = Object.keys(exports.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (!(d1 && d2))
        return void 0;
      if (d1 > d2)
        return 1;
      if (d1 < d2)
        return -1;
      return 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function getTime(strictTimeZone) {
      return function time(str) {
        const matches = TIME.exec(str);
        if (!matches)
          return false;
        const hr2 = +matches[1];
        const min = +matches[2];
        const sec = +matches[3];
        const tz = matches[4];
        const tzSign = matches[5] === "-" ? -1 : 1;
        const tzH = +(matches[6] || 0);
        const tzM = +(matches[7] || 0);
        if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
          return false;
        if (hr2 <= 23 && min <= 59 && sec < 60)
          return true;
        const utcMin = min - tzM * tzSign;
        const utcHr = hr2 - tzH * tzSign - (utcMin < 0 ? 1 : 0);
        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
      };
    }
    function compareTime(s1, s2) {
      if (!(s1 && s2))
        return void 0;
      const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
      const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
      if (!(t1 && t2))
        return void 0;
      return t1 - t2;
    }
    function compareIsoTime(t1, t2) {
      if (!(t1 && t2))
        return void 0;
      const a1 = TIME.exec(t1);
      const a2 = TIME.exec(t2);
      if (!(a1 && a2))
        return void 0;
      t1 = a1[1] + a1[2] + a1[3];
      t2 = a2[1] + a2[2] + a2[3];
      if (t1 > t2)
        return 1;
      if (t1 < t2)
        return -1;
      return 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function getDateTime(strictTimeZone) {
      const time = getTime(strictTimeZone);
      return function date_time(str) {
        const dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
      };
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const d1 = new Date(dt1).valueOf();
      const d2 = new Date(dt2).valueOf();
      if (!(d1 && d2))
        return void 0;
      return d1 - d2;
    }
    function compareIsoDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
      const res = compareDate(d1, d2);
      if (res === void 0)
        return void 0;
      return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      BYTE.lastIndex = 0;
      return BYTE.test(str);
    }
    var MIN_INT32 = -(2 ** 31);
    var MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return true;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "node_modules/ajv-formats/dist/limit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv();
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    exports.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, keyword, it: it2 } = cxt;
        const { opts, self } = it2;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it2, self.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          const format = fCxt.schema;
          const fmtDef = self.formats[format];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
          }
          const fmt = gen.scopeValue("formats", {
            key: format,
            ref: fmtDef,
            code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => {
      ajv.addKeyword(exports.formatLimitDefinition);
      return ajv;
    };
    exports.default = formatLimitPlugin;
  }
});

// node_modules/ajv-formats/dist/index.js
var require_dist = __commonJS({
  "node_modules/ajv-formats/dist/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var formats_1 = require_formats();
    var limit_1 = require_limit();
    var codegen_1 = require_codegen();
    var fullName = new codegen_1.Name("fullFormats");
    var fastName = new codegen_1.Name("fastFormats");
    var formatsPlugin = (ajv, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
      }
      const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats(ajv, list, formats, exportName);
      if (opts.keywords)
        (0, limit_1.default)(ajv);
      return ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f2 = formats[name];
      if (!f2)
        throw new Error(`Unknown format "${name}"`);
      return f2;
    };
    function addFormats(ajv, list, fs, exportName) {
      var _a16;
      var _b;
      (_a16 = (_b = ajv.opts.code).formats) !== null && _a16 !== void 0 ? _a16 : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
      for (const f2 of list)
        ajv.addFormat(f2, fs[f2]);
    }
    module.exports = exports = formatsPlugin;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = formatsPlugin;
  }
});

// node_modules/mcp-use/dist/chunk-GKPKUKD6.js
var _a;
var ConnectionManager = (_a = class {
  _readyPromise;
  _readyResolver;
  _donePromise;
  _doneResolver;
  _exception = null;
  _connection = null;
  _task = null;
  _abortController = null;
  constructor() {
    this.reset();
  }
  /**
   * Start the connection manager and establish a connection.
   *
   * @returns The established connection.
   * @throws If the connection cannot be established.
   */
  async start() {
    this.reset();
    logger.debug(`Starting ${this.constructor.name}`);
    this._task = this.connectionTask();
    await this._readyPromise;
    if (this._exception) {
      throw this._exception;
    }
    if (this._connection === null) {
      throw new Error("Connection was not established");
    }
    return this._connection;
  }
  /**
   * Stop the connection manager and close the connection.
   */
  async stop() {
    if (this._task && this._abortController) {
      logger.debug(`Cancelling ${this.constructor.name} task`);
      this._abortController.abort();
      try {
        await this._task;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError") {
          logger.debug(`${this.constructor.name} task aborted successfully`);
        } else {
          logger.warn(`Error stopping ${this.constructor.name} task: ${e}`);
        }
      }
    }
    await this._donePromise;
    logger.debug(`${this.constructor.name} task completed`);
  }
  /**
   * Reset all internal state.
   */
  reset() {
    this._readyPromise = new Promise((res) => this._readyResolver = res);
    this._donePromise = new Promise((res) => this._doneResolver = res);
    this._exception = null;
    this._connection = null;
    this._task = null;
    this._abortController = new AbortController();
  }
  /**
   * The background task responsible for establishing and maintaining the
   * connection until it is cancelled.
   */
  async connectionTask() {
    logger.debug(`Running ${this.constructor.name} task`);
    try {
      this._connection = await this.establishConnection();
      logger.debug(`${this.constructor.name} connected successfully`);
      this._readyResolver();
      await this.waitForAbort();
    } catch (err) {
      this._exception = err;
      logger.error(`Error in ${this.constructor.name} task: ${err}`);
      this._readyResolver();
    } finally {
      if (this._connection !== null) {
        try {
          await this.closeConnection(this._connection);
        } catch (closeErr) {
          logger.warn(
            `Error closing connection in ${this.constructor.name}: ${closeErr}`
          );
        }
        this._connection = null;
      }
      this._doneResolver();
    }
  }
  /**
   * Helper that returns a promise which resolves when the abort signal fires.
   */
  async waitForAbort() {
    return new Promise((_resolve, _reject) => {
      if (!this._abortController) {
        return;
      }
      const signal = this._abortController.signal;
      if (signal.aborted) {
        _resolve();
        return;
      }
      const onAbort = __name(() => {
        signal.removeEventListener("abort", onAbort);
        _resolve();
      }, "onAbort");
      signal.addEventListener("abort", onAbort);
    });
  }
}, __name(_a, "ConnectionManager"), _a);

// node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object3) => {
    const keys = [];
    for (const key in object3) {
      if (Object.prototype.hasOwnProperty.call(object3, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el2 = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el2] = curr[el2] || { _errors: [] };
            } else {
              curr[el2] = curr[el2] || { _errors: [] };
              curr[el2]._errors.push(mapper(issue));
            }
            curr = curr[el2];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = /* @__PURE__ */ Object.create(null);
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};

// node_modules/zod/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var en_default = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function getErrorMap() {
  return overrideErrorMap;
}

// node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x2) => x2.status === "aborted";
var isDirty = (x2) => x2.status === "dirty";
var isValid = (x2) => x2.status === "valid";
var isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a2, b2) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b2);
  if (a2 === b2) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b2[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn2 = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me2 = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn2, this, parsedArgs);
        const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me2 = this;
      return OK(function(...args) {
        const parsedArgs = me2._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn2, this, parsedArgs.data);
        const parsedReturns = me2._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess2, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess2 },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b2) {
    return new _ZodPipeline({
      in: a2,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;

// node_modules/zod/v4/mini/schemas.js
var ZodMiniType = $constructor("ZodMiniType", (inst, def) => {
  if (!inst._zod)
    throw new Error("Uninitialized schema in ZodMiniType.");
  $ZodType.init(inst, def);
  inst.def = def;
  inst.type = def.type;
  inst.parse = (data, params) => parse(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
  inst.check = (...checks) => {
    return inst.clone({
      ...def,
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }, { parent: true });
  };
  inst.with = inst.check;
  inst.clone = (_def, params) => clone(inst, _def, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta2) => {
    reg.add(inst, meta2);
    return inst;
  });
  inst.apply = (fn2) => fn2(inst);
});
var ZodMiniString = $constructor("ZodMiniString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniStringFormat = $constructor("ZodMiniStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  ZodMiniString.init(inst, def);
});
var ZodMiniEmail = $constructor("ZodMiniEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniGUID = $constructor("ZodMiniGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniUUID = $constructor("ZodMiniUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniURL = $constructor("ZodMiniURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniEmoji = $constructor("ZodMiniEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniNanoID = $constructor("ZodMiniNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCUID = $constructor("ZodMiniCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCUID2 = $constructor("ZodMiniCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniULID = $constructor("ZodMiniULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniXID = $constructor("ZodMiniXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniKSUID = $constructor("ZodMiniKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniIPv4 = $constructor("ZodMiniIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniIPv6 = $constructor("ZodMiniIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCIDRv4 = $constructor("ZodMiniCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCIDRv6 = $constructor("ZodMiniCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniMAC = $constructor("ZodMiniMAC", (inst, def) => {
  $ZodMAC.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniBase64 = $constructor("ZodMiniBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniBase64URL = $constructor("ZodMiniBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniE164 = $constructor("ZodMiniE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniJWT = $constructor("ZodMiniJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCustomStringFormat = $constructor("ZodMiniCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniNumber = $constructor("ZodMiniNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNumberFormat = $constructor("ZodMiniNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodMiniNumber.init(inst, def);
});
var ZodMiniBoolean = $constructor("ZodMiniBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniBigInt = $constructor("ZodMiniBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniBigIntFormat = $constructor("ZodMiniBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodMiniBigInt.init(inst, def);
});
var ZodMiniSymbol = $constructor("ZodMiniSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniUndefined = $constructor("ZodMiniUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNull = $constructor("ZodMiniNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniAny = $constructor("ZodMiniAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniUnknown = $constructor("ZodMiniUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNever = $constructor("ZodMiniNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniVoid = $constructor("ZodMiniVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniDate = $constructor("ZodMiniDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniArray = $constructor("ZodMiniArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniObject = $constructor("ZodMiniObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodMiniType.init(inst, def);
  defineLazy(inst, "shape", () => def.shape);
});
var ZodMiniUnion = $constructor("ZodMiniUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniXor = $constructor("ZodMiniXor", (inst, def) => {
  ZodMiniUnion.init(inst, def);
  $ZodXor.init(inst, def);
});
var ZodMiniDiscriminatedUnion = $constructor("ZodMiniDiscriminatedUnion", (inst, def) => {
  $ZodDiscriminatedUnion.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniIntersection = $constructor("ZodMiniIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniTuple = $constructor("ZodMiniTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniRecord = $constructor("ZodMiniRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniMap = $constructor("ZodMiniMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniSet = $constructor("ZodMiniSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniEnum = $constructor("ZodMiniEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodMiniType.init(inst, def);
  inst.options = Object.values(def.entries);
});
var ZodMiniLiteral = $constructor("ZodMiniLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniFile = $constructor("ZodMiniFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniTransform = $constructor("ZodMiniTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniOptional = $constructor("ZodMiniOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniExactOptional = $constructor("ZodMiniExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNullable = $constructor("ZodMiniNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniDefault = $constructor("ZodMiniDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniPrefault = $constructor("ZodMiniPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNonOptional = $constructor("ZodMiniNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniSuccess = $constructor("ZodMiniSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniCatch = $constructor("ZodMiniCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNaN = $constructor("ZodMiniNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniPipe = $constructor("ZodMiniPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniCodec = $constructor("ZodMiniCodec", (inst, def) => {
  ZodMiniPipe.init(inst, def);
  $ZodCodec.init(inst, def);
});
var ZodMiniReadonly = $constructor("ZodMiniReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniTemplateLiteral = $constructor("ZodMiniTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniLazy = $constructor("ZodMiniLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniPromise = $constructor("ZodMiniPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniCustom = $constructor("ZodMiniCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniFunction = $constructor("ZodMiniFunction", (inst, def) => {
  $ZodFunction.init(inst, def);
  ZodMiniType.init(inst, def);
});

// node_modules/zod/v4/mini/iso.js
var ZodMiniISODateTime = $constructor("ZodMiniISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniISODate = $constructor("ZodMiniISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniISOTime = $constructor("ZodMiniISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniISODuration = $constructor("ZodMiniISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-compat.js
function isZ4Schema(s2) {
  const schema = s2;
  return !!schema._zod;
}
function safeParse2(schema, data) {
  if (isZ4Schema(schema)) {
    const result2 = safeParse(schema, data);
    return result2;
  }
  const v3Schema = schema;
  const result = v3Schema.safeParse(data);
  return result;
}
function getObjectShape(schema) {
  if (!schema)
    return void 0;
  let rawShape;
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    rawShape = v4Schema._zod?.def?.shape;
  } else {
    const v3Schema = schema;
    rawShape = v3Schema.shape;
  }
  if (!rawShape)
    return void 0;
  if (typeof rawShape === "function") {
    try {
      return rawShape();
    } catch {
      return void 0;
    }
  }
  return rawShape;
}
function getLiteralValue(schema) {
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    const def2 = v4Schema._zod?.def;
    if (def2) {
      if (def2.value !== void 0)
        return def2.value;
      if (Array.isArray(def2.values) && def2.values.length > 0) {
        return def2.values[0];
      }
    }
  }
  const v3Schema = schema;
  const def = v3Schema._def;
  if (def) {
    if (def.value !== void 0)
      return def.value;
    if (Array.isArray(def.values) && def.values.length > 0) {
      return def.values[0];
    }
  }
  const directValue = schema.value;
  if (directValue !== void 0)
    return directValue;
  return void 0;
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
var LATEST_PROTOCOL_VERSION = "2025-11-25";
var SUPPORTED_PROTOCOL_VERSIONS = [LATEST_PROTOCOL_VERSION, "2025-06-18", "2025-03-26", "2024-11-05", "2024-10-07"];
var RELATED_TASK_META_KEY = "io.modelcontextprotocol/related-task";
var JSONRPC_VERSION = "2.0";
var AssertObjectSchema = custom((v) => v !== null && (typeof v === "object" || typeof v === "function"));
var ProgressTokenSchema = union([string(), number().int()]);
var CursorSchema = string();
var TaskCreationParamsSchema = looseObject({
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: union([number(), _null()]).optional(),
  /**
   * Time in milliseconds to wait between task status requests.
   */
  pollInterval: number().optional()
});
var TaskMetadataSchema = object({
  ttl: number().optional()
});
var RelatedTaskMetadataSchema = object({
  taskId: string()
});
var RequestMetaSchema = looseObject({
  /**
   * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
   */
  progressToken: ProgressTokenSchema.optional(),
  /**
   * If specified, this request is related to the provided task.
   */
  [RELATED_TASK_META_KEY]: RelatedTaskMetadataSchema.optional()
});
var BaseRequestParamsSchema = object({
  /**
   * See [General fields: `_meta`](/specification/draft/basic/index#meta) for notes on `_meta` usage.
   */
  _meta: RequestMetaSchema.optional()
});
var TaskAugmentedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * If specified, the caller is requesting task-augmented execution for this request.
   * The request will return a CreateTaskResult immediately, and the actual result can be
   * retrieved later via tasks/result.
   *
   * Task augmentation is subject to capability negotiation - receivers MUST declare support
   * for task augmentation of specific request types in their capabilities.
   */
  task: TaskMetadataSchema.optional()
});
var isTaskAugmentedRequestParams = (value) => TaskAugmentedRequestParamsSchema.safeParse(value).success;
var RequestSchema = object({
  method: string(),
  params: BaseRequestParamsSchema.loose().optional()
});
var NotificationsParamsSchema = object({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
});
var NotificationSchema = object({
  method: string(),
  params: NotificationsParamsSchema.loose().optional()
});
var ResultSchema = looseObject({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
});
var RequestIdSchema = union([string(), number().int()]);
var JSONRPCRequestSchema = object({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  ...RequestSchema.shape
}).strict();
var isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success;
var JSONRPCNotificationSchema = object({
  jsonrpc: literal(JSONRPC_VERSION),
  ...NotificationSchema.shape
}).strict();
var isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success;
var JSONRPCResultResponseSchema = object({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  result: ResultSchema
}).strict();
var isJSONRPCResultResponse = (value) => JSONRPCResultResponseSchema.safeParse(value).success;
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["ConnectionClosed"] = -32e3] = "ConnectionClosed";
  ErrorCode2[ErrorCode2["RequestTimeout"] = -32001] = "RequestTimeout";
  ErrorCode2[ErrorCode2["ParseError"] = -32700] = "ParseError";
  ErrorCode2[ErrorCode2["InvalidRequest"] = -32600] = "InvalidRequest";
  ErrorCode2[ErrorCode2["MethodNotFound"] = -32601] = "MethodNotFound";
  ErrorCode2[ErrorCode2["InvalidParams"] = -32602] = "InvalidParams";
  ErrorCode2[ErrorCode2["InternalError"] = -32603] = "InternalError";
  ErrorCode2[ErrorCode2["UrlElicitationRequired"] = -32042] = "UrlElicitationRequired";
})(ErrorCode || (ErrorCode = {}));
var JSONRPCErrorResponseSchema = object({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema.optional(),
  error: object({
    /**
     * The error type that occurred.
     */
    code: number().int(),
    /**
     * A short description of the error. The message SHOULD be limited to a concise single sentence.
     */
    message: string(),
    /**
     * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
     */
    data: unknown().optional()
  })
}).strict();
var isJSONRPCErrorResponse = (value) => JSONRPCErrorResponseSchema.safeParse(value).success;
var JSONRPCMessageSchema = union([
  JSONRPCRequestSchema,
  JSONRPCNotificationSchema,
  JSONRPCResultResponseSchema,
  JSONRPCErrorResponseSchema
]);
var JSONRPCResponseSchema = union([JSONRPCResultResponseSchema, JSONRPCErrorResponseSchema]);
var EmptyResultSchema = ResultSchema.strict();
var CancelledNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the request to cancel.
   *
   * This MUST correspond to the ID of a request previously issued in the same direction.
   */
  requestId: RequestIdSchema.optional(),
  /**
   * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
   */
  reason: string().optional()
});
var CancelledNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/cancelled"),
  params: CancelledNotificationParamsSchema
});
var IconSchema = object({
  /**
   * URL or data URI for the icon.
   */
  src: string(),
  /**
   * Optional MIME type for the icon.
   */
  mimeType: string().optional(),
  /**
   * Optional array of strings that specify sizes at which the icon can be used.
   * Each string should be in WxH format (e.g., `"48x48"`, `"96x96"`) or `"any"` for scalable formats like SVG.
   *
   * If not provided, the client should assume that the icon can be used at any size.
   */
  sizes: array(string()).optional(),
  /**
   * Optional specifier for the theme this icon is designed for. `light` indicates
   * the icon is designed to be used with a light background, and `dark` indicates
   * the icon is designed to be used with a dark background.
   *
   * If not provided, the client should assume the icon can be used with any theme.
   */
  theme: _enum(["light", "dark"]).optional()
});
var IconsSchema = object({
  /**
   * Optional set of sized icons that the client can display in a user interface.
   *
   * Clients that support rendering icons MUST support at least the following MIME types:
   * - `image/png` - PNG images (safe, universal compatibility)
   * - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
   *
   * Clients that support rendering icons SHOULD also support:
   * - `image/svg+xml` - SVG images (scalable but requires security precautions)
   * - `image/webp` - WebP images (modern, efficient format)
   */
  icons: array(IconSchema).optional()
});
var BaseMetadataSchema = object({
  /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */
  name: string(),
  /**
   * Intended for UI and end-user contexts  optimized to be human-readable and easily understood,
   * even by those unfamiliar with domain-specific terminology.
   *
   * If not provided, the name should be used for display (except for Tool,
   * where `annotations.title` should be given precedence over using `name`,
   * if present).
   */
  title: string().optional()
});
var ImplementationSchema = BaseMetadataSchema.extend({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  version: string(),
  /**
   * An optional URL of the website for this implementation.
   */
  websiteUrl: string().optional(),
  /**
   * An optional human-readable description of what this implementation does.
   *
   * This can be used by clients or servers to provide context about their purpose
   * and capabilities. For example, a server might describe the types of resources
   * or tools it provides, while a client might describe its intended use case.
   */
  description: string().optional()
});
var FormElicitationCapabilitySchema = intersection(object({
  applyDefaults: boolean().optional()
}), record(string(), unknown()));
var ElicitationCapabilitySchema = preprocess((value) => {
  if (value && typeof value === "object" && !Array.isArray(value)) {
    if (Object.keys(value).length === 0) {
      return { form: {} };
    }
  }
  return value;
}, intersection(object({
  form: FormElicitationCapabilitySchema.optional(),
  url: AssertObjectSchema.optional()
}), record(string(), unknown()).optional()));
var ClientTasksCapabilitySchema = looseObject({
  /**
   * Present if the client supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the client supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: looseObject({
    /**
     * Task support for sampling requests.
     */
    sampling: looseObject({
      createMessage: AssertObjectSchema.optional()
    }).optional(),
    /**
     * Task support for elicitation requests.
     */
    elicitation: looseObject({
      create: AssertObjectSchema.optional()
    }).optional()
  }).optional()
});
var ServerTasksCapabilitySchema = looseObject({
  /**
   * Present if the server supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the server supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: looseObject({
    /**
     * Task support for tool requests.
     */
    tools: looseObject({
      call: AssertObjectSchema.optional()
    }).optional()
  }).optional()
});
var ClientCapabilitiesSchema = object({
  /**
   * Experimental, non-standard capabilities that the client supports.
   */
  experimental: record(string(), AssertObjectSchema).optional(),
  /**
   * Present if the client supports sampling from an LLM.
   */
  sampling: object({
    /**
     * Present if the client supports context inclusion via includeContext parameter.
     * If not declared, servers SHOULD only use `includeContext: "none"` (or omit it).
     */
    context: AssertObjectSchema.optional(),
    /**
     * Present if the client supports tool use via tools and toolChoice parameters.
     */
    tools: AssertObjectSchema.optional()
  }).optional(),
  /**
   * Present if the client supports eliciting user input.
   */
  elicitation: ElicitationCapabilitySchema.optional(),
  /**
   * Present if the client supports listing roots.
   */
  roots: object({
    /**
     * Whether the client supports issuing notifications for changes to the roots list.
     */
    listChanged: boolean().optional()
  }).optional(),
  /**
   * Present if the client supports task creation.
   */
  tasks: ClientTasksCapabilitySchema.optional()
});
var InitializeRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
   */
  protocolVersion: string(),
  capabilities: ClientCapabilitiesSchema,
  clientInfo: ImplementationSchema
});
var InitializeRequestSchema = RequestSchema.extend({
  method: literal("initialize"),
  params: InitializeRequestParamsSchema
});
var ServerCapabilitiesSchema = object({
  /**
   * Experimental, non-standard capabilities that the server supports.
   */
  experimental: record(string(), AssertObjectSchema).optional(),
  /**
   * Present if the server supports sending log messages to the client.
   */
  logging: AssertObjectSchema.optional(),
  /**
   * Present if the server supports sending completions to the client.
   */
  completions: AssertObjectSchema.optional(),
  /**
   * Present if the server offers any prompt templates.
   */
  prompts: object({
    /**
     * Whether this server supports issuing notifications for changes to the prompt list.
     */
    listChanged: boolean().optional()
  }).optional(),
  /**
   * Present if the server offers any resources to read.
   */
  resources: object({
    /**
     * Whether this server supports clients subscribing to resource updates.
     */
    subscribe: boolean().optional(),
    /**
     * Whether this server supports issuing notifications for changes to the resource list.
     */
    listChanged: boolean().optional()
  }).optional(),
  /**
   * Present if the server offers any tools to call.
   */
  tools: object({
    /**
     * Whether this server supports issuing notifications for changes to the tool list.
     */
    listChanged: boolean().optional()
  }).optional(),
  /**
   * Present if the server supports task creation.
   */
  tasks: ServerTasksCapabilitySchema.optional()
});
var InitializeResultSchema = ResultSchema.extend({
  /**
   * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
   */
  protocolVersion: string(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ImplementationSchema,
  /**
   * Instructions describing how to use the server and its features.
   *
   * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
   */
  instructions: string().optional()
});
var InitializedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/initialized"),
  params: NotificationsParamsSchema.optional()
});
var isInitializedNotification = (value) => InitializedNotificationSchema.safeParse(value).success;
var PingRequestSchema = RequestSchema.extend({
  method: literal("ping"),
  params: BaseRequestParamsSchema.optional()
});
var ProgressSchema = object({
  /**
   * The progress thus far. This should increase every time progress is made, even if the total is unknown.
   */
  progress: number(),
  /**
   * Total number of items to process (or total progress required), if known.
   */
  total: optional(number()),
  /**
   * An optional message describing the current progress.
   */
  message: optional(string())
});
var ProgressNotificationParamsSchema = object({
  ...NotificationsParamsSchema.shape,
  ...ProgressSchema.shape,
  /**
   * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
   */
  progressToken: ProgressTokenSchema
});
var ProgressNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/progress"),
  params: ProgressNotificationParamsSchema
});
var PaginatedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * An opaque token representing the current pagination position.
   * If provided, the server should return results starting after this cursor.
   */
  cursor: CursorSchema.optional()
});
var PaginatedRequestSchema = RequestSchema.extend({
  params: PaginatedRequestParamsSchema.optional()
});
var PaginatedResultSchema = ResultSchema.extend({
  /**
   * An opaque token representing the pagination position after the last returned result.
   * If present, there may be more results available.
   */
  nextCursor: CursorSchema.optional()
});
var TaskStatusSchema = _enum(["working", "input_required", "completed", "failed", "cancelled"]);
var TaskSchema = object({
  taskId: string(),
  status: TaskStatusSchema,
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: union([number(), _null()]),
  /**
   * ISO 8601 timestamp when the task was created.
   */
  createdAt: string(),
  /**
   * ISO 8601 timestamp when the task was last updated.
   */
  lastUpdatedAt: string(),
  pollInterval: optional(number()),
  /**
   * Optional diagnostic message for failed tasks or other status information.
   */
  statusMessage: optional(string())
});
var CreateTaskResultSchema = ResultSchema.extend({
  task: TaskSchema
});
var TaskStatusNotificationParamsSchema = NotificationsParamsSchema.merge(TaskSchema);
var TaskStatusNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/tasks/status"),
  params: TaskStatusNotificationParamsSchema
});
var GetTaskRequestSchema = RequestSchema.extend({
  method: literal("tasks/get"),
  params: BaseRequestParamsSchema.extend({
    taskId: string()
  })
});
var GetTaskResultSchema = ResultSchema.merge(TaskSchema);
var GetTaskPayloadRequestSchema = RequestSchema.extend({
  method: literal("tasks/result"),
  params: BaseRequestParamsSchema.extend({
    taskId: string()
  })
});
var GetTaskPayloadResultSchema = ResultSchema.loose();
var ListTasksRequestSchema = PaginatedRequestSchema.extend({
  method: literal("tasks/list")
});
var ListTasksResultSchema = PaginatedResultSchema.extend({
  tasks: array(TaskSchema)
});
var CancelTaskRequestSchema = RequestSchema.extend({
  method: literal("tasks/cancel"),
  params: BaseRequestParamsSchema.extend({
    taskId: string()
  })
});
var CancelTaskResultSchema = ResultSchema.merge(TaskSchema);
var ResourceContentsSchema = object({
  /**
   * The URI of this resource.
   */
  uri: string(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional(string()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var TextResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
   */
  text: string()
});
var Base64Schema = string().refine((val) => {
  try {
    atob(val);
    return true;
  } catch {
    return false;
  }
}, { message: "Invalid Base64 string" });
var BlobResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * A base64-encoded string representing the binary data of the item.
   */
  blob: Base64Schema
});
var RoleSchema = _enum(["user", "assistant"]);
var AnnotationsSchema = object({
  /**
   * Intended audience(s) for the resource.
   */
  audience: array(RoleSchema).optional(),
  /**
   * Importance hint for the resource, from 0 (least) to 1 (most).
   */
  priority: number().min(0).max(1).optional(),
  /**
   * ISO 8601 timestamp for the most recent modification.
   */
  lastModified: iso_exports.datetime({ offset: true }).optional()
});
var ResourceSchema = object({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * The URI of this resource.
   */
  uri: string(),
  /**
   * A description of what this resource represents.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional(string()),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional(string()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
});
var ResourceTemplateSchema = object({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A URI template (according to RFC 6570) that can be used to construct resource URIs.
   */
  uriTemplate: string(),
  /**
   * A description of what this template is for.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional(string()),
  /**
   * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
   */
  mimeType: optional(string()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
});
var ListResourcesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/list")
});
var ListResourcesResultSchema = PaginatedResultSchema.extend({
  resources: array(ResourceSchema)
});
var ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/templates/list")
});
var ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({
  resourceTemplates: array(ResourceTemplateSchema)
});
var ResourceRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
   *
   * @format uri
   */
  uri: string()
});
var ReadResourceRequestParamsSchema = ResourceRequestParamsSchema;
var ReadResourceRequestSchema = RequestSchema.extend({
  method: literal("resources/read"),
  params: ReadResourceRequestParamsSchema
});
var ReadResourceResultSchema = ResultSchema.extend({
  contents: array(union([TextResourceContentsSchema, BlobResourceContentsSchema]))
});
var ResourceListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/list_changed"),
  params: NotificationsParamsSchema.optional()
});
var SubscribeRequestParamsSchema = ResourceRequestParamsSchema;
var SubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/subscribe"),
  params: SubscribeRequestParamsSchema
});
var UnsubscribeRequestParamsSchema = ResourceRequestParamsSchema;
var UnsubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/unsubscribe"),
  params: UnsubscribeRequestParamsSchema
});
var ResourceUpdatedNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
   */
  uri: string()
});
var ResourceUpdatedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/updated"),
  params: ResourceUpdatedNotificationParamsSchema
});
var PromptArgumentSchema = object({
  /**
   * The name of the argument.
   */
  name: string(),
  /**
   * A human-readable description of the argument.
   */
  description: optional(string()),
  /**
   * Whether this argument must be provided.
   */
  required: optional(boolean())
});
var PromptSchema = object({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * An optional description of what this prompt provides
   */
  description: optional(string()),
  /**
   * A list of arguments to use for templating the prompt.
   */
  arguments: optional(array(PromptArgumentSchema)),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
});
var ListPromptsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("prompts/list")
});
var ListPromptsResultSchema = PaginatedResultSchema.extend({
  prompts: array(PromptSchema)
});
var GetPromptRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The name of the prompt or prompt template.
   */
  name: string(),
  /**
   * Arguments to use for templating the prompt.
   */
  arguments: record(string(), string()).optional()
});
var GetPromptRequestSchema = RequestSchema.extend({
  method: literal("prompts/get"),
  params: GetPromptRequestParamsSchema
});
var TextContentSchema = object({
  type: literal("text"),
  /**
   * The text content of the message.
   */
  text: string(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var ImageContentSchema = object({
  type: literal("image"),
  /**
   * The base64-encoded image data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the image. Different providers may support different image types.
   */
  mimeType: string(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var AudioContentSchema = object({
  type: literal("audio"),
  /**
   * The base64-encoded audio data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the audio. Different providers may support different audio types.
   */
  mimeType: string(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var ToolUseContentSchema = object({
  type: literal("tool_use"),
  /**
   * The name of the tool to invoke.
   * Must match a tool name from the request's tools array.
   */
  name: string(),
  /**
   * Unique identifier for this tool call.
   * Used to correlate with ToolResultContent in subsequent messages.
   */
  id: string(),
  /**
   * Arguments to pass to the tool.
   * Must conform to the tool's inputSchema.
   */
  input: record(string(), unknown()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var EmbeddedResourceSchema = object({
  type: literal("resource"),
  resource: union([TextResourceContentsSchema, BlobResourceContentsSchema]),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var ResourceLinkSchema = ResourceSchema.extend({
  type: literal("resource_link")
});
var ContentBlockSchema = union([
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ResourceLinkSchema,
  EmbeddedResourceSchema
]);
var PromptMessageSchema = object({
  role: RoleSchema,
  content: ContentBlockSchema
});
var GetPromptResultSchema = ResultSchema.extend({
  /**
   * An optional description for the prompt.
   */
  description: string().optional(),
  messages: array(PromptMessageSchema)
});
var PromptListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/prompts/list_changed"),
  params: NotificationsParamsSchema.optional()
});
var ToolAnnotationsSchema = object({
  /**
   * A human-readable title for the tool.
   */
  title: string().optional(),
  /**
   * If true, the tool does not modify its environment.
   *
   * Default: false
   */
  readOnlyHint: boolean().optional(),
  /**
   * If true, the tool may perform destructive updates to its environment.
   * If false, the tool performs only additive updates.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: true
   */
  destructiveHint: boolean().optional(),
  /**
   * If true, calling the tool repeatedly with the same arguments
   * will have no additional effect on the its environment.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: false
   */
  idempotentHint: boolean().optional(),
  /**
   * If true, this tool may interact with an "open world" of external
   * entities. If false, the tool's domain of interaction is closed.
   * For example, the world of a web search tool is open, whereas that
   * of a memory tool is not.
   *
   * Default: true
   */
  openWorldHint: boolean().optional()
});
var ToolExecutionSchema = object({
  /**
   * Indicates the tool's preference for task-augmented execution.
   * - "required": Clients MUST invoke the tool as a task
   * - "optional": Clients MAY invoke the tool as a task or normal request
   * - "forbidden": Clients MUST NOT attempt to invoke the tool as a task
   *
   * If not present, defaults to "forbidden".
   */
  taskSupport: _enum(["required", "optional", "forbidden"]).optional()
});
var ToolSchema = object({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A human-readable description of the tool.
   */
  description: string().optional(),
  /**
   * A JSON Schema 2020-12 object defining the expected parameters for the tool.
   * Must have type: 'object' at the root level per MCP spec.
   */
  inputSchema: object({
    type: literal("object"),
    properties: record(string(), AssertObjectSchema).optional(),
    required: array(string()).optional()
  }).catchall(unknown()),
  /**
   * An optional JSON Schema 2020-12 object defining the structure of the tool's output
   * returned in the structuredContent field of a CallToolResult.
   * Must have type: 'object' at the root level per MCP spec.
   */
  outputSchema: object({
    type: literal("object"),
    properties: record(string(), AssertObjectSchema).optional(),
    required: array(string()).optional()
  }).catchall(unknown()).optional(),
  /**
   * Optional additional tool information.
   */
  annotations: ToolAnnotationsSchema.optional(),
  /**
   * Execution-related properties for this tool.
   */
  execution: ToolExecutionSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var ListToolsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("tools/list")
});
var ListToolsResultSchema = PaginatedResultSchema.extend({
  tools: array(ToolSchema)
});
var CallToolResultSchema = ResultSchema.extend({
  /**
   * A list of content objects that represent the result of the tool call.
   *
   * If the Tool does not define an outputSchema, this field MUST be present in the result.
   * For backwards compatibility, this field is always present, but it may be empty.
   */
  content: array(ContentBlockSchema).default([]),
  /**
   * An object containing structured tool output.
   *
   * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
   */
  structuredContent: record(string(), unknown()).optional(),
  /**
   * Whether the tool call ended in an error.
   *
   * If not set, this is assumed to be false (the call was successful).
   *
   * Any errors that originate from the tool SHOULD be reported inside the result
   * object, with `isError` set to true, _not_ as an MCP protocol-level error
   * response. Otherwise, the LLM would not be able to see that an error occurred
   * and self-correct.
   *
   * However, any errors in _finding_ the tool, an error indicating that the
   * server does not support tool calls, or any other exceptional conditions,
   * should be reported as an MCP error response.
   */
  isError: boolean().optional()
});
var CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({
  toolResult: unknown()
}));
var CallToolRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The name of the tool to call.
   */
  name: string(),
  /**
   * Arguments to pass to the tool.
   */
  arguments: record(string(), unknown()).optional()
});
var CallToolRequestSchema = RequestSchema.extend({
  method: literal("tools/call"),
  params: CallToolRequestParamsSchema
});
var ToolListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/tools/list_changed"),
  params: NotificationsParamsSchema.optional()
});
var ListChangedOptionsBaseSchema = object({
  /**
   * If true, the list will be refreshed automatically when a list changed notification is received.
   * The callback will be called with the updated list.
   *
   * If false, the callback will be called with null items, allowing manual refresh.
   *
   * @default true
   */
  autoRefresh: boolean().default(true),
  /**
   * Debounce time in milliseconds for list changed notification processing.
   *
   * Multiple notifications received within this timeframe will only trigger one refresh.
   * Set to 0 to disable debouncing.
   *
   * @default 300
   */
  debounceMs: number().int().nonnegative().default(300)
});
var LoggingLevelSchema = _enum(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]);
var SetLevelRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
   */
  level: LoggingLevelSchema
});
var SetLevelRequestSchema = RequestSchema.extend({
  method: literal("logging/setLevel"),
  params: SetLevelRequestParamsSchema
});
var LoggingMessageNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The severity of this log message.
   */
  level: LoggingLevelSchema,
  /**
   * An optional name of the logger issuing this message.
   */
  logger: string().optional(),
  /**
   * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
   */
  data: unknown()
});
var LoggingMessageNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/message"),
  params: LoggingMessageNotificationParamsSchema
});
var ModelHintSchema = object({
  /**
   * A hint for a model name.
   */
  name: string().optional()
});
var ModelPreferencesSchema = object({
  /**
   * Optional hints to use for model selection.
   */
  hints: array(ModelHintSchema).optional(),
  /**
   * How much to prioritize cost when selecting a model.
   */
  costPriority: number().min(0).max(1).optional(),
  /**
   * How much to prioritize sampling speed (latency) when selecting a model.
   */
  speedPriority: number().min(0).max(1).optional(),
  /**
   * How much to prioritize intelligence and capabilities when selecting a model.
   */
  intelligencePriority: number().min(0).max(1).optional()
});
var ToolChoiceSchema = object({
  /**
   * Controls when tools are used:
   * - "auto": Model decides whether to use tools (default)
   * - "required": Model MUST use at least one tool before completing
   * - "none": Model MUST NOT use any tools
   */
  mode: _enum(["auto", "required", "none"]).optional()
});
var ToolResultContentSchema = object({
  type: literal("tool_result"),
  toolUseId: string().describe("The unique identifier for the corresponding tool call."),
  content: array(ContentBlockSchema).default([]),
  structuredContent: object({}).loose().optional(),
  isError: boolean().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var SamplingContentSchema = discriminatedUnion("type", [TextContentSchema, ImageContentSchema, AudioContentSchema]);
var SamplingMessageContentBlockSchema = discriminatedUnion("type", [
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ToolUseContentSchema,
  ToolResultContentSchema
]);
var SamplingMessageSchema = object({
  role: RoleSchema,
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)]),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var CreateMessageRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  messages: array(SamplingMessageSchema),
  /**
   * The server's preferences for which model to select. The client MAY modify or omit this request.
   */
  modelPreferences: ModelPreferencesSchema.optional(),
  /**
   * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
   */
  systemPrompt: string().optional(),
  /**
   * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt.
   * The client MAY ignore this request.
   *
   * Default is "none". Values "thisServer" and "allServers" are soft-deprecated. Servers SHOULD only use these values if the client
   * declares ClientCapabilities.sampling.context. These values may be removed in future spec releases.
   */
  includeContext: _enum(["none", "thisServer", "allServers"]).optional(),
  temperature: number().optional(),
  /**
   * The requested maximum number of tokens to sample (to prevent runaway completions).
   *
   * The client MAY choose to sample fewer tokens than the requested maximum.
   */
  maxTokens: number().int(),
  stopSequences: array(string()).optional(),
  /**
   * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
   */
  metadata: AssertObjectSchema.optional(),
  /**
   * Tools that the model may use during generation.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   */
  tools: array(ToolSchema).optional(),
  /**
   * Controls how the model uses tools.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   * Default is `{ mode: "auto" }`.
   */
  toolChoice: ToolChoiceSchema.optional()
});
var CreateMessageRequestSchema = RequestSchema.extend({
  method: literal("sampling/createMessage"),
  params: CreateMessageRequestParamsSchema
});
var CreateMessageResultSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: string(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: optional(_enum(["endTurn", "stopSequence", "maxTokens"]).or(string())),
  role: RoleSchema,
  /**
   * Response content. Single content block (text, image, or audio).
   */
  content: SamplingContentSchema
});
var CreateMessageResultWithToolsSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: string(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   * - "toolUse": The model wants to use one or more tools
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: optional(_enum(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(string())),
  role: RoleSchema,
  /**
   * Response content. May be a single block or array. May include ToolUseContent if stopReason is "toolUse".
   */
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)])
});
var BooleanSchemaSchema = object({
  type: literal("boolean"),
  title: string().optional(),
  description: string().optional(),
  default: boolean().optional()
});
var StringSchemaSchema = object({
  type: literal("string"),
  title: string().optional(),
  description: string().optional(),
  minLength: number().optional(),
  maxLength: number().optional(),
  format: _enum(["email", "uri", "date", "date-time"]).optional(),
  default: string().optional()
});
var NumberSchemaSchema = object({
  type: _enum(["number", "integer"]),
  title: string().optional(),
  description: string().optional(),
  minimum: number().optional(),
  maximum: number().optional(),
  default: number().optional()
});
var UntitledSingleSelectEnumSchemaSchema = object({
  type: literal("string"),
  title: string().optional(),
  description: string().optional(),
  enum: array(string()),
  default: string().optional()
});
var TitledSingleSelectEnumSchemaSchema = object({
  type: literal("string"),
  title: string().optional(),
  description: string().optional(),
  oneOf: array(object({
    const: string(),
    title: string()
  })),
  default: string().optional()
});
var LegacyTitledEnumSchemaSchema = object({
  type: literal("string"),
  title: string().optional(),
  description: string().optional(),
  enum: array(string()),
  enumNames: array(string()).optional(),
  default: string().optional()
});
var SingleSelectEnumSchemaSchema = union([UntitledSingleSelectEnumSchemaSchema, TitledSingleSelectEnumSchemaSchema]);
var UntitledMultiSelectEnumSchemaSchema = object({
  type: literal("array"),
  title: string().optional(),
  description: string().optional(),
  minItems: number().optional(),
  maxItems: number().optional(),
  items: object({
    type: literal("string"),
    enum: array(string())
  }),
  default: array(string()).optional()
});
var TitledMultiSelectEnumSchemaSchema = object({
  type: literal("array"),
  title: string().optional(),
  description: string().optional(),
  minItems: number().optional(),
  maxItems: number().optional(),
  items: object({
    anyOf: array(object({
      const: string(),
      title: string()
    }))
  }),
  default: array(string()).optional()
});
var MultiSelectEnumSchemaSchema = union([UntitledMultiSelectEnumSchemaSchema, TitledMultiSelectEnumSchemaSchema]);
var EnumSchemaSchema = union([LegacyTitledEnumSchemaSchema, SingleSelectEnumSchemaSchema, MultiSelectEnumSchemaSchema]);
var PrimitiveSchemaDefinitionSchema = union([EnumSchemaSchema, BooleanSchemaSchema, StringSchemaSchema, NumberSchemaSchema]);
var ElicitRequestFormParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   *
   * Optional for backward compatibility. Clients MUST treat missing mode as "form".
   */
  mode: literal("form").optional(),
  /**
   * The message to present to the user describing what information is being requested.
   */
  message: string(),
  /**
   * A restricted subset of JSON Schema.
   * Only top-level properties are allowed, without nesting.
   */
  requestedSchema: object({
    type: literal("object"),
    properties: record(string(), PrimitiveSchemaDefinitionSchema),
    required: array(string()).optional()
  })
});
var ElicitRequestURLParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   */
  mode: literal("url"),
  /**
   * The message to present to the user explaining why the interaction is needed.
   */
  message: string(),
  /**
   * The ID of the elicitation, which must be unique within the context of the server.
   * The client MUST treat this ID as an opaque value.
   */
  elicitationId: string(),
  /**
   * The URL that the user should navigate to.
   */
  url: string().url()
});
var ElicitRequestParamsSchema = union([ElicitRequestFormParamsSchema, ElicitRequestURLParamsSchema]);
var ElicitRequestSchema = RequestSchema.extend({
  method: literal("elicitation/create"),
  params: ElicitRequestParamsSchema
});
var ElicitationCompleteNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the elicitation that completed.
   */
  elicitationId: string()
});
var ElicitationCompleteNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/elicitation/complete"),
  params: ElicitationCompleteNotificationParamsSchema
});
var ElicitResultSchema = ResultSchema.extend({
  /**
   * The user action in response to the elicitation.
   * - "accept": User submitted the form/confirmed the action
   * - "decline": User explicitly decline the action
   * - "cancel": User dismissed without making an explicit choice
   */
  action: _enum(["accept", "decline", "cancel"]),
  /**
   * The submitted form data, only present when action is "accept".
   * Contains values matching the requested schema.
   * Per MCP spec, content is "typically omitted" for decline/cancel actions.
   * We normalize null to undefined for leniency while maintaining type compatibility.
   */
  content: preprocess((val) => val === null ? void 0 : val, record(string(), union([string(), number(), boolean(), array(string())])).optional())
});
var ResourceTemplateReferenceSchema = object({
  type: literal("ref/resource"),
  /**
   * The URI or URI template of the resource.
   */
  uri: string()
});
var PromptReferenceSchema = object({
  type: literal("ref/prompt"),
  /**
   * The name of the prompt or prompt template
   */
  name: string()
});
var CompleteRequestParamsSchema = BaseRequestParamsSchema.extend({
  ref: union([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
  /**
   * The argument's information
   */
  argument: object({
    /**
     * The name of the argument
     */
    name: string(),
    /**
     * The value of the argument to use for completion matching.
     */
    value: string()
  }),
  context: object({
    /**
     * Previously-resolved variables in a URI template or prompt.
     */
    arguments: record(string(), string()).optional()
  }).optional()
});
var CompleteRequestSchema = RequestSchema.extend({
  method: literal("completion/complete"),
  params: CompleteRequestParamsSchema
});
var CompleteResultSchema = ResultSchema.extend({
  completion: looseObject({
    /**
     * An array of completion values. Must not exceed 100 items.
     */
    values: array(string()).max(100),
    /**
     * The total number of completion options available. This can exceed the number of values actually sent in the response.
     */
    total: optional(number().int()),
    /**
     * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
     */
    hasMore: optional(boolean())
  })
});
var RootSchema = object({
  /**
   * The URI identifying the root. This *must* start with file:// for now.
   */
  uri: string().startsWith("file://"),
  /**
   * An optional name for the root.
   */
  name: string().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var ListRootsRequestSchema = RequestSchema.extend({
  method: literal("roots/list"),
  params: BaseRequestParamsSchema.optional()
});
var ListRootsResultSchema = ResultSchema.extend({
  roots: array(RootSchema)
});
var RootsListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/roots/list_changed"),
  params: NotificationsParamsSchema.optional()
});
var ClientRequestSchema = union([
  PingRequestSchema,
  InitializeRequestSchema,
  CompleteRequestSchema,
  SetLevelRequestSchema,
  GetPromptRequestSchema,
  ListPromptsRequestSchema,
  ListResourcesRequestSchema,
  ListResourceTemplatesRequestSchema,
  ReadResourceRequestSchema,
  SubscribeRequestSchema,
  UnsubscribeRequestSchema,
  CallToolRequestSchema,
  ListToolsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]);
var ClientNotificationSchema = union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  InitializedNotificationSchema,
  RootsListChangedNotificationSchema,
  TaskStatusNotificationSchema
]);
var ClientResultSchema = union([
  EmptyResultSchema,
  CreateMessageResultSchema,
  CreateMessageResultWithToolsSchema,
  ElicitResultSchema,
  ListRootsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]);
var ServerRequestSchema = union([
  PingRequestSchema,
  CreateMessageRequestSchema,
  ElicitRequestSchema,
  ListRootsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]);
var ServerNotificationSchema = union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  LoggingMessageNotificationSchema,
  ResourceUpdatedNotificationSchema,
  ResourceListChangedNotificationSchema,
  ToolListChangedNotificationSchema,
  PromptListChangedNotificationSchema,
  TaskStatusNotificationSchema,
  ElicitationCompleteNotificationSchema
]);
var ServerResultSchema = union([
  EmptyResultSchema,
  InitializeResultSchema,
  CompleteResultSchema,
  GetPromptResultSchema,
  ListPromptsResultSchema,
  ListResourcesResultSchema,
  ListResourceTemplatesResultSchema,
  ReadResourceResultSchema,
  CallToolResultSchema,
  ListToolsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]);
var McpError = class _McpError extends Error {
  constructor(code, message, data) {
    super(`MCP error ${code}: ${message}`);
    this.code = code;
    this.data = data;
    this.name = "McpError";
  }
  /**
   * Factory method to create the appropriate error type based on the error code and data
   */
  static fromError(code, message, data) {
    if (code === ErrorCode.UrlElicitationRequired && data) {
      const errorData = data;
      if (errorData.elicitations) {
        return new UrlElicitationRequiredError(errorData.elicitations, message);
      }
    }
    return new _McpError(code, message, data);
  }
};
var UrlElicitationRequiredError = class extends McpError {
  constructor(elicitations, message = `URL elicitation${elicitations.length > 1 ? "s" : ""} required`) {
    super(ErrorCode.UrlElicitationRequired, message, {
      elicitations
    });
  }
  get elicitations() {
    return this.data?.elicitations ?? [];
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/interfaces.js
function isTerminal(status) {
  return status === "completed" || status === "failed" || status === "cancelled";
}

// node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-json-schema-compat.js
function getMethodLiteral(schema) {
  const shape = getObjectShape(schema);
  const methodSchema = shape?.method;
  if (!methodSchema) {
    throw new Error("Schema is missing a method literal");
  }
  const value = getLiteralValue(methodSchema);
  if (typeof value !== "string") {
    throw new Error("Schema method literal must be a string");
  }
  return value;
}
function parseWithCompat(schema, data) {
  const result = safeParse2(schema, data);
  if (!result.success) {
    throw result.error;
  }
  return result.data;
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
var DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4;
var Protocol = class {
  constructor(_options) {
    this._options = _options;
    this._requestMessageId = 0;
    this._requestHandlers = /* @__PURE__ */ new Map();
    this._requestHandlerAbortControllers = /* @__PURE__ */ new Map();
    this._notificationHandlers = /* @__PURE__ */ new Map();
    this._responseHandlers = /* @__PURE__ */ new Map();
    this._progressHandlers = /* @__PURE__ */ new Map();
    this._timeoutInfo = /* @__PURE__ */ new Map();
    this._pendingDebouncedNotifications = /* @__PURE__ */ new Set();
    this._taskProgressTokens = /* @__PURE__ */ new Map();
    this._requestResolvers = /* @__PURE__ */ new Map();
    this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
      this._oncancel(notification);
    });
    this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
      this._onprogress(notification);
    });
    this.setRequestHandler(
      PingRequestSchema,
      // Automatic pong by default.
      (_request) => ({})
    );
    this._taskStore = _options?.taskStore;
    this._taskMessageQueue = _options?.taskMessageQueue;
    if (this._taskStore) {
      this.setRequestHandler(GetTaskRequestSchema, async (request, extra) => {
        const task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        }
        return {
          ...task
        };
      });
      this.setRequestHandler(GetTaskPayloadRequestSchema, async (request, extra) => {
        const handleTaskResult = async () => {
          const taskId = request.params.taskId;
          if (this._taskMessageQueue) {
            let queuedMessage;
            while (queuedMessage = await this._taskMessageQueue.dequeue(taskId, extra.sessionId)) {
              if (queuedMessage.type === "response" || queuedMessage.type === "error") {
                const message = queuedMessage.message;
                const requestId = message.id;
                const resolver = this._requestResolvers.get(requestId);
                if (resolver) {
                  this._requestResolvers.delete(requestId);
                  if (queuedMessage.type === "response") {
                    resolver(message);
                  } else {
                    const errorMessage = message;
                    const error = new McpError(errorMessage.error.code, errorMessage.error.message, errorMessage.error.data);
                    resolver(error);
                  }
                } else {
                  const messageType = queuedMessage.type === "response" ? "Response" : "Error";
                  this._onerror(new Error(`${messageType} handler missing for request ${requestId}`));
                }
                continue;
              }
              await this._transport?.send(queuedMessage.message, { relatedRequestId: extra.requestId });
            }
          }
          const task = await this._taskStore.getTask(taskId, extra.sessionId);
          if (!task) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found: ${taskId}`);
          }
          if (!isTerminal(task.status)) {
            await this._waitForTaskUpdate(taskId, extra.signal);
            return await handleTaskResult();
          }
          if (isTerminal(task.status)) {
            const result = await this._taskStore.getTaskResult(taskId, extra.sessionId);
            this._clearTaskQueue(taskId);
            return {
              ...result,
              _meta: {
                ...result._meta,
                [RELATED_TASK_META_KEY]: {
                  taskId
                }
              }
            };
          }
          return await handleTaskResult();
        };
        return await handleTaskResult();
      });
      this.setRequestHandler(ListTasksRequestSchema, async (request, extra) => {
        try {
          const { tasks, nextCursor } = await this._taskStore.listTasks(request.params?.cursor, extra.sessionId);
          return {
            tasks,
            nextCursor,
            _meta: {}
          };
        } catch (error) {
          throw new McpError(ErrorCode.InvalidParams, `Failed to list tasks: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
      this.setRequestHandler(CancelTaskRequestSchema, async (request, extra) => {
        try {
          const task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
          if (!task) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found: ${request.params.taskId}`);
          }
          if (isTerminal(task.status)) {
            throw new McpError(ErrorCode.InvalidParams, `Cannot cancel task in terminal status: ${task.status}`);
          }
          await this._taskStore.updateTaskStatus(request.params.taskId, "cancelled", "Client cancelled task execution.", extra.sessionId);
          this._clearTaskQueue(request.params.taskId);
          const cancelledTask = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
          if (!cancelledTask) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found after cancellation: ${request.params.taskId}`);
          }
          return {
            _meta: {},
            ...cancelledTask
          };
        } catch (error) {
          if (error instanceof McpError) {
            throw error;
          }
          throw new McpError(ErrorCode.InvalidRequest, `Failed to cancel task: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
    }
  }
  async _oncancel(notification) {
    if (!notification.params.requestId) {
      return;
    }
    const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
    controller?.abort(notification.params.reason);
  }
  _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
    this._timeoutInfo.set(messageId, {
      timeoutId: setTimeout(onTimeout, timeout),
      startTime: Date.now(),
      timeout,
      maxTotalTimeout,
      resetTimeoutOnProgress,
      onTimeout
    });
  }
  _resetTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (!info)
      return false;
    const totalElapsed = Date.now() - info.startTime;
    if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
      this._timeoutInfo.delete(messageId);
      throw McpError.fromError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", {
        maxTotalTimeout: info.maxTotalTimeout,
        totalElapsed
      });
    }
    clearTimeout(info.timeoutId);
    info.timeoutId = setTimeout(info.onTimeout, info.timeout);
    return true;
  }
  _cleanupTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (info) {
      clearTimeout(info.timeoutId);
      this._timeoutInfo.delete(messageId);
    }
  }
  /**
   * Attaches to the given transport, starts it, and starts listening for messages.
   *
   * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
   */
  async connect(transport) {
    if (this._transport) {
      throw new Error("Already connected to a transport. Call close() before connecting to a new transport, or use a separate Protocol instance per connection.");
    }
    this._transport = transport;
    const _onclose = this.transport?.onclose;
    this._transport.onclose = () => {
      _onclose?.();
      this._onclose();
    };
    const _onerror = this.transport?.onerror;
    this._transport.onerror = (error) => {
      _onerror?.(error);
      this._onerror(error);
    };
    const _onmessage = this._transport?.onmessage;
    this._transport.onmessage = (message, extra) => {
      _onmessage?.(message, extra);
      if (isJSONRPCResultResponse(message) || isJSONRPCErrorResponse(message)) {
        this._onresponse(message);
      } else if (isJSONRPCRequest(message)) {
        this._onrequest(message, extra);
      } else if (isJSONRPCNotification(message)) {
        this._onnotification(message);
      } else {
        this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
      }
    };
    await this._transport.start();
  }
  _onclose() {
    const responseHandlers = this._responseHandlers;
    this._responseHandlers = /* @__PURE__ */ new Map();
    this._progressHandlers.clear();
    this._taskProgressTokens.clear();
    this._pendingDebouncedNotifications.clear();
    for (const controller of this._requestHandlerAbortControllers.values()) {
      controller.abort();
    }
    this._requestHandlerAbortControllers.clear();
    const error = McpError.fromError(ErrorCode.ConnectionClosed, "Connection closed");
    this._transport = void 0;
    this.onclose?.();
    for (const handler of responseHandlers.values()) {
      handler(error);
    }
  }
  _onerror(error) {
    this.onerror?.(error);
  }
  _onnotification(notification) {
    const handler = this._notificationHandlers.get(notification.method) ?? this.fallbackNotificationHandler;
    if (handler === void 0) {
      return;
    }
    Promise.resolve().then(() => handler(notification)).catch((error) => this._onerror(new Error(`Uncaught error in notification handler: ${error}`)));
  }
  _onrequest(request, extra) {
    const handler = this._requestHandlers.get(request.method) ?? this.fallbackRequestHandler;
    const capturedTransport = this._transport;
    const relatedTaskId = request.params?._meta?.[RELATED_TASK_META_KEY]?.taskId;
    if (handler === void 0) {
      const errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: ErrorCode.MethodNotFound,
          message: "Method not found"
        }
      };
      if (relatedTaskId && this._taskMessageQueue) {
        this._enqueueTaskMessage(relatedTaskId, {
          type: "error",
          message: errorResponse,
          timestamp: Date.now()
        }, capturedTransport?.sessionId).catch((error) => this._onerror(new Error(`Failed to enqueue error response: ${error}`)));
      } else {
        capturedTransport?.send(errorResponse).catch((error) => this._onerror(new Error(`Failed to send an error response: ${error}`)));
      }
      return;
    }
    const abortController = new AbortController();
    this._requestHandlerAbortControllers.set(request.id, abortController);
    const taskCreationParams = isTaskAugmentedRequestParams(request.params) ? request.params.task : void 0;
    const taskStore = this._taskStore ? this.requestTaskStore(request, capturedTransport?.sessionId) : void 0;
    const fullExtra = {
      signal: abortController.signal,
      sessionId: capturedTransport?.sessionId,
      _meta: request.params?._meta,
      sendNotification: async (notification) => {
        if (abortController.signal.aborted)
          return;
        const notificationOptions = { relatedRequestId: request.id };
        if (relatedTaskId) {
          notificationOptions.relatedTask = { taskId: relatedTaskId };
        }
        await this.notification(notification, notificationOptions);
      },
      sendRequest: async (r, resultSchema, options) => {
        if (abortController.signal.aborted) {
          throw new McpError(ErrorCode.ConnectionClosed, "Request was cancelled");
        }
        const requestOptions = { ...options, relatedRequestId: request.id };
        if (relatedTaskId && !requestOptions.relatedTask) {
          requestOptions.relatedTask = { taskId: relatedTaskId };
        }
        const effectiveTaskId = requestOptions.relatedTask?.taskId ?? relatedTaskId;
        if (effectiveTaskId && taskStore) {
          await taskStore.updateTaskStatus(effectiveTaskId, "input_required");
        }
        return await this.request(r, resultSchema, requestOptions);
      },
      authInfo: extra?.authInfo,
      requestId: request.id,
      requestInfo: extra?.requestInfo,
      taskId: relatedTaskId,
      taskStore,
      taskRequestedTtl: taskCreationParams?.ttl,
      closeSSEStream: extra?.closeSSEStream,
      closeStandaloneSSEStream: extra?.closeStandaloneSSEStream
    };
    Promise.resolve().then(() => {
      if (taskCreationParams) {
        this.assertTaskHandlerCapability(request.method);
      }
    }).then(() => handler(request, fullExtra)).then(async (result) => {
      if (abortController.signal.aborted) {
        return;
      }
      const response = {
        result,
        jsonrpc: "2.0",
        id: request.id
      };
      if (relatedTaskId && this._taskMessageQueue) {
        await this._enqueueTaskMessage(relatedTaskId, {
          type: "response",
          message: response,
          timestamp: Date.now()
        }, capturedTransport?.sessionId);
      } else {
        await capturedTransport?.send(response);
      }
    }, async (error) => {
      if (abortController.signal.aborted) {
        return;
      }
      const errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: Number.isSafeInteger(error["code"]) ? error["code"] : ErrorCode.InternalError,
          message: error.message ?? "Internal error",
          ...error["data"] !== void 0 && { data: error["data"] }
        }
      };
      if (relatedTaskId && this._taskMessageQueue) {
        await this._enqueueTaskMessage(relatedTaskId, {
          type: "error",
          message: errorResponse,
          timestamp: Date.now()
        }, capturedTransport?.sessionId);
      } else {
        await capturedTransport?.send(errorResponse);
      }
    }).catch((error) => this._onerror(new Error(`Failed to send response: ${error}`))).finally(() => {
      this._requestHandlerAbortControllers.delete(request.id);
    });
  }
  _onprogress(notification) {
    const { progressToken, ...params } = notification.params;
    const messageId = Number(progressToken);
    const handler = this._progressHandlers.get(messageId);
    if (!handler) {
      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
      return;
    }
    const responseHandler = this._responseHandlers.get(messageId);
    const timeoutInfo = this._timeoutInfo.get(messageId);
    if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {
      try {
        this._resetTimeout(messageId);
      } catch (error) {
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        responseHandler(error);
        return;
      }
    }
    handler(params);
  }
  _onresponse(response) {
    const messageId = Number(response.id);
    const resolver = this._requestResolvers.get(messageId);
    if (resolver) {
      this._requestResolvers.delete(messageId);
      if (isJSONRPCResultResponse(response)) {
        resolver(response);
      } else {
        const error = new McpError(response.error.code, response.error.message, response.error.data);
        resolver(error);
      }
      return;
    }
    const handler = this._responseHandlers.get(messageId);
    if (handler === void 0) {
      this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
      return;
    }
    this._responseHandlers.delete(messageId);
    this._cleanupTimeout(messageId);
    let isTaskResponse = false;
    if (isJSONRPCResultResponse(response) && response.result && typeof response.result === "object") {
      const result = response.result;
      if (result.task && typeof result.task === "object") {
        const task = result.task;
        if (typeof task.taskId === "string") {
          isTaskResponse = true;
          this._taskProgressTokens.set(task.taskId, messageId);
        }
      }
    }
    if (!isTaskResponse) {
      this._progressHandlers.delete(messageId);
    }
    if (isJSONRPCResultResponse(response)) {
      handler(response);
    } else {
      const error = McpError.fromError(response.error.code, response.error.message, response.error.data);
      handler(error);
    }
  }
  get transport() {
    return this._transport;
  }
  /**
   * Closes the connection.
   */
  async close() {
    await this._transport?.close();
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * @example
   * ```typescript
   * const stream = protocol.requestStream(request, resultSchema, options);
   * for await (const message of stream) {
   *   switch (message.type) {
   *     case 'taskCreated':
   *       console.log('Task created:', message.task.taskId);
   *       break;
   *     case 'taskStatus':
   *       console.log('Task status:', message.task.status);
   *       break;
   *     case 'result':
   *       console.log('Final result:', message.result);
   *       break;
   *     case 'error':
   *       console.error('Error:', message.error);
   *       break;
   *   }
   * }
   * ```
   *
   * @experimental Use `client.experimental.tasks.requestStream()` to access this method.
   */
  async *requestStream(request, resultSchema, options) {
    const { task } = options ?? {};
    if (!task) {
      try {
        const result = await this.request(request, resultSchema, options);
        yield { type: "result", result };
      } catch (error) {
        yield {
          type: "error",
          error: error instanceof McpError ? error : new McpError(ErrorCode.InternalError, String(error))
        };
      }
      return;
    }
    let taskId;
    try {
      const createResult = await this.request(request, CreateTaskResultSchema, options);
      if (createResult.task) {
        taskId = createResult.task.taskId;
        yield { type: "taskCreated", task: createResult.task };
      } else {
        throw new McpError(ErrorCode.InternalError, "Task creation did not return a task");
      }
      while (true) {
        const task2 = await this.getTask({ taskId }, options);
        yield { type: "taskStatus", task: task2 };
        if (isTerminal(task2.status)) {
          if (task2.status === "completed") {
            const result = await this.getTaskResult({ taskId }, resultSchema, options);
            yield { type: "result", result };
          } else if (task2.status === "failed") {
            yield {
              type: "error",
              error: new McpError(ErrorCode.InternalError, `Task ${taskId} failed`)
            };
          } else if (task2.status === "cancelled") {
            yield {
              type: "error",
              error: new McpError(ErrorCode.InternalError, `Task ${taskId} was cancelled`)
            };
          }
          return;
        }
        if (task2.status === "input_required") {
          const result = await this.getTaskResult({ taskId }, resultSchema, options);
          yield { type: "result", result };
          return;
        }
        const pollInterval = task2.pollInterval ?? this._options?.defaultTaskPollInterval ?? 1e3;
        await new Promise((resolve) => setTimeout(resolve, pollInterval));
        options?.signal?.throwIfAborted();
      }
    } catch (error) {
      yield {
        type: "error",
        error: error instanceof McpError ? error : new McpError(ErrorCode.InternalError, String(error))
      };
    }
  }
  /**
   * Sends a request and waits for a response.
   *
   * Do not use this method to emit notifications! Use notification() instead.
   */
  request(request, resultSchema, options) {
    const { relatedRequestId, resumptionToken, onresumptiontoken, task, relatedTask } = options ?? {};
    return new Promise((resolve, reject) => {
      const earlyReject = (error) => {
        reject(error);
      };
      if (!this._transport) {
        earlyReject(new Error("Not connected"));
        return;
      }
      if (this._options?.enforceStrictCapabilities === true) {
        try {
          this.assertCapabilityForMethod(request.method);
          if (task) {
            this.assertTaskCapability(request.method);
          }
        } catch (e) {
          earlyReject(e);
          return;
        }
      }
      options?.signal?.throwIfAborted();
      const messageId = this._requestMessageId++;
      const jsonrpcRequest = {
        ...request,
        jsonrpc: "2.0",
        id: messageId
      };
      if (options?.onprogress) {
        this._progressHandlers.set(messageId, options.onprogress);
        jsonrpcRequest.params = {
          ...request.params,
          _meta: {
            ...request.params?._meta || {},
            progressToken: messageId
          }
        };
      }
      if (task) {
        jsonrpcRequest.params = {
          ...jsonrpcRequest.params,
          task
        };
      }
      if (relatedTask) {
        jsonrpcRequest.params = {
          ...jsonrpcRequest.params,
          _meta: {
            ...jsonrpcRequest.params?._meta || {},
            [RELATED_TASK_META_KEY]: relatedTask
          }
        };
      }
      const cancel = (reason) => {
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        this._transport?.send({
          jsonrpc: "2.0",
          method: "notifications/cancelled",
          params: {
            requestId: messageId,
            reason: String(reason)
          }
        }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error2) => this._onerror(new Error(`Failed to send cancellation: ${error2}`)));
        const error = reason instanceof McpError ? reason : new McpError(ErrorCode.RequestTimeout, String(reason));
        reject(error);
      };
      this._responseHandlers.set(messageId, (response) => {
        if (options?.signal?.aborted) {
          return;
        }
        if (response instanceof Error) {
          return reject(response);
        }
        try {
          const parseResult = safeParse2(resultSchema, response.result);
          if (!parseResult.success) {
            reject(parseResult.error);
          } else {
            resolve(parseResult.data);
          }
        } catch (error) {
          reject(error);
        }
      });
      options?.signal?.addEventListener("abort", () => {
        cancel(options?.signal?.reason);
      });
      const timeout = options?.timeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC;
      const timeoutHandler = () => cancel(McpError.fromError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
      this._setupTimeout(messageId, timeout, options?.maxTotalTimeout, timeoutHandler, options?.resetTimeoutOnProgress ?? false);
      const relatedTaskId = relatedTask?.taskId;
      if (relatedTaskId) {
        const responseResolver = (response) => {
          const handler = this._responseHandlers.get(messageId);
          if (handler) {
            handler(response);
          } else {
            this._onerror(new Error(`Response handler missing for side-channeled request ${messageId}`));
          }
        };
        this._requestResolvers.set(messageId, responseResolver);
        this._enqueueTaskMessage(relatedTaskId, {
          type: "request",
          message: jsonrpcRequest,
          timestamp: Date.now()
        }).catch((error) => {
          this._cleanupTimeout(messageId);
          reject(error);
        });
      } else {
        this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error) => {
          this._cleanupTimeout(messageId);
          reject(error);
        });
      }
    });
  }
  /**
   * Gets the current status of a task.
   *
   * @experimental Use `client.experimental.tasks.getTask()` to access this method.
   */
  async getTask(params, options) {
    return this.request({ method: "tasks/get", params }, GetTaskResultSchema, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @experimental Use `client.experimental.tasks.getTaskResult()` to access this method.
   */
  async getTaskResult(params, resultSchema, options) {
    return this.request({ method: "tasks/result", params }, resultSchema, options);
  }
  /**
   * Lists tasks, optionally starting from a pagination cursor.
   *
   * @experimental Use `client.experimental.tasks.listTasks()` to access this method.
   */
  async listTasks(params, options) {
    return this.request({ method: "tasks/list", params }, ListTasksResultSchema, options);
  }
  /**
   * Cancels a specific task.
   *
   * @experimental Use `client.experimental.tasks.cancelTask()` to access this method.
   */
  async cancelTask(params, options) {
    return this.request({ method: "tasks/cancel", params }, CancelTaskResultSchema, options);
  }
  /**
   * Emits a notification, which is a one-way message that does not expect a response.
   */
  async notification(notification, options) {
    if (!this._transport) {
      throw new Error("Not connected");
    }
    this.assertNotificationCapability(notification.method);
    const relatedTaskId = options?.relatedTask?.taskId;
    if (relatedTaskId) {
      const jsonrpcNotification2 = {
        ...notification,
        jsonrpc: "2.0",
        params: {
          ...notification.params,
          _meta: {
            ...notification.params?._meta || {},
            [RELATED_TASK_META_KEY]: options.relatedTask
          }
        }
      };
      await this._enqueueTaskMessage(relatedTaskId, {
        type: "notification",
        message: jsonrpcNotification2,
        timestamp: Date.now()
      });
      return;
    }
    const debouncedMethods = this._options?.debouncedNotificationMethods ?? [];
    const canDebounce = debouncedMethods.includes(notification.method) && !notification.params && !options?.relatedRequestId && !options?.relatedTask;
    if (canDebounce) {
      if (this._pendingDebouncedNotifications.has(notification.method)) {
        return;
      }
      this._pendingDebouncedNotifications.add(notification.method);
      Promise.resolve().then(() => {
        this._pendingDebouncedNotifications.delete(notification.method);
        if (!this._transport) {
          return;
        }
        let jsonrpcNotification2 = {
          ...notification,
          jsonrpc: "2.0"
        };
        if (options?.relatedTask) {
          jsonrpcNotification2 = {
            ...jsonrpcNotification2,
            params: {
              ...jsonrpcNotification2.params,
              _meta: {
                ...jsonrpcNotification2.params?._meta || {},
                [RELATED_TASK_META_KEY]: options.relatedTask
              }
            }
          };
        }
        this._transport?.send(jsonrpcNotification2, options).catch((error) => this._onerror(error));
      });
      return;
    }
    let jsonrpcNotification = {
      ...notification,
      jsonrpc: "2.0"
    };
    if (options?.relatedTask) {
      jsonrpcNotification = {
        ...jsonrpcNotification,
        params: {
          ...jsonrpcNotification.params,
          _meta: {
            ...jsonrpcNotification.params?._meta || {},
            [RELATED_TASK_META_KEY]: options.relatedTask
          }
        }
      };
    }
    await this._transport.send(jsonrpcNotification, options);
  }
  /**
   * Registers a handler to invoke when this protocol object receives a request with the given method.
   *
   * Note that this will replace any previous request handler for the same method.
   */
  setRequestHandler(requestSchema, handler) {
    const method = getMethodLiteral(requestSchema);
    this.assertRequestHandlerCapability(method);
    this._requestHandlers.set(method, (request, extra) => {
      const parsed = parseWithCompat(requestSchema, request);
      return Promise.resolve(handler(parsed, extra));
    });
  }
  /**
   * Removes the request handler for the given method.
   */
  removeRequestHandler(method) {
    this._requestHandlers.delete(method);
  }
  /**
   * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
   */
  assertCanSetRequestHandler(method) {
    if (this._requestHandlers.has(method)) {
      throw new Error(`A request handler for ${method} already exists, which would be overridden`);
    }
  }
  /**
   * Registers a handler to invoke when this protocol object receives a notification with the given method.
   *
   * Note that this will replace any previous notification handler for the same method.
   */
  setNotificationHandler(notificationSchema, handler) {
    const method = getMethodLiteral(notificationSchema);
    this._notificationHandlers.set(method, (notification) => {
      const parsed = parseWithCompat(notificationSchema, notification);
      return Promise.resolve(handler(parsed));
    });
  }
  /**
   * Removes the notification handler for the given method.
   */
  removeNotificationHandler(method) {
    this._notificationHandlers.delete(method);
  }
  /**
   * Cleans up the progress handler associated with a task.
   * This should be called when a task reaches a terminal status.
   */
  _cleanupTaskProgressHandler(taskId) {
    const progressToken = this._taskProgressTokens.get(taskId);
    if (progressToken !== void 0) {
      this._progressHandlers.delete(progressToken);
      this._taskProgressTokens.delete(taskId);
    }
  }
  /**
   * Enqueues a task-related message for side-channel delivery via tasks/result.
   * @param taskId The task ID to associate the message with
   * @param message The message to enqueue
   * @param sessionId Optional session ID for binding the operation to a specific session
   * @throws Error if taskStore is not configured or if enqueue fails (e.g., queue overflow)
   *
   * Note: If enqueue fails, it's the TaskMessageQueue implementation's responsibility to handle
   * the error appropriately (e.g., by failing the task, logging, etc.). The Protocol layer
   * simply propagates the error.
   */
  async _enqueueTaskMessage(taskId, message, sessionId) {
    if (!this._taskStore || !this._taskMessageQueue) {
      throw new Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");
    }
    const maxQueueSize = this._options?.maxTaskQueueSize;
    await this._taskMessageQueue.enqueue(taskId, message, sessionId, maxQueueSize);
  }
  /**
   * Clears the message queue for a task and rejects any pending request resolvers.
   * @param taskId The task ID whose queue should be cleared
   * @param sessionId Optional session ID for binding the operation to a specific session
   */
  async _clearTaskQueue(taskId, sessionId) {
    if (this._taskMessageQueue) {
      const messages = await this._taskMessageQueue.dequeueAll(taskId, sessionId);
      for (const message of messages) {
        if (message.type === "request" && isJSONRPCRequest(message.message)) {
          const requestId = message.message.id;
          const resolver = this._requestResolvers.get(requestId);
          if (resolver) {
            resolver(new McpError(ErrorCode.InternalError, "Task cancelled or completed"));
            this._requestResolvers.delete(requestId);
          } else {
            this._onerror(new Error(`Resolver missing for request ${requestId} during task ${taskId} cleanup`));
          }
        }
      }
    }
  }
  /**
   * Waits for a task update (new messages or status change) with abort signal support.
   * Uses polling to check for updates at the task's configured poll interval.
   * @param taskId The task ID to wait for
   * @param signal Abort signal to cancel the wait
   * @returns Promise that resolves when an update occurs or rejects if aborted
   */
  async _waitForTaskUpdate(taskId, signal) {
    let interval = this._options?.defaultTaskPollInterval ?? 1e3;
    try {
      const task = await this._taskStore?.getTask(taskId);
      if (task?.pollInterval) {
        interval = task.pollInterval;
      }
    } catch {
    }
    return new Promise((resolve, reject) => {
      if (signal.aborted) {
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
        return;
      }
      const timeoutId = setTimeout(resolve, interval);
      signal.addEventListener("abort", () => {
        clearTimeout(timeoutId);
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
      }, { once: true });
    });
  }
  requestTaskStore(request, sessionId) {
    const taskStore = this._taskStore;
    if (!taskStore) {
      throw new Error("No task store configured");
    }
    return {
      createTask: async (taskParams) => {
        if (!request) {
          throw new Error("No request provided");
        }
        return await taskStore.createTask(taskParams, request.id, {
          method: request.method,
          params: request.params
        }, sessionId);
      },
      getTask: async (taskId) => {
        const task = await taskStore.getTask(taskId, sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        }
        return task;
      },
      storeTaskResult: async (taskId, status, result) => {
        await taskStore.storeTaskResult(taskId, status, result, sessionId);
        const task = await taskStore.getTask(taskId, sessionId);
        if (task) {
          const notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: task
          });
          await this.notification(notification);
          if (isTerminal(task.status)) {
            this._cleanupTaskProgressHandler(taskId);
          }
        }
      },
      getTaskResult: (taskId) => {
        return taskStore.getTaskResult(taskId, sessionId);
      },
      updateTaskStatus: async (taskId, status, statusMessage) => {
        const task = await taskStore.getTask(taskId, sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, `Task "${taskId}" not found - it may have been cleaned up`);
        }
        if (isTerminal(task.status)) {
          throw new McpError(ErrorCode.InvalidParams, `Cannot update task "${taskId}" from terminal status "${task.status}" to "${status}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);
        }
        await taskStore.updateTaskStatus(taskId, status, statusMessage, sessionId);
        const updatedTask = await taskStore.getTask(taskId, sessionId);
        if (updatedTask) {
          const notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: updatedTask
          });
          await this.notification(notification);
          if (isTerminal(updatedTask.status)) {
            this._cleanupTaskProgressHandler(taskId);
          }
        }
      },
      listTasks: (cursor) => {
        return taskStore.listTasks(cursor, sessionId);
      }
    };
  }
};
function isPlainObject(value) {
  return value !== null && typeof value === "object" && !Array.isArray(value);
}
function mergeCapabilities(base, additional) {
  const result = { ...base };
  for (const key in additional) {
    const k2 = key;
    const addValue = additional[k2];
    if (addValue === void 0)
      continue;
    const baseValue = result[k2];
    if (isPlainObject(baseValue) && isPlainObject(addValue)) {
      result[k2] = { ...baseValue, ...addValue };
    } else {
      result[k2] = addValue;
    }
  }
  return result;
}

// node_modules/@modelcontextprotocol/ext-apps/dist/src/app.js
var Kc = Object.defineProperty;
var s = (r, i) => {
  for (var o in i) Kc(r, o, { get: i[o], enumerable: true, configurable: true, set: (t) => i[o] = () => t });
};
var g = {};
s(g, { xor: () => yl, xid: () => Nl, void: () => xl, uuidv7: () => cl, uuidv6: () => ll, uuidv4: () => el, uuid: () => gl, util: () => D, url: () => Il, uppercase: () => Kr, unknown: () => Nr, union: () => ev, undefined: () => Ml, ulid: () => wl, uint64: () => Bl, uint32: () => ml, tuple: () => Qg, trim: () => Fr, treeifyError: () => Xv, transform: () => cv, toUpperCase: () => Hr, toLowerCase: () => Br, toJSONSchema: () => Qi, templateLiteral: () => ec, symbol: () => Hl, superRefine: () => ee, success: () => uc, stringbool: () => Dc, stringFormat: () => Xl, string: () => Mi, strictObject: () => fl, startsWith: () => Yr, slugify: () => Mr, size: () => kr, setErrorMap: () => J6, set: () => nc, safeParseAsync: () => lg, safeParse: () => eg, safeEncodeAsync: () => Dg, safeEncode: () => Ug, safeDecodeAsync: () => wg, safeDecode: () => kg, registry: () => $i, regexes: () => x, regex: () => Vr, refine: () => ge, record: () => mg, readonly: () => ie, property: () => Ai, promise: () => lc, prettifyError: () => Vv, preprocess: () => Nc, prefault: () => hg, positive: () => Gi, pipe: () => En, partialRecord: () => pl, parseAsync: () => gg, parse: () => $g, overwrite: () => d, optional: () => Jn, object: () => Cl, number: () => Og, nullish: () => tc, nullable: () => Ln, null: () => Jg, normalize: () => Tr, nonpositive: () => Xi, nonoptional: () => yg, nonnegative: () => Vi, never: () => gv, negative: () => Wi, nativeEnum: () => ic, nanoid: () => Ul, nan: () => $c, multipleOf: () => $r, minSize: () => a, minLength: () => nr, mime: () => mr, meta: () => Uc, maxSize: () => gr, maxLength: () => Dr, map: () => rc, mac: () => zl, lte: () => M, lt: () => h, lowercase: () => Ar, looseRecord: () => sl, looseObject: () => hl, locales: () => On, literal: () => vc, length: () => wr, lazy: () => te, ksuid: () => Ol, keyof: () => dl, jwt: () => Wl, json: () => wc, iso: () => Zr, ipv6: () => Pl, ipv4: () => Sl, intersection: () => qg, int64: () => Fl, int32: () => Ql, int: () => Ri, instanceof: () => kc, includes: () => qr, httpUrl: () => bl, hostname: () => Vl, hex: () => Al, hash: () => Kl, guid: () => $l, gte: () => Y, gt: () => y, globalRegistry: () => A, getErrorMap: () => L6, function: () => cc, fromJSONSchema: () => Sc, formatError: () => en, float64: () => Yl, float32: () => ql, flattenError: () => gn, file: () => oc, exactOptional: () => xg, enum: () => lv, endsWith: () => Qr, encodeAsync: () => bg, encode: () => cg, emoji: () => _l, email: () => ul, e164: () => Gl, discriminatedUnion: () => al, describe: () => _c, decodeAsync: () => _g, decode: () => Ig, date: () => Zl, custom: () => bc, cuid2: () => Dl, cuid: () => kl, core: () => ir, config: () => V, coerce: () => ce, codec: () => gc, clone: () => q, cidrv6: () => Jl, cidrv4: () => jl, check: () => Ic, catch: () => sg, boolean: () => Sg, bigint: () => Tl, base64url: () => El, base64: () => Ll, array: () => Xn, any: () => Rl, _function: () => cc, _default: () => Cg, _ZodString: () => xi, ZodXor: () => Vg, ZodXID: () => ai, ZodVoid: () => Wg, ZodUnknown: () => Eg, ZodUnion: () => An, ZodUndefined: () => Pg, ZodUUID: () => p, ZodURL: () => Gn, ZodULID: () => yi, ZodType: () => P, ZodTuple: () => Yg, ZodTransform: () => Mg, ZodTemplateLiteral: () => ve, ZodSymbol: () => zg, ZodSuccess: () => ag, ZodStringFormat: () => G, ZodString: () => Cr, ZodSet: () => Fg, ZodRecord: () => Kn, ZodRealError: () => B, ZodReadonly: () => ne, ZodPromise: () => ue, ZodPrefault: () => fg, ZodPipe: () => _v, ZodOptional: () => Iv, ZodObject: () => Vn, ZodNumberFormat: () => Or, ZodNumber: () => hr, ZodNullable: () => Zg, ZodNull: () => jg, ZodNonOptional: () => bv, ZodNever: () => Gg, ZodNanoID: () => Ci, ZodNaN: () => re, ZodMap: () => Tg, ZodMAC: () => Ng, ZodLiteral: () => Bg, ZodLazy: () => oe, ZodKSUID: () => pi, ZodJWT: () => uv, ZodIssueCode: () => j6, ZodIntersection: () => Kg, ZodISOTime: () => Bi, ZodISODuration: () => Hi, ZodISODateTime: () => Ti, ZodISODate: () => Fi, ZodIPv6: () => rv, ZodIPv4: () => si, ZodGUID: () => jn, ZodFunction: () => $e, ZodFirstPartyTypeKind: () => le, ZodFile: () => Hg, ZodExactOptional: () => Rg, ZodError: () => z6, ZodEnum: () => dr, ZodEmoji: () => di, ZodEmail: () => Zi, ZodE164: () => tv, ZodDiscriminatedUnion: () => Ag, ZodDefault: () => dg, ZodDate: () => Wn, ZodCustomStringFormat: () => fr, ZodCustom: () => qn, ZodCodec: () => Uv, ZodCatch: () => pg, ZodCUID2: () => hi, ZodCUID: () => fi, ZodCIDRv6: () => iv, ZodCIDRv4: () => nv, ZodBoolean: () => yr, ZodBigIntFormat: () => $v, ZodBigInt: () => ar, ZodBase64URL: () => ov, ZodBase64: () => vv, ZodArray: () => Xg, ZodAny: () => Lg, TimePrecision: () => Qu, NEVER: () => Nv, $output: () => Xu, $input: () => Vu, $brand: () => Ov });
var ir = {};
s(ir, { version: () => Lo, util: () => D, treeifyError: () => Xv, toJSONSchema: () => Qi, toDotPath: () => We, safeParseAsync: () => Kv, safeParse: () => Av, safeEncodeAsync: () => EI, safeEncode: () => JI, safeDecodeAsync: () => GI, safeDecode: () => LI, registry: () => $i, regexes: () => x, process: () => L, prettifyError: () => Vv, parseAsync: () => Fn, parse: () => Tn, meta: () => k$, locales: () => On, isValidJWT: () => fe, isValidBase64URL: () => Ce, isValidBase64: () => ho, initializeContext: () => er, globalRegistry: () => A, globalConfig: () => sr, formatError: () => en, flattenError: () => gn, finalize: () => cr, extractDefs: () => lr, encodeAsync: () => PI, encode: () => SI, describe: () => U$, decodeAsync: () => jI, decode: () => zI, createToJSONSchemaMethod: () => w$, createStandardJSONSchemaMethod: () => xr, config: () => V, clone: () => q, _xor: () => p4, _xid: () => wi, _void: () => u$, _uuidv7: () => Ii, _uuidv6: () => ci, _uuidv4: () => li, _uuid: () => ei, _url: () => zn, _uppercase: () => Kr, _unknown: () => o$, _union: () => a4, _undefined: () => n$, _ulid: () => Di, _uint64: () => su, _uint32: () => Cu, _tuple: () => n6, _trim: () => Fr, _transform: () => g6, _toUpperCase: () => Hr, _toLowerCase: () => Br, _templateLiteral: () => D6, _symbol: () => r$, _superRefine: () => _$, _success: () => b6, _stringbool: () => D$, _stringFormat: () => Rr, _string: () => Ku, _startsWith: () => Yr, _slugify: () => Mr, _size: () => kr, _set: () => o6, _safeParseAsync: () => Gr, _safeParse: () => Er, _safeEncodeAsync: () => dn, _safeEncode: () => xn, _safeDecodeAsync: () => Cn, _safeDecode: () => Zn, _regex: () => Vr, _refine: () => b$, _record: () => i6, _readonly: () => k6, _property: () => Ai, _promise: () => N6, _positive: () => Gi, _pipe: () => U6, _parseAsync: () => Lr, _parse: () => Jr, _overwrite: () => d, _optional: () => e6, _number: () => Hu, _nullable: () => l6, _null: () => i$, _normalize: () => Tr, _nonpositive: () => Xi, _nonoptional: () => I6, _nonnegative: () => Vi, _never: () => t$, _negative: () => Wi, _nativeEnum: () => u6, _nanoid: () => _i, _nan: () => e$, _multipleOf: () => $r, _minSize: () => a, _minLength: () => nr, _min: () => Y, _mime: () => mr, _maxSize: () => gr, _maxLength: () => Dr, _max: () => M, _map: () => v6, _mac: () => Yu, _lte: () => M, _lt: () => h, _lowercase: () => Ar, _literal: () => $6, _length: () => wr, _lazy: () => w6, _ksuid: () => Ni, _jwt: () => Ei, _isoTime: () => Fu, _isoDuration: () => Bu, _isoDateTime: () => mu, _isoDate: () => Tu, _ipv6: () => Si, _ipv4: () => Oi, _intersection: () => r6, _int64: () => pu, _int32: () => du, _int: () => Ru, _includes: () => qr, _guid: () => Sn, _gte: () => Y, _gt: () => y, _float64: () => Zu, _float32: () => xu, _file: () => c$, _enum: () => t6, _endsWith: () => Qr, _encodeAsync: () => Mn, _encode: () => Bn, _emoji: () => bi, _email: () => gi, _e164: () => Li, _discriminatedUnion: () => s4, _default: () => c6, _decodeAsync: () => Rn, _decode: () => Hn, _date: () => $$, _custom: () => I$, _cuid2: () => ki, _cuid: () => Ui, _coercedString: () => qu, _coercedNumber: () => Mu, _coercedDate: () => g$, _coercedBoolean: () => hu, _coercedBigint: () => au, _cidrv6: () => Pi, _cidrv4: () => zi, _check: () => vl, _catch: () => _6, _boolean: () => fu, _bigint: () => yu, _base64url: () => Ji, _base64: () => ji, _array: () => l$, _any: () => v$, TimePrecision: () => Qu, NEVER: () => Nv, JSONSchemaGenerator: () => ig, JSONSchema: () => ol, Doc: () => an, $output: () => Xu, $input: () => Vu, $constructor: () => c, $brand: () => Ov, $ZodXor: () => bt, $ZodXID: () => mo, $ZodVoid: () => et, $ZodUnknown: () => $t, $ZodUnion: () => _n, $ZodUndefined: () => ot, $ZodUUID: () => Wo, $ZodURL: () => Vo, $ZodULID: () => Qo, $ZodType: () => z, $ZodTuple: () => ti, $ZodTransform: () => zt, $ZodTemplateLiteral: () => Kt, $ZodSymbol: () => vt, $ZodSuccess: () => Gt, $ZodStringFormat: () => E, $ZodString: () => Ur, $ZodSet: () => wt, $ZodRegistry: () => Au, $ZodRecord: () => kt, $ZodRealError: () => F, $ZodReadonly: () => At, $ZodPromise: () => Yt, $ZodPrefault: () => Lt, $ZodPipe: () => Vt, $ZodOptional: () => ui, $ZodObjectJIT: () => It, $ZodObject: () => ae, $ZodNumberFormat: () => nt, $ZodNumber: () => vi, $ZodNullable: () => jt, $ZodNull: () => tt, $ZodNonOptional: () => Et, $ZodNever: () => gt, $ZodNanoID: () => Ko, $ZodNaN: () => Xt, $ZodMap: () => Dt, $ZodMAC: () => Zo, $ZodLiteral: () => Ot, $ZodLazy: () => Qt, $ZodKSUID: () => To, $ZodJWT: () => so, $ZodIntersection: () => Ut, $ZodISOTime: () => Ho, $ZodISODuration: () => Mo, $ZodISODateTime: () => Fo, $ZodISODate: () => Bo, $ZodIPv6: () => xo, $ZodIPv4: () => Ro, $ZodGUID: () => Go, $ZodFunction: () => qt, $ZodFile: () => St, $ZodExactOptional: () => Pt, $ZodError: () => $n, $ZodEnum: () => Nt, $ZodEncodeError: () => Ir, $ZodEmoji: () => Ao, $ZodEmail: () => Xo, $ZodE164: () => po, $ZodDiscriminatedUnion: () => _t, $ZodDefault: () => Jt, $ZodDate: () => lt, $ZodCustomStringFormat: () => rt, $ZodCustom: () => mt, $ZodCodec: () => Un, $ZodCheckUpperCase: () => No, $ZodCheckStringFormat: () => Wr, $ZodCheckStartsWith: () => So, $ZodCheckSizeEquals: () => bo, $ZodCheckRegex: () => Do, $ZodCheckProperty: () => Po, $ZodCheckOverwrite: () => Jo, $ZodCheckNumberFormat: () => eo, $ZodCheckMultipleOf: () => go, $ZodCheckMinSize: () => Io, $ZodCheckMinLength: () => Uo, $ZodCheckMimeType: () => jo, $ZodCheckMaxSize: () => co, $ZodCheckMaxLength: () => _o, $ZodCheckLowerCase: () => wo, $ZodCheckLessThan: () => hn, $ZodCheckLengthEquals: () => ko, $ZodCheckIncludes: () => Oo, $ZodCheckGreaterThan: () => yn, $ZodCheckEndsWith: () => zo, $ZodCheckBigIntFormat: () => lo, $ZodCheck: () => W, $ZodCatch: () => Wt, $ZodCUID2: () => Yo, $ZodCUID: () => qo, $ZodCIDRv6: () => fo, $ZodCIDRv4: () => Co, $ZodBoolean: () => bn, $ZodBigIntFormat: () => it, $ZodBigInt: () => oi, $ZodBase64URL: () => ao, $ZodBase64: () => yo, $ZodAsyncError: () => f, $ZodArray: () => ct, $ZodAny: () => ut });
var Nv = Object.freeze({ status: "aborted" });
function c(r, i, o) {
  function t($, l) {
    if (!$._zod) Object.defineProperty($, "_zod", { value: { def: l, constr: u, traits: /* @__PURE__ */ new Set() }, enumerable: false });
    if ($._zod.traits.has(r)) return;
    $._zod.traits.add(r), i($, l);
    let e = u.prototype, I = Object.keys(e);
    for (let _ = 0; _ < I.length; _++) {
      let N = I[_];
      if (!(N in $)) $[N] = e[N].bind($);
    }
  }
  let n = o?.Parent ?? Object;
  class v extends n {
  }
  Object.defineProperty(v, "name", { value: r });
  function u($) {
    var l;
    let e = o?.Parent ? new v() : this;
    t(e, $), (l = e._zod).deferred ?? (l.deferred = []);
    for (let I of e._zod.deferred) I();
    return e;
  }
  return Object.defineProperty(u, "init", { value: t }), Object.defineProperty(u, Symbol.hasInstance, { value: ($) => {
    if (o?.Parent && $ instanceof o.Parent) return true;
    return $?._zod?.traits?.has(r);
  } }), Object.defineProperty(u, "name", { value: r }), u;
}
var Ov = /* @__PURE__ */ Symbol("zod_brand");
var f = class extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
};
var Ir = class extends Error {
  constructor(r) {
    super(`Encountered unidirectional transform during encode: ${r}`);
    this.name = "ZodEncodeError";
  }
};
var sr = {};
function V(r) {
  if (r) Object.assign(sr, r);
  return sr;
}
var D = {};
s(D, { unwrapMessage: () => rn, uint8ArrayToHex: () => NI, uint8ArrayToBase64url: () => DI, uint8ArrayToBase64: () => Le, stringifyPrimitive: () => U, slugify: () => Pv, shallowClone: () => Jv, safeExtend: () => cI, required: () => _I, randomString: () => oI, propertyKeyTypes: () => on, promiseAllObject: () => vI, primitiveTypes: () => Lv, prefixIssues: () => H, pick: () => gI, partial: () => bI, parsedType: () => k, optionalKeys: () => Ev, omit: () => eI, objectClone: () => rI, numKeys: () => tI, nullish: () => vr, normalizeParams: () => w, mergeDefs: () => rr, merge: () => II, jsonStringifyReplacer: () => zr, joinValues: () => b, issue: () => jr, isPlainObject: () => tr, isObject: () => br, hexToUint8Array: () => wI, getSizableOrigin: () => tn, getParsedType: () => uI, getLengthableOrigin: () => un, getEnumValues: () => nn, getElementAtPath: () => iI, floatSafeRemainder: () => zv, finalizeIssue: () => T, extend: () => lI, escapeRegex: () => R, esc: () => Qn, defineLazy: () => j, createTransparentProxy: () => $I, cloneDef: () => nI, clone: () => q, cleanRegex: () => vn, cleanEnum: () => UI, captureStackTrace: () => mn, cached: () => Pr, base64urlToUint8Array: () => kI, base64ToUint8Array: () => Je, assignProp: () => or, assertNotEqual: () => yc, assertNever: () => pc, assertIs: () => ac, assertEqual: () => hc, assert: () => sc, allowsEval: () => jv, aborted: () => ur, NUMBER_FORMAT_RANGES: () => Gv, Class: () => Ee, BIGINT_FORMAT_RANGES: () => Wv });
function hc(r) {
  return r;
}
function yc(r) {
  return r;
}
function ac(r) {
}
function pc(r) {
  throw Error("Unexpected value in exhaustive check");
}
function sc(r) {
}
function nn(r) {
  let i = Object.values(r).filter((t) => typeof t === "number");
  return Object.entries(r).filter(([t, n]) => i.indexOf(+t) === -1).map(([t, n]) => n);
}
function b(r, i = "|") {
  return r.map((o) => U(o)).join(i);
}
function zr(r, i) {
  if (typeof i === "bigint") return i.toString();
  return i;
}
function Pr(r) {
  return { get value() {
    {
      let o = r();
      return Object.defineProperty(this, "value", { value: o }), o;
    }
    throw Error("cached value already set");
  } };
}
function vr(r) {
  return r === null || r === void 0;
}
function vn(r) {
  let i = r.startsWith("^") ? 1 : 0, o = r.endsWith("$") ? r.length - 1 : r.length;
  return r.slice(i, o);
}
function zv(r, i) {
  let o = (r.toString().split(".")[1] || "").length, t = i.toString(), n = (t.split(".")[1] || "").length;
  if (n === 0 && /\d?e-\d?/.test(t)) {
    let l = t.match(/\d?e-(\d?)/);
    if (l?.[1]) n = Number.parseInt(l[1]);
  }
  let v = o > n ? o : n, u = Number.parseInt(r.toFixed(v).replace(".", "")), $ = Number.parseInt(i.toFixed(v).replace(".", ""));
  return u % $ / 10 ** v;
}
var je = /* @__PURE__ */ Symbol("evaluating");
function j(r, i, o) {
  let t = void 0;
  Object.defineProperty(r, i, { get() {
    if (t === je) return;
    if (t === void 0) t = je, t = o();
    return t;
  }, set(n) {
    Object.defineProperty(r, i, { value: n });
  }, configurable: true });
}
function rI(r) {
  return Object.create(Object.getPrototypeOf(r), Object.getOwnPropertyDescriptors(r));
}
function or(r, i, o) {
  Object.defineProperty(r, i, { value: o, writable: true, enumerable: true, configurable: true });
}
function rr(...r) {
  let i = {};
  for (let o of r) {
    let t = Object.getOwnPropertyDescriptors(o);
    Object.assign(i, t);
  }
  return Object.defineProperties({}, i);
}
function nI(r) {
  return rr(r._zod.def);
}
function iI(r, i) {
  if (!i) return r;
  return i.reduce((o, t) => o?.[t], r);
}
function vI(r) {
  let i = Object.keys(r), o = i.map((t) => r[t]);
  return Promise.all(o).then((t) => {
    let n = {};
    for (let v = 0; v < i.length; v++) n[i[v]] = t[v];
    return n;
  });
}
function oI(r = 10) {
  let o = "";
  for (let t = 0; t < r; t++) o += "abcdefghijklmnopqrstuvwxyz"[Math.floor(Math.random() * 26)];
  return o;
}
function Qn(r) {
  return JSON.stringify(r);
}
function Pv(r) {
  return r.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var mn = "captureStackTrace" in Error ? Error.captureStackTrace : (...r) => {
};
function br(r) {
  return typeof r === "object" && r !== null && !Array.isArray(r);
}
var jv = Pr(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare")) return false;
  try {
    return new Function(""), true;
  } catch (r) {
    return false;
  }
});
function tr(r) {
  if (br(r) === false) return false;
  let i = r.constructor;
  if (i === void 0) return true;
  if (typeof i !== "function") return true;
  let o = i.prototype;
  if (br(o) === false) return false;
  if (Object.prototype.hasOwnProperty.call(o, "isPrototypeOf") === false) return false;
  return true;
}
function Jv(r) {
  if (tr(r)) return { ...r };
  if (Array.isArray(r)) return [...r];
  return r;
}
function tI(r) {
  let i = 0;
  for (let o in r) if (Object.prototype.hasOwnProperty.call(r, o)) i++;
  return i;
}
var uI = (r) => {
  let i = typeof r;
  switch (i) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(r) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(r)) return "array";
      if (r === null) return "null";
      if (r.then && typeof r.then === "function" && r.catch && typeof r.catch === "function") return "promise";
      if (typeof Map < "u" && r instanceof Map) return "map";
      if (typeof Set < "u" && r instanceof Set) return "set";
      if (typeof Date < "u" && r instanceof Date) return "date";
      if (typeof File < "u" && r instanceof File) return "file";
      return "object";
    default:
      throw Error(`Unknown data type: ${i}`);
  }
};
var on = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var Lv = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function R(r) {
  return r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function q(r, i, o) {
  let t = new r._zod.constr(i ?? r._zod.def);
  if (!i || o?.parent) t._zod.parent = r;
  return t;
}
function w(r) {
  let i = r;
  if (!i) return {};
  if (typeof i === "string") return { error: () => i };
  if (i?.message !== void 0) {
    if (i?.error !== void 0) throw Error("Cannot specify both `message` and `error` params");
    i.error = i.message;
  }
  if (delete i.message, typeof i.error === "string") return { ...i, error: () => i.error };
  return i;
}
function $I(r) {
  let i;
  return new Proxy({}, { get(o, t, n) {
    return i ?? (i = r()), Reflect.get(i, t, n);
  }, set(o, t, n, v) {
    return i ?? (i = r()), Reflect.set(i, t, n, v);
  }, has(o, t) {
    return i ?? (i = r()), Reflect.has(i, t);
  }, deleteProperty(o, t) {
    return i ?? (i = r()), Reflect.deleteProperty(i, t);
  }, ownKeys(o) {
    return i ?? (i = r()), Reflect.ownKeys(i);
  }, getOwnPropertyDescriptor(o, t) {
    return i ?? (i = r()), Reflect.getOwnPropertyDescriptor(i, t);
  }, defineProperty(o, t, n) {
    return i ?? (i = r()), Reflect.defineProperty(i, t, n);
  } });
}
function U(r) {
  if (typeof r === "bigint") return r.toString() + "n";
  if (typeof r === "string") return `"${r}"`;
  return `${r}`;
}
function Ev(r) {
  return Object.keys(r).filter((i) => {
    return r[i]._zod.optin === "optional" && r[i]._zod.optout === "optional";
  });
}
var Gv = { safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], int32: [-2147483648, 2147483647], uint32: [0, 4294967295], float32: [-34028234663852886e22, 34028234663852886e22], float64: [-Number.MAX_VALUE, Number.MAX_VALUE] };
var Wv = { int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")], uint64: [BigInt(0), BigInt("18446744073709551615")] };
function gI(r, i) {
  let o = r._zod.def, t = o.checks;
  if (t && t.length > 0) throw Error(".pick() cannot be used on object schemas containing refinements");
  let v = rr(r._zod.def, { get shape() {
    let u = {};
    for (let $ in i) {
      if (!($ in o.shape)) throw Error(`Unrecognized key: "${$}"`);
      if (!i[$]) continue;
      u[$] = o.shape[$];
    }
    return or(this, "shape", u), u;
  }, checks: [] });
  return q(r, v);
}
function eI(r, i) {
  let o = r._zod.def, t = o.checks;
  if (t && t.length > 0) throw Error(".omit() cannot be used on object schemas containing refinements");
  let v = rr(r._zod.def, { get shape() {
    let u = { ...r._zod.def.shape };
    for (let $ in i) {
      if (!($ in o.shape)) throw Error(`Unrecognized key: "${$}"`);
      if (!i[$]) continue;
      delete u[$];
    }
    return or(this, "shape", u), u;
  }, checks: [] });
  return q(r, v);
}
function lI(r, i) {
  if (!tr(i)) throw Error("Invalid input to extend: expected a plain object");
  let o = r._zod.def.checks;
  if (o && o.length > 0) {
    let v = r._zod.def.shape;
    for (let u in i) if (Object.getOwnPropertyDescriptor(v, u) !== void 0) throw Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
  }
  let n = rr(r._zod.def, { get shape() {
    let v = { ...r._zod.def.shape, ...i };
    return or(this, "shape", v), v;
  } });
  return q(r, n);
}
function cI(r, i) {
  if (!tr(i)) throw Error("Invalid input to safeExtend: expected a plain object");
  let o = rr(r._zod.def, { get shape() {
    let t = { ...r._zod.def.shape, ...i };
    return or(this, "shape", t), t;
  } });
  return q(r, o);
}
function II(r, i) {
  let o = rr(r._zod.def, { get shape() {
    let t = { ...r._zod.def.shape, ...i._zod.def.shape };
    return or(this, "shape", t), t;
  }, get catchall() {
    return i._zod.def.catchall;
  }, checks: [] });
  return q(r, o);
}
function bI(r, i, o) {
  let n = i._zod.def.checks;
  if (n && n.length > 0) throw Error(".partial() cannot be used on object schemas containing refinements");
  let u = rr(i._zod.def, { get shape() {
    let $ = i._zod.def.shape, l = { ...$ };
    if (o) for (let e in o) {
      if (!(e in $)) throw Error(`Unrecognized key: "${e}"`);
      if (!o[e]) continue;
      l[e] = r ? new r({ type: "optional", innerType: $[e] }) : $[e];
    }
    else for (let e in $) l[e] = r ? new r({ type: "optional", innerType: $[e] }) : $[e];
    return or(this, "shape", l), l;
  }, checks: [] });
  return q(i, u);
}
function _I(r, i, o) {
  let t = rr(i._zod.def, { get shape() {
    let n = i._zod.def.shape, v = { ...n };
    if (o) for (let u in o) {
      if (!(u in v)) throw Error(`Unrecognized key: "${u}"`);
      if (!o[u]) continue;
      v[u] = new r({ type: "nonoptional", innerType: n[u] });
    }
    else for (let u in n) v[u] = new r({ type: "nonoptional", innerType: n[u] });
    return or(this, "shape", v), v;
  } });
  return q(i, t);
}
function ur(r, i = 0) {
  if (r.aborted === true) return true;
  for (let o = i; o < r.issues.length; o++) if (r.issues[o]?.continue !== true) return true;
  return false;
}
function H(r, i) {
  return i.map((o) => {
    var t;
    return (t = o).path ?? (t.path = []), o.path.unshift(r), o;
  });
}
function rn(r) {
  return typeof r === "string" ? r : r?.message;
}
function T(r, i, o) {
  let t = { ...r, path: r.path ?? [] };
  if (!r.message) {
    let n = rn(r.inst?._zod.def?.error?.(r)) ?? rn(i?.error?.(r)) ?? rn(o.customError?.(r)) ?? rn(o.localeError?.(r)) ?? "Invalid input";
    t.message = n;
  }
  if (delete t.inst, delete t.continue, !i?.reportInput) delete t.input;
  return t;
}
function tn(r) {
  if (r instanceof Set) return "set";
  if (r instanceof Map) return "map";
  if (r instanceof File) return "file";
  return "unknown";
}
function un(r) {
  if (Array.isArray(r)) return "array";
  if (typeof r === "string") return "string";
  return "unknown";
}
function k(r) {
  let i = typeof r;
  switch (i) {
    case "number":
      return Number.isNaN(r) ? "nan" : "number";
    case "object": {
      if (r === null) return "null";
      if (Array.isArray(r)) return "array";
      let o = r;
      if (o && Object.getPrototypeOf(o) !== Object.prototype && "constructor" in o && o.constructor) return o.constructor.name;
    }
  }
  return i;
}
function jr(...r) {
  let [i, o, t] = r;
  if (typeof i === "string") return { message: i, code: "custom", input: o, inst: t };
  return { ...i };
}
function UI(r) {
  return Object.entries(r).filter(([i, o]) => {
    return Number.isNaN(Number.parseInt(i, 10));
  }).map((i) => i[1]);
}
function Je(r) {
  let i = atob(r), o = new Uint8Array(i.length);
  for (let t = 0; t < i.length; t++) o[t] = i.charCodeAt(t);
  return o;
}
function Le(r) {
  let i = "";
  for (let o = 0; o < r.length; o++) i += String.fromCharCode(r[o]);
  return btoa(i);
}
function kI(r) {
  let i = r.replace(/-/g, "+").replace(/_/g, "/"), o = "=".repeat((4 - i.length % 4) % 4);
  return Je(i + o);
}
function DI(r) {
  return Le(r).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function wI(r) {
  let i = r.replace(/^0x/, "");
  if (i.length % 2 !== 0) throw Error("Invalid hex string length");
  let o = new Uint8Array(i.length / 2);
  for (let t = 0; t < i.length; t += 2) o[t / 2] = Number.parseInt(i.slice(t, t + 2), 16);
  return o;
}
function NI(r) {
  return Array.from(r).map((i) => i.toString(16).padStart(2, "0")).join("");
}
var Ee = class {
  constructor(...r) {
  }
};
var Ge = (r, i) => {
  r.name = "$ZodError", Object.defineProperty(r, "_zod", { value: r._zod, enumerable: false }), Object.defineProperty(r, "issues", { value: i, enumerable: false }), r.message = JSON.stringify(i, zr, 2), Object.defineProperty(r, "toString", { value: () => r.message, enumerable: false });
};
var $n = c("$ZodError", Ge);
var F = c("$ZodError", Ge, { Parent: Error });
function gn(r, i = (o) => o.message) {
  let o = {}, t = [];
  for (let n of r.issues) if (n.path.length > 0) o[n.path[0]] = o[n.path[0]] || [], o[n.path[0]].push(i(n));
  else t.push(i(n));
  return { formErrors: t, fieldErrors: o };
}
function en(r, i = (o) => o.message) {
  let o = { _errors: [] }, t = (n) => {
    for (let v of n.issues) if (v.code === "invalid_union" && v.errors.length) v.errors.map((u) => t({ issues: u }));
    else if (v.code === "invalid_key") t({ issues: v.issues });
    else if (v.code === "invalid_element") t({ issues: v.issues });
    else if (v.path.length === 0) o._errors.push(i(v));
    else {
      let u = o, $ = 0;
      while ($ < v.path.length) {
        let l = v.path[$];
        if ($ !== v.path.length - 1) u[l] = u[l] || { _errors: [] };
        else u[l] = u[l] || { _errors: [] }, u[l]._errors.push(i(v));
        u = u[l], $++;
      }
    }
  };
  return t(r), o;
}
function Xv(r, i = (o) => o.message) {
  let o = { errors: [] }, t = (n, v = []) => {
    var u, $;
    for (let l of n.issues) if (l.code === "invalid_union" && l.errors.length) l.errors.map((e) => t({ issues: e }, l.path));
    else if (l.code === "invalid_key") t({ issues: l.issues }, l.path);
    else if (l.code === "invalid_element") t({ issues: l.issues }, l.path);
    else {
      let e = [...v, ...l.path];
      if (e.length === 0) {
        o.errors.push(i(l));
        continue;
      }
      let I = o, _ = 0;
      while (_ < e.length) {
        let N = e[_], O = _ === e.length - 1;
        if (typeof N === "string") I.properties ?? (I.properties = {}), (u = I.properties)[N] ?? (u[N] = { errors: [] }), I = I.properties[N];
        else I.items ?? (I.items = []), ($ = I.items)[N] ?? ($[N] = { errors: [] }), I = I.items[N];
        if (O) I.errors.push(i(l));
        _++;
      }
    }
  };
  return t(r), o;
}
function We(r) {
  let i = [], o = r.map((t) => typeof t === "object" ? t.key : t);
  for (let t of o) if (typeof t === "number") i.push(`[${t}]`);
  else if (typeof t === "symbol") i.push(`[${JSON.stringify(String(t))}]`);
  else if (/[^\w$]/.test(t)) i.push(`[${JSON.stringify(t)}]`);
  else {
    if (i.length) i.push(".");
    i.push(t);
  }
  return i.join("");
}
function Vv(r) {
  let i = [], o = [...r.issues].sort((t, n) => (t.path ?? []).length - (n.path ?? []).length);
  for (let t of o) if (i.push(` ${t.message}`), t.path?.length) i.push(`   at ${We(t.path)}`);
  return i.join(`
`);
}
var Jr = (r) => (i, o, t, n) => {
  let v = t ? Object.assign(t, { async: false }) : { async: false }, u = i._zod.run({ value: o, issues: [] }, v);
  if (u instanceof Promise) throw new f();
  if (u.issues.length) {
    let $ = new (n?.Err ?? r)(u.issues.map((l) => T(l, v, V())));
    throw mn($, n?.callee), $;
  }
  return u.value;
};
var Tn = Jr(F);
var Lr = (r) => async (i, o, t, n) => {
  let v = t ? Object.assign(t, { async: true }) : { async: true }, u = i._zod.run({ value: o, issues: [] }, v);
  if (u instanceof Promise) u = await u;
  if (u.issues.length) {
    let $ = new (n?.Err ?? r)(u.issues.map((l) => T(l, v, V())));
    throw mn($, n?.callee), $;
  }
  return u.value;
};
var Fn = Lr(F);
var Er = (r) => (i, o, t) => {
  let n = t ? { ...t, async: false } : { async: false }, v = i._zod.run({ value: o, issues: [] }, n);
  if (v instanceof Promise) throw new f();
  return v.issues.length ? { success: false, error: new (r ?? $n)(v.issues.map((u) => T(u, n, V()))) } : { success: true, data: v.value };
};
var Av = Er(F);
var Gr = (r) => async (i, o, t) => {
  let n = t ? Object.assign(t, { async: true }) : { async: true }, v = i._zod.run({ value: o, issues: [] }, n);
  if (v instanceof Promise) v = await v;
  return v.issues.length ? { success: false, error: new r(v.issues.map((u) => T(u, n, V()))) } : { success: true, data: v.value };
};
var Kv = Gr(F);
var Bn = (r) => (i, o, t) => {
  let n = t ? Object.assign(t, { direction: "backward" }) : { direction: "backward" };
  return Jr(r)(i, o, n);
};
var SI = Bn(F);
var Hn = (r) => (i, o, t) => {
  return Jr(r)(i, o, t);
};
var zI = Hn(F);
var Mn = (r) => async (i, o, t) => {
  let n = t ? Object.assign(t, { direction: "backward" }) : { direction: "backward" };
  return Lr(r)(i, o, n);
};
var PI = Mn(F);
var Rn = (r) => async (i, o, t) => {
  return Lr(r)(i, o, t);
};
var jI = Rn(F);
var xn = (r) => (i, o, t) => {
  let n = t ? Object.assign(t, { direction: "backward" }) : { direction: "backward" };
  return Er(r)(i, o, n);
};
var JI = xn(F);
var Zn = (r) => (i, o, t) => {
  return Er(r)(i, o, t);
};
var LI = Zn(F);
var dn = (r) => async (i, o, t) => {
  let n = t ? Object.assign(t, { direction: "backward" }) : { direction: "backward" };
  return Gr(r)(i, o, n);
};
var EI = dn(F);
var Cn = (r) => async (i, o, t) => {
  return Gr(r)(i, o, t);
};
var GI = Cn(F);
var x = {};
s(x, { xid: () => mv, uuid7: () => AI, uuid6: () => VI, uuid4: () => XI, uuid: () => _r, uppercase: () => $o, unicodeEmail: () => Xe, undefined: () => to, ulid: () => Qv, time: () => pv, string: () => ro, sha512_hex: () => sI, sha512_base64url: () => n4, sha512_base64: () => r4, sha384_hex: () => yI, sha384_base64url: () => pI, sha384_base64: () => aI, sha256_hex: () => CI, sha256_base64url: () => hI, sha256_base64: () => fI, sha1_hex: () => xI, sha1_base64url: () => dI, sha1_base64: () => ZI, rfc5322Email: () => qI, number: () => ln, null: () => oo, nanoid: () => Fv, md5_hex: () => HI, md5_base64url: () => RI, md5_base64: () => MI, mac: () => dv, lowercase: () => uo, ksuid: () => Tv, ipv6: () => Zv, ipv4: () => xv, integer: () => io, idnEmail: () => YI, html5Email: () => KI, hostname: () => TI, hex: () => BI, guid: () => Hv, extendedDuration: () => WI, emoji: () => Rv, email: () => Mv, e164: () => yv, duration: () => Bv, domain: () => FI, datetime: () => sv, date: () => av, cuid2: () => Yv, cuid: () => qv, cidrv6: () => fv, cidrv4: () => Cv, browserEmail: () => QI, boolean: () => vo, bigint: () => no, base64url: () => fn, base64: () => hv });
var qv = /^[cC][^\s-]{8,}$/;
var Yv = /^[0-9a-z]+$/;
var Qv = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var mv = /^[0-9a-vA-V]{20}$/;
var Tv = /^[A-Za-z0-9]{27}$/;
var Fv = /^[a-zA-Z0-9_-]{21}$/;
var Bv = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var WI = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var Hv = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var _r = (r) => {
  if (!r) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${r}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var XI = _r(4);
var VI = _r(6);
var AI = _r(7);
var Mv = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var KI = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var qI = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var Xe = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var YI = Xe;
var QI = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var mI = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function Rv() {
  return new RegExp(mI, "u");
}
var xv = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var Zv = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var dv = (r) => {
  let i = R(r ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${i}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${i}){5}[0-9a-f]{2}$`);
};
var Cv = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var fv = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var hv = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var fn = /^[A-Za-z0-9_-]*$/;
var TI = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var FI = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var yv = /^\+[1-9]\d{6,14}$/;
var Ve = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))";
var av = new RegExp(`^${Ve}$`);
function Ae(r) {
  return typeof r.precision === "number" ? r.precision === -1 ? "(?:[01]\\d|2[0-3]):[0-5]\\d" : r.precision === 0 ? "(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d" : `(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d\\.\\d{${r.precision}}` : "(?:[01]\\d|2[0-3]):[0-5]\\d(?::[0-5]\\d(?:\\.\\d+)?)?";
}
function pv(r) {
  return new RegExp(`^${Ae(r)}$`);
}
function sv(r) {
  let i = Ae({ precision: r.precision }), o = ["Z"];
  if (r.local) o.push("");
  if (r.offset) o.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  let t = `${i}(?:${o.join("|")})`;
  return new RegExp(`^${Ve}T(?:${t})$`);
}
var ro = (r) => {
  let i = r ? `[\\s\\S]{${r?.minimum ?? 0},${r?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${i}$`);
};
var no = /^-?\d+n?$/;
var io = /^-?\d+$/;
var ln = /^-?\d+(?:\.\d+)?$/;
var vo = /^(?:true|false)$/i;
var oo = /^null$/i;
var to = /^undefined$/i;
var uo = /^[^A-Z]*$/;
var $o = /^[^a-z]*$/;
var BI = /^[0-9a-fA-F]*$/;
function cn(r, i) {
  return new RegExp(`^[A-Za-z0-9+/]{${r}}${i}$`);
}
function In(r) {
  return new RegExp(`^[A-Za-z0-9_-]{${r}}$`);
}
var HI = /^[0-9a-fA-F]{32}$/;
var MI = cn(22, "==");
var RI = In(22);
var xI = /^[0-9a-fA-F]{40}$/;
var ZI = cn(27, "=");
var dI = In(27);
var CI = /^[0-9a-fA-F]{64}$/;
var fI = cn(43, "=");
var hI = In(43);
var yI = /^[0-9a-fA-F]{96}$/;
var aI = cn(64, "");
var pI = In(64);
var sI = /^[0-9a-fA-F]{128}$/;
var r4 = cn(86, "==");
var n4 = In(86);
var W = c("$ZodCheck", (r, i) => {
  var o;
  r._zod ?? (r._zod = {}), r._zod.def = i, (o = r._zod).onattach ?? (o.onattach = []);
});
var qe = { number: "number", bigint: "bigint", object: "date" };
var hn = c("$ZodCheckLessThan", (r, i) => {
  W.init(r, i);
  let o = qe[typeof i.value];
  r._zod.onattach.push((t) => {
    let n = t._zod.bag, v = (i.inclusive ? n.maximum : n.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (i.value < v) if (i.inclusive) n.maximum = i.value;
    else n.exclusiveMaximum = i.value;
  }), r._zod.check = (t) => {
    if (i.inclusive ? t.value <= i.value : t.value < i.value) return;
    t.issues.push({ origin: o, code: "too_big", maximum: typeof i.value === "object" ? i.value.getTime() : i.value, input: t.value, inclusive: i.inclusive, inst: r, continue: !i.abort });
  };
});
var yn = c("$ZodCheckGreaterThan", (r, i) => {
  W.init(r, i);
  let o = qe[typeof i.value];
  r._zod.onattach.push((t) => {
    let n = t._zod.bag, v = (i.inclusive ? n.minimum : n.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (i.value > v) if (i.inclusive) n.minimum = i.value;
    else n.exclusiveMinimum = i.value;
  }), r._zod.check = (t) => {
    if (i.inclusive ? t.value >= i.value : t.value > i.value) return;
    t.issues.push({ origin: o, code: "too_small", minimum: typeof i.value === "object" ? i.value.getTime() : i.value, input: t.value, inclusive: i.inclusive, inst: r, continue: !i.abort });
  };
});
var go = c("$ZodCheckMultipleOf", (r, i) => {
  W.init(r, i), r._zod.onattach.push((o) => {
    var t;
    (t = o._zod.bag).multipleOf ?? (t.multipleOf = i.value);
  }), r._zod.check = (o) => {
    if (typeof o.value !== typeof i.value) throw Error("Cannot mix number and bigint in multiple_of check.");
    if (typeof o.value === "bigint" ? o.value % i.value === BigInt(0) : zv(o.value, i.value) === 0) return;
    o.issues.push({ origin: typeof o.value, code: "not_multiple_of", divisor: i.value, input: o.value, inst: r, continue: !i.abort });
  };
});
var eo = c("$ZodCheckNumberFormat", (r, i) => {
  W.init(r, i), i.format = i.format || "float64";
  let o = i.format?.includes("int"), t = o ? "int" : "number", [n, v] = Gv[i.format];
  r._zod.onattach.push((u) => {
    let $ = u._zod.bag;
    if ($.format = i.format, $.minimum = n, $.maximum = v, o) $.pattern = io;
  }), r._zod.check = (u) => {
    let $ = u.value;
    if (o) {
      if (!Number.isInteger($)) {
        u.issues.push({ expected: t, format: i.format, code: "invalid_type", continue: false, input: $, inst: r });
        return;
      }
      if (!Number.isSafeInteger($)) {
        if ($ > 0) u.issues.push({ input: $, code: "too_big", maximum: Number.MAX_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: r, origin: t, inclusive: true, continue: !i.abort });
        else u.issues.push({ input: $, code: "too_small", minimum: Number.MIN_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: r, origin: t, inclusive: true, continue: !i.abort });
        return;
      }
    }
    if ($ < n) u.issues.push({ origin: "number", input: $, code: "too_small", minimum: n, inclusive: true, inst: r, continue: !i.abort });
    if ($ > v) u.issues.push({ origin: "number", input: $, code: "too_big", maximum: v, inclusive: true, inst: r, continue: !i.abort });
  };
});
var lo = c("$ZodCheckBigIntFormat", (r, i) => {
  W.init(r, i);
  let [o, t] = Wv[i.format];
  r._zod.onattach.push((n) => {
    let v = n._zod.bag;
    v.format = i.format, v.minimum = o, v.maximum = t;
  }), r._zod.check = (n) => {
    let v = n.value;
    if (v < o) n.issues.push({ origin: "bigint", input: v, code: "too_small", minimum: o, inclusive: true, inst: r, continue: !i.abort });
    if (v > t) n.issues.push({ origin: "bigint", input: v, code: "too_big", maximum: t, inclusive: true, inst: r, continue: !i.abort });
  };
});
var co = c("$ZodCheckMaxSize", (r, i) => {
  var o;
  W.init(r, i), (o = r._zod.def).when ?? (o.when = (t) => {
    let n = t.value;
    return !vr(n) && n.size !== void 0;
  }), r._zod.onattach.push((t) => {
    let n = t._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (i.maximum < n) t._zod.bag.maximum = i.maximum;
  }), r._zod.check = (t) => {
    let n = t.value;
    if (n.size <= i.maximum) return;
    t.issues.push({ origin: tn(n), code: "too_big", maximum: i.maximum, inclusive: true, input: n, inst: r, continue: !i.abort });
  };
});
var Io = c("$ZodCheckMinSize", (r, i) => {
  var o;
  W.init(r, i), (o = r._zod.def).when ?? (o.when = (t) => {
    let n = t.value;
    return !vr(n) && n.size !== void 0;
  }), r._zod.onattach.push((t) => {
    let n = t._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (i.minimum > n) t._zod.bag.minimum = i.minimum;
  }), r._zod.check = (t) => {
    let n = t.value;
    if (n.size >= i.minimum) return;
    t.issues.push({ origin: tn(n), code: "too_small", minimum: i.minimum, inclusive: true, input: n, inst: r, continue: !i.abort });
  };
});
var bo = c("$ZodCheckSizeEquals", (r, i) => {
  var o;
  W.init(r, i), (o = r._zod.def).when ?? (o.when = (t) => {
    let n = t.value;
    return !vr(n) && n.size !== void 0;
  }), r._zod.onattach.push((t) => {
    let n = t._zod.bag;
    n.minimum = i.size, n.maximum = i.size, n.size = i.size;
  }), r._zod.check = (t) => {
    let n = t.value, v = n.size;
    if (v === i.size) return;
    let u = v > i.size;
    t.issues.push({ origin: tn(n), ...u ? { code: "too_big", maximum: i.size } : { code: "too_small", minimum: i.size }, inclusive: true, exact: true, input: t.value, inst: r, continue: !i.abort });
  };
});
var _o = c("$ZodCheckMaxLength", (r, i) => {
  var o;
  W.init(r, i), (o = r._zod.def).when ?? (o.when = (t) => {
    let n = t.value;
    return !vr(n) && n.length !== void 0;
  }), r._zod.onattach.push((t) => {
    let n = t._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (i.maximum < n) t._zod.bag.maximum = i.maximum;
  }), r._zod.check = (t) => {
    let n = t.value;
    if (n.length <= i.maximum) return;
    let u = un(n);
    t.issues.push({ origin: u, code: "too_big", maximum: i.maximum, inclusive: true, input: n, inst: r, continue: !i.abort });
  };
});
var Uo = c("$ZodCheckMinLength", (r, i) => {
  var o;
  W.init(r, i), (o = r._zod.def).when ?? (o.when = (t) => {
    let n = t.value;
    return !vr(n) && n.length !== void 0;
  }), r._zod.onattach.push((t) => {
    let n = t._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (i.minimum > n) t._zod.bag.minimum = i.minimum;
  }), r._zod.check = (t) => {
    let n = t.value;
    if (n.length >= i.minimum) return;
    let u = un(n);
    t.issues.push({ origin: u, code: "too_small", minimum: i.minimum, inclusive: true, input: n, inst: r, continue: !i.abort });
  };
});
var ko = c("$ZodCheckLengthEquals", (r, i) => {
  var o;
  W.init(r, i), (o = r._zod.def).when ?? (o.when = (t) => {
    let n = t.value;
    return !vr(n) && n.length !== void 0;
  }), r._zod.onattach.push((t) => {
    let n = t._zod.bag;
    n.minimum = i.length, n.maximum = i.length, n.length = i.length;
  }), r._zod.check = (t) => {
    let n = t.value, v = n.length;
    if (v === i.length) return;
    let u = un(n), $ = v > i.length;
    t.issues.push({ origin: u, ...$ ? { code: "too_big", maximum: i.length } : { code: "too_small", minimum: i.length }, inclusive: true, exact: true, input: t.value, inst: r, continue: !i.abort });
  };
});
var Wr = c("$ZodCheckStringFormat", (r, i) => {
  var o, t;
  if (W.init(r, i), r._zod.onattach.push((n) => {
    let v = n._zod.bag;
    if (v.format = i.format, i.pattern) v.patterns ?? (v.patterns = /* @__PURE__ */ new Set()), v.patterns.add(i.pattern);
  }), i.pattern) (o = r._zod).check ?? (o.check = (n) => {
    if (i.pattern.lastIndex = 0, i.pattern.test(n.value)) return;
    n.issues.push({ origin: "string", code: "invalid_format", format: i.format, input: n.value, ...i.pattern ? { pattern: i.pattern.toString() } : {}, inst: r, continue: !i.abort });
  });
  else (t = r._zod).check ?? (t.check = () => {
  });
});
var Do = c("$ZodCheckRegex", (r, i) => {
  Wr.init(r, i), r._zod.check = (o) => {
    if (i.pattern.lastIndex = 0, i.pattern.test(o.value)) return;
    o.issues.push({ origin: "string", code: "invalid_format", format: "regex", input: o.value, pattern: i.pattern.toString(), inst: r, continue: !i.abort });
  };
});
var wo = c("$ZodCheckLowerCase", (r, i) => {
  i.pattern ?? (i.pattern = uo), Wr.init(r, i);
});
var No = c("$ZodCheckUpperCase", (r, i) => {
  i.pattern ?? (i.pattern = $o), Wr.init(r, i);
});
var Oo = c("$ZodCheckIncludes", (r, i) => {
  W.init(r, i);
  let o = R(i.includes), t = new RegExp(typeof i.position === "number" ? `^.{${i.position}}${o}` : o);
  i.pattern = t, r._zod.onattach.push((n) => {
    let v = n._zod.bag;
    v.patterns ?? (v.patterns = /* @__PURE__ */ new Set()), v.patterns.add(t);
  }), r._zod.check = (n) => {
    if (n.value.includes(i.includes, i.position)) return;
    n.issues.push({ origin: "string", code: "invalid_format", format: "includes", includes: i.includes, input: n.value, inst: r, continue: !i.abort });
  };
});
var So = c("$ZodCheckStartsWith", (r, i) => {
  W.init(r, i);
  let o = new RegExp(`^${R(i.prefix)}.*`);
  i.pattern ?? (i.pattern = o), r._zod.onattach.push((t) => {
    let n = t._zod.bag;
    n.patterns ?? (n.patterns = /* @__PURE__ */ new Set()), n.patterns.add(o);
  }), r._zod.check = (t) => {
    if (t.value.startsWith(i.prefix)) return;
    t.issues.push({ origin: "string", code: "invalid_format", format: "starts_with", prefix: i.prefix, input: t.value, inst: r, continue: !i.abort });
  };
});
var zo = c("$ZodCheckEndsWith", (r, i) => {
  W.init(r, i);
  let o = new RegExp(`.*${R(i.suffix)}$`);
  i.pattern ?? (i.pattern = o), r._zod.onattach.push((t) => {
    let n = t._zod.bag;
    n.patterns ?? (n.patterns = /* @__PURE__ */ new Set()), n.patterns.add(o);
  }), r._zod.check = (t) => {
    if (t.value.endsWith(i.suffix)) return;
    t.issues.push({ origin: "string", code: "invalid_format", format: "ends_with", suffix: i.suffix, input: t.value, inst: r, continue: !i.abort });
  };
});
function Ke(r, i, o) {
  if (r.issues.length) i.issues.push(...H(o, r.issues));
}
var Po = c("$ZodCheckProperty", (r, i) => {
  W.init(r, i), r._zod.check = (o) => {
    let t = i.schema._zod.run({ value: o.value[i.property], issues: [] }, {});
    if (t instanceof Promise) return t.then((n) => Ke(n, o, i.property));
    Ke(t, o, i.property);
    return;
  };
});
var jo = c("$ZodCheckMimeType", (r, i) => {
  W.init(r, i);
  let o = new Set(i.mime);
  r._zod.onattach.push((t) => {
    t._zod.bag.mime = i.mime;
  }), r._zod.check = (t) => {
    if (o.has(t.value.type)) return;
    t.issues.push({ code: "invalid_value", values: i.mime, input: t.value.type, inst: r, continue: !i.abort });
  };
});
var Jo = c("$ZodCheckOverwrite", (r, i) => {
  W.init(r, i), r._zod.check = (o) => {
    o.value = i.tx(o.value);
  };
});
var an = class {
  constructor(r = []) {
    if (this.content = [], this.indent = 0, this) this.args = r;
  }
  indented(r) {
    this.indent += 1, r(this), this.indent -= 1;
  }
  write(r) {
    if (typeof r === "function") {
      r(this, { execution: "sync" }), r(this, { execution: "async" });
      return;
    }
    let o = r.split(`
`).filter((v) => v), t = Math.min(...o.map((v) => v.length - v.trimStart().length)), n = o.map((v) => v.slice(t)).map((v) => " ".repeat(this.indent * 2) + v);
    for (let v of n) this.content.push(v);
  }
  compile() {
    let r = Function, i = this?.args, t = [...(this?.content ?? [""]).map((n) => `  ${n}`)];
    return new r(...i, t.join(`
`));
  }
};
var Lo = { major: 4, minor: 3, patch: 5 };
var z = c("$ZodType", (r, i) => {
  var o;
  r ?? (r = {}), r._zod.def = i, r._zod.bag = r._zod.bag || {}, r._zod.version = Lo;
  let t = [...r._zod.def.checks ?? []];
  if (r._zod.traits.has("$ZodCheck")) t.unshift(r);
  for (let n of t) for (let v of n._zod.onattach) v(r);
  if (t.length === 0) (o = r._zod).deferred ?? (o.deferred = []), r._zod.deferred?.push(() => {
    r._zod.run = r._zod.parse;
  });
  else {
    let n = (u, $, l) => {
      let e = ur(u), I;
      for (let _ of $) {
        if (_._zod.def.when) {
          if (!_._zod.def.when(u)) continue;
        } else if (e) continue;
        let N = u.issues.length, O = _._zod.check(u);
        if (O instanceof Promise && l?.async === false) throw new f();
        if (I || O instanceof Promise) I = (I ?? Promise.resolve()).then(async () => {
          if (await O, u.issues.length === N) return;
          if (!e) e = ur(u, N);
        });
        else {
          if (u.issues.length === N) continue;
          if (!e) e = ur(u, N);
        }
      }
      if (I) return I.then(() => {
        return u;
      });
      return u;
    }, v = (u, $, l) => {
      if (ur(u)) return u.aborted = true, u;
      let e = n($, t, l);
      if (e instanceof Promise) {
        if (l.async === false) throw new f();
        return e.then((I) => r._zod.parse(I, l));
      }
      return r._zod.parse(e, l);
    };
    r._zod.run = (u, $) => {
      if ($.skipChecks) return r._zod.parse(u, $);
      if ($.direction === "backward") {
        let e = r._zod.parse({ value: u.value, issues: [] }, { ...$, skipChecks: true });
        if (e instanceof Promise) return e.then((I) => {
          return v(I, u, $);
        });
        return v(e, u, $);
      }
      let l = r._zod.parse(u, $);
      if (l instanceof Promise) {
        if ($.async === false) throw new f();
        return l.then((e) => n(e, t, $));
      }
      return n(l, t, $);
    };
  }
  j(r, "~standard", () => ({ validate: (n) => {
    try {
      let v = Av(r, n);
      return v.success ? { value: v.data } : { issues: v.error?.issues };
    } catch (v) {
      return Kv(r, n).then((u) => u.success ? { value: u.data } : { issues: u.error?.issues });
    }
  }, vendor: "zod", version: 1 }));
});
var Ur = c("$ZodString", (r, i) => {
  z.init(r, i), r._zod.pattern = [...r?._zod.bag?.patterns ?? []].pop() ?? ro(r._zod.bag), r._zod.parse = (o, t) => {
    if (i.coerce) try {
      o.value = String(o.value);
    } catch (n) {
    }
    if (typeof o.value === "string") return o;
    return o.issues.push({ expected: "string", code: "invalid_type", input: o.value, inst: r }), o;
  };
});
var E = c("$ZodStringFormat", (r, i) => {
  Wr.init(r, i), Ur.init(r, i);
});
var Go = c("$ZodGUID", (r, i) => {
  i.pattern ?? (i.pattern = Hv), E.init(r, i);
});
var Wo = c("$ZodUUID", (r, i) => {
  if (i.version) {
    let t = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[i.version];
    if (t === void 0) throw Error(`Invalid UUID version: "${i.version}"`);
    i.pattern ?? (i.pattern = _r(t));
  } else i.pattern ?? (i.pattern = _r());
  E.init(r, i);
});
var Xo = c("$ZodEmail", (r, i) => {
  i.pattern ?? (i.pattern = Mv), E.init(r, i);
});
var Vo = c("$ZodURL", (r, i) => {
  E.init(r, i), r._zod.check = (o) => {
    try {
      let t = o.value.trim(), n = new URL(t);
      if (i.hostname) {
        if (i.hostname.lastIndex = 0, !i.hostname.test(n.hostname)) o.issues.push({ code: "invalid_format", format: "url", note: "Invalid hostname", pattern: i.hostname.source, input: o.value, inst: r, continue: !i.abort });
      }
      if (i.protocol) {
        if (i.protocol.lastIndex = 0, !i.protocol.test(n.protocol.endsWith(":") ? n.protocol.slice(0, -1) : n.protocol)) o.issues.push({ code: "invalid_format", format: "url", note: "Invalid protocol", pattern: i.protocol.source, input: o.value, inst: r, continue: !i.abort });
      }
      if (i.normalize) o.value = n.href;
      else o.value = t;
      return;
    } catch (t) {
      o.issues.push({ code: "invalid_format", format: "url", input: o.value, inst: r, continue: !i.abort });
    }
  };
});
var Ao = c("$ZodEmoji", (r, i) => {
  i.pattern ?? (i.pattern = Rv()), E.init(r, i);
});
var Ko = c("$ZodNanoID", (r, i) => {
  i.pattern ?? (i.pattern = Fv), E.init(r, i);
});
var qo = c("$ZodCUID", (r, i) => {
  i.pattern ?? (i.pattern = qv), E.init(r, i);
});
var Yo = c("$ZodCUID2", (r, i) => {
  i.pattern ?? (i.pattern = Yv), E.init(r, i);
});
var Qo = c("$ZodULID", (r, i) => {
  i.pattern ?? (i.pattern = Qv), E.init(r, i);
});
var mo = c("$ZodXID", (r, i) => {
  i.pattern ?? (i.pattern = mv), E.init(r, i);
});
var To = c("$ZodKSUID", (r, i) => {
  i.pattern ?? (i.pattern = Tv), E.init(r, i);
});
var Fo = c("$ZodISODateTime", (r, i) => {
  i.pattern ?? (i.pattern = sv(i)), E.init(r, i);
});
var Bo = c("$ZodISODate", (r, i) => {
  i.pattern ?? (i.pattern = av), E.init(r, i);
});
var Ho = c("$ZodISOTime", (r, i) => {
  i.pattern ?? (i.pattern = pv(i)), E.init(r, i);
});
var Mo = c("$ZodISODuration", (r, i) => {
  i.pattern ?? (i.pattern = Bv), E.init(r, i);
});
var Ro = c("$ZodIPv4", (r, i) => {
  i.pattern ?? (i.pattern = xv), E.init(r, i), r._zod.bag.format = "ipv4";
});
var xo = c("$ZodIPv6", (r, i) => {
  i.pattern ?? (i.pattern = Zv), E.init(r, i), r._zod.bag.format = "ipv6", r._zod.check = (o) => {
    try {
      new URL(`http://[${o.value}]`);
    } catch {
      o.issues.push({ code: "invalid_format", format: "ipv6", input: o.value, inst: r, continue: !i.abort });
    }
  };
});
var Zo = c("$ZodMAC", (r, i) => {
  i.pattern ?? (i.pattern = dv(i.delimiter)), E.init(r, i), r._zod.bag.format = "mac";
});
var Co = c("$ZodCIDRv4", (r, i) => {
  i.pattern ?? (i.pattern = Cv), E.init(r, i);
});
var fo = c("$ZodCIDRv6", (r, i) => {
  i.pattern ?? (i.pattern = fv), E.init(r, i), r._zod.check = (o) => {
    let t = o.value.split("/");
    try {
      if (t.length !== 2) throw Error();
      let [n, v] = t;
      if (!v) throw Error();
      let u = Number(v);
      if (`${u}` !== v) throw Error();
      if (u < 0 || u > 128) throw Error();
      new URL(`http://[${n}]`);
    } catch {
      o.issues.push({ code: "invalid_format", format: "cidrv6", input: o.value, inst: r, continue: !i.abort });
    }
  };
});
function ho(r) {
  if (r === "") return true;
  if (r.length % 4 !== 0) return false;
  try {
    return atob(r), true;
  } catch {
    return false;
  }
}
var yo = c("$ZodBase64", (r, i) => {
  i.pattern ?? (i.pattern = hv), E.init(r, i), r._zod.bag.contentEncoding = "base64", r._zod.check = (o) => {
    if (ho(o.value)) return;
    o.issues.push({ code: "invalid_format", format: "base64", input: o.value, inst: r, continue: !i.abort });
  };
});
function Ce(r) {
  if (!fn.test(r)) return false;
  let i = r.replace(/[-_]/g, (t) => t === "-" ? "+" : "/"), o = i.padEnd(Math.ceil(i.length / 4) * 4, "=");
  return ho(o);
}
var ao = c("$ZodBase64URL", (r, i) => {
  i.pattern ?? (i.pattern = fn), E.init(r, i), r._zod.bag.contentEncoding = "base64url", r._zod.check = (o) => {
    if (Ce(o.value)) return;
    o.issues.push({ code: "invalid_format", format: "base64url", input: o.value, inst: r, continue: !i.abort });
  };
});
var po = c("$ZodE164", (r, i) => {
  i.pattern ?? (i.pattern = yv), E.init(r, i);
});
function fe(r, i = null) {
  try {
    let o = r.split(".");
    if (o.length !== 3) return false;
    let [t] = o;
    if (!t) return false;
    let n = JSON.parse(atob(t));
    if ("typ" in n && n?.typ !== "JWT") return false;
    if (!n.alg) return false;
    if (i && (!("alg" in n) || n.alg !== i)) return false;
    return true;
  } catch {
    return false;
  }
}
var so = c("$ZodJWT", (r, i) => {
  E.init(r, i), r._zod.check = (o) => {
    if (fe(o.value, i.alg)) return;
    o.issues.push({ code: "invalid_format", format: "jwt", input: o.value, inst: r, continue: !i.abort });
  };
});
var rt = c("$ZodCustomStringFormat", (r, i) => {
  E.init(r, i), r._zod.check = (o) => {
    if (i.fn(o.value)) return;
    o.issues.push({ code: "invalid_format", format: i.format, input: o.value, inst: r, continue: !i.abort });
  };
});
var vi = c("$ZodNumber", (r, i) => {
  z.init(r, i), r._zod.pattern = r._zod.bag.pattern ?? ln, r._zod.parse = (o, t) => {
    if (i.coerce) try {
      o.value = Number(o.value);
    } catch (u) {
    }
    let n = o.value;
    if (typeof n === "number" && !Number.isNaN(n) && Number.isFinite(n)) return o;
    let v = typeof n === "number" ? Number.isNaN(n) ? "NaN" : !Number.isFinite(n) ? "Infinity" : void 0 : void 0;
    return o.issues.push({ expected: "number", code: "invalid_type", input: n, inst: r, ...v ? { received: v } : {} }), o;
  };
});
var nt = c("$ZodNumberFormat", (r, i) => {
  eo.init(r, i), vi.init(r, i);
});
var bn = c("$ZodBoolean", (r, i) => {
  z.init(r, i), r._zod.pattern = vo, r._zod.parse = (o, t) => {
    if (i.coerce) try {
      o.value = Boolean(o.value);
    } catch (v) {
    }
    let n = o.value;
    if (typeof n === "boolean") return o;
    return o.issues.push({ expected: "boolean", code: "invalid_type", input: n, inst: r }), o;
  };
});
var oi = c("$ZodBigInt", (r, i) => {
  z.init(r, i), r._zod.pattern = no, r._zod.parse = (o, t) => {
    if (i.coerce) try {
      o.value = BigInt(o.value);
    } catch (n) {
    }
    if (typeof o.value === "bigint") return o;
    return o.issues.push({ expected: "bigint", code: "invalid_type", input: o.value, inst: r }), o;
  };
});
var it = c("$ZodBigIntFormat", (r, i) => {
  lo.init(r, i), oi.init(r, i);
});
var vt = c("$ZodSymbol", (r, i) => {
  z.init(r, i), r._zod.parse = (o, t) => {
    let n = o.value;
    if (typeof n === "symbol") return o;
    return o.issues.push({ expected: "symbol", code: "invalid_type", input: n, inst: r }), o;
  };
});
var ot = c("$ZodUndefined", (r, i) => {
  z.init(r, i), r._zod.pattern = to, r._zod.values = /* @__PURE__ */ new Set([void 0]), r._zod.optin = "optional", r._zod.optout = "optional", r._zod.parse = (o, t) => {
    let n = o.value;
    if (typeof n > "u") return o;
    return o.issues.push({ expected: "undefined", code: "invalid_type", input: n, inst: r }), o;
  };
});
var tt = c("$ZodNull", (r, i) => {
  z.init(r, i), r._zod.pattern = oo, r._zod.values = /* @__PURE__ */ new Set([null]), r._zod.parse = (o, t) => {
    let n = o.value;
    if (n === null) return o;
    return o.issues.push({ expected: "null", code: "invalid_type", input: n, inst: r }), o;
  };
});
var ut = c("$ZodAny", (r, i) => {
  z.init(r, i), r._zod.parse = (o) => o;
});
var $t = c("$ZodUnknown", (r, i) => {
  z.init(r, i), r._zod.parse = (o) => o;
});
var gt = c("$ZodNever", (r, i) => {
  z.init(r, i), r._zod.parse = (o, t) => {
    return o.issues.push({ expected: "never", code: "invalid_type", input: o.value, inst: r }), o;
  };
});
var et = c("$ZodVoid", (r, i) => {
  z.init(r, i), r._zod.parse = (o, t) => {
    let n = o.value;
    if (typeof n > "u") return o;
    return o.issues.push({ expected: "void", code: "invalid_type", input: n, inst: r }), o;
  };
});
var lt = c("$ZodDate", (r, i) => {
  z.init(r, i), r._zod.parse = (o, t) => {
    if (i.coerce) try {
      o.value = new Date(o.value);
    } catch ($) {
    }
    let n = o.value, v = n instanceof Date;
    if (v && !Number.isNaN(n.getTime())) return o;
    return o.issues.push({ expected: "date", code: "invalid_type", input: n, ...v ? { received: "Invalid Date" } : {}, inst: r }), o;
  };
});
function Qe(r, i, o) {
  if (r.issues.length) i.issues.push(...H(o, r.issues));
  i.value[o] = r.value;
}
var ct = c("$ZodArray", (r, i) => {
  z.init(r, i), r._zod.parse = (o, t) => {
    let n = o.value;
    if (!Array.isArray(n)) return o.issues.push({ expected: "array", code: "invalid_type", input: n, inst: r }), o;
    o.value = Array(n.length);
    let v = [];
    for (let u = 0; u < n.length; u++) {
      let $ = n[u], l = i.element._zod.run({ value: $, issues: [] }, t);
      if (l instanceof Promise) v.push(l.then((e) => Qe(e, o, u)));
      else Qe(l, o, u);
    }
    if (v.length) return Promise.all(v).then(() => o);
    return o;
  };
});
function ii(r, i, o, t, n) {
  if (r.issues.length) {
    if (n && !(o in t)) return;
    i.issues.push(...H(o, r.issues));
  }
  if (r.value === void 0) {
    if (o in t) i.value[o] = void 0;
  } else i.value[o] = r.value;
}
function he(r) {
  let i = Object.keys(r.shape);
  for (let t of i) if (!r.shape?.[t]?._zod?.traits?.has("$ZodType")) throw Error(`Invalid element at key "${t}": expected a Zod schema`);
  let o = Ev(r.shape);
  return { ...r, keys: i, keySet: new Set(i), numKeys: i.length, optionalKeys: new Set(o) };
}
function ye(r, i, o, t, n, v) {
  let u = [], $ = n.keySet, l = n.catchall._zod, e = l.def.type, I = l.optout === "optional";
  for (let _ in i) {
    if ($.has(_)) continue;
    if (e === "never") {
      u.push(_);
      continue;
    }
    let N = l.run({ value: i[_], issues: [] }, t);
    if (N instanceof Promise) r.push(N.then((O) => ii(O, o, _, i, I)));
    else ii(N, o, _, i, I);
  }
  if (u.length) o.issues.push({ code: "unrecognized_keys", keys: u, input: i, inst: v });
  if (!r.length) return o;
  return Promise.all(r).then(() => {
    return o;
  });
}
var ae = c("$ZodObject", (r, i) => {
  if (z.init(r, i), !Object.getOwnPropertyDescriptor(i, "shape")?.get) {
    let $ = i.shape;
    Object.defineProperty(i, "shape", { get: () => {
      let l = { ...$ };
      return Object.defineProperty(i, "shape", { value: l }), l;
    } });
  }
  let t = Pr(() => he(i));
  j(r._zod, "propValues", () => {
    let $ = i.shape, l = {};
    for (let e in $) {
      let I = $[e]._zod;
      if (I.values) {
        l[e] ?? (l[e] = /* @__PURE__ */ new Set());
        for (let _ of I.values) l[e].add(_);
      }
    }
    return l;
  });
  let n = br, v = i.catchall, u;
  r._zod.parse = ($, l) => {
    u ?? (u = t.value);
    let e = $.value;
    if (!n(e)) return $.issues.push({ expected: "object", code: "invalid_type", input: e, inst: r }), $;
    $.value = {};
    let I = [], _ = u.shape;
    for (let N of u.keys) {
      let O = _[N], J = O._zod.optout === "optional", X = O._zod.run({ value: e[N], issues: [] }, l);
      if (X instanceof Promise) I.push(X.then((Sr) => ii(Sr, $, N, e, J)));
      else ii(X, $, N, e, J);
    }
    if (!v) return I.length ? Promise.all(I).then(() => $) : $;
    return ye(I, e, $, l, t.value, r);
  };
});
var It = c("$ZodObjectJIT", (r, i) => {
  ae.init(r, i);
  let o = r._zod.parse, t = Pr(() => he(i)), n = (N) => {
    let O = new an(["shape", "payload", "ctx"]), J = t.value, X = (C) => {
      let m = Qn(C);
      return `shape[${m}]._zod.run({ value: input[${m}], issues: [] }, ctx)`;
    };
    O.write("const input = payload.value;");
    let Sr = /* @__PURE__ */ Object.create(null), Xc = 0;
    for (let C of J.keys) Sr[C] = `key_${Xc++}`;
    O.write("const newResult = {};");
    for (let C of J.keys) {
      let m = Sr[C], Z = Qn(C), Ac = N[C]?._zod?.optout === "optional";
      if (O.write(`const ${m} = ${X(C)};`), Ac) O.write(`
        if (${m}.issues.length) {
          if (${Z} in input) {
            payload.issues = payload.issues.concat(${m}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${Z}, ...iss.path] : [${Z}]
            })));
          }
        }
        
        if (${m}.value === undefined) {
          if (${Z} in input) {
            newResult[${Z}] = undefined;
          }
        } else {
          newResult[${Z}] = ${m}.value;
        }
        
      `);
      else O.write(`
        if (${m}.issues.length) {
          payload.issues = payload.issues.concat(${m}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${Z}, ...iss.path] : [${Z}]
          })));
        }
        
        if (${m}.value === undefined) {
          if (${Z} in input) {
            newResult[${Z}] = undefined;
          }
        } else {
          newResult[${Z}] = ${m}.value;
        }
        
      `);
    }
    O.write("payload.value = newResult;"), O.write("return payload;");
    let Vc = O.compile();
    return (C, m) => Vc(N, C, m);
  }, v, u = br, $ = !sr.jitless, e = $ && jv.value, I = i.catchall, _;
  r._zod.parse = (N, O) => {
    _ ?? (_ = t.value);
    let J = N.value;
    if (!u(J)) return N.issues.push({ expected: "object", code: "invalid_type", input: J, inst: r }), N;
    if ($ && e && O?.async === false && O.jitless !== true) {
      if (!v) v = n(i.shape);
      if (N = v(N, O), !I) return N;
      return ye([], J, N, O, _, r);
    }
    return o(N, O);
  };
});
function me(r, i, o, t) {
  for (let v of r) if (v.issues.length === 0) return i.value = v.value, i;
  let n = r.filter((v) => !ur(v));
  if (n.length === 1) return i.value = n[0].value, n[0];
  return i.issues.push({ code: "invalid_union", input: i.value, inst: o, errors: r.map((v) => v.issues.map((u) => T(u, t, V()))) }), i;
}
var _n = c("$ZodUnion", (r, i) => {
  z.init(r, i), j(r._zod, "optin", () => i.options.some((n) => n._zod.optin === "optional") ? "optional" : void 0), j(r._zod, "optout", () => i.options.some((n) => n._zod.optout === "optional") ? "optional" : void 0), j(r._zod, "values", () => {
    if (i.options.every((n) => n._zod.values)) return new Set(i.options.flatMap((n) => Array.from(n._zod.values)));
    return;
  }), j(r._zod, "pattern", () => {
    if (i.options.every((n) => n._zod.pattern)) {
      let n = i.options.map((v) => v._zod.pattern);
      return new RegExp(`^(${n.map((v) => vn(v.source)).join("|")})$`);
    }
    return;
  });
  let o = i.options.length === 1, t = i.options[0]._zod.run;
  r._zod.parse = (n, v) => {
    if (o) return t(n, v);
    let u = false, $ = [];
    for (let l of i.options) {
      let e = l._zod.run({ value: n.value, issues: [] }, v);
      if (e instanceof Promise) $.push(e), u = true;
      else {
        if (e.issues.length === 0) return e;
        $.push(e);
      }
    }
    if (!u) return me($, n, r, v);
    return Promise.all($).then((l) => {
      return me(l, n, r, v);
    });
  };
});
function Te(r, i, o, t) {
  let n = r.filter((v) => v.issues.length === 0);
  if (n.length === 1) return i.value = n[0].value, i;
  if (n.length === 0) i.issues.push({ code: "invalid_union", input: i.value, inst: o, errors: r.map((v) => v.issues.map((u) => T(u, t, V()))) });
  else i.issues.push({ code: "invalid_union", input: i.value, inst: o, errors: [], inclusive: false });
  return i;
}
var bt = c("$ZodXor", (r, i) => {
  _n.init(r, i), i.inclusive = false;
  let o = i.options.length === 1, t = i.options[0]._zod.run;
  r._zod.parse = (n, v) => {
    if (o) return t(n, v);
    let u = false, $ = [];
    for (let l of i.options) {
      let e = l._zod.run({ value: n.value, issues: [] }, v);
      if (e instanceof Promise) $.push(e), u = true;
      else $.push(e);
    }
    if (!u) return Te($, n, r, v);
    return Promise.all($).then((l) => {
      return Te(l, n, r, v);
    });
  };
});
var _t = c("$ZodDiscriminatedUnion", (r, i) => {
  i.inclusive = false, _n.init(r, i);
  let o = r._zod.parse;
  j(r._zod, "propValues", () => {
    let n = {};
    for (let v of i.options) {
      let u = v._zod.propValues;
      if (!u || Object.keys(u).length === 0) throw Error(`Invalid discriminated union option at index "${i.options.indexOf(v)}"`);
      for (let [$, l] of Object.entries(u)) {
        if (!n[$]) n[$] = /* @__PURE__ */ new Set();
        for (let e of l) n[$].add(e);
      }
    }
    return n;
  });
  let t = Pr(() => {
    let n = i.options, v = /* @__PURE__ */ new Map();
    for (let u of n) {
      let $ = u._zod.propValues?.[i.discriminator];
      if (!$ || $.size === 0) throw Error(`Invalid discriminated union option at index "${i.options.indexOf(u)}"`);
      for (let l of $) {
        if (v.has(l)) throw Error(`Duplicate discriminator value "${String(l)}"`);
        v.set(l, u);
      }
    }
    return v;
  });
  r._zod.parse = (n, v) => {
    let u = n.value;
    if (!br(u)) return n.issues.push({ code: "invalid_type", expected: "object", input: u, inst: r }), n;
    let $ = t.value.get(u?.[i.discriminator]);
    if ($) return $._zod.run(n, v);
    if (i.unionFallback) return o(n, v);
    return n.issues.push({ code: "invalid_union", errors: [], note: "No matching discriminator", discriminator: i.discriminator, input: u, path: [i.discriminator], inst: r }), n;
  };
});
var Ut = c("$ZodIntersection", (r, i) => {
  z.init(r, i), r._zod.parse = (o, t) => {
    let n = o.value, v = i.left._zod.run({ value: n, issues: [] }, t), u = i.right._zod.run({ value: n, issues: [] }, t);
    if (v instanceof Promise || u instanceof Promise) return Promise.all([v, u]).then(([l, e]) => {
      return Fe(o, l, e);
    });
    return Fe(o, v, u);
  };
});
function Eo(r, i) {
  if (r === i) return { valid: true, data: r };
  if (r instanceof Date && i instanceof Date && +r === +i) return { valid: true, data: r };
  if (tr(r) && tr(i)) {
    let o = Object.keys(i), t = Object.keys(r).filter((v) => o.indexOf(v) !== -1), n = { ...r, ...i };
    for (let v of t) {
      let u = Eo(r[v], i[v]);
      if (!u.valid) return { valid: false, mergeErrorPath: [v, ...u.mergeErrorPath] };
      n[v] = u.data;
    }
    return { valid: true, data: n };
  }
  if (Array.isArray(r) && Array.isArray(i)) {
    if (r.length !== i.length) return { valid: false, mergeErrorPath: [] };
    let o = [];
    for (let t = 0; t < r.length; t++) {
      let n = r[t], v = i[t], u = Eo(n, v);
      if (!u.valid) return { valid: false, mergeErrorPath: [t, ...u.mergeErrorPath] };
      o.push(u.data);
    }
    return { valid: true, data: o };
  }
  return { valid: false, mergeErrorPath: [] };
}
function Fe(r, i, o) {
  let t = /* @__PURE__ */ new Map(), n;
  for (let $ of i.issues) if ($.code === "unrecognized_keys") {
    n ?? (n = $);
    for (let l of $.keys) {
      if (!t.has(l)) t.set(l, {});
      t.get(l).l = true;
    }
  } else r.issues.push($);
  for (let $ of o.issues) if ($.code === "unrecognized_keys") for (let l of $.keys) {
    if (!t.has(l)) t.set(l, {});
    t.get(l).r = true;
  }
  else r.issues.push($);
  let v = [...t].filter(([, $]) => $.l && $.r).map(([$]) => $);
  if (v.length && n) r.issues.push({ ...n, keys: v });
  if (ur(r)) return r;
  let u = Eo(i.value, o.value);
  if (!u.valid) throw Error(`Unmergable intersection. Error path: ${JSON.stringify(u.mergeErrorPath)}`);
  return r.value = u.data, r;
}
var ti = c("$ZodTuple", (r, i) => {
  z.init(r, i);
  let o = i.items;
  r._zod.parse = (t, n) => {
    let v = t.value;
    if (!Array.isArray(v)) return t.issues.push({ input: v, inst: r, expected: "tuple", code: "invalid_type" }), t;
    t.value = [];
    let u = [], $ = [...o].reverse().findIndex((I) => I._zod.optin !== "optional"), l = $ === -1 ? 0 : o.length - $;
    if (!i.rest) {
      let I = v.length > o.length, _ = v.length < l - 1;
      if (I || _) return t.issues.push({ ...I ? { code: "too_big", maximum: o.length, inclusive: true } : { code: "too_small", minimum: o.length }, input: v, inst: r, origin: "array" }), t;
    }
    let e = -1;
    for (let I of o) {
      if (e++, e >= v.length) {
        if (e >= l) continue;
      }
      let _ = I._zod.run({ value: v[e], issues: [] }, n);
      if (_ instanceof Promise) u.push(_.then((N) => pn(N, t, e)));
      else pn(_, t, e);
    }
    if (i.rest) {
      let I = v.slice(o.length);
      for (let _ of I) {
        e++;
        let N = i.rest._zod.run({ value: _, issues: [] }, n);
        if (N instanceof Promise) u.push(N.then((O) => pn(O, t, e)));
        else pn(N, t, e);
      }
    }
    if (u.length) return Promise.all(u).then(() => t);
    return t;
  };
});
function pn(r, i, o) {
  if (r.issues.length) i.issues.push(...H(o, r.issues));
  i.value[o] = r.value;
}
var kt = c("$ZodRecord", (r, i) => {
  z.init(r, i), r._zod.parse = (o, t) => {
    let n = o.value;
    if (!tr(n)) return o.issues.push({ expected: "record", code: "invalid_type", input: n, inst: r }), o;
    let v = [], u = i.keyType._zod.values;
    if (u) {
      o.value = {};
      let $ = /* @__PURE__ */ new Set();
      for (let e of u) if (typeof e === "string" || typeof e === "number" || typeof e === "symbol") {
        $.add(typeof e === "number" ? e.toString() : e);
        let I = i.valueType._zod.run({ value: n[e], issues: [] }, t);
        if (I instanceof Promise) v.push(I.then((_) => {
          if (_.issues.length) o.issues.push(...H(e, _.issues));
          o.value[e] = _.value;
        }));
        else {
          if (I.issues.length) o.issues.push(...H(e, I.issues));
          o.value[e] = I.value;
        }
      }
      let l;
      for (let e in n) if (!$.has(e)) l = l ?? [], l.push(e);
      if (l && l.length > 0) o.issues.push({ code: "unrecognized_keys", input: n, inst: r, keys: l });
    } else {
      o.value = {};
      for (let $ of Reflect.ownKeys(n)) {
        if ($ === "__proto__") continue;
        let l = i.keyType._zod.run({ value: $, issues: [] }, t);
        if (l instanceof Promise) throw Error("Async schemas not supported in object keys currently");
        if (typeof $ === "string" && ln.test($) && l.issues.length && l.issues.some((_) => _.code === "invalid_type" && _.expected === "number")) {
          let _ = i.keyType._zod.run({ value: Number($), issues: [] }, t);
          if (_ instanceof Promise) throw Error("Async schemas not supported in object keys currently");
          if (_.issues.length === 0) l = _;
        }
        if (l.issues.length) {
          if (i.mode === "loose") o.value[$] = n[$];
          else o.issues.push({ code: "invalid_key", origin: "record", issues: l.issues.map((_) => T(_, t, V())), input: $, path: [$], inst: r });
          continue;
        }
        let I = i.valueType._zod.run({ value: n[$], issues: [] }, t);
        if (I instanceof Promise) v.push(I.then((_) => {
          if (_.issues.length) o.issues.push(...H($, _.issues));
          o.value[l.value] = _.value;
        }));
        else {
          if (I.issues.length) o.issues.push(...H($, I.issues));
          o.value[l.value] = I.value;
        }
      }
    }
    if (v.length) return Promise.all(v).then(() => o);
    return o;
  };
});
var Dt = c("$ZodMap", (r, i) => {
  z.init(r, i), r._zod.parse = (o, t) => {
    let n = o.value;
    if (!(n instanceof Map)) return o.issues.push({ expected: "map", code: "invalid_type", input: n, inst: r }), o;
    let v = [];
    o.value = /* @__PURE__ */ new Map();
    for (let [u, $] of n) {
      let l = i.keyType._zod.run({ value: u, issues: [] }, t), e = i.valueType._zod.run({ value: $, issues: [] }, t);
      if (l instanceof Promise || e instanceof Promise) v.push(Promise.all([l, e]).then(([I, _]) => {
        Be(I, _, o, u, n, r, t);
      }));
      else Be(l, e, o, u, n, r, t);
    }
    if (v.length) return Promise.all(v).then(() => o);
    return o;
  };
});
function Be(r, i, o, t, n, v, u) {
  if (r.issues.length) if (on.has(typeof t)) o.issues.push(...H(t, r.issues));
  else o.issues.push({ code: "invalid_key", origin: "map", input: n, inst: v, issues: r.issues.map(($) => T($, u, V())) });
  if (i.issues.length) if (on.has(typeof t)) o.issues.push(...H(t, i.issues));
  else o.issues.push({ origin: "map", code: "invalid_element", input: n, inst: v, key: t, issues: i.issues.map(($) => T($, u, V())) });
  o.value.set(r.value, i.value);
}
var wt = c("$ZodSet", (r, i) => {
  z.init(r, i), r._zod.parse = (o, t) => {
    let n = o.value;
    if (!(n instanceof Set)) return o.issues.push({ input: n, inst: r, expected: "set", code: "invalid_type" }), o;
    let v = [];
    o.value = /* @__PURE__ */ new Set();
    for (let u of n) {
      let $ = i.valueType._zod.run({ value: u, issues: [] }, t);
      if ($ instanceof Promise) v.push($.then((l) => He(l, o)));
      else He($, o);
    }
    if (v.length) return Promise.all(v).then(() => o);
    return o;
  };
});
function He(r, i) {
  if (r.issues.length) i.issues.push(...r.issues);
  i.value.add(r.value);
}
var Nt = c("$ZodEnum", (r, i) => {
  z.init(r, i);
  let o = nn(i.entries), t = new Set(o);
  r._zod.values = t, r._zod.pattern = new RegExp(`^(${o.filter((n) => on.has(typeof n)).map((n) => typeof n === "string" ? R(n) : n.toString()).join("|")})$`), r._zod.parse = (n, v) => {
    let u = n.value;
    if (t.has(u)) return n;
    return n.issues.push({ code: "invalid_value", values: o, input: u, inst: r }), n;
  };
});
var Ot = c("$ZodLiteral", (r, i) => {
  if (z.init(r, i), i.values.length === 0) throw Error("Cannot create literal schema with no valid values");
  let o = new Set(i.values);
  r._zod.values = o, r._zod.pattern = new RegExp(`^(${i.values.map((t) => typeof t === "string" ? R(t) : t ? R(t.toString()) : String(t)).join("|")})$`), r._zod.parse = (t, n) => {
    let v = t.value;
    if (o.has(v)) return t;
    return t.issues.push({ code: "invalid_value", values: i.values, input: v, inst: r }), t;
  };
});
var St = c("$ZodFile", (r, i) => {
  z.init(r, i), r._zod.parse = (o, t) => {
    let n = o.value;
    if (n instanceof File) return o;
    return o.issues.push({ expected: "file", code: "invalid_type", input: n, inst: r }), o;
  };
});
var zt = c("$ZodTransform", (r, i) => {
  z.init(r, i), r._zod.parse = (o, t) => {
    if (t.direction === "backward") throw new Ir(r.constructor.name);
    let n = i.transform(o.value, o);
    if (t.async) return (n instanceof Promise ? n : Promise.resolve(n)).then((u) => {
      return o.value = u, o;
    });
    if (n instanceof Promise) throw new f();
    return o.value = n, o;
  };
});
function Me(r, i) {
  if (r.issues.length && i === void 0) return { issues: [], value: void 0 };
  return r;
}
var ui = c("$ZodOptional", (r, i) => {
  z.init(r, i), r._zod.optin = "optional", r._zod.optout = "optional", j(r._zod, "values", () => {
    return i.innerType._zod.values ? /* @__PURE__ */ new Set([...i.innerType._zod.values, void 0]) : void 0;
  }), j(r._zod, "pattern", () => {
    let o = i.innerType._zod.pattern;
    return o ? new RegExp(`^(${vn(o.source)})?$`) : void 0;
  }), r._zod.parse = (o, t) => {
    if (i.innerType._zod.optin === "optional") {
      let n = i.innerType._zod.run(o, t);
      if (n instanceof Promise) return n.then((v) => Me(v, o.value));
      return Me(n, o.value);
    }
    if (o.value === void 0) return o;
    return i.innerType._zod.run(o, t);
  };
});
var Pt = c("$ZodExactOptional", (r, i) => {
  ui.init(r, i), j(r._zod, "values", () => i.innerType._zod.values), j(r._zod, "pattern", () => i.innerType._zod.pattern), r._zod.parse = (o, t) => {
    return i.innerType._zod.run(o, t);
  };
});
var jt = c("$ZodNullable", (r, i) => {
  z.init(r, i), j(r._zod, "optin", () => i.innerType._zod.optin), j(r._zod, "optout", () => i.innerType._zod.optout), j(r._zod, "pattern", () => {
    let o = i.innerType._zod.pattern;
    return o ? new RegExp(`^(${vn(o.source)}|null)$`) : void 0;
  }), j(r._zod, "values", () => {
    return i.innerType._zod.values ? /* @__PURE__ */ new Set([...i.innerType._zod.values, null]) : void 0;
  }), r._zod.parse = (o, t) => {
    if (o.value === null) return o;
    return i.innerType._zod.run(o, t);
  };
});
var Jt = c("$ZodDefault", (r, i) => {
  z.init(r, i), r._zod.optin = "optional", j(r._zod, "values", () => i.innerType._zod.values), r._zod.parse = (o, t) => {
    if (t.direction === "backward") return i.innerType._zod.run(o, t);
    if (o.value === void 0) return o.value = i.defaultValue, o;
    let n = i.innerType._zod.run(o, t);
    if (n instanceof Promise) return n.then((v) => Re(v, i));
    return Re(n, i);
  };
});
function Re(r, i) {
  if (r.value === void 0) r.value = i.defaultValue;
  return r;
}
var Lt = c("$ZodPrefault", (r, i) => {
  z.init(r, i), r._zod.optin = "optional", j(r._zod, "values", () => i.innerType._zod.values), r._zod.parse = (o, t) => {
    if (t.direction === "backward") return i.innerType._zod.run(o, t);
    if (o.value === void 0) o.value = i.defaultValue;
    return i.innerType._zod.run(o, t);
  };
});
var Et = c("$ZodNonOptional", (r, i) => {
  z.init(r, i), j(r._zod, "values", () => {
    let o = i.innerType._zod.values;
    return o ? new Set([...o].filter((t) => t !== void 0)) : void 0;
  }), r._zod.parse = (o, t) => {
    let n = i.innerType._zod.run(o, t);
    if (n instanceof Promise) return n.then((v) => xe(v, r));
    return xe(n, r);
  };
});
function xe(r, i) {
  if (!r.issues.length && r.value === void 0) r.issues.push({ code: "invalid_type", expected: "nonoptional", input: r.value, inst: i });
  return r;
}
var Gt = c("$ZodSuccess", (r, i) => {
  z.init(r, i), r._zod.parse = (o, t) => {
    if (t.direction === "backward") throw new Ir("ZodSuccess");
    let n = i.innerType._zod.run(o, t);
    if (n instanceof Promise) return n.then((v) => {
      return o.value = v.issues.length === 0, o;
    });
    return o.value = n.issues.length === 0, o;
  };
});
var Wt = c("$ZodCatch", (r, i) => {
  z.init(r, i), j(r._zod, "optin", () => i.innerType._zod.optin), j(r._zod, "optout", () => i.innerType._zod.optout), j(r._zod, "values", () => i.innerType._zod.values), r._zod.parse = (o, t) => {
    if (t.direction === "backward") return i.innerType._zod.run(o, t);
    let n = i.innerType._zod.run(o, t);
    if (n instanceof Promise) return n.then((v) => {
      if (o.value = v.value, v.issues.length) o.value = i.catchValue({ ...o, error: { issues: v.issues.map((u) => T(u, t, V())) }, input: o.value }), o.issues = [];
      return o;
    });
    if (o.value = n.value, n.issues.length) o.value = i.catchValue({ ...o, error: { issues: n.issues.map((v) => T(v, t, V())) }, input: o.value }), o.issues = [];
    return o;
  };
});
var Xt = c("$ZodNaN", (r, i) => {
  z.init(r, i), r._zod.parse = (o, t) => {
    if (typeof o.value !== "number" || !Number.isNaN(o.value)) return o.issues.push({ input: o.value, inst: r, expected: "nan", code: "invalid_type" }), o;
    return o;
  };
});
var Vt = c("$ZodPipe", (r, i) => {
  z.init(r, i), j(r._zod, "values", () => i.in._zod.values), j(r._zod, "optin", () => i.in._zod.optin), j(r._zod, "optout", () => i.out._zod.optout), j(r._zod, "propValues", () => i.in._zod.propValues), r._zod.parse = (o, t) => {
    if (t.direction === "backward") {
      let v = i.out._zod.run(o, t);
      if (v instanceof Promise) return v.then((u) => sn(u, i.in, t));
      return sn(v, i.in, t);
    }
    let n = i.in._zod.run(o, t);
    if (n instanceof Promise) return n.then((v) => sn(v, i.out, t));
    return sn(n, i.out, t);
  };
});
function sn(r, i, o) {
  if (r.issues.length) return r.aborted = true, r;
  return i._zod.run({ value: r.value, issues: r.issues }, o);
}
var Un = c("$ZodCodec", (r, i) => {
  z.init(r, i), j(r._zod, "values", () => i.in._zod.values), j(r._zod, "optin", () => i.in._zod.optin), j(r._zod, "optout", () => i.out._zod.optout), j(r._zod, "propValues", () => i.in._zod.propValues), r._zod.parse = (o, t) => {
    if ((t.direction || "forward") === "forward") {
      let v = i.in._zod.run(o, t);
      if (v instanceof Promise) return v.then((u) => ri(u, i, t));
      return ri(v, i, t);
    } else {
      let v = i.out._zod.run(o, t);
      if (v instanceof Promise) return v.then((u) => ri(u, i, t));
      return ri(v, i, t);
    }
  };
});
function ri(r, i, o) {
  if (r.issues.length) return r.aborted = true, r;
  if ((o.direction || "forward") === "forward") {
    let n = i.transform(r.value, r);
    if (n instanceof Promise) return n.then((v) => ni(r, v, i.out, o));
    return ni(r, n, i.out, o);
  } else {
    let n = i.reverseTransform(r.value, r);
    if (n instanceof Promise) return n.then((v) => ni(r, v, i.in, o));
    return ni(r, n, i.in, o);
  }
}
function ni(r, i, o, t) {
  if (r.issues.length) return r.aborted = true, r;
  return o._zod.run({ value: i, issues: r.issues }, t);
}
var At = c("$ZodReadonly", (r, i) => {
  z.init(r, i), j(r._zod, "propValues", () => i.innerType._zod.propValues), j(r._zod, "values", () => i.innerType._zod.values), j(r._zod, "optin", () => i.innerType?._zod?.optin), j(r._zod, "optout", () => i.innerType?._zod?.optout), r._zod.parse = (o, t) => {
    if (t.direction === "backward") return i.innerType._zod.run(o, t);
    let n = i.innerType._zod.run(o, t);
    if (n instanceof Promise) return n.then(Ze);
    return Ze(n);
  };
});
function Ze(r) {
  return r.value = Object.freeze(r.value), r;
}
var Kt = c("$ZodTemplateLiteral", (r, i) => {
  z.init(r, i);
  let o = [];
  for (let t of i.parts) if (typeof t === "object" && t !== null) {
    if (!t._zod.pattern) throw Error(`Invalid template literal part, no pattern found: ${[...t._zod.traits].shift()}`);
    let n = t._zod.pattern instanceof RegExp ? t._zod.pattern.source : t._zod.pattern;
    if (!n) throw Error(`Invalid template literal part: ${t._zod.traits}`);
    let v = n.startsWith("^") ? 1 : 0, u = n.endsWith("$") ? n.length - 1 : n.length;
    o.push(n.slice(v, u));
  } else if (t === null || Lv.has(typeof t)) o.push(R(`${t}`));
  else throw Error(`Invalid template literal part: ${t}`);
  r._zod.pattern = new RegExp(`^${o.join("")}$`), r._zod.parse = (t, n) => {
    if (typeof t.value !== "string") return t.issues.push({ input: t.value, inst: r, expected: "string", code: "invalid_type" }), t;
    if (r._zod.pattern.lastIndex = 0, !r._zod.pattern.test(t.value)) return t.issues.push({ input: t.value, inst: r, code: "invalid_format", format: i.format ?? "template_literal", pattern: r._zod.pattern.source }), t;
    return t;
  };
});
var qt = c("$ZodFunction", (r, i) => {
  return z.init(r, i), r._def = i, r._zod.def = i, r.implement = (o) => {
    if (typeof o !== "function") throw Error("implement() must be called with a function");
    return function(...t) {
      let n = r._def.input ? Tn(r._def.input, t) : t, v = Reflect.apply(o, this, n);
      if (r._def.output) return Tn(r._def.output, v);
      return v;
    };
  }, r.implementAsync = (o) => {
    if (typeof o !== "function") throw Error("implementAsync() must be called with a function");
    return async function(...t) {
      let n = r._def.input ? await Fn(r._def.input, t) : t, v = await Reflect.apply(o, this, n);
      if (r._def.output) return await Fn(r._def.output, v);
      return v;
    };
  }, r._zod.parse = (o, t) => {
    if (typeof o.value !== "function") return o.issues.push({ code: "invalid_type", expected: "function", input: o.value, inst: r }), o;
    if (r._def.output && r._def.output._zod.def.type === "promise") o.value = r.implementAsync(o.value);
    else o.value = r.implement(o.value);
    return o;
  }, r.input = (...o) => {
    let t = r.constructor;
    if (Array.isArray(o[0])) return new t({ type: "function", input: new ti({ type: "tuple", items: o[0], rest: o[1] }), output: r._def.output });
    return new t({ type: "function", input: o[0], output: r._def.output });
  }, r.output = (o) => {
    return new r.constructor({ type: "function", input: r._def.input, output: o });
  }, r;
});
var Yt = c("$ZodPromise", (r, i) => {
  z.init(r, i), r._zod.parse = (o, t) => {
    return Promise.resolve(o.value).then((n) => i.innerType._zod.run({ value: n, issues: [] }, t));
  };
});
var Qt = c("$ZodLazy", (r, i) => {
  z.init(r, i), j(r._zod, "innerType", () => i.getter()), j(r._zod, "pattern", () => r._zod.innerType?._zod?.pattern), j(r._zod, "propValues", () => r._zod.innerType?._zod?.propValues), j(r._zod, "optin", () => r._zod.innerType?._zod?.optin ?? void 0), j(r._zod, "optout", () => r._zod.innerType?._zod?.optout ?? void 0), r._zod.parse = (o, t) => {
    return r._zod.innerType._zod.run(o, t);
  };
});
var mt = c("$ZodCustom", (r, i) => {
  W.init(r, i), z.init(r, i), r._zod.parse = (o, t) => {
    return o;
  }, r._zod.check = (o) => {
    let t = o.value, n = i.fn(t);
    if (n instanceof Promise) return n.then((v) => de(v, o, t, r));
    de(n, o, t, r);
    return;
  };
});
function de(r, i, o, t) {
  if (!r) {
    let n = { code: "custom", input: o, inst: t, path: [...t._zod.def.path ?? []], continue: !t._zod.def.abort };
    if (t._zod.def.params) n.params = t._zod.def.params;
    i.issues.push(jr(n));
  }
}
var On = {};
s(On, { zhTW: () => Gu, zhCN: () => Eu, yo: () => Wu, vi: () => Lu, uz: () => Ju, ur: () => ju, uk: () => Nn, ua: () => Pu, tr: () => zu, th: () => Su, ta: () => Ou, sv: () => Nu, sl: () => wu, ru: () => Du, pt: () => ku, ps: () => _u, pl: () => Uu, ota: () => bu, no: () => Iu, nl: () => cu, ms: () => lu, mk: () => eu, lt: () => gu, ko: () => $u, km: () => Dn, kh: () => uu, ka: () => tu, ja: () => ou, it: () => vu, is: () => iu, id: () => nu, hy: () => ru, hu: () => st, he: () => pt, frCA: () => at, fr: () => yt, fi: () => ht, fa: () => ft, es: () => Ct, eo: () => dt, en: () => kn, de: () => Zt, da: () => xt, cs: () => Rt, ca: () => Mt, bg: () => Ht, be: () => Bt, az: () => Ft, ar: () => Tt });
var v4 = () => {
  let r = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "", email: " ", url: "", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ISO", date: "  ISO", time: "  ISO", duration: "  ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: "   IPv4", cidrv6: "   IPv6", base64: "  base64-encoded", base64url: "  base64url-encoded", json_string: "   JSON", e164: "   E.164", jwt: "JWT", template_literal: "" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `  :   instanceof ${n.expected}    ${$}`;
        return `  :   ${v}    ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `  :   ${U(n.values[0])}`;
        return `  :     : ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `   :    ${n.origin ?? ""} ${v} ${n.maximum.toString()} ${u.unit ?? ""}`;
        return `  :    ${n.origin ?? ""} ${v} ${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `  :   ${n.origin}   ${v} ${n.minimum.toString()} ${u.unit}`;
        return `  :   ${n.origin}   ${v} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `  :     "${n.prefix}"`;
        if (v.format === "ends_with") return `  :     "${v.suffix}"`;
        if (v.format === "includes") return `  :    "${v.includes}"`;
        if (v.format === "regex") return `  :     ${v.pattern}`;
        return `${o[v.format] ?? n.format}  `;
      }
      case "not_multiple_of":
        return `  :      ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "" : ""} ${n.keys.length > 1 ? "" : ""}: ${b(n.keys, " ")}`;
      case "invalid_key":
        return `    ${n.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `    ${n.origin}`;
      default:
        return "  ";
    }
  };
};
function Tt() {
  return { localeError: v4() };
}
var o4 = () => {
  let r = { string: { unit: "simvol", verb: "olmaldr" }, file: { unit: "bayt", verb: "olmaldr" }, array: { unit: "element", verb: "olmaldr" }, set: { unit: "element", verb: "olmaldr" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Yanl dyr: gzlniln instanceof ${n.expected}, daxil olan ${$}`;
        return `Yanl dyr: gzlniln ${v}, daxil olan ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Yanl dyr: gzlniln ${U(n.values[0])}`;
        return `Yanl seim: aadaklardan biri olmaldr: ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `ox byk: gzlniln ${n.origin ?? "dyr"} ${v}${n.maximum.toString()} ${u.unit ?? "element"}`;
        return `ox byk: gzlniln ${n.origin ?? "dyr"} ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `ox kiik: gzlniln ${n.origin} ${v}${n.minimum.toString()} ${u.unit}`;
        return `ox kiik: gzlniln ${n.origin} ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Yanl mtn: "${v.prefix}" il balamaldr`;
        if (v.format === "ends_with") return `Yanl mtn: "${v.suffix}" il bitmlidir`;
        if (v.format === "includes") return `Yanl mtn: "${v.includes}" daxil olmaldr`;
        if (v.format === "regex") return `Yanl mtn: ${v.pattern} ablonuna uyun olmaldr`;
        return `Yanl ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Yanl dd: ${n.divisor} il bln biln olmaldr`;
      case "unrecognized_keys":
        return `Tannmayan aar${n.keys.length > 1 ? "lar" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} daxilind yanl aar`;
      case "invalid_union":
        return "Yanl dyr";
      case "invalid_element":
        return `${n.origin} daxilind yanl dyr`;
      default:
        return "Yanl dyr";
    }
  };
};
function Ft() {
  return { localeError: o4() };
}
function pe(r, i, o, t) {
  let n = Math.abs(r), v = n % 10, u = n % 100;
  if (u >= 11 && u <= 19) return t;
  if (v === 1) return i;
  if (v >= 2 && v <= 4) return o;
  return t;
}
var t4 = () => {
  let r = { string: { unit: { one: "", few: "", many: "" }, verb: "" }, array: { unit: { one: "", few: "", many: "" }, verb: "" }, set: { unit: { one: "", few: "", many: "" }, verb: "" }, file: { unit: { one: "", few: "", many: "" }, verb: "" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "", email: "email ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "   base64", base64url: "   base64url", json_string: "JSON ", e164: " E.164", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return ` :  instanceof ${n.expected},  ${$}`;
        return ` :  ${v},  ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` :  ${U(n.values[0])}`;
        return ` :    ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) {
          let $ = Number(n.maximum), l = pe($, u.unit.one, u.unit.few, u.unit.many);
          return ` : ,  ${n.origin ?? ""}  ${u.verb} ${v}${n.maximum.toString()} ${l}`;
        }
        return ` : ,  ${n.origin ?? ""}   ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) {
          let $ = Number(n.minimum), l = pe($, u.unit.one, u.unit.few, u.unit.many);
          return ` : ,  ${n.origin}  ${u.verb} ${v}${n.minimum.toString()} ${l}`;
        }
        return ` : ,  ${n.origin}   ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` :    "${v.prefix}"`;
        if (v.format === "ends_with") return ` :    "${v.suffix}"`;
        if (v.format === "includes") return ` :   "${v.includes}"`;
        if (v.format === "regex") return ` :    ${v.pattern}`;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` :    ${n.divisor}`;
      case "unrecognized_keys":
        return ` ${n.keys.length > 1 ? "" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${n.origin}`;
      default:
        return " ";
    }
  };
};
function Bt() {
  return { localeError: t4() };
}
var u4 = () => {
  let r = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "", email: " ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64- ", base64url: "base64url- ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return ` :  instanceof ${n.expected},  ${$}`;
        return ` :  ${v},  ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` :  ${U(n.values[0])}`;
        return ` :    ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return ` :   ${n.origin ?? ""}   ${v}${n.maximum.toString()} ${u.unit ?? ""}`;
        return ` :   ${n.origin ?? ""}   ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return ` :   ${n.origin}   ${v}${n.minimum.toString()} ${u.unit}`;
        return ` :   ${n.origin}   ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` :     "${v.prefix}"`;
        if (v.format === "ends_with") return ` :     "${v.suffix}"`;
        if (v.format === "includes") return ` :    "${v.includes}"`;
        if (v.format === "regex") return ` :     ${v.pattern}`;
        let u = "";
        if (v.format === "emoji") u = "";
        if (v.format === "datetime") u = "";
        if (v.format === "date") u = "";
        if (v.format === "time") u = "";
        if (v.format === "duration") u = "";
        return `${u} ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` :      ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "" : ""} ${n.keys.length > 1 ? "" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${n.origin}`;
      default:
        return " ";
    }
  };
};
function Ht() {
  return { localeError: u4() };
}
var $4 = () => {
  let r = { string: { unit: "carcters", verb: "contenir" }, file: { unit: "bytes", verb: "contenir" }, array: { unit: "elements", verb: "contenir" }, set: { unit: "elements", verb: "contenir" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "entrada", email: "adrea electrnica", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i hora ISO", date: "data ISO", time: "hora ISO", duration: "durada ISO", ipv4: "adrea IPv4", ipv6: "adrea IPv6", cidrv4: "rang IPv4", cidrv6: "rang IPv6", base64: "cadena codificada en base64", base64url: "cadena codificada en base64url", json_string: "cadena JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Tipus invlid: s'esperava instanceof ${n.expected}, s'ha rebut ${$}`;
        return `Tipus invlid: s'esperava ${v}, s'ha rebut ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Valor invlid: s'esperava ${U(n.values[0])}`;
        return `Opci invlida: s'esperava una de ${b(n.values, " o ")}`;
      case "too_big": {
        let v = n.inclusive ? "com a mxim" : "menys de", u = i(n.origin);
        if (u) return `Massa gran: s'esperava que ${n.origin ?? "el valor"} contingus ${v} ${n.maximum.toString()} ${u.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${n.origin ?? "el valor"} fos ${v} ${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? "com a mnim" : "ms de", u = i(n.origin);
        if (u) return `Massa petit: s'esperava que ${n.origin} contingus ${v} ${n.minimum.toString()} ${u.unit}`;
        return `Massa petit: s'esperava que ${n.origin} fos ${v} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Format invlid: ha de comenar amb "${v.prefix}"`;
        if (v.format === "ends_with") return `Format invlid: ha d'acabar amb "${v.suffix}"`;
        if (v.format === "includes") return `Format invlid: ha d'incloure "${v.includes}"`;
        if (v.format === "regex") return `Format invlid: ha de coincidir amb el patr ${v.pattern}`;
        return `Format invlid per a ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlid: ha de ser mltiple de ${n.divisor}`;
      case "unrecognized_keys":
        return `Clau${n.keys.length > 1 ? "s" : ""} no reconeguda${n.keys.length > 1 ? "s" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Clau invlida a ${n.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Element invlid a ${n.origin}`;
      default:
        return "Entrada invlida";
    }
  };
};
function Mt() {
  return { localeError: $4() };
}
var g4 = () => {
  let r = { string: { unit: "znak", verb: "mt" }, file: { unit: "bajt", verb: "mt" }, array: { unit: "prvk", verb: "mt" }, set: { unit: "prvk", verb: "mt" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "regulrn vraz", email: "e-mailov adresa", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "datum a as ve formtu ISO", date: "datum ve formtu ISO", time: "as ve formtu ISO", duration: "doba trvn ISO", ipv4: "IPv4 adresa", ipv6: "IPv6 adresa", cidrv4: "rozsah IPv4", cidrv6: "rozsah IPv6", base64: "etzec zakdovan ve formtu base64", base64url: "etzec zakdovan ve formtu base64url", json_string: "etzec ve formtu JSON", e164: "slo E.164", jwt: "JWT", template_literal: "vstup" }, t = { nan: "NaN", number: "slo", string: "etzec", function: "funkce", array: "pole" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Neplatn vstup: oekvno instanceof ${n.expected}, obdreno ${$}`;
        return `Neplatn vstup: oekvno ${v}, obdreno ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Neplatn vstup: oekvno ${U(n.values[0])}`;
        return `Neplatn monost: oekvna jedna z hodnot ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `Hodnota je pli velk: ${n.origin ?? "hodnota"} mus mt ${v}${n.maximum.toString()} ${u.unit ?? "prvk"}`;
        return `Hodnota je pli velk: ${n.origin ?? "hodnota"} mus bt ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `Hodnota je pli mal: ${n.origin ?? "hodnota"} mus mt ${v}${n.minimum.toString()} ${u.unit ?? "prvk"}`;
        return `Hodnota je pli mal: ${n.origin ?? "hodnota"} mus bt ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Neplatn etzec: mus zanat na "${v.prefix}"`;
        if (v.format === "ends_with") return `Neplatn etzec: mus konit na "${v.suffix}"`;
        if (v.format === "includes") return `Neplatn etzec: mus obsahovat "${v.includes}"`;
        if (v.format === "regex") return `Neplatn etzec: mus odpovdat vzoru ${v.pattern}`;
        return `Neplatn formt ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Neplatn slo: mus bt nsobkem ${n.divisor}`;
      case "unrecognized_keys":
        return `Neznm kle: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn kl v ${n.origin}`;
      case "invalid_union":
        return "Neplatn vstup";
      case "invalid_element":
        return `Neplatn hodnota v ${n.origin}`;
      default:
        return "Neplatn vstup";
    }
  };
};
function Rt() {
  return { localeError: g4() };
}
var e4 = () => {
  let r = { string: { unit: "tegn", verb: "havde" }, file: { unit: "bytes", verb: "havde" }, array: { unit: "elementer", verb: "indeholdt" }, set: { unit: "elementer", verb: "indeholdt" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "input", email: "e-mailadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslt", date: "ISO-dato", time: "ISO-klokkeslt", duration: "ISO-varighed", ipv4: "IPv4-omrde", ipv6: "IPv6-omrde", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodet streng", base64url: "base64url-kodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" }, t = { nan: "NaN", string: "streng", number: "tal", boolean: "boolean", array: "liste", object: "objekt", set: "st", file: "fil" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Ugyldigt input: forventede instanceof ${n.expected}, fik ${$}`;
        return `Ugyldigt input: forventede ${v}, fik ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Ugyldig vrdi: forventede ${U(n.values[0])}`;
        return `Ugyldigt valg: forventede en af flgende ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin), $ = t[n.origin] ?? n.origin;
        if (u) return `For stor: forventede ${$ ?? "value"} ${u.verb} ${v} ${n.maximum.toString()} ${u.unit ?? "elementer"}`;
        return `For stor: forventede ${$ ?? "value"} havde ${v} ${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin), $ = t[n.origin] ?? n.origin;
        if (u) return `For lille: forventede ${$} ${u.verb} ${v} ${n.minimum.toString()} ${u.unit}`;
        return `For lille: forventede ${$} havde ${v} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Ugyldig streng: skal starte med "${v.prefix}"`;
        if (v.format === "ends_with") return `Ugyldig streng: skal ende med "${v.suffix}"`;
        if (v.format === "includes") return `Ugyldig streng: skal indeholde "${v.includes}"`;
        if (v.format === "regex") return `Ugyldig streng: skal matche mnsteret ${v.pattern}`;
        return `Ugyldig ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal vre deleligt med ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Ukendte ngler" : "Ukendt ngle"}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig ngle i ${n.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig vrdi i ${n.origin}`;
      default:
        return "Ugyldigt input";
    }
  };
};
function xt() {
  return { localeError: e4() };
}
var l4 = () => {
  let r = { string: { unit: "Zeichen", verb: "zu haben" }, file: { unit: "Bytes", verb: "zu haben" }, array: { unit: "Elemente", verb: "zu haben" }, set: { unit: "Elemente", verb: "zu haben" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "Eingabe", email: "E-Mail-Adresse", url: "URL", emoji: "Emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-Datum und -Uhrzeit", date: "ISO-Datum", time: "ISO-Uhrzeit", duration: "ISO-Dauer", ipv4: "IPv4-Adresse", ipv6: "IPv6-Adresse", cidrv4: "IPv4-Bereich", cidrv6: "IPv6-Bereich", base64: "Base64-codierter String", base64url: "Base64-URL-codierter String", json_string: "JSON-String", e164: "E.164-Nummer", jwt: "JWT", template_literal: "Eingabe" }, t = { nan: "NaN", number: "Zahl", array: "Array" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Ungltige Eingabe: erwartet instanceof ${n.expected}, erhalten ${$}`;
        return `Ungltige Eingabe: erwartet ${v}, erhalten ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Ungltige Eingabe: erwartet ${U(n.values[0])}`;
        return `Ungltige Option: erwartet eine von ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `Zu gro: erwartet, dass ${n.origin ?? "Wert"} ${v}${n.maximum.toString()} ${u.unit ?? "Elemente"} hat`;
        return `Zu gro: erwartet, dass ${n.origin ?? "Wert"} ${v}${n.maximum.toString()} ist`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `Zu klein: erwartet, dass ${n.origin} ${v}${n.minimum.toString()} ${u.unit} hat`;
        return `Zu klein: erwartet, dass ${n.origin} ${v}${n.minimum.toString()} ist`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Ungltiger String: muss mit "${v.prefix}" beginnen`;
        if (v.format === "ends_with") return `Ungltiger String: muss mit "${v.suffix}" enden`;
        if (v.format === "includes") return `Ungltiger String: muss "${v.includes}" enthalten`;
        if (v.format === "regex") return `Ungltiger String: muss dem Muster ${v.pattern} entsprechen`;
        return `Ungltig: ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ungltige Zahl: muss ein Vielfaches von ${n.divisor} sein`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Ungltiger Schlssel in ${n.origin}`;
      case "invalid_union":
        return "Ungltige Eingabe";
      case "invalid_element":
        return `Ungltiger Wert in ${n.origin}`;
      default:
        return "Ungltige Eingabe";
    }
  };
};
function Zt() {
  return { localeError: l4() };
}
var c4 = () => {
  let r = { string: { unit: "characters", verb: "to have" }, file: { unit: "bytes", verb: "to have" }, array: { unit: "items", verb: "to have" }, set: { unit: "items", verb: "to have" }, map: { unit: "entries", verb: "to have" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", mac: "MAC address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        return `Invalid input: expected ${v}, received ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Invalid input: expected ${U(n.values[0])}`;
        return `Invalid option: expected one of ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `Too big: expected ${n.origin ?? "value"} to have ${v}${n.maximum.toString()} ${u.unit ?? "elements"}`;
        return `Too big: expected ${n.origin ?? "value"} to be ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `Too small: expected ${n.origin} to have ${v}${n.minimum.toString()} ${u.unit}`;
        return `Too small: expected ${n.origin} to be ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Invalid string: must start with "${v.prefix}"`;
        if (v.format === "ends_with") return `Invalid string: must end with "${v.suffix}"`;
        if (v.format === "includes") return `Invalid string: must include "${v.includes}"`;
        if (v.format === "regex") return `Invalid string: must match pattern ${v.pattern}`;
        return `Invalid ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${n.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${n.keys.length > 1 ? "s" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${n.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${n.origin}`;
      default:
        return "Invalid input";
    }
  };
};
function kn() {
  return { localeError: c4() };
}
var I4 = () => {
  let r = { string: { unit: "karaktrojn", verb: "havi" }, file: { unit: "bajtojn", verb: "havi" }, array: { unit: "elementojn", verb: "havi" }, set: { unit: "elementojn", verb: "havi" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "enigo", email: "retadreso", url: "URL", emoji: "emoio", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datotempo", date: "ISO-dato", time: "ISO-tempo", duration: "ISO-daro", ipv4: "IPv4-adreso", ipv6: "IPv6-adreso", cidrv4: "IPv4-rango", cidrv6: "IPv6-rango", base64: "64-ume kodita karaktraro", base64url: "URL-64-ume kodita karaktraro", json_string: "JSON-karaktraro", e164: "E.164-nombro", jwt: "JWT", template_literal: "enigo" }, t = { nan: "NaN", number: "nombro", array: "tabelo", null: "senvalora" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Nevalida enigo: atendiis instanceof ${n.expected}, riceviis ${$}`;
        return `Nevalida enigo: atendiis ${v}, riceviis ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Nevalida enigo: atendiis ${U(n.values[0])}`;
        return `Nevalida opcio: atendiis unu el ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `Tro granda: atendiis ke ${n.origin ?? "valoro"} havu ${v}${n.maximum.toString()} ${u.unit ?? "elementojn"}`;
        return `Tro granda: atendiis ke ${n.origin ?? "valoro"} havu ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `Tro malgranda: atendiis ke ${n.origin} havu ${v}${n.minimum.toString()} ${u.unit}`;
        return `Tro malgranda: atendiis ke ${n.origin} estu ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Nevalida karaktraro: devas komencii per "${v.prefix}"`;
        if (v.format === "ends_with") return `Nevalida karaktraro: devas finii per "${v.suffix}"`;
        if (v.format === "includes") return `Nevalida karaktraro: devas inkluzivi "${v.includes}"`;
        if (v.format === "regex") return `Nevalida karaktraro: devas kongrui kun la modelo ${v.pattern}`;
        return `Nevalida ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${n.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${n.keys.length > 1 ? "j" : ""} losilo${n.keys.length > 1 ? "j" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida losilo en ${n.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${n.origin}`;
      default:
        return "Nevalida enigo";
    }
  };
};
function dt() {
  return { localeError: I4() };
}
var b4 = () => {
  let r = { string: { unit: "caracteres", verb: "tener" }, file: { unit: "bytes", verb: "tener" }, array: { unit: "elementos", verb: "tener" }, set: { unit: "elementos", verb: "tener" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "entrada", email: "direccin de correo electrnico", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "fecha y hora ISO", date: "fecha ISO", time: "hora ISO", duration: "duracin ISO", ipv4: "direccin IPv4", ipv6: "direccin IPv6", cidrv4: "rango IPv4", cidrv6: "rango IPv6", base64: "cadena codificada en base64", base64url: "URL codificada en base64", json_string: "cadena JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" }, t = { nan: "NaN", string: "texto", number: "nmero", boolean: "booleano", array: "arreglo", object: "objeto", set: "conjunto", file: "archivo", date: "fecha", bigint: "nmero grande", symbol: "smbolo", undefined: "indefinido", null: "nulo", function: "funcin", map: "mapa", record: "registro", tuple: "tupla", enum: "enumeracin", union: "unin", literal: "literal", promise: "promesa", void: "vaco", never: "nunca", unknown: "desconocido", any: "cualquiera" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Entrada invlida: se esperaba instanceof ${n.expected}, recibido ${$}`;
        return `Entrada invlida: se esperaba ${v}, recibido ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Entrada invlida: se esperaba ${U(n.values[0])}`;
        return `Opcin invlida: se esperaba una de ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin), $ = t[n.origin] ?? n.origin;
        if (u) return `Demasiado grande: se esperaba que ${$ ?? "valor"} tuviera ${v}${n.maximum.toString()} ${u.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${$ ?? "valor"} fuera ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin), $ = t[n.origin] ?? n.origin;
        if (u) return `Demasiado pequeo: se esperaba que ${$} tuviera ${v}${n.minimum.toString()} ${u.unit}`;
        return `Demasiado pequeo: se esperaba que ${$} fuera ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Cadena invlida: debe comenzar con "${v.prefix}"`;
        if (v.format === "ends_with") return `Cadena invlida: debe terminar en "${v.suffix}"`;
        if (v.format === "includes") return `Cadena invlida: debe incluir "${v.includes}"`;
        if (v.format === "regex") return `Cadena invlida: debe coincidir con el patrn ${v.pattern}`;
        return `Invlido ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlido: debe ser mltiplo de ${n.divisor}`;
      case "unrecognized_keys":
        return `Llave${n.keys.length > 1 ? "s" : ""} desconocida${n.keys.length > 1 ? "s" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Llave invlida en ${t[n.origin] ?? n.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido en ${t[n.origin] ?? n.origin}`;
      default:
        return "Entrada invlida";
    }
  };
};
function Ct() {
  return { localeError: b4() };
}
var _4 = () => {
  let r = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "", email: " ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ", date: " ", time: " ", duration: "  ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return ` :  instanceof ${n.expected}  ${$}  `;
        return ` :  ${v}  ${$}  `;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` :  ${U(n.values[0])} `;
        return ` :    ${b(n.values, "|")} `;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return ` : ${n.origin ?? ""}  ${v}${n.maximum.toString()} ${u.unit ?? ""} `;
        return ` : ${n.origin ?? ""}  ${v}${n.maximum.toString()} `;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return ` : ${n.origin}  ${v}${n.minimum.toString()} ${u.unit} `;
        return ` : ${n.origin}  ${v}${n.minimum.toString()} `;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` :   "${v.prefix}"  `;
        if (v.format === "ends_with") return ` :   "${v.suffix}"  `;
        if (v.format === "includes") return ` :   "${v.includes}" `;
        if (v.format === "regex") return ` :    ${v.pattern}   `;
        return `${o[v.format] ?? n.format} `;
      }
      case "not_multiple_of":
        return ` :   ${n.divisor} `;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "" : ""} : ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${n.origin}`;
      default:
        return " ";
    }
  };
};
function ft() {
  return { localeError: _4() };
}
var U4 = () => {
  let r = { string: { unit: "merkki", subject: "merkkijonon" }, file: { unit: "tavua", subject: "tiedoston" }, array: { unit: "alkiota", subject: "listan" }, set: { unit: "alkiota", subject: "joukon" }, number: { unit: "", subject: "luvun" }, bigint: { unit: "", subject: "suuren kokonaisluvun" }, int: { unit: "", subject: "kokonaisluvun" }, date: { unit: "", subject: "pivmrn" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "snnllinen lauseke", email: "shkpostiosoite", url: "URL-osoite", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-aikaleima", date: "ISO-pivmr", time: "ISO-aika", duration: "ISO-kesto", ipv4: "IPv4-osoite", ipv6: "IPv6-osoite", cidrv4: "IPv4-alue", cidrv6: "IPv6-alue", base64: "base64-koodattu merkkijono", base64url: "base64url-koodattu merkkijono", json_string: "JSON-merkkijono", e164: "E.164-luku", jwt: "JWT", template_literal: "templaattimerkkijono" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Virheellinen tyyppi: odotettiin instanceof ${n.expected}, oli ${$}`;
        return `Virheellinen tyyppi: odotettiin ${v}, oli ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Virheellinen syte: tytyy olla ${U(n.values[0])}`;
        return `Virheellinen valinta: tytyy olla yksi seuraavista: ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `Liian suuri: ${u.subject} tytyy olla ${v}${n.maximum.toString()} ${u.unit}`.trim();
        return `Liian suuri: arvon tytyy olla ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `Liian pieni: ${u.subject} tytyy olla ${v}${n.minimum.toString()} ${u.unit}`.trim();
        return `Liian pieni: arvon tytyy olla ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Virheellinen syte: tytyy alkaa "${v.prefix}"`;
        if (v.format === "ends_with") return `Virheellinen syte: tytyy loppua "${v.suffix}"`;
        if (v.format === "includes") return `Virheellinen syte: tytyy sislt "${v.includes}"`;
        if (v.format === "regex") return `Virheellinen syte: tytyy vastata snnllist lauseketta ${v.pattern}`;
        return `Virheellinen ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: tytyy olla luvun ${n.divisor} monikerta`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return "Virheellinen syte";
    }
  };
};
function ht() {
  return { localeError: U4() };
}
var k4 = () => {
  let r = { string: { unit: "caractres", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "lments", verb: "avoir" }, set: { unit: "lments", verb: "avoir" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "entre", email: "adresse e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date et heure ISO", date: "date ISO", time: "heure ISO", duration: "dure ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chane encode en base64", base64url: "chane encode en base64url", json_string: "chane JSON", e164: "numro E.164", jwt: "JWT", template_literal: "entre" }, t = { nan: "NaN", number: "nombre", array: "tableau" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Entre invalide : instanceof ${n.expected} attendu, ${$} reu`;
        return `Entre invalide : ${v} attendu, ${$} reu`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Entre invalide : ${U(n.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${b(n.values, "|")} attendue`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `Trop grand : ${n.origin ?? "valeur"} doit ${u.verb} ${v}${n.maximum.toString()} ${u.unit ?? "lment(s)"}`;
        return `Trop grand : ${n.origin ?? "valeur"} doit tre ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `Trop petit : ${n.origin} doit ${u.verb} ${v}${n.minimum.toString()} ${u.unit}`;
        return `Trop petit : ${n.origin} doit tre ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Chane invalide : doit commencer par "${v.prefix}"`;
        if (v.format === "ends_with") return `Chane invalide : doit se terminer par "${v.suffix}"`;
        if (v.format === "includes") return `Chane invalide : doit inclure "${v.includes}"`;
        if (v.format === "regex") return `Chane invalide : doit correspondre au modle ${v.pattern}`;
        return `${o[v.format] ?? n.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${n.divisor}`;
      case "unrecognized_keys":
        return `Cl${n.keys.length > 1 ? "s" : ""} non reconnue${n.keys.length > 1 ? "s" : ""} : ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${n.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${n.origin}`;
      default:
        return "Entre invalide";
    }
  };
};
function yt() {
  return { localeError: k4() };
}
var D4 = () => {
  let r = { string: { unit: "caractres", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "lments", verb: "avoir" }, set: { unit: "lments", verb: "avoir" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "entre", email: "adresse courriel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date-heure ISO", date: "date ISO", time: "heure ISO", duration: "dure ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chane encode en base64", base64url: "chane encode en base64url", json_string: "chane JSON", e164: "numro E.164", jwt: "JWT", template_literal: "entre" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Entre invalide : attendu instanceof ${n.expected}, reu ${$}`;
        return `Entre invalide : attendu ${v}, reu ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Entre invalide : attendu ${U(n.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "" : "<", u = i(n.origin);
        if (u) return `Trop grand : attendu que ${n.origin ?? "la valeur"} ait ${v}${n.maximum.toString()} ${u.unit}`;
        return `Trop grand : attendu que ${n.origin ?? "la valeur"} soit ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? "" : ">", u = i(n.origin);
        if (u) return `Trop petit : attendu que ${n.origin} ait ${v}${n.minimum.toString()} ${u.unit}`;
        return `Trop petit : attendu que ${n.origin} soit ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Chane invalide : doit commencer par "${v.prefix}"`;
        if (v.format === "ends_with") return `Chane invalide : doit se terminer par "${v.suffix}"`;
        if (v.format === "includes") return `Chane invalide : doit inclure "${v.includes}"`;
        if (v.format === "regex") return `Chane invalide : doit correspondre au motif ${v.pattern}`;
        return `${o[v.format] ?? n.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${n.divisor}`;
      case "unrecognized_keys":
        return `Cl${n.keys.length > 1 ? "s" : ""} non reconnue${n.keys.length > 1 ? "s" : ""} : ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${n.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${n.origin}`;
      default:
        return "Entre invalide";
    }
  };
};
function at() {
  return { localeError: D4() };
}
var w4 = () => {
  let r = { string: { label: "", gender: "f" }, number: { label: "", gender: "m" }, boolean: { label: " ", gender: "m" }, bigint: { label: "BigInt", gender: "m" }, date: { label: "", gender: "m" }, array: { label: "", gender: "m" }, object: { label: "", gender: "m" }, null: { label: "  (null)", gender: "m" }, undefined: { label: "   (undefined)", gender: "m" }, symbol: { label: " (Symbol)", gender: "m" }, function: { label: "", gender: "f" }, map: { label: " (Map)", gender: "f" }, set: { label: " (Set)", gender: "f" }, file: { label: "", gender: "m" }, promise: { label: "Promise", gender: "m" }, NaN: { label: "NaN", gender: "m" }, unknown: { label: "  ", gender: "m" }, value: { label: "", gender: "m" } }, i = { string: { unit: "", shortLabel: "", longLabel: "" }, file: { unit: "", shortLabel: "", longLabel: "" }, array: { unit: "", shortLabel: "", longLabel: "" }, set: { unit: "", shortLabel: "", longLabel: "" }, number: { unit: "", shortLabel: "", longLabel: "" } }, o = (e) => e ? r[e] : void 0, t = (e) => {
    let I = o(e);
    if (I) return I.label;
    return e ?? r.unknown.label;
  }, n = (e) => `${t(e)}`, v = (e) => {
    return (o(e)?.gender ?? "m") === "f" ? " " : " ";
  }, u = (e) => {
    if (!e) return null;
    return i[e] ?? null;
  }, $ = { regex: { label: "", gender: "m" }, email: { label: " ", gender: "f" }, url: { label: " ", gender: "f" }, emoji: { label: "'", gender: "m" }, uuid: { label: "UUID", gender: "m" }, nanoid: { label: "nanoid", gender: "m" }, guid: { label: "GUID", gender: "m" }, cuid: { label: "cuid", gender: "m" }, cuid2: { label: "cuid2", gender: "m" }, ulid: { label: "ULID", gender: "m" }, xid: { label: "XID", gender: "m" }, ksuid: { label: "KSUID", gender: "m" }, datetime: { label: "  ISO", gender: "m" }, date: { label: " ISO", gender: "m" }, time: { label: " ISO", gender: "m" }, duration: { label: "  ISO", gender: "m" }, ipv4: { label: " IPv4", gender: "f" }, ipv6: { label: " IPv6", gender: "f" }, cidrv4: { label: " IPv4", gender: "m" }, cidrv6: { label: " IPv6", gender: "m" }, base64: { label: "  64", gender: "f" }, base64url: { label: "  64  ", gender: "f" }, json_string: { label: " JSON", gender: "f" }, e164: { label: " E.164", gender: "m" }, jwt: { label: "JWT", gender: "m" }, ends_with: { label: "", gender: "m" }, includes: { label: "", gender: "m" }, lowercase: { label: "", gender: "m" }, starts_with: { label: "", gender: "m" }, uppercase: { label: "", gender: "m" } }, l = { nan: "NaN" };
  return (e) => {
    switch (e.code) {
      case "invalid_type": {
        let I = e.expected, _ = l[I ?? ""] ?? t(I), N = k(e.input), O = l[N] ?? r[N]?.label ?? N;
        if (/^[A-Z]/.test(e.expected)) return `  :   instanceof ${e.expected},  ${O}`;
        return `  :   ${_},  ${O}`;
      }
      case "invalid_value": {
        if (e.values.length === 1) return `  :    ${U(e.values[0])}`;
        let I = e.values.map((O) => U(O));
        if (e.values.length === 2) return `  :    ${I[0]}  ${I[1]}`;
        let _ = I[I.length - 1];
        return `  :    ${I.slice(0, -1).join(", ")}  ${_}`;
      }
      case "too_big": {
        let I = u(e.origin), _ = n(e.origin ?? "value");
        if (e.origin === "string") return `${I?.longLabel ?? ""} : ${_}   ${e.maximum.toString()} ${I?.unit ?? ""} ${e.inclusive ? " " : " "}`.trim();
        if (e.origin === "number") {
          let J = e.inclusive ? `   -${e.maximum}` : ` -${e.maximum}`;
          return ` : ${_}   ${J}`;
        }
        if (e.origin === "array" || e.origin === "set") {
          let J = e.origin === "set" ? "" : "", X = e.inclusive ? `${e.maximum} ${I?.unit ?? ""}  ` : ` -${e.maximum} ${I?.unit ?? ""}`;
          return ` : ${_} ${J}  ${X}`.trim();
        }
        let N = e.inclusive ? "<=" : "<", O = v(e.origin ?? "value");
        if (I?.unit) return `${I.longLabel} : ${_} ${O} ${N}${e.maximum.toString()} ${I.unit}`;
        return `${I?.longLabel ?? ""} : ${_} ${O} ${N}${e.maximum.toString()}`;
      }
      case "too_small": {
        let I = u(e.origin), _ = n(e.origin ?? "value");
        if (e.origin === "string") return `${I?.shortLabel ?? ""} : ${_}   ${e.minimum.toString()} ${I?.unit ?? ""} ${e.inclusive ? " " : ""}`.trim();
        if (e.origin === "number") {
          let J = e.inclusive ? `   -${e.minimum}` : ` -${e.minimum}`;
          return ` : ${_}   ${J}`;
        }
        if (e.origin === "array" || e.origin === "set") {
          let J = e.origin === "set" ? "" : "";
          if (e.minimum === 1 && e.inclusive) {
            let Sr = e.origin === "set" ? "  " : "  ";
            return ` : ${_} ${J}  ${Sr}`;
          }
          let X = e.inclusive ? `${e.minimum} ${I?.unit ?? ""}  ` : ` -${e.minimum} ${I?.unit ?? ""}`;
          return ` : ${_} ${J}  ${X}`.trim();
        }
        let N = e.inclusive ? ">=" : ">", O = v(e.origin ?? "value");
        if (I?.unit) return `${I.shortLabel} : ${_} ${O} ${N}${e.minimum.toString()} ${I.unit}`;
        return `${I?.shortLabel ?? ""} : ${_} ${O} ${N}${e.minimum.toString()}`;
      }
      case "invalid_format": {
        let I = e;
        if (I.format === "starts_with") return `    "${I.prefix}"`;
        if (I.format === "ends_with") return `    "${I.suffix}"`;
        if (I.format === "includes") return `   "${I.includes}"`;
        if (I.format === "regex") return `    ${I.pattern}`;
        let _ = $[I.format], N = _?.label ?? I.format, J = (_?.gender ?? "m") === "f" ? "" : "";
        return `${N}  ${J}`;
      }
      case "not_multiple_of":
        return `  :     ${e.divisor}`;
      case "unrecognized_keys":
        return `${e.keys.length > 1 ? "" : ""}  ${e.keys.length > 1 ? "" : ""}: ${b(e.keys, ", ")}`;
      case "invalid_key":
        return "   ";
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${n(e.origin ?? "array")}`;
      default:
        return "  ";
    }
  };
};
function pt() {
  return { localeError: w4() };
}
var N4 = () => {
  let r = { string: { unit: "karakter", verb: "legyen" }, file: { unit: "byte", verb: "legyen" }, array: { unit: "elem", verb: "legyen" }, set: { unit: "elem", verb: "legyen" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "bemenet", email: "email cm", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO idblyeg", date: "ISO dtum", time: "ISO id", duration: "ISO idintervallum", ipv4: "IPv4 cm", ipv6: "IPv6 cm", cidrv4: "IPv4 tartomny", cidrv6: "IPv6 tartomny", base64: "base64-kdolt string", base64url: "base64url-kdolt string", json_string: "JSON string", e164: "E.164 szm", jwt: "JWT", template_literal: "bemenet" }, t = { nan: "NaN", number: "szm", array: "tmb" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `rvnytelen bemenet: a vrt rtk instanceof ${n.expected}, a kapott rtk ${$}`;
        return `rvnytelen bemenet: a vrt rtk ${v}, a kapott rtk ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `rvnytelen bemenet: a vrt rtk ${U(n.values[0])}`;
        return `rvnytelen opci: valamelyik rtk vrt ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `Tl nagy: ${n.origin ?? "rtk"} mrete tl nagy ${v}${n.maximum.toString()} ${u.unit ?? "elem"}`;
        return `Tl nagy: a bemeneti rtk ${n.origin ?? "rtk"} tl nagy: ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `Tl kicsi: a bemeneti rtk ${n.origin} mrete tl kicsi ${v}${n.minimum.toString()} ${u.unit}`;
        return `Tl kicsi: a bemeneti rtk ${n.origin} tl kicsi ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `rvnytelen string: "${v.prefix}" rtkkel kell kezddnie`;
        if (v.format === "ends_with") return `rvnytelen string: "${v.suffix}" rtkkel kell vgzdnie`;
        if (v.format === "includes") return `rvnytelen string: "${v.includes}" rtket kell tartalmaznia`;
        if (v.format === "regex") return `rvnytelen string: ${v.pattern} mintnak kell megfelelnie`;
        return `rvnytelen ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `rvnytelen szm: ${n.divisor} tbbszrsnek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${n.keys.length > 1 ? "s" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `rvnytelen kulcs ${n.origin}`;
      case "invalid_union":
        return "rvnytelen bemenet";
      case "invalid_element":
        return `rvnytelen rtk: ${n.origin}`;
      default:
        return "rvnytelen bemenet";
    }
  };
};
function st() {
  return { localeError: N4() };
}
function se(r, i, o) {
  return Math.abs(r) === 1 ? i : o;
}
function Xr(r) {
  if (!r) return "";
  let i = ["", "", "", "", "", "", ""], o = r[r.length - 1];
  return r + (i.includes(o) ? "" : "");
}
var O4 = () => {
  let r = { string: { unit: { one: "", many: "" }, verb: "" }, file: { unit: { one: "", many: "" }, verb: "" }, array: { unit: { one: "", many: "" }, verb: "" }, set: { unit: { one: "", many: "" }, verb: "" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "", email: ". ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64  ", base64url: "base64url  ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `    instanceof ${n.expected},   ${$}`;
        return `    ${v},   ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `    ${U(n.values[1])}`;
        return `      ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) {
          let $ = Number(n.maximum), l = se($, u.unit.one, u.unit.many);
          return `    ,  ${Xr(n.origin ?? "")}  ${v}${n.maximum.toString()} ${l}`;
        }
        return `    ,  ${Xr(n.origin ?? "")}  ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) {
          let $ = Number(n.minimum), l = se($, u.unit.one, u.unit.many);
          return `    ,  ${Xr(n.origin)}  ${v}${n.minimum.toString()} ${l}`;
        }
        return `    ,  ${Xr(n.origin)}  ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `     "${v.prefix}"-`;
        if (v.format === "ends_with") return `     "${v.suffix}"-`;
        if (v.format === "includes") return `     "${v.includes}"`;
        if (v.format === "regex") return `     ${v.pattern} `;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `      ${n.divisor}-`;
      case "unrecognized_keys":
        return ` ${n.keys.length > 1 ? "" : ""}. ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `  ${Xr(n.origin)}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${Xr(n.origin)}-`;
      default:
        return " ";
    }
  };
};
function ru() {
  return { localeError: O4() };
}
var S4 = () => {
  let r = { string: { unit: "karakter", verb: "memiliki" }, file: { unit: "byte", verb: "memiliki" }, array: { unit: "item", verb: "memiliki" }, set: { unit: "item", verb: "memiliki" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "input", email: "alamat email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tanggal dan waktu format ISO", date: "tanggal format ISO", time: "jam format ISO", duration: "durasi format ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "rentang alamat IPv4", cidrv6: "rentang alamat IPv6", base64: "string dengan enkode base64", base64url: "string dengan enkode base64url", json_string: "string JSON", e164: "angka E.164", jwt: "JWT", template_literal: "input" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Input tidak valid: diharapkan instanceof ${n.expected}, diterima ${$}`;
        return `Input tidak valid: diharapkan ${v}, diterima ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Input tidak valid: diharapkan ${U(n.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `Terlalu besar: diharapkan ${n.origin ?? "value"} memiliki ${v}${n.maximum.toString()} ${u.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${n.origin ?? "value"} menjadi ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `Terlalu kecil: diharapkan ${n.origin} memiliki ${v}${n.minimum.toString()} ${u.unit}`;
        return `Terlalu kecil: diharapkan ${n.origin} menjadi ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `String tidak valid: harus dimulai dengan "${v.prefix}"`;
        if (v.format === "ends_with") return `String tidak valid: harus berakhir dengan "${v.suffix}"`;
        if (v.format === "includes") return `String tidak valid: harus menyertakan "${v.includes}"`;
        if (v.format === "regex") return `String tidak valid: harus sesuai pola ${v.pattern}`;
        return `${o[v.format] ?? n.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${n.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${n.keys.length > 1 ? "s" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${n.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${n.origin}`;
      default:
        return "Input tidak valid";
    }
  };
};
function nu() {
  return { localeError: S4() };
}
var z4 = () => {
  let r = { string: { unit: "stafi", verb: "a hafa" }, file: { unit: "bti", verb: "a hafa" }, array: { unit: "hluti", verb: "a hafa" }, set: { unit: "hluti", verb: "a hafa" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "gildi", email: "netfang", url: "vefsl", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dagsetning og tmi", date: "ISO dagsetning", time: "ISO tmi", duration: "ISO tmalengd", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded strengur", base64url: "base64url-encoded strengur", json_string: "JSON strengur", e164: "E.164 tlugildi", jwt: "JWT", template_literal: "gildi" }, t = { nan: "NaN", number: "nmer", array: "fylki" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Rangt gildi:  slst inn ${$} ar sem  a vera instanceof ${n.expected}`;
        return `Rangt gildi:  slst inn ${$} ar sem  a vera ${v}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Rangt gildi: gert r fyrir ${U(n.values[0])}`;
        return `gilt val: m vera eitt af eftirfarandi ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `Of strt: gert er r fyrir a ${n.origin ?? "gildi"} hafi ${v}${n.maximum.toString()} ${u.unit ?? "hluti"}`;
        return `Of strt: gert er r fyrir a ${n.origin ?? "gildi"} s ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `Of lti: gert er r fyrir a ${n.origin} hafi ${v}${n.minimum.toString()} ${u.unit}`;
        return `Of lti: gert er r fyrir a ${n.origin} s ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `gildur strengur: verur a byrja  "${v.prefix}"`;
        if (v.format === "ends_with") return `gildur strengur: verur a enda  "${v.suffix}"`;
        if (v.format === "includes") return `gildur strengur: verur a innihalda "${v.includes}"`;
        if (v.format === "regex") return `gildur strengur: verur a fylgja mynstri ${v.pattern}`;
        return `Rangt ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Rng tala: verur a vera margfeldi af ${n.divisor}`;
      case "unrecognized_keys":
        return `ekkt ${n.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill  ${n.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi  ${n.origin}`;
      default:
        return "Rangt gildi";
    }
  };
};
function iu() {
  return { localeError: z4() };
}
var P4 = () => {
  let r = { string: { unit: "caratteri", verb: "avere" }, file: { unit: "byte", verb: "avere" }, array: { unit: "elementi", verb: "avere" }, set: { unit: "elementi", verb: "avere" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "input", email: "indirizzo email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e ora ISO", date: "data ISO", time: "ora ISO", duration: "durata ISO", ipv4: "indirizzo IPv4", ipv6: "indirizzo IPv6", cidrv4: "intervallo IPv4", cidrv6: "intervallo IPv6", base64: "stringa codificata in base64", base64url: "URL codificata in base64", json_string: "stringa JSON", e164: "numero E.164", jwt: "JWT", template_literal: "input" }, t = { nan: "NaN", number: "numero", array: "vettore" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Input non valido: atteso instanceof ${n.expected}, ricevuto ${$}`;
        return `Input non valido: atteso ${v}, ricevuto ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Input non valido: atteso ${U(n.values[0])}`;
        return `Opzione non valida: atteso uno tra ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `Troppo grande: ${n.origin ?? "valore"} deve avere ${v}${n.maximum.toString()} ${u.unit ?? "elementi"}`;
        return `Troppo grande: ${n.origin ?? "valore"} deve essere ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `Troppo piccolo: ${n.origin} deve avere ${v}${n.minimum.toString()} ${u.unit}`;
        return `Troppo piccolo: ${n.origin} deve essere ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Stringa non valida: deve iniziare con "${v.prefix}"`;
        if (v.format === "ends_with") return `Stringa non valida: deve terminare con "${v.suffix}"`;
        if (v.format === "includes") return `Stringa non valida: deve includere "${v.includes}"`;
        if (v.format === "regex") return `Stringa non valida: deve corrispondere al pattern ${v.pattern}`;
        return `Invalid ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${n.divisor}`;
      case "unrecognized_keys":
        return `Chiav${n.keys.length > 1 ? "i" : "e"} non riconosciut${n.keys.length > 1 ? "e" : "a"}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${n.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${n.origin}`;
      default:
        return "Input non valido";
    }
  };
};
function vu() {
  return { localeError: P4() };
}
var j4 = () => {
  let r = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO", date: "ISO", time: "ISO", duration: "ISO", ipv4: "IPv4", ipv6: "IPv6", cidrv4: "IPv4", cidrv6: "IPv6", base64: "base64", base64url: "base64url", json_string: "JSON", e164: "E.164", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `: instanceof ${n.expected}${$}`;
        return `: ${v}${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `: ${U(n.values[0])}`;
        return `: ${b(n.values, "")}`;
      case "too_big": {
        let v = n.inclusive ? "" : "", u = i(n.origin);
        if (u) return `: ${n.origin ?? ""}${n.maximum.toString()}${u.unit ?? ""}${v}`;
        return `: ${n.origin ?? ""}${n.maximum.toString()}${v}`;
      }
      case "too_small": {
        let v = n.inclusive ? "" : "", u = i(n.origin);
        if (u) return `: ${n.origin}${n.minimum.toString()}${u.unit}${v}`;
        return `: ${n.origin}${n.minimum.toString()}${v}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `: "${v.prefix}"`;
        if (v.format === "ends_with") return `: "${v.suffix}"`;
        if (v.format === "includes") return `: "${v.includes}"`;
        if (v.format === "regex") return `: ${v.pattern}`;
        return `${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `: ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "" : ""}: ${b(n.keys, "")}`;
      case "invalid_key":
        return `${n.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${n.origin}`;
      default:
        return "";
    }
  };
};
function ou() {
  return { localeError: j4() };
}
var J4 = () => {
  let r = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "", email: "- ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "-", date: "", time: "", duration: "", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64- ", base64url: "base64url- ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", string: "", boolean: "", function: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return ` :  instanceof ${n.expected},  ${$}`;
        return ` :  ${v},  ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` :  ${U(n.values[0])}`;
        return ` :  - ${b(n.values, "|")}-`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return ` :  ${n.origin ?? ""} ${u.verb} ${v}${n.maximum.toString()} ${u.unit}`;
        return ` :  ${n.origin ?? ""}  ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return ` :  ${n.origin} ${u.verb} ${v}${n.minimum.toString()} ${u.unit}`;
        return ` :  ${n.origin}  ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` :   "${v.prefix}"-`;
        if (v.format === "ends_with") return ` :   "${v.suffix}"-`;
        if (v.format === "includes") return ` :   "${v.includes}"-`;
        if (v.format === "regex") return ` :    ${v.pattern}`;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` :   ${n.divisor}- `;
      case "unrecognized_keys":
        return ` ${n.keys.length > 1 ? "" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `  ${n.origin}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${n.origin}-`;
      default:
        return " ";
    }
  };
};
function tu() {
  return { localeError: J4() };
}
var L4 = () => {
  let r = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "  ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IPv4", cidrv6: " IPv6", base64: " base64", base64url: " base64url", json_string: " JSON", e164: " E.164", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: " (Array)", null: " (null)" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `  instanceof ${n.expected}  ${$}`;
        return `  ${v}  ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `  ${U(n.values[0])}`;
        return `  ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `  ${n.origin ?? ""} ${v} ${n.maximum.toString()} ${u.unit ?? ""}`;
        return `  ${n.origin ?? ""} ${v} ${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `  ${n.origin} ${v} ${n.minimum.toString()} ${u.unit}`;
        return `  ${n.origin} ${v} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `  "${v.prefix}"`;
        if (v.format === "ends_with") return `  "${v.suffix}"`;
        if (v.format === "includes") return `  "${v.includes}"`;
        if (v.format === "regex") return `  ${v.pattern}`;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `  ${n.divisor}`;
      case "unrecognized_keys":
        return ` ${b(n.keys, ", ")}`;
      case "invalid_key":
        return ` ${n.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return ` ${n.origin}`;
      default:
        return "";
    }
  };
};
function Dn() {
  return { localeError: L4() };
}
function uu() {
  return Dn();
}
var E4 = () => {
  let r = { string: { unit: "", verb: "to have" }, file: { unit: "", verb: "to have" }, array: { unit: "", verb: "to have" }, set: { unit: "", verb: "to have" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "", email: " ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64  ", base64url: "base64url  ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return ` :   instanceof ${n.expected},   ${$}`;
        return ` :   ${v},   ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` :  ${U(n.values[0])}  `;
        return ` : ${b(n.values, " ")}   `;
      case "too_big": {
        let v = n.inclusive ? "" : "", u = v === "" ? " " : " ", $ = i(n.origin), l = $?.unit ?? "";
        if ($) return `${n.origin ?? ""}  : ${n.maximum.toString()}${l} ${v}${u}`;
        return `${n.origin ?? ""}  : ${n.maximum.toString()} ${v}${u}`;
      }
      case "too_small": {
        let v = n.inclusive ? "" : "", u = v === "" ? " " : " ", $ = i(n.origin), l = $?.unit ?? "";
        if ($) return `${n.origin ?? ""}  : ${n.minimum.toString()}${l} ${v}${u}`;
        return `${n.origin ?? ""}  : ${n.minimum.toString()} ${v}${u}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` : "${v.prefix}"()  `;
        if (v.format === "ends_with") return ` : "${v.suffix}"()  `;
        if (v.format === "includes") return ` : "${v.includes}"()  `;
        if (v.format === "regex") return ` :  ${v.pattern}   `;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` : ${n.divisor}  `;
      case "unrecognized_keys":
        return `   : ${b(n.keys, ", ")}`;
      case "invalid_key":
        return ` : ${n.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return ` : ${n.origin}`;
      default:
        return " ";
    }
  };
};
function $u() {
  return { localeError: E4() };
}
var wn = (r) => {
  return r.charAt(0).toUpperCase() + r.slice(1);
};
function rl(r) {
  let i = Math.abs(r), o = i % 10, t = i % 100;
  if (t >= 11 && t <= 19 || o === 0) return "many";
  if (o === 1) return "one";
  return "few";
}
var G4 = () => {
  let r = { string: { unit: { one: "simbolis", few: "simboliai", many: "simboli" }, verb: { smaller: { inclusive: "turi bti ne ilgesn kaip", notInclusive: "turi bti trumpesn kaip" }, bigger: { inclusive: "turi bti ne trumpesn kaip", notInclusive: "turi bti ilgesn kaip" } } }, file: { unit: { one: "baitas", few: "baitai", many: "bait" }, verb: { smaller: { inclusive: "turi bti ne didesnis kaip", notInclusive: "turi bti maesnis kaip" }, bigger: { inclusive: "turi bti ne maesnis kaip", notInclusive: "turi bti didesnis kaip" } } }, array: { unit: { one: "element", few: "elementus", many: "element" }, verb: { smaller: { inclusive: "turi turti ne daugiau kaip", notInclusive: "turi turti maiau kaip" }, bigger: { inclusive: "turi turti ne maiau kaip", notInclusive: "turi turti daugiau kaip" } } }, set: { unit: { one: "element", few: "elementus", many: "element" }, verb: { smaller: { inclusive: "turi turti ne daugiau kaip", notInclusive: "turi turti maiau kaip" }, bigger: { inclusive: "turi turti ne maiau kaip", notInclusive: "turi turti daugiau kaip" } } } };
  function i(n, v, u, $) {
    let l = r[n] ?? null;
    if (l === null) return l;
    return { unit: l.unit[v], verb: l.verb[$][u ? "inclusive" : "notInclusive"] };
  }
  let o = { regex: "vestis", email: "el. pato adresas", url: "URL", emoji: "jaustukas", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO data ir laikas", date: "ISO data", time: "ISO laikas", duration: "ISO trukm", ipv4: "IPv4 adresas", ipv6: "IPv6 adresas", cidrv4: "IPv4 tinklo prefiksas (CIDR)", cidrv6: "IPv6 tinklo prefiksas (CIDR)", base64: "base64 ukoduota eilut", base64url: "base64url ukoduota eilut", json_string: "JSON eilut", e164: "E.164 numeris", jwt: "JWT", template_literal: "vestis" }, t = { nan: "NaN", number: "skaiius", bigint: "sveikasis skaiius", string: "eilut", boolean: "login reikm", undefined: "neapibrta reikm", function: "funkcija", symbol: "simbolis", array: "masyvas", object: "objektas", null: "nulin reikm" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Gautas tipas ${$}, o tiktasi - instanceof ${n.expected}`;
        return `Gautas tipas ${$}, o tiktasi - ${v}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Privalo bti ${U(n.values[0])}`;
        return `Privalo bti vienas i ${b(n.values, "|")} pasirinkim`;
      case "too_big": {
        let v = t[n.origin] ?? n.origin, u = i(n.origin, rl(Number(n.maximum)), n.inclusive ?? false, "smaller");
        if (u?.verb) return `${wn(v ?? n.origin ?? "reikm")} ${u.verb} ${n.maximum.toString()} ${u.unit ?? "element"}`;
        let $ = n.inclusive ? "ne didesnis kaip" : "maesnis kaip";
        return `${wn(v ?? n.origin ?? "reikm")} turi bti ${$} ${n.maximum.toString()} ${u?.unit}`;
      }
      case "too_small": {
        let v = t[n.origin] ?? n.origin, u = i(n.origin, rl(Number(n.minimum)), n.inclusive ?? false, "bigger");
        if (u?.verb) return `${wn(v ?? n.origin ?? "reikm")} ${u.verb} ${n.minimum.toString()} ${u.unit ?? "element"}`;
        let $ = n.inclusive ? "ne maesnis kaip" : "didesnis kaip";
        return `${wn(v ?? n.origin ?? "reikm")} turi bti ${$} ${n.minimum.toString()} ${u?.unit}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Eilut privalo prasidti "${v.prefix}"`;
        if (v.format === "ends_with") return `Eilut privalo pasibaigti "${v.suffix}"`;
        if (v.format === "includes") return `Eilut privalo traukti "${v.includes}"`;
        if (v.format === "regex") return `Eilut privalo atitikti ${v.pattern}`;
        return `Neteisingas ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Skaiius privalo bti ${n.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpaint${n.keys.length > 1 ? "i" : "as"} rakt${n.keys.length > 1 ? "ai" : "as"}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga vestis";
      case "invalid_element": {
        let v = t[n.origin] ?? n.origin;
        return `${wn(v ?? n.origin ?? "reikm")} turi klaiding vest`;
      }
      default:
        return "Klaidinga vestis";
    }
  };
};
function gu() {
  return { localeError: G4() };
}
var W4 = () => {
  let r = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "", email: "  -", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64- ", base64url: "base64url- ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return ` :   instanceof ${n.expected},  ${$}`;
        return ` :   ${v},  ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Invalid input: expected ${U(n.values[0])}`;
        return ` :    ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return ` :   ${n.origin ?? ""}   ${v}${n.maximum.toString()} ${u.unit ?? ""}`;
        return ` :   ${n.origin ?? ""}   ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return ` :   ${n.origin}   ${v}${n.minimum.toString()} ${u.unit}`;
        return ` :   ${n.origin}   ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` :     "${v.prefix}"`;
        if (v.format === "ends_with") return ` :     "${v.suffix}"`;
        if (v.format === "includes") return ` :    "${v.includes}"`;
        if (v.format === "regex") return ` :      ${v.pattern}`;
        return `Invalid ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` :      ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? " " : " "}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${n.origin}`;
      default:
        return " ";
    }
  };
};
function eu() {
  return { localeError: W4() };
}
var X4 = () => {
  let r = { string: { unit: "aksara", verb: "mempunyai" }, file: { unit: "bait", verb: "mempunyai" }, array: { unit: "elemen", verb: "mempunyai" }, set: { unit: "elemen", verb: "mempunyai" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "input", email: "alamat e-mel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tarikh masa ISO", date: "tarikh ISO", time: "masa ISO", duration: "tempoh ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "julat IPv4", cidrv6: "julat IPv6", base64: "string dikodkan base64", base64url: "string dikodkan base64url", json_string: "string JSON", e164: "nombor E.164", jwt: "JWT", template_literal: "input" }, t = { nan: "NaN", number: "nombor" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Input tidak sah: dijangka instanceof ${n.expected}, diterima ${$}`;
        return `Input tidak sah: dijangka ${v}, diterima ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Input tidak sah: dijangka ${U(n.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `Terlalu besar: dijangka ${n.origin ?? "nilai"} ${u.verb} ${v}${n.maximum.toString()} ${u.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${n.origin ?? "nilai"} adalah ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `Terlalu kecil: dijangka ${n.origin} ${u.verb} ${v}${n.minimum.toString()} ${u.unit}`;
        return `Terlalu kecil: dijangka ${n.origin} adalah ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `String tidak sah: mesti bermula dengan "${v.prefix}"`;
        if (v.format === "ends_with") return `String tidak sah: mesti berakhir dengan "${v.suffix}"`;
        if (v.format === "includes") return `String tidak sah: mesti mengandungi "${v.includes}"`;
        if (v.format === "regex") return `String tidak sah: mesti sepadan dengan corak ${v.pattern}`;
        return `${o[v.format] ?? n.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${n.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${n.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${n.origin}`;
      default:
        return "Input tidak sah";
    }
  };
};
function lu() {
  return { localeError: X4() };
}
var V4 = () => {
  let r = { string: { unit: "tekens", verb: "heeft" }, file: { unit: "bytes", verb: "heeft" }, array: { unit: "elementen", verb: "heeft" }, set: { unit: "elementen", verb: "heeft" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "invoer", email: "emailadres", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum en tijd", date: "ISO datum", time: "ISO tijd", duration: "ISO duur", ipv4: "IPv4-adres", ipv6: "IPv6-adres", cidrv4: "IPv4-bereik", cidrv6: "IPv6-bereik", base64: "base64-gecodeerde tekst", base64url: "base64 URL-gecodeerde tekst", json_string: "JSON string", e164: "E.164-nummer", jwt: "JWT", template_literal: "invoer" }, t = { nan: "NaN", number: "getal" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Ongeldige invoer: verwacht instanceof ${n.expected}, ontving ${$}`;
        return `Ongeldige invoer: verwacht ${v}, ontving ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Ongeldige invoer: verwacht ${U(n.values[0])}`;
        return `Ongeldige optie: verwacht n van ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin), $ = n.origin === "date" ? "laat" : n.origin === "string" ? "lang" : "groot";
        if (u) return `Te ${$}: verwacht dat ${n.origin ?? "waarde"} ${v}${n.maximum.toString()} ${u.unit ?? "elementen"} ${u.verb}`;
        return `Te ${$}: verwacht dat ${n.origin ?? "waarde"} ${v}${n.maximum.toString()} is`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin), $ = n.origin === "date" ? "vroeg" : n.origin === "string" ? "kort" : "klein";
        if (u) return `Te ${$}: verwacht dat ${n.origin} ${v}${n.minimum.toString()} ${u.unit} ${u.verb}`;
        return `Te ${$}: verwacht dat ${n.origin} ${v}${n.minimum.toString()} is`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Ongeldige tekst: moet met "${v.prefix}" beginnen`;
        if (v.format === "ends_with") return `Ongeldige tekst: moet op "${v.suffix}" eindigen`;
        if (v.format === "includes") return `Ongeldige tekst: moet "${v.includes}" bevatten`;
        if (v.format === "regex") return `Ongeldige tekst: moet overeenkomen met patroon ${v.pattern}`;
        return `Ongeldig: ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${n.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${n.keys.length > 1 ? "s" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${n.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${n.origin}`;
      default:
        return "Ongeldige invoer";
    }
  };
};
function cu() {
  return { localeError: V4() };
}
var A4 = () => {
  let r = { string: { unit: "tegn", verb: " ha" }, file: { unit: "bytes", verb: " ha" }, array: { unit: "elementer", verb: " inneholde" }, set: { unit: "elementer", verb: " inneholde" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "input", email: "e-postadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslett", date: "ISO-dato", time: "ISO-klokkeslett", duration: "ISO-varighet", ipv4: "IPv4-omrde", ipv6: "IPv6-omrde", cidrv4: "IPv4-spekter", cidrv6: "IPv6-spekter", base64: "base64-enkodet streng", base64url: "base64url-enkodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" }, t = { nan: "NaN", number: "tall", array: "liste" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Ugyldig input: forventet instanceof ${n.expected}, fikk ${$}`;
        return `Ugyldig input: forventet ${v}, fikk ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Ugyldig verdi: forventet ${U(n.values[0])}`;
        return `Ugyldig valg: forventet en av ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `For stor(t): forventet ${n.origin ?? "value"} til  ha ${v}${n.maximum.toString()} ${u.unit ?? "elementer"}`;
        return `For stor(t): forventet ${n.origin ?? "value"} til  ha ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `For lite(n): forventet ${n.origin} til  ha ${v}${n.minimum.toString()} ${u.unit}`;
        return `For lite(n): forventet ${n.origin} til  ha ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Ugyldig streng: m starte med "${v.prefix}"`;
        if (v.format === "ends_with") return `Ugyldig streng: m ende med "${v.suffix}"`;
        if (v.format === "includes") return `Ugyldig streng: m inneholde "${v.includes}"`;
        if (v.format === "regex") return `Ugyldig streng: m matche mnsteret ${v.pattern}`;
        return `Ugyldig ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m vre et multiplum av ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nkkel i ${n.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${n.origin}`;
      default:
        return "Ugyldig input";
    }
  };
};
function Iu() {
  return { localeError: A4() };
}
var K4 = () => {
  let r = { string: { unit: "harf", verb: "olmaldr" }, file: { unit: "bayt", verb: "olmaldr" }, array: { unit: "unsur", verb: "olmaldr" }, set: { unit: "unsur", verb: "olmaldr" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "giren", email: "epostagh", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO hengm", date: "ISO tarihi", time: "ISO zaman", duration: "ISO mddeti", ipv4: "IPv4 nin", ipv6: "IPv6 nin", cidrv4: "IPv4 menzili", cidrv6: "IPv6 menzili", base64: "base64-ifreli metin", base64url: "base64url-ifreli metin", json_string: "JSON metin", e164: "E.164 says", jwt: "JWT", template_literal: "giren" }, t = { nan: "NaN", number: "numara", array: "saf", null: "gayb" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Fsit giren: umulan instanceof ${n.expected}, alnan ${$}`;
        return `Fsit giren: umulan ${v}, alnan ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Fsit giren: umulan ${U(n.values[0])}`;
        return `Fsit tercih: mteberler ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `Fazla byk: ${n.origin ?? "value"}, ${v}${n.maximum.toString()} ${u.unit ?? "elements"} sahip olmalyd.`;
        return `Fazla byk: ${n.origin ?? "value"}, ${v}${n.maximum.toString()} olmalyd.`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `Fazla kk: ${n.origin}, ${v}${n.minimum.toString()} ${u.unit} sahip olmalyd.`;
        return `Fazla kk: ${n.origin}, ${v}${n.minimum.toString()} olmalyd.`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Fsit metin: "${v.prefix}" ile balamal.`;
        if (v.format === "ends_with") return `Fsit metin: "${v.suffix}" ile bitmeli.`;
        if (v.format === "includes") return `Fsit metin: "${v.includes}" ihtiv etmeli.`;
        if (v.format === "regex") return `Fsit metin: ${v.pattern} nakna uymal.`;
        return `Fsit ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Fsit say: ${n.divisor} kat olmalyd.`;
      case "unrecognized_keys":
        return `Tannmayan anahtar ${n.keys.length > 1 ? "s" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} iin tannmayan anahtar var.`;
      case "invalid_union":
        return "Giren tannamad.";
      case "invalid_element":
        return `${n.origin} iin tannmayan kymet var.`;
      default:
        return "Kymet tannamad.";
    }
  };
};
function bu() {
  return { localeError: K4() };
}
var q4 = () => {
  let r = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "", email: "", url: "  ", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "  ", date: "", time: "", duration: "", ipv4: " IPv4 ", ipv6: " IPv6 ", cidrv4: " IPv4 ", cidrv6: " IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: " E.164 ", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return ` :  instanceof ${n.expected} ,  ${$}  `;
        return ` :  ${v} ,  ${$}  `;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` :  ${U(n.values[0])} `;
        return ` :    ${b(n.values, "|")}  `;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return ` : ${n.origin ?? ""}  ${v}${n.maximum.toString()} ${u.unit ?? ""} `;
        return ` : ${n.origin ?? ""}  ${v}${n.maximum.toString()} `;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return ` : ${n.origin}  ${v}${n.minimum.toString()} ${u.unit} `;
        return ` : ${n.origin}  ${v}${n.minimum.toString()} `;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` :   "${v.prefix}"   `;
        if (v.format === "ends_with") return ` :   "${v.suffix}"    `;
        if (v.format === "includes") return ` :  "${v.includes}" `;
        if (v.format === "regex") return ` :   ${v.pattern}   `;
        return `${o[v.format] ?? n.format}  `;
      }
      case "not_multiple_of":
        return ` :   ${n.divisor}  `;
      case "unrecognized_keys":
        return ` ${n.keys.length > 1 ? "" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin} `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${n.origin} `;
      default:
        return " ";
    }
  };
};
function _u() {
  return { localeError: q4() };
}
var Y4 = () => {
  let r = { string: { unit: "znakw", verb: "mie" }, file: { unit: "bajtw", verb: "mie" }, array: { unit: "elementw", verb: "mie" }, set: { unit: "elementw", verb: "mie" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "wyraenie", email: "adres email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i godzina w formacie ISO", date: "data w formacie ISO", time: "godzina w formacie ISO", duration: "czas trwania ISO", ipv4: "adres IPv4", ipv6: "adres IPv6", cidrv4: "zakres IPv4", cidrv6: "zakres IPv6", base64: "cig znakw zakodowany w formacie base64", base64url: "cig znakw zakodowany w formacie base64url", json_string: "cig znakw w formacie JSON", e164: "liczba E.164", jwt: "JWT", template_literal: "wejcie" }, t = { nan: "NaN", number: "liczba", array: "tablica" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Nieprawidowe dane wejciowe: oczekiwano instanceof ${n.expected}, otrzymano ${$}`;
        return `Nieprawidowe dane wejciowe: oczekiwano ${v}, otrzymano ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Nieprawidowe dane wejciowe: oczekiwano ${U(n.values[0])}`;
        return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `Za dua warto: oczekiwano, e ${n.origin ?? "warto"} bdzie mie ${v}${n.maximum.toString()} ${u.unit ?? "elementw"}`;
        return `Zbyt du(y/a/e): oczekiwano, e ${n.origin ?? "warto"} bdzie wynosi ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `Za maa warto: oczekiwano, e ${n.origin ?? "warto"} bdzie mie ${v}${n.minimum.toString()} ${u.unit ?? "elementw"}`;
        return `Zbyt ma(y/a/e): oczekiwano, e ${n.origin ?? "warto"} bdzie wynosi ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Nieprawidowy cig znakw: musi zaczyna si od "${v.prefix}"`;
        if (v.format === "ends_with") return `Nieprawidowy cig znakw: musi koczy si na "${v.suffix}"`;
        if (v.format === "includes") return `Nieprawidowy cig znakw: musi zawiera "${v.includes}"`;
        if (v.format === "regex") return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${v.pattern}`;
        return `Nieprawidow(y/a/e) ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidowa liczba: musi by wielokrotnoci ${n.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${n.keys.length > 1 ? "s" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidowy klucz w ${n.origin}`;
      case "invalid_union":
        return "Nieprawidowe dane wejciowe";
      case "invalid_element":
        return `Nieprawidowa warto w ${n.origin}`;
      default:
        return "Nieprawidowe dane wejciowe";
    }
  };
};
function Uu() {
  return { localeError: Y4() };
}
var Q4 = () => {
  let r = { string: { unit: "caracteres", verb: "ter" }, file: { unit: "bytes", verb: "ter" }, array: { unit: "itens", verb: "ter" }, set: { unit: "itens", verb: "ter" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "padro", email: "endereo de e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e hora ISO", date: "data ISO", time: "hora ISO", duration: "durao ISO", ipv4: "endereo IPv4", ipv6: "endereo IPv6", cidrv4: "faixa de IPv4", cidrv6: "faixa de IPv6", base64: "texto codificado em base64", base64url: "URL codificada em base64", json_string: "texto JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" }, t = { nan: "NaN", number: "nmero", null: "nulo" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Tipo invlido: esperado instanceof ${n.expected}, recebido ${$}`;
        return `Tipo invlido: esperado ${v}, recebido ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Entrada invlida: esperado ${U(n.values[0])}`;
        return `Opo invlida: esperada uma das ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `Muito grande: esperado que ${n.origin ?? "valor"} tivesse ${v}${n.maximum.toString()} ${u.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${n.origin ?? "valor"} fosse ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `Muito pequeno: esperado que ${n.origin} tivesse ${v}${n.minimum.toString()} ${u.unit}`;
        return `Muito pequeno: esperado que ${n.origin} fosse ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Texto invlido: deve comear com "${v.prefix}"`;
        if (v.format === "ends_with") return `Texto invlido: deve terminar com "${v.suffix}"`;
        if (v.format === "includes") return `Texto invlido: deve incluir "${v.includes}"`;
        if (v.format === "regex") return `Texto invlido: deve corresponder ao padro ${v.pattern}`;
        return `${o[v.format] ?? n.format} invlido`;
      }
      case "not_multiple_of":
        return `Nmero invlido: deve ser mltiplo de ${n.divisor}`;
      case "unrecognized_keys":
        return `Chave${n.keys.length > 1 ? "s" : ""} desconhecida${n.keys.length > 1 ? "s" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Chave invlida em ${n.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido em ${n.origin}`;
      default:
        return "Campo invlido";
    }
  };
};
function ku() {
  return { localeError: Q4() };
}
function nl(r, i, o, t) {
  let n = Math.abs(r), v = n % 10, u = n % 100;
  if (u >= 11 && u <= 19) return t;
  if (v === 1) return i;
  if (v >= 2 && v <= 4) return o;
  return t;
}
var m4 = () => {
  let r = { string: { unit: { one: "", few: "", many: "" }, verb: "" }, file: { unit: { one: "", few: "", many: "" }, verb: "" }, array: { unit: { one: "", few: "", many: "" }, verb: "" }, set: { unit: { one: "", few: "", many: "" }, verb: "" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "", email: "email ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "   base64", base64url: "   base64url", json_string: "JSON ", e164: " E.164", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return ` :  instanceof ${n.expected},  ${$}`;
        return ` :  ${v},  ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` :  ${U(n.values[0])}`;
        return ` :    ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) {
          let $ = Number(n.maximum), l = nl($, u.unit.one, u.unit.few, u.unit.many);
          return `  : ,  ${n.origin ?? ""}   ${v}${n.maximum.toString()} ${l}`;
        }
        return `  : ,  ${n.origin ?? ""}  ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) {
          let $ = Number(n.minimum), l = nl($, u.unit.one, u.unit.few, u.unit.many);
          return `  : ,  ${n.origin}   ${v}${n.minimum.toString()} ${l}`;
        }
        return `  : ,  ${n.origin}  ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` :    "${v.prefix}"`;
        if (v.format === "ends_with") return ` :    "${v.suffix}"`;
        if (v.format === "includes") return ` :   "${v.includes}"`;
        if (v.format === "regex") return ` :    ${v.pattern}`;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` :    ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "" : ""} ${n.keys.length > 1 ? "" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${n.origin}`;
      default:
        return "  ";
    }
  };
};
function Du() {
  return { localeError: m4() };
}
var T4 = () => {
  let r = { string: { unit: "znakov", verb: "imeti" }, file: { unit: "bajtov", verb: "imeti" }, array: { unit: "elementov", verb: "imeti" }, set: { unit: "elementov", verb: "imeti" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "vnos", email: "e-potni naslov", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum in as", date: "ISO datum", time: "ISO as", duration: "ISO trajanje", ipv4: "IPv4 naslov", ipv6: "IPv6 naslov", cidrv4: "obseg IPv4", cidrv6: "obseg IPv6", base64: "base64 kodiran niz", base64url: "base64url kodiran niz", json_string: "JSON niz", e164: "E.164 tevilka", jwt: "JWT", template_literal: "vnos" }, t = { nan: "NaN", number: "tevilo", array: "tabela" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Neveljaven vnos: priakovano instanceof ${n.expected}, prejeto ${$}`;
        return `Neveljaven vnos: priakovano ${v}, prejeto ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Neveljaven vnos: priakovano ${U(n.values[0])}`;
        return `Neveljavna monost: priakovano eno izmed ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `Preveliko: priakovano, da bo ${n.origin ?? "vrednost"} imelo ${v}${n.maximum.toString()} ${u.unit ?? "elementov"}`;
        return `Preveliko: priakovano, da bo ${n.origin ?? "vrednost"} ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `Premajhno: priakovano, da bo ${n.origin} imelo ${v}${n.minimum.toString()} ${u.unit}`;
        return `Premajhno: priakovano, da bo ${n.origin} ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Neveljaven niz: mora se zaeti z "${v.prefix}"`;
        if (v.format === "ends_with") return `Neveljaven niz: mora se konati z "${v.suffix}"`;
        if (v.format === "includes") return `Neveljaven niz: mora vsebovati "${v.includes}"`;
        if (v.format === "regex") return `Neveljaven niz: mora ustrezati vzorcu ${v.pattern}`;
        return `Neveljaven ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno tevilo: mora biti vekratnik ${n.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${n.keys.length > 1 ? "i kljui" : " klju"}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju v ${n.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${n.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function wu() {
  return { localeError: T4() };
}
var F4 = () => {
  let r = { string: { unit: "tecken", verb: "att ha" }, file: { unit: "bytes", verb: "att ha" }, array: { unit: "objekt", verb: "att innehlla" }, set: { unit: "objekt", verb: "att innehlla" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "reguljrt uttryck", email: "e-postadress", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datum och tid", date: "ISO-datum", time: "ISO-tid", duration: "ISO-varaktighet", ipv4: "IPv4-intervall", ipv6: "IPv6-intervall", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodad strng", base64url: "base64url-kodad strng", json_string: "JSON-strng", e164: "E.164-nummer", jwt: "JWT", template_literal: "mall-literal" }, t = { nan: "NaN", number: "antal", array: "lista" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Ogiltig inmatning: frvntat instanceof ${n.expected}, fick ${$}`;
        return `Ogiltig inmatning: frvntat ${v}, fick ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Ogiltig inmatning: frvntat ${U(n.values[0])}`;
        return `Ogiltigt val: frvntade en av ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `Fr stor(t): frvntade ${n.origin ?? "vrdet"} att ha ${v}${n.maximum.toString()} ${u.unit ?? "element"}`;
        return `Fr stor(t): frvntat ${n.origin ?? "vrdet"} att ha ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `Fr lite(t): frvntade ${n.origin ?? "vrdet"} att ha ${v}${n.minimum.toString()} ${u.unit}`;
        return `Fr lite(t): frvntade ${n.origin ?? "vrdet"} att ha ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Ogiltig strng: mste brja med "${v.prefix}"`;
        if (v.format === "ends_with") return `Ogiltig strng: mste sluta med "${v.suffix}"`;
        if (v.format === "includes") return `Ogiltig strng: mste innehlla "${v.includes}"`;
        if (v.format === "regex") return `Ogiltig strng: mste matcha mnstret "${v.pattern}"`;
        return `Ogiltig(t) ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: mste vara en multipel av ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${n.origin ?? "vrdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt vrde i ${n.origin ?? "vrdet"}`;
      default:
        return "Ogiltig input";
    }
  };
};
function Nu() {
  return { localeError: F4() };
}
var B4 = () => {
  let r = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "", email: " ", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO  ", date: "ISO ", time: "ISO ", duration: "ISO  ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "input" }, t = { nan: "NaN", number: "", array: "", null: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return ` :  instanceof ${n.expected},  ${$}`;
        return ` :  ${v},  ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` :  ${U(n.values[0])}`;
        return ` :  ${b(n.values, "|")}  `;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return ` :  ${n.origin ?? ""} ${v}${n.maximum.toString()} ${u.unit ?? ""}   `;
        return ` :  ${n.origin ?? ""} ${v}${n.maximum.toString()}   `;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return ` :  ${n.origin} ${v}${n.minimum.toString()} ${u.unit}   `;
        return ` :  ${n.origin} ${v}${n.minimum.toString()}   `;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` : "${v.prefix}"   `;
        if (v.format === "ends_with") return ` : "${v.suffix}"   `;
        if (v.format === "includes") return ` : "${v.includes}"   `;
        if (v.format === "regex") return ` : ${v.pattern}   `;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` : ${n.divisor}    `;
      case "unrecognized_keys":
        return `  ${n.keys.length > 1 ? "" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin}   `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `${n.origin}   `;
      default:
        return " ";
    }
  };
};
function Ou() {
  return { localeError: B4() };
}
var H4 = () => {
  let r = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: " ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IP  IPv4", cidrv6: " IP  IPv6", base64: " Base64", base64url: " Base64  URL", json_string: " JSON", e164: " (E.164)", jwt: " JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: " (Array)", null: " (null)" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `:  instanceof ${n.expected}  ${$}`;
        return `:  ${v}  ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `:  ${U(n.values[0])}`;
        return `:  ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "" : "", u = i(n.origin);
        if (u) return `: ${n.origin ?? ""} ${v} ${n.maximum.toString()} ${u.unit ?? ""}`;
        return `: ${n.origin ?? ""} ${v} ${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? "" : "", u = i(n.origin);
        if (u) return `: ${n.origin} ${v} ${n.minimum.toString()} ${u.unit}`;
        return `: ${n.origin} ${v} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `:  "${v.prefix}"`;
        if (v.format === "ends_with") return `:  "${v.suffix}"`;
        if (v.format === "includes") return `:  "${v.includes}" `;
        if (v.format === "regex") return `:  ${v.pattern}`;
        return `: ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `:  ${n.divisor} `;
      case "unrecognized_keys":
        return `: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return ` ${n.origin}`;
      case "invalid_union":
        return ": ";
      case "invalid_element":
        return ` ${n.origin}`;
      default:
        return "";
    }
  };
};
function Su() {
  return { localeError: H4() };
}
var M4 = () => {
  let r = { string: { unit: "karakter", verb: "olmal" }, file: { unit: "bayt", verb: "olmal" }, array: { unit: "e", verb: "olmal" }, set: { unit: "e", verb: "olmal" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "girdi", email: "e-posta adresi", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO tarih ve saat", date: "ISO tarih", time: "ISO saat", duration: "ISO sre", ipv4: "IPv4 adresi", ipv6: "IPv6 adresi", cidrv4: "IPv4 aral", cidrv6: "IPv6 aral", base64: "base64 ile ifrelenmi metin", base64url: "base64url ile ifrelenmi metin", json_string: "JSON dizesi", e164: "E.164 says", jwt: "JWT", template_literal: "ablon dizesi" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Geersiz deer: beklenen instanceof ${n.expected}, alnan ${$}`;
        return `Geersiz deer: beklenen ${v}, alnan ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Geersiz deer: beklenen ${U(n.values[0])}`;
        return `Geersiz seenek: aadakilerden biri olmal: ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `ok byk: beklenen ${n.origin ?? "deer"} ${v}${n.maximum.toString()} ${u.unit ?? "e"}`;
        return `ok byk: beklenen ${n.origin ?? "deer"} ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `ok kk: beklenen ${n.origin} ${v}${n.minimum.toString()} ${u.unit}`;
        return `ok kk: beklenen ${n.origin} ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Geersiz metin: "${v.prefix}" ile balamal`;
        if (v.format === "ends_with") return `Geersiz metin: "${v.suffix}" ile bitmeli`;
        if (v.format === "includes") return `Geersiz metin: "${v.includes}" iermeli`;
        if (v.format === "regex") return `Geersiz metin: ${v.pattern} desenine uymal`;
        return `Geersiz ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Geersiz say: ${n.divisor} ile tam blnebilmeli`;
      case "unrecognized_keys":
        return `Tannmayan anahtar${n.keys.length > 1 ? "lar" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} iinde geersiz anahtar`;
      case "invalid_union":
        return "Geersiz deer";
      case "invalid_element":
        return `${n.origin} iinde geersiz deer`;
      default:
        return "Geersiz deer";
    }
  };
};
function zu() {
  return { localeError: M4() };
}
var R4 = () => {
  let r = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: " ", email: "  ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IPv4", cidrv6: " IPv6", base64: "   base64", base64url: "   base64url", json_string: " JSON", e164: " E.164", jwt: "JWT", template_literal: " " }, t = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `  :  instanceof ${n.expected},  ${$}`;
        return `  :  ${v},  ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `  :  ${U(n.values[0])}`;
        return ` :    ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return ` : ,  ${n.origin ?? ""} ${u.verb} ${v}${n.maximum.toString()} ${u.unit ?? ""}`;
        return ` : ,  ${n.origin ?? ""}  ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return ` : ,  ${n.origin} ${u.verb} ${v}${n.minimum.toString()} ${u.unit}`;
        return ` : ,  ${n.origin}  ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` :    "${v.prefix}"`;
        if (v.format === "ends_with") return ` :    "${v.suffix}"`;
        if (v.format === "includes") return ` :   "${v.includes}"`;
        if (v.format === "regex") return ` :    ${v.pattern}`;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` :    ${n.divisor}`;
      case "unrecognized_keys":
        return ` ${n.keys.length > 1 ? "" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${n.origin}`;
      default:
        return "  ";
    }
  };
};
function Nn() {
  return { localeError: R4() };
}
function Pu() {
  return Nn();
}
var x4 = () => {
  let r = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: " ", email: "  ", url: "  ", emoji: "", uuid: "   ", uuidv4: "     4", uuidv6: "     6", nanoid: "  ", guid: "   ", cuid: "   ", cuid2: "    2", ulid: "   ", xid: "  ", ksuid: "    ", datetime: "    ", date: "   ", time: "   ", duration: "   ", ipv4: "   4 ", ipv6: "   6 ", cidrv4: "   4 ", cidrv6: "   6 ", base64: " 64   ", base64url: " 64      ", json_string: "    ", e164: " 164 ", jwt: "  ", template_literal: " " }, t = { nan: "NaN", number: "", array: "", null: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `  : instanceof ${n.expected}   ${$}  `;
        return `  : ${v}   ${$}  `;
      }
      case "invalid_value":
        if (n.values.length === 1) return `  : ${U(n.values[0])}  `;
        return ` : ${b(n.values, "|")}     `;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return ` : ${n.origin ?? ""}  ${v}${n.maximum.toString()} ${u.unit ?? ""}   `;
        return ` : ${n.origin ?? ""}  ${v}${n.maximum.toString()}   `;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return ` : ${n.origin}  ${v}${n.minimum.toString()} ${u.unit}   `;
        return ` : ${n.origin}  ${v}${n.minimum.toString()}   `;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` : "${v.prefix}"    `;
        if (v.format === "ends_with") return ` : "${v.suffix}"    `;
        if (v.format === "includes") return ` : "${v.includes}"   `;
        if (v.format === "regex") return ` :  ${v.pattern}    `;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` : ${n.divisor}    `;
      case "unrecognized_keys":
        return `   ${n.keys.length > 1 ? "" : ""}: ${b(n.keys, " ")}`;
      case "invalid_key":
        return `${n.origin}   `;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `${n.origin}   `;
      default:
        return "  ";
    }
  };
};
function ju() {
  return { localeError: x4() };
}
var Z4 = () => {
  let r = { string: { unit: "belgi", verb: "bolishi kerak" }, file: { unit: "bayt", verb: "bolishi kerak" }, array: { unit: "element", verb: "bolishi kerak" }, set: { unit: "element", verb: "bolishi kerak" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "kirish", email: "elektron pochta manzili", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO sana va vaqti", date: "ISO sana", time: "ISO vaqt", duration: "ISO davomiylik", ipv4: "IPv4 manzil", ipv6: "IPv6 manzil", mac: "MAC manzil", cidrv4: "IPv4 diapazon", cidrv6: "IPv6 diapazon", base64: "base64 kodlangan satr", base64url: "base64url kodlangan satr", json_string: "JSON satr", e164: "E.164 raqam", jwt: "JWT", template_literal: "kirish" }, t = { nan: "NaN", number: "raqam", array: "massiv" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `Notogri kirish: kutilgan instanceof ${n.expected}, qabul qilingan ${$}`;
        return `Notogri kirish: kutilgan ${v}, qabul qilingan ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `Notogri kirish: kutilgan ${U(n.values[0])}`;
        return `Notogri variant: quyidagilardan biri kutilgan ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `Juda katta: kutilgan ${n.origin ?? "qiymat"} ${v}${n.maximum.toString()} ${u.unit} ${u.verb}`;
        return `Juda katta: kutilgan ${n.origin ?? "qiymat"} ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `Juda kichik: kutilgan ${n.origin} ${v}${n.minimum.toString()} ${u.unit} ${u.verb}`;
        return `Juda kichik: kutilgan ${n.origin} ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Notogri satr: "${v.prefix}" bilan boshlanishi kerak`;
        if (v.format === "ends_with") return `Notogri satr: "${v.suffix}" bilan tugashi kerak`;
        if (v.format === "includes") return `Notogri satr: "${v.includes}" ni oz ichiga olishi kerak`;
        if (v.format === "regex") return `Notogri satr: ${v.pattern} shabloniga mos kelishi kerak`;
        return `Notogri ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Notogri raqam: ${n.divisor} ning karralisi bolishi kerak`;
      case "unrecognized_keys":
        return `Nomalum kalit${n.keys.length > 1 ? "lar" : ""}: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} dagi kalit notogri`;
      case "invalid_union":
        return "Notogri kirish";
      case "invalid_element":
        return `${n.origin} da notogri qiymat`;
      default:
        return "Notogri kirish";
    }
  };
};
function Ju() {
  return { localeError: Z4() };
}
var d4 = () => {
  let r = { string: { unit: "k t", verb: "c" }, file: { unit: "byte", verb: "c" }, array: { unit: "phn t", verb: "c" }, set: { unit: "phn t", verb: "c" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "u vo", email: "a ch email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ngy gi ISO", date: "ngy ISO", time: "gi ISO", duration: "khong thi gian ISO", ipv4: "a ch IPv4", ipv6: "a ch IPv6", cidrv4: "di IPv4", cidrv6: "di IPv6", base64: "chui m ha base64", base64url: "chui m ha base64url", json_string: "chui JSON", e164: "s E.164", jwt: "JWT", template_literal: "u vo" }, t = { nan: "NaN", number: "s", array: "mng" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `u vo khng hp l: mong i instanceof ${n.expected}, nhn c ${$}`;
        return `u vo khng hp l: mong i ${v}, nhn c ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `u vo khng hp l: mong i ${U(n.values[0])}`;
        return `Ty chn khng hp l: mong i mt trong cc gi tr ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `Qu ln: mong i ${n.origin ?? "gi tr"} ${u.verb} ${v}${n.maximum.toString()} ${u.unit ?? "phn t"}`;
        return `Qu ln: mong i ${n.origin ?? "gi tr"} ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `Qu nh: mong i ${n.origin} ${u.verb} ${v}${n.minimum.toString()} ${u.unit}`;
        return `Qu nh: mong i ${n.origin} ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `Chui khng hp l: phi bt u bng "${v.prefix}"`;
        if (v.format === "ends_with") return `Chui khng hp l: phi kt thc bng "${v.suffix}"`;
        if (v.format === "includes") return `Chui khng hp l: phi bao gm "${v.includes}"`;
        if (v.format === "regex") return `Chui khng hp l: phi khp vi mu ${v.pattern}`;
        return `${o[v.format] ?? n.format} khng hp l`;
      }
      case "not_multiple_of":
        return `S khng hp l: phi l bi s ca ${n.divisor}`;
      case "unrecognized_keys":
        return `Kha khng c nhn dng: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Kha khng hp l trong ${n.origin}`;
      case "invalid_union":
        return "u vo khng hp l";
      case "invalid_element":
        return `Gi tr khng hp l trong ${n.origin}`;
      default:
        return "u vo khng hp l";
    }
  };
};
function Lu() {
  return { localeError: d4() };
}
var C4 = () => {
  let r = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO", date: "ISO", time: "ISO", duration: "ISO", ipv4: "IPv4", ipv6: "IPv6", cidrv4: "IPv4", cidrv6: "IPv6", base64: "base64", base64url: "base64url", json_string: "JSON", e164: "E.164", jwt: "JWT", template_literal: "" }, t = { nan: "NaN", number: "", array: "", null: "(null)" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return ` instanceof ${n.expected} ${$}`;
        return ` ${v} ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` ${U(n.values[0])}`;
        return ` ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return ` ${n.origin ?? ""} ${v}${n.maximum.toString()} ${u.unit ?? ""}`;
        return ` ${n.origin ?? ""} ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return ` ${n.origin} ${v}${n.minimum.toString()} ${u.unit}`;
        return ` ${n.origin} ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` "${v.prefix}" `;
        if (v.format === "ends_with") return ` "${v.suffix}" `;
        if (v.format === "includes") return ` "${v.includes}"`;
        if (v.format === "regex") return ` ${v.pattern}`;
        return `${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` ${n.divisor} `;
      case "unrecognized_keys":
        return `(key): ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} (key)`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${n.origin} (value)`;
      default:
        return "";
    }
  };
};
function Eu() {
  return { localeError: C4() };
}
var f4 = () => {
  let r = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "", email: "", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64 ", base64url: "base64url ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, t = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return ` instanceof ${n.expected} ${$}`;
        return ` ${v} ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return ` ${U(n.values[0])}`;
        return ` ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return ` ${n.origin ?? ""}  ${v}${n.maximum.toString()} ${u.unit ?? ""}`;
        return ` ${n.origin ?? ""}  ${v}${n.maximum.toString()}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return ` ${n.origin}  ${v}${n.minimum.toString()} ${u.unit}`;
        return ` ${n.origin}  ${v}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return ` "${v.prefix}" `;
        if (v.format === "ends_with") return ` "${v.suffix}" `;
        if (v.format === "includes") return ` "${v.includes}"`;
        if (v.format === "regex") return ` ${v.pattern}`;
        return ` ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` ${n.divisor} `;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "" : ""}${b(n.keys, "")}`;
      case "invalid_key":
        return `${n.origin} `;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${n.origin} `;
      default:
        return "";
    }
  };
};
function Gu() {
  return { localeError: f4() };
}
var h4 = () => {
  let r = { string: { unit: "mi", verb: "n" }, file: { unit: "bytes", verb: "n" }, array: { unit: "nkan", verb: "n" }, set: { unit: "nkan", verb: "n" } };
  function i(n) {
    return r[n] ?? null;
  }
  let o = { regex: "r bwl", email: "drs ml", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "kk ISO", date: "j ISO", time: "kk ISO", duration: "kk t p ISO", ipv4: "drs IPv4", ipv6: "drs IPv6", cidrv4: "gbgb IPv4", cidrv6: "gbgb IPv6", base64: "r t a k n base64", base64url: "r base64url", json_string: "r JSON", e164: "nmb E.164", jwt: "JWT", template_literal: "r bwl" }, t = { nan: "NaN", number: "nmb", array: "akop" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let v = t[n.expected] ?? n.expected, u = k(n.input), $ = t[u] ?? u;
        if (/^[A-Z]/.test(n.expected)) return `bwl ae: a n lti fi instanceof ${n.expected}, m a r ${$}`;
        return `bwl ae: a n lti fi ${v}, m a r ${$}`;
      }
      case "invalid_value":
        if (n.values.length === 1) return `bwl ae: a n lti fi ${U(n.values[0])}`;
        return `yn ae: yan kan lra ${b(n.values, "|")}`;
      case "too_big": {
        let v = n.inclusive ? "<=" : "<", u = i(n.origin);
        if (u) return `T p j: a n lti j p ${n.origin ?? "iye"} ${u.verb} ${v}${n.maximum} ${u.unit}`;
        return `T p j: a n lti j ${v}${n.maximum}`;
      }
      case "too_small": {
        let v = n.inclusive ? ">=" : ">", u = i(n.origin);
        if (u) return `Kr ju: a n lti j p ${n.origin} ${u.verb} ${v}${n.minimum} ${u.unit}`;
        return `Kr ju: a n lti j ${v}${n.minimum}`;
      }
      case "invalid_format": {
        let v = n;
        if (v.format === "starts_with") return `r ae: gbd br pl "${v.prefix}"`;
        if (v.format === "ends_with") return `r ae: gbd par pl "${v.suffix}"`;
        if (v.format === "includes") return `r ae: gbd n "${v.includes}"`;
        if (v.format === "regex") return `r ae: gbd b pr mu ${v.pattern}`;
        return `Ae: ${o[v.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Nmb ae: gbd j y ppn ti ${n.divisor}`;
      case "unrecognized_keys":
        return `Btn m: ${b(n.keys, ", ")}`;
      case "invalid_key":
        return `Btn ae nn ${n.origin}`;
      case "invalid_union":
        return "bwl ae";
      case "invalid_element":
        return `Iye ae nn ${n.origin}`;
      default:
        return "bwl ae";
    }
  };
};
function Wu() {
  return { localeError: h4() };
}
var il;
var Xu = /* @__PURE__ */ Symbol("ZodOutput");
var Vu = /* @__PURE__ */ Symbol("ZodInput");
var Au = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(r, ...i) {
    let o = i[0];
    if (this._map.set(r, o), o && typeof o === "object" && "id" in o) this._idmap.set(o.id, r);
    return this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(r) {
    let i = this._map.get(r);
    if (i && typeof i === "object" && "id" in i) this._idmap.delete(i.id);
    return this._map.delete(r), this;
  }
  get(r) {
    let i = r._zod.parent;
    if (i) {
      let o = { ...this.get(i) ?? {} };
      delete o.id;
      let t = { ...o, ...this._map.get(r) };
      return Object.keys(t).length ? t : void 0;
    }
    return this._map.get(r);
  }
  has(r) {
    return this._map.has(r);
  }
};
function $i() {
  return new Au();
}
(il = globalThis).__zod_globalRegistry ?? (il.__zod_globalRegistry = $i());
var A = globalThis.__zod_globalRegistry;
function Ku(r, i) {
  return new r({ type: "string", ...w(i) });
}
function qu(r, i) {
  return new r({ type: "string", coerce: true, ...w(i) });
}
function gi(r, i) {
  return new r({ type: "string", format: "email", check: "string_format", abort: false, ...w(i) });
}
function Sn(r, i) {
  return new r({ type: "string", format: "guid", check: "string_format", abort: false, ...w(i) });
}
function ei(r, i) {
  return new r({ type: "string", format: "uuid", check: "string_format", abort: false, ...w(i) });
}
function li(r, i) {
  return new r({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v4", ...w(i) });
}
function ci(r, i) {
  return new r({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v6", ...w(i) });
}
function Ii(r, i) {
  return new r({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v7", ...w(i) });
}
function zn(r, i) {
  return new r({ type: "string", format: "url", check: "string_format", abort: false, ...w(i) });
}
function bi(r, i) {
  return new r({ type: "string", format: "emoji", check: "string_format", abort: false, ...w(i) });
}
function _i(r, i) {
  return new r({ type: "string", format: "nanoid", check: "string_format", abort: false, ...w(i) });
}
function Ui(r, i) {
  return new r({ type: "string", format: "cuid", check: "string_format", abort: false, ...w(i) });
}
function ki(r, i) {
  return new r({ type: "string", format: "cuid2", check: "string_format", abort: false, ...w(i) });
}
function Di(r, i) {
  return new r({ type: "string", format: "ulid", check: "string_format", abort: false, ...w(i) });
}
function wi(r, i) {
  return new r({ type: "string", format: "xid", check: "string_format", abort: false, ...w(i) });
}
function Ni(r, i) {
  return new r({ type: "string", format: "ksuid", check: "string_format", abort: false, ...w(i) });
}
function Oi(r, i) {
  return new r({ type: "string", format: "ipv4", check: "string_format", abort: false, ...w(i) });
}
function Si(r, i) {
  return new r({ type: "string", format: "ipv6", check: "string_format", abort: false, ...w(i) });
}
function Yu(r, i) {
  return new r({ type: "string", format: "mac", check: "string_format", abort: false, ...w(i) });
}
function zi(r, i) {
  return new r({ type: "string", format: "cidrv4", check: "string_format", abort: false, ...w(i) });
}
function Pi(r, i) {
  return new r({ type: "string", format: "cidrv6", check: "string_format", abort: false, ...w(i) });
}
function ji(r, i) {
  return new r({ type: "string", format: "base64", check: "string_format", abort: false, ...w(i) });
}
function Ji(r, i) {
  return new r({ type: "string", format: "base64url", check: "string_format", abort: false, ...w(i) });
}
function Li(r, i) {
  return new r({ type: "string", format: "e164", check: "string_format", abort: false, ...w(i) });
}
function Ei(r, i) {
  return new r({ type: "string", format: "jwt", check: "string_format", abort: false, ...w(i) });
}
var Qu = { Any: null, Minute: -1, Second: 0, Millisecond: 3, Microsecond: 6 };
function mu(r, i) {
  return new r({ type: "string", format: "datetime", check: "string_format", offset: false, local: false, precision: null, ...w(i) });
}
function Tu(r, i) {
  return new r({ type: "string", format: "date", check: "string_format", ...w(i) });
}
function Fu(r, i) {
  return new r({ type: "string", format: "time", check: "string_format", precision: null, ...w(i) });
}
function Bu(r, i) {
  return new r({ type: "string", format: "duration", check: "string_format", ...w(i) });
}
function Hu(r, i) {
  return new r({ type: "number", checks: [], ...w(i) });
}
function Mu(r, i) {
  return new r({ type: "number", coerce: true, checks: [], ...w(i) });
}
function Ru(r, i) {
  return new r({ type: "number", check: "number_format", abort: false, format: "safeint", ...w(i) });
}
function xu(r, i) {
  return new r({ type: "number", check: "number_format", abort: false, format: "float32", ...w(i) });
}
function Zu(r, i) {
  return new r({ type: "number", check: "number_format", abort: false, format: "float64", ...w(i) });
}
function du(r, i) {
  return new r({ type: "number", check: "number_format", abort: false, format: "int32", ...w(i) });
}
function Cu(r, i) {
  return new r({ type: "number", check: "number_format", abort: false, format: "uint32", ...w(i) });
}
function fu(r, i) {
  return new r({ type: "boolean", ...w(i) });
}
function hu(r, i) {
  return new r({ type: "boolean", coerce: true, ...w(i) });
}
function yu(r, i) {
  return new r({ type: "bigint", ...w(i) });
}
function au(r, i) {
  return new r({ type: "bigint", coerce: true, ...w(i) });
}
function pu(r, i) {
  return new r({ type: "bigint", check: "bigint_format", abort: false, format: "int64", ...w(i) });
}
function su(r, i) {
  return new r({ type: "bigint", check: "bigint_format", abort: false, format: "uint64", ...w(i) });
}
function r$(r, i) {
  return new r({ type: "symbol", ...w(i) });
}
function n$(r, i) {
  return new r({ type: "undefined", ...w(i) });
}
function i$(r, i) {
  return new r({ type: "null", ...w(i) });
}
function v$(r) {
  return new r({ type: "any" });
}
function o$(r) {
  return new r({ type: "unknown" });
}
function t$(r, i) {
  return new r({ type: "never", ...w(i) });
}
function u$(r, i) {
  return new r({ type: "void", ...w(i) });
}
function $$(r, i) {
  return new r({ type: "date", ...w(i) });
}
function g$(r, i) {
  return new r({ type: "date", coerce: true, ...w(i) });
}
function e$(r, i) {
  return new r({ type: "nan", ...w(i) });
}
function h(r, i) {
  return new hn({ check: "less_than", ...w(i), value: r, inclusive: false });
}
function M(r, i) {
  return new hn({ check: "less_than", ...w(i), value: r, inclusive: true });
}
function y(r, i) {
  return new yn({ check: "greater_than", ...w(i), value: r, inclusive: false });
}
function Y(r, i) {
  return new yn({ check: "greater_than", ...w(i), value: r, inclusive: true });
}
function Gi(r) {
  return y(0, r);
}
function Wi(r) {
  return h(0, r);
}
function Xi(r) {
  return M(0, r);
}
function Vi(r) {
  return Y(0, r);
}
function $r(r, i) {
  return new go({ check: "multiple_of", ...w(i), value: r });
}
function gr(r, i) {
  return new co({ check: "max_size", ...w(i), maximum: r });
}
function a(r, i) {
  return new Io({ check: "min_size", ...w(i), minimum: r });
}
function kr(r, i) {
  return new bo({ check: "size_equals", ...w(i), size: r });
}
function Dr(r, i) {
  return new _o({ check: "max_length", ...w(i), maximum: r });
}
function nr(r, i) {
  return new Uo({ check: "min_length", ...w(i), minimum: r });
}
function wr(r, i) {
  return new ko({ check: "length_equals", ...w(i), length: r });
}
function Vr(r, i) {
  return new Do({ check: "string_format", format: "regex", ...w(i), pattern: r });
}
function Ar(r) {
  return new wo({ check: "string_format", format: "lowercase", ...w(r) });
}
function Kr(r) {
  return new No({ check: "string_format", format: "uppercase", ...w(r) });
}
function qr(r, i) {
  return new Oo({ check: "string_format", format: "includes", ...w(i), includes: r });
}
function Yr(r, i) {
  return new So({ check: "string_format", format: "starts_with", ...w(i), prefix: r });
}
function Qr(r, i) {
  return new zo({ check: "string_format", format: "ends_with", ...w(i), suffix: r });
}
function Ai(r, i, o) {
  return new Po({ check: "property", property: r, schema: i, ...w(o) });
}
function mr(r, i) {
  return new jo({ check: "mime_type", mime: r, ...w(i) });
}
function d(r) {
  return new Jo({ check: "overwrite", tx: r });
}
function Tr(r) {
  return d((i) => i.normalize(r));
}
function Fr() {
  return d((r) => r.trim());
}
function Br() {
  return d((r) => r.toLowerCase());
}
function Hr() {
  return d((r) => r.toUpperCase());
}
function Mr() {
  return d((r) => Pv(r));
}
function l$(r, i, o) {
  return new r({ type: "array", element: i, ...w(o) });
}
function a4(r, i, o) {
  return new r({ type: "union", options: i, ...w(o) });
}
function p4(r, i, o) {
  return new r({ type: "union", options: i, inclusive: false, ...w(o) });
}
function s4(r, i, o, t) {
  return new r({ type: "union", options: o, discriminator: i, ...w(t) });
}
function r6(r, i, o) {
  return new r({ type: "intersection", left: i, right: o });
}
function n6(r, i, o, t) {
  let n = o instanceof z;
  return new r({ type: "tuple", items: i, rest: n ? o : null, ...w(n ? t : o) });
}
function i6(r, i, o, t) {
  return new r({ type: "record", keyType: i, valueType: o, ...w(t) });
}
function v6(r, i, o, t) {
  return new r({ type: "map", keyType: i, valueType: o, ...w(t) });
}
function o6(r, i, o) {
  return new r({ type: "set", valueType: i, ...w(o) });
}
function t6(r, i, o) {
  let t = Array.isArray(i) ? Object.fromEntries(i.map((n) => [n, n])) : i;
  return new r({ type: "enum", entries: t, ...w(o) });
}
function u6(r, i, o) {
  return new r({ type: "enum", entries: i, ...w(o) });
}
function $6(r, i, o) {
  return new r({ type: "literal", values: Array.isArray(i) ? i : [i], ...w(o) });
}
function c$(r, i) {
  return new r({ type: "file", ...w(i) });
}
function g6(r, i) {
  return new r({ type: "transform", transform: i });
}
function e6(r, i) {
  return new r({ type: "optional", innerType: i });
}
function l6(r, i) {
  return new r({ type: "nullable", innerType: i });
}
function c6(r, i, o) {
  return new r({ type: "default", innerType: i, get defaultValue() {
    return typeof o === "function" ? o() : Jv(o);
  } });
}
function I6(r, i, o) {
  return new r({ type: "nonoptional", innerType: i, ...w(o) });
}
function b6(r, i) {
  return new r({ type: "success", innerType: i });
}
function _6(r, i, o) {
  return new r({ type: "catch", innerType: i, catchValue: typeof o === "function" ? o : () => o });
}
function U6(r, i, o) {
  return new r({ type: "pipe", in: i, out: o });
}
function k6(r, i) {
  return new r({ type: "readonly", innerType: i });
}
function D6(r, i, o) {
  return new r({ type: "template_literal", parts: i, ...w(o) });
}
function w6(r, i) {
  return new r({ type: "lazy", getter: i });
}
function N6(r, i) {
  return new r({ type: "promise", innerType: i });
}
function I$(r, i, o) {
  let t = w(o);
  return t.abort ?? (t.abort = true), new r({ type: "custom", check: "custom", fn: i, ...t });
}
function b$(r, i, o) {
  return new r({ type: "custom", check: "custom", fn: i, ...w(o) });
}
function _$(r) {
  let i = vl((o) => {
    return o.addIssue = (t) => {
      if (typeof t === "string") o.issues.push(jr(t, o.value, i._zod.def));
      else {
        let n = t;
        if (n.fatal) n.continue = false;
        n.code ?? (n.code = "custom"), n.input ?? (n.input = o.value), n.inst ?? (n.inst = i), n.continue ?? (n.continue = !i._zod.def.abort), o.issues.push(jr(n));
      }
    }, r(o.value, o);
  });
  return i;
}
function vl(r, i) {
  let o = new W({ check: "custom", ...w(i) });
  return o._zod.check = r, o;
}
function U$(r) {
  let i = new W({ check: "describe" });
  return i._zod.onattach = [(o) => {
    let t = A.get(o) ?? {};
    A.add(o, { ...t, description: r });
  }], i._zod.check = () => {
  }, i;
}
function k$(r) {
  let i = new W({ check: "meta" });
  return i._zod.onattach = [(o) => {
    let t = A.get(o) ?? {};
    A.add(o, { ...t, ...r });
  }], i._zod.check = () => {
  }, i;
}
function D$(r, i) {
  let o = w(i), t = o.truthy ?? ["true", "1", "yes", "on", "y", "enabled"], n = o.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (o.case !== "sensitive") t = t.map((O) => typeof O === "string" ? O.toLowerCase() : O), n = n.map((O) => typeof O === "string" ? O.toLowerCase() : O);
  let v = new Set(t), u = new Set(n), $ = r.Codec ?? Un, l = r.Boolean ?? bn, I = new (r.String ?? Ur)({ type: "string", error: o.error }), _ = new l({ type: "boolean", error: o.error }), N = new $({ type: "pipe", in: I, out: _, transform: (O, J) => {
    let X = O;
    if (o.case !== "sensitive") X = X.toLowerCase();
    if (v.has(X)) return true;
    else if (u.has(X)) return false;
    else return J.issues.push({ code: "invalid_value", expected: "stringbool", values: [...v, ...u], input: J.value, inst: N, continue: false }), {};
  }, reverseTransform: (O, J) => {
    if (O === true) return t[0] || "true";
    else return n[0] || "false";
  }, error: o.error });
  return N;
}
function Rr(r, i, o, t = {}) {
  let n = w(t), v = { ...w(t), check: "string_format", type: "string", format: i, fn: typeof o === "function" ? o : ($) => o.test($), ...n };
  if (o instanceof RegExp) v.pattern = o;
  return new r(v);
}
function er(r) {
  let i = r?.target ?? "draft-2020-12";
  if (i === "draft-4") i = "draft-04";
  if (i === "draft-7") i = "draft-07";
  return { processors: r.processors ?? {}, metadataRegistry: r?.metadata ?? A, target: i, unrepresentable: r?.unrepresentable ?? "throw", override: r?.override ?? (() => {
  }), io: r?.io ?? "output", counter: 0, seen: /* @__PURE__ */ new Map(), cycles: r?.cycles ?? "ref", reused: r?.reused ?? "inline", external: r?.external ?? void 0 };
}
function L(r, i, o = { path: [], schemaPath: [] }) {
  var t;
  let n = r._zod.def, v = i.seen.get(r);
  if (v) {
    if (v.count++, o.schemaPath.includes(r)) v.cycle = o.path;
    return v.schema;
  }
  let u = { schema: {}, count: 1, cycle: void 0, path: o.path };
  i.seen.set(r, u);
  let $ = r._zod.toJSONSchema?.();
  if ($) u.schema = $;
  else {
    let I = { ...o, schemaPath: [...o.schemaPath, r], path: o.path };
    if (r._zod.processJSONSchema) r._zod.processJSONSchema(i, u.schema, I);
    else {
      let N = u.schema, O = i.processors[n.type];
      if (!O) throw Error(`[toJSONSchema]: Non-representable type encountered: ${n.type}`);
      O(r, i, N, I);
    }
    let _ = r._zod.parent;
    if (_) {
      if (!u.ref) u.ref = _;
      L(_, i, I), i.seen.get(_).isParent = true;
    }
  }
  let l = i.metadataRegistry.get(r);
  if (l) Object.assign(u.schema, l);
  if (i.io === "input" && Q(r)) delete u.schema.examples, delete u.schema.default;
  if (i.io === "input" && u.schema._prefault) (t = u.schema).default ?? (t.default = u.schema._prefault);
  return delete u.schema._prefault, i.seen.get(r).schema;
}
function lr(r, i) {
  let o = r.seen.get(i);
  if (!o) throw Error("Unprocessed schema. This is a bug in Zod.");
  let t = /* @__PURE__ */ new Map();
  for (let u of r.seen.entries()) {
    let $ = r.metadataRegistry.get(u[0])?.id;
    if ($) {
      let l = t.get($);
      if (l && l !== u[0]) throw Error(`Duplicate schema id "${$}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      t.set($, u[0]);
    }
  }
  let n = (u) => {
    let $ = r.target === "draft-2020-12" ? "$defs" : "definitions";
    if (r.external) {
      let _ = r.external.registry.get(u[0])?.id, N = r.external.uri ?? ((J) => J);
      if (_) return { ref: N(_) };
      let O = u[1].defId ?? u[1].schema.id ?? `schema${r.counter++}`;
      return u[1].defId = O, { defId: O, ref: `${N("__shared")}#/${$}/${O}` };
    }
    if (u[1] === o) return { ref: "#" };
    let e = `${"#"}/${$}/`, I = u[1].schema.id ?? `__schema${r.counter++}`;
    return { defId: I, ref: e + I };
  }, v = (u) => {
    if (u[1].schema.$ref) return;
    let $ = u[1], { ref: l, defId: e } = n(u);
    if ($.def = { ...$.schema }, e) $.defId = e;
    let I = $.schema;
    for (let _ in I) delete I[_];
    I.$ref = l;
  };
  if (r.cycles === "throw") for (let u of r.seen.entries()) {
    let $ = u[1];
    if ($.cycle) throw Error(`Cycle detected: #/${$.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
  }
  for (let u of r.seen.entries()) {
    let $ = u[1];
    if (i === u[0]) {
      v(u);
      continue;
    }
    if (r.external) {
      let e = r.external.registry.get(u[0])?.id;
      if (i !== u[0] && e) {
        v(u);
        continue;
      }
    }
    if (r.metadataRegistry.get(u[0])?.id) {
      v(u);
      continue;
    }
    if ($.cycle) {
      v(u);
      continue;
    }
    if ($.count > 1) {
      if (r.reused === "ref") {
        v(u);
        continue;
      }
    }
  }
}
function cr(r, i) {
  let o = r.seen.get(i);
  if (!o) throw Error("Unprocessed schema. This is a bug in Zod.");
  let t = (u) => {
    let $ = r.seen.get(u);
    if ($.ref === null) return;
    let l = $.def ?? $.schema, e = { ...l }, I = $.ref;
    if ($.ref = null, I) {
      t(I);
      let N = r.seen.get(I), O = N.schema;
      if (O.$ref && (r.target === "draft-07" || r.target === "draft-04" || r.target === "openapi-3.0")) l.allOf = l.allOf ?? [], l.allOf.push(O);
      else Object.assign(l, O);
      if (Object.assign(l, e), u._zod.parent === I) for (let X in l) {
        if (X === "$ref" || X === "allOf") continue;
        if (!(X in e)) delete l[X];
      }
      if (O.$ref) for (let X in l) {
        if (X === "$ref" || X === "allOf") continue;
        if (X in N.def && JSON.stringify(l[X]) === JSON.stringify(N.def[X])) delete l[X];
      }
    }
    let _ = u._zod.parent;
    if (_ && _ !== I) {
      t(_);
      let N = r.seen.get(_);
      if (N?.schema.$ref) {
        if (l.$ref = N.schema.$ref, N.def) for (let O in l) {
          if (O === "$ref" || O === "allOf") continue;
          if (O in N.def && JSON.stringify(l[O]) === JSON.stringify(N.def[O])) delete l[O];
        }
      }
    }
    r.override({ zodSchema: u, jsonSchema: l, path: $.path ?? [] });
  };
  for (let u of [...r.seen.entries()].reverse()) t(u[0]);
  let n = {};
  if (r.target === "draft-2020-12") n.$schema = "https://json-schema.org/draft/2020-12/schema";
  else if (r.target === "draft-07") n.$schema = "http://json-schema.org/draft-07/schema#";
  else if (r.target === "draft-04") n.$schema = "http://json-schema.org/draft-04/schema#";
  else if (r.target === "openapi-3.0") ;
  if (r.external?.uri) {
    let u = r.external.registry.get(i)?.id;
    if (!u) throw Error("Schema is missing an `id` property");
    n.$id = r.external.uri(u);
  }
  Object.assign(n, o.def ?? o.schema);
  let v = r.external?.defs ?? {};
  for (let u of r.seen.entries()) {
    let $ = u[1];
    if ($.def && $.defId) v[$.defId] = $.def;
  }
  if (r.external) ;
  else if (Object.keys(v).length > 0) if (r.target === "draft-2020-12") n.$defs = v;
  else n.definitions = v;
  try {
    let u = JSON.parse(JSON.stringify(n));
    return Object.defineProperty(u, "~standard", { value: { ...i["~standard"], jsonSchema: { input: xr(i, "input", r.processors), output: xr(i, "output", r.processors) } }, enumerable: false, writable: false }), u;
  } catch (u) {
    throw Error("Error converting schema to JSON.");
  }
}
function Q(r, i) {
  let o = i ?? { seen: /* @__PURE__ */ new Set() };
  if (o.seen.has(r)) return false;
  o.seen.add(r);
  let t = r._zod.def;
  if (t.type === "transform") return true;
  if (t.type === "array") return Q(t.element, o);
  if (t.type === "set") return Q(t.valueType, o);
  if (t.type === "lazy") return Q(t.getter(), o);
  if (t.type === "promise" || t.type === "optional" || t.type === "nonoptional" || t.type === "nullable" || t.type === "readonly" || t.type === "default" || t.type === "prefault") return Q(t.innerType, o);
  if (t.type === "intersection") return Q(t.left, o) || Q(t.right, o);
  if (t.type === "record" || t.type === "map") return Q(t.keyType, o) || Q(t.valueType, o);
  if (t.type === "pipe") return Q(t.in, o) || Q(t.out, o);
  if (t.type === "object") {
    for (let n in t.shape) if (Q(t.shape[n], o)) return true;
    return false;
  }
  if (t.type === "union") {
    for (let n of t.options) if (Q(n, o)) return true;
    return false;
  }
  if (t.type === "tuple") {
    for (let n of t.items) if (Q(n, o)) return true;
    if (t.rest && Q(t.rest, o)) return true;
    return false;
  }
  return false;
}
var w$ = (r, i = {}) => (o) => {
  let t = er({ ...o, processors: i });
  return L(r, t), lr(t, r), cr(t, r);
};
var xr = (r, i, o = {}) => (t) => {
  let { libraryOptions: n, target: v } = t ?? {}, u = er({ ...n ?? {}, target: v, io: i, processors: o });
  return L(r, u), lr(u, r), cr(u, r);
};
var O6 = { guid: "uuid", url: "uri", datetime: "date-time", json_string: "json-string", regex: "" };
var N$ = (r, i, o, t) => {
  let n = o;
  n.type = "string";
  let { minimum: v, maximum: u, format: $, patterns: l, contentEncoding: e } = r._zod.bag;
  if (typeof v === "number") n.minLength = v;
  if (typeof u === "number") n.maxLength = u;
  if ($) {
    if (n.format = O6[$] ?? $, n.format === "") delete n.format;
    if ($ === "time") delete n.format;
  }
  if (e) n.contentEncoding = e;
  if (l && l.size > 0) {
    let I = [...l];
    if (I.length === 1) n.pattern = I[0].source;
    else if (I.length > 1) n.allOf = [...I.map((_) => ({ ...i.target === "draft-07" || i.target === "draft-04" || i.target === "openapi-3.0" ? { type: "string" } : {}, pattern: _.source }))];
  }
};
var O$ = (r, i, o, t) => {
  let n = o, { minimum: v, maximum: u, format: $, multipleOf: l, exclusiveMaximum: e, exclusiveMinimum: I } = r._zod.bag;
  if (typeof $ === "string" && $.includes("int")) n.type = "integer";
  else n.type = "number";
  if (typeof I === "number") if (i.target === "draft-04" || i.target === "openapi-3.0") n.minimum = I, n.exclusiveMinimum = true;
  else n.exclusiveMinimum = I;
  if (typeof v === "number") {
    if (n.minimum = v, typeof I === "number" && i.target !== "draft-04") if (I >= v) delete n.minimum;
    else delete n.exclusiveMinimum;
  }
  if (typeof e === "number") if (i.target === "draft-04" || i.target === "openapi-3.0") n.maximum = e, n.exclusiveMaximum = true;
  else n.exclusiveMaximum = e;
  if (typeof u === "number") {
    if (n.maximum = u, typeof e === "number" && i.target !== "draft-04") if (e <= u) delete n.maximum;
    else delete n.exclusiveMaximum;
  }
  if (typeof l === "number") n.multipleOf = l;
};
var S$ = (r, i, o, t) => {
  o.type = "boolean";
};
var z$ = (r, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("BigInt cannot be represented in JSON Schema");
};
var P$ = (r, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("Symbols cannot be represented in JSON Schema");
};
var j$ = (r, i, o, t) => {
  if (i.target === "openapi-3.0") o.type = "string", o.nullable = true, o.enum = [null];
  else o.type = "null";
};
var J$ = (r, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("Undefined cannot be represented in JSON Schema");
};
var L$ = (r, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("Void cannot be represented in JSON Schema");
};
var E$ = (r, i, o, t) => {
  o.not = {};
};
var G$ = (r, i, o, t) => {
};
var W$ = (r, i, o, t) => {
};
var X$ = (r, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("Date cannot be represented in JSON Schema");
};
var V$ = (r, i, o, t) => {
  let n = r._zod.def, v = nn(n.entries);
  if (v.every((u) => typeof u === "number")) o.type = "number";
  if (v.every((u) => typeof u === "string")) o.type = "string";
  o.enum = v;
};
var A$ = (r, i, o, t) => {
  let n = r._zod.def, v = [];
  for (let u of n.values) if (u === void 0) {
    if (i.unrepresentable === "throw") throw Error("Literal `undefined` cannot be represented in JSON Schema");
  } else if (typeof u === "bigint") if (i.unrepresentable === "throw") throw Error("BigInt literals cannot be represented in JSON Schema");
  else v.push(Number(u));
  else v.push(u);
  if (v.length === 0) ;
  else if (v.length === 1) {
    let u = v[0];
    if (o.type = u === null ? "null" : typeof u, i.target === "draft-04" || i.target === "openapi-3.0") o.enum = [u];
    else o.const = u;
  } else {
    if (v.every((u) => typeof u === "number")) o.type = "number";
    if (v.every((u) => typeof u === "string")) o.type = "string";
    if (v.every((u) => typeof u === "boolean")) o.type = "boolean";
    if (v.every((u) => u === null)) o.type = "null";
    o.enum = v;
  }
};
var K$ = (r, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("NaN cannot be represented in JSON Schema");
};
var q$ = (r, i, o, t) => {
  let n = o, v = r._zod.pattern;
  if (!v) throw Error("Pattern not found in template literal");
  n.type = "string", n.pattern = v.source;
};
var Y$ = (r, i, o, t) => {
  let n = o, v = { type: "string", format: "binary", contentEncoding: "binary" }, { minimum: u, maximum: $, mime: l } = r._zod.bag;
  if (u !== void 0) v.minLength = u;
  if ($ !== void 0) v.maxLength = $;
  if (l) if (l.length === 1) v.contentMediaType = l[0], Object.assign(n, v);
  else Object.assign(n, v), n.anyOf = l.map((e) => ({ contentMediaType: e }));
  else Object.assign(n, v);
};
var Q$ = (r, i, o, t) => {
  o.type = "boolean";
};
var m$ = (r, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("Custom types cannot be represented in JSON Schema");
};
var T$ = (r, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("Function types cannot be represented in JSON Schema");
};
var F$ = (r, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("Transforms cannot be represented in JSON Schema");
};
var B$ = (r, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("Map cannot be represented in JSON Schema");
};
var H$ = (r, i, o, t) => {
  if (i.unrepresentable === "throw") throw Error("Set cannot be represented in JSON Schema");
};
var M$ = (r, i, o, t) => {
  let n = o, v = r._zod.def, { minimum: u, maximum: $ } = r._zod.bag;
  if (typeof u === "number") n.minItems = u;
  if (typeof $ === "number") n.maxItems = $;
  n.type = "array", n.items = L(v.element, i, { ...t, path: [...t.path, "items"] });
};
var R$ = (r, i, o, t) => {
  let n = o, v = r._zod.def;
  n.type = "object", n.properties = {};
  let u = v.shape;
  for (let e in u) n.properties[e] = L(u[e], i, { ...t, path: [...t.path, "properties", e] });
  let $ = new Set(Object.keys(u)), l = new Set([...$].filter((e) => {
    let I = v.shape[e]._zod;
    if (i.io === "input") return I.optin === void 0;
    else return I.optout === void 0;
  }));
  if (l.size > 0) n.required = Array.from(l);
  if (v.catchall?._zod.def.type === "never") n.additionalProperties = false;
  else if (!v.catchall) {
    if (i.io === "output") n.additionalProperties = false;
  } else if (v.catchall) n.additionalProperties = L(v.catchall, i, { ...t, path: [...t.path, "additionalProperties"] });
};
var qi = (r, i, o, t) => {
  let n = r._zod.def, v = n.inclusive === false, u = n.options.map(($, l) => L($, i, { ...t, path: [...t.path, v ? "oneOf" : "anyOf", l] }));
  if (v) o.oneOf = u;
  else o.anyOf = u;
};
var x$ = (r, i, o, t) => {
  let n = r._zod.def, v = L(n.left, i, { ...t, path: [...t.path, "allOf", 0] }), u = L(n.right, i, { ...t, path: [...t.path, "allOf", 1] }), $ = (e) => "allOf" in e && Object.keys(e).length === 1, l = [...$(v) ? v.allOf : [v], ...$(u) ? u.allOf : [u]];
  o.allOf = l;
};
var Z$ = (r, i, o, t) => {
  let n = o, v = r._zod.def;
  n.type = "array";
  let u = i.target === "draft-2020-12" ? "prefixItems" : "items", $ = i.target === "draft-2020-12" ? "items" : i.target === "openapi-3.0" ? "items" : "additionalItems", l = v.items.map((N, O) => L(N, i, { ...t, path: [...t.path, u, O] })), e = v.rest ? L(v.rest, i, { ...t, path: [...t.path, $, ...i.target === "openapi-3.0" ? [v.items.length] : []] }) : null;
  if (i.target === "draft-2020-12") {
    if (n.prefixItems = l, e) n.items = e;
  } else if (i.target === "openapi-3.0") {
    if (n.items = { anyOf: l }, e) n.items.anyOf.push(e);
    if (n.minItems = l.length, !e) n.maxItems = l.length;
  } else if (n.items = l, e) n.additionalItems = e;
  let { minimum: I, maximum: _ } = r._zod.bag;
  if (typeof I === "number") n.minItems = I;
  if (typeof _ === "number") n.maxItems = _;
};
var d$ = (r, i, o, t) => {
  let n = o, v = r._zod.def;
  n.type = "object";
  let u = v.keyType, l = u._zod.bag?.patterns;
  if (v.mode === "loose" && l && l.size > 0) {
    let I = L(v.valueType, i, { ...t, path: [...t.path, "patternProperties", "*"] });
    n.patternProperties = {};
    for (let _ of l) n.patternProperties[_.source] = I;
  } else {
    if (i.target === "draft-07" || i.target === "draft-2020-12") n.propertyNames = L(v.keyType, i, { ...t, path: [...t.path, "propertyNames"] });
    n.additionalProperties = L(v.valueType, i, { ...t, path: [...t.path, "additionalProperties"] });
  }
  let e = u._zod.values;
  if (e) {
    let I = [...e].filter((_) => typeof _ === "string" || typeof _ === "number");
    if (I.length > 0) n.required = I;
  }
};
var C$ = (r, i, o, t) => {
  let n = r._zod.def, v = L(n.innerType, i, t), u = i.seen.get(r);
  if (i.target === "openapi-3.0") u.ref = n.innerType, o.nullable = true;
  else o.anyOf = [v, { type: "null" }];
};
var f$ = (r, i, o, t) => {
  let n = r._zod.def;
  L(n.innerType, i, t);
  let v = i.seen.get(r);
  v.ref = n.innerType;
};
var h$ = (r, i, o, t) => {
  let n = r._zod.def;
  L(n.innerType, i, t);
  let v = i.seen.get(r);
  v.ref = n.innerType, o.default = JSON.parse(JSON.stringify(n.defaultValue));
};
var y$ = (r, i, o, t) => {
  let n = r._zod.def;
  L(n.innerType, i, t);
  let v = i.seen.get(r);
  if (v.ref = n.innerType, i.io === "input") o._prefault = JSON.parse(JSON.stringify(n.defaultValue));
};
var a$ = (r, i, o, t) => {
  let n = r._zod.def;
  L(n.innerType, i, t);
  let v = i.seen.get(r);
  v.ref = n.innerType;
  let u;
  try {
    u = n.catchValue(void 0);
  } catch {
    throw Error("Dynamic catch values are not supported in JSON Schema");
  }
  o.default = u;
};
var p$ = (r, i, o, t) => {
  let n = r._zod.def, v = i.io === "input" ? n.in._zod.def.type === "transform" ? n.out : n.in : n.out;
  L(v, i, t);
  let u = i.seen.get(r);
  u.ref = v;
};
var s$ = (r, i, o, t) => {
  let n = r._zod.def;
  L(n.innerType, i, t);
  let v = i.seen.get(r);
  v.ref = n.innerType, o.readOnly = true;
};
var rg = (r, i, o, t) => {
  let n = r._zod.def;
  L(n.innerType, i, t);
  let v = i.seen.get(r);
  v.ref = n.innerType;
};
var Yi = (r, i, o, t) => {
  let n = r._zod.def;
  L(n.innerType, i, t);
  let v = i.seen.get(r);
  v.ref = n.innerType;
};
var ng = (r, i, o, t) => {
  let n = r._zod.innerType;
  L(n, i, t);
  let v = i.seen.get(r);
  v.ref = n;
};
var Ki = { string: N$, number: O$, boolean: S$, bigint: z$, symbol: P$, null: j$, undefined: J$, void: L$, never: E$, any: G$, unknown: W$, date: X$, enum: V$, literal: A$, nan: K$, template_literal: q$, file: Y$, success: Q$, custom: m$, function: T$, transform: F$, map: B$, set: H$, array: M$, object: R$, union: qi, intersection: x$, tuple: Z$, record: d$, nullable: C$, nonoptional: f$, default: h$, prefault: y$, catch: a$, pipe: p$, readonly: s$, promise: rg, optional: Yi, lazy: ng };
function Qi(r, i) {
  if ("_idmap" in r) {
    let t = r, n = er({ ...i, processors: Ki }), v = {};
    for (let l of t._idmap.entries()) {
      let [e, I] = l;
      L(I, n);
    }
    let u = {}, $ = { registry: t, uri: i?.uri, defs: v };
    n.external = $;
    for (let l of t._idmap.entries()) {
      let [e, I] = l;
      lr(n, I), u[e] = cr(n, I);
    }
    if (Object.keys(v).length > 0) {
      let l = n.target === "draft-2020-12" ? "$defs" : "definitions";
      u.__shared = { [l]: v };
    }
    return { schemas: u };
  }
  let o = er({ ...i, processors: Ki });
  return L(r, o), lr(o, r), cr(o, r);
}
var ig = class {
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  get target() {
    return this.ctx.target;
  }
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  get override() {
    return this.ctx.override;
  }
  get io() {
    return this.ctx.io;
  }
  get counter() {
    return this.ctx.counter;
  }
  set counter(r) {
    this.ctx.counter = r;
  }
  get seen() {
    return this.ctx.seen;
  }
  constructor(r) {
    let i = r?.target ?? "draft-2020-12";
    if (i === "draft-4") i = "draft-04";
    if (i === "draft-7") i = "draft-07";
    this.ctx = er({ processors: Ki, target: i, ...r?.metadata && { metadata: r.metadata }, ...r?.unrepresentable && { unrepresentable: r.unrepresentable }, ...r?.override && { override: r.override }, ...r?.io && { io: r.io } });
  }
  process(r, i = { path: [], schemaPath: [] }) {
    return L(r, this.ctx, i);
  }
  emit(r, i) {
    if (i) {
      if (i.cycles) this.ctx.cycles = i.cycles;
      if (i.reused) this.ctx.reused = i.reused;
      if (i.external) this.ctx.external = i.external;
    }
    lr(this.ctx, r);
    let o = cr(this.ctx, r), { "~standard": t, ...n } = o;
    return n;
  }
};
var ol = {};
var Pn = {};
s(Pn, { xor: () => yl, xid: () => Nl, void: () => xl, uuidv7: () => cl, uuidv6: () => ll, uuidv4: () => el, uuid: () => gl, url: () => Il, unknown: () => Nr, union: () => ev, undefined: () => Ml, ulid: () => wl, uint64: () => Bl, uint32: () => ml, tuple: () => Qg, transform: () => cv, templateLiteral: () => ec, symbol: () => Hl, superRefine: () => ee, success: () => uc, stringbool: () => Dc, stringFormat: () => Xl, string: () => Mi, strictObject: () => fl, set: () => nc, refine: () => ge, record: () => mg, readonly: () => ie, promise: () => lc, preprocess: () => Nc, prefault: () => hg, pipe: () => En, partialRecord: () => pl, optional: () => Jn, object: () => Cl, number: () => Og, nullish: () => tc, nullable: () => Ln, null: () => Jg, nonoptional: () => yg, never: () => gv, nativeEnum: () => ic, nanoid: () => Ul, nan: () => $c, meta: () => Uc, map: () => rc, mac: () => zl, looseRecord: () => sl, looseObject: () => hl, literal: () => vc, lazy: () => te, ksuid: () => Ol, keyof: () => dl, jwt: () => Wl, json: () => wc, ipv6: () => Pl, ipv4: () => Sl, intersection: () => qg, int64: () => Fl, int32: () => Ql, int: () => Ri, instanceof: () => kc, httpUrl: () => bl, hostname: () => Vl, hex: () => Al, hash: () => Kl, guid: () => $l, function: () => cc, float64: () => Yl, float32: () => ql, file: () => oc, exactOptional: () => xg, enum: () => lv, emoji: () => _l, email: () => ul, e164: () => Gl, discriminatedUnion: () => al, describe: () => _c, date: () => Zl, custom: () => bc, cuid2: () => Dl, cuid: () => kl, codec: () => gc, cidrv6: () => Jl, cidrv4: () => jl, check: () => Ic, catch: () => sg, boolean: () => Sg, bigint: () => Tl, base64url: () => El, base64: () => Ll, array: () => Xn, any: () => Rl, _function: () => cc, _default: () => Cg, _ZodString: () => xi, ZodXor: () => Vg, ZodXID: () => ai, ZodVoid: () => Wg, ZodUnknown: () => Eg, ZodUnion: () => An, ZodUndefined: () => Pg, ZodUUID: () => p, ZodURL: () => Gn, ZodULID: () => yi, ZodType: () => P, ZodTuple: () => Yg, ZodTransform: () => Mg, ZodTemplateLiteral: () => ve, ZodSymbol: () => zg, ZodSuccess: () => ag, ZodStringFormat: () => G, ZodString: () => Cr, ZodSet: () => Fg, ZodRecord: () => Kn, ZodReadonly: () => ne, ZodPromise: () => ue, ZodPrefault: () => fg, ZodPipe: () => _v, ZodOptional: () => Iv, ZodObject: () => Vn, ZodNumberFormat: () => Or, ZodNumber: () => hr, ZodNullable: () => Zg, ZodNull: () => jg, ZodNonOptional: () => bv, ZodNever: () => Gg, ZodNanoID: () => Ci, ZodNaN: () => re, ZodMap: () => Tg, ZodMAC: () => Ng, ZodLiteral: () => Bg, ZodLazy: () => oe, ZodKSUID: () => pi, ZodJWT: () => uv, ZodIntersection: () => Kg, ZodIPv6: () => rv, ZodIPv4: () => si, ZodGUID: () => jn, ZodFunction: () => $e, ZodFile: () => Hg, ZodExactOptional: () => Rg, ZodEnum: () => dr, ZodEmoji: () => di, ZodEmail: () => Zi, ZodE164: () => tv, ZodDiscriminatedUnion: () => Ag, ZodDefault: () => dg, ZodDate: () => Wn, ZodCustomStringFormat: () => fr, ZodCustom: () => qn, ZodCodec: () => Uv, ZodCatch: () => pg, ZodCUID2: () => hi, ZodCUID: () => fi, ZodCIDRv6: () => iv, ZodCIDRv4: () => nv, ZodBoolean: () => yr, ZodBigIntFormat: () => $v, ZodBigInt: () => ar, ZodBase64URL: () => ov, ZodBase64: () => vv, ZodArray: () => Xg, ZodAny: () => Lg });
var mi = {};
s(mi, { uppercase: () => Kr, trim: () => Fr, toUpperCase: () => Hr, toLowerCase: () => Br, startsWith: () => Yr, slugify: () => Mr, size: () => kr, regex: () => Vr, property: () => Ai, positive: () => Gi, overwrite: () => d, normalize: () => Tr, nonpositive: () => Xi, nonnegative: () => Vi, negative: () => Wi, multipleOf: () => $r, minSize: () => a, minLength: () => nr, mime: () => mr, maxSize: () => gr, maxLength: () => Dr, lte: () => M, lt: () => h, lowercase: () => Ar, length: () => wr, includes: () => qr, gte: () => Y, gt: () => y, endsWith: () => Qr });
var Zr = {};
s(Zr, { time: () => tg, duration: () => ug, datetime: () => vg, date: () => og, ZodISOTime: () => Bi, ZodISODuration: () => Hi, ZodISODateTime: () => Ti, ZodISODate: () => Fi });
var Ti = c("ZodISODateTime", (r, i) => {
  Fo.init(r, i), G.init(r, i);
});
function vg(r) {
  return mu(Ti, r);
}
var Fi = c("ZodISODate", (r, i) => {
  Bo.init(r, i), G.init(r, i);
});
function og(r) {
  return Tu(Fi, r);
}
var Bi = c("ZodISOTime", (r, i) => {
  Ho.init(r, i), G.init(r, i);
});
function tg(r) {
  return Fu(Bi, r);
}
var Hi = c("ZodISODuration", (r, i) => {
  Mo.init(r, i), G.init(r, i);
});
function ug(r) {
  return Bu(Hi, r);
}
var tl = (r, i) => {
  $n.init(r, i), r.name = "ZodError", Object.defineProperties(r, { format: { value: (o) => en(r, o) }, flatten: { value: (o) => gn(r, o) }, addIssue: { value: (o) => {
    r.issues.push(o), r.message = JSON.stringify(r.issues, zr, 2);
  } }, addIssues: { value: (o) => {
    r.issues.push(...o), r.message = JSON.stringify(r.issues, zr, 2);
  } }, isEmpty: { get() {
    return r.issues.length === 0;
  } } });
};
var z6 = c("ZodError", tl);
var B = c("ZodError", tl, { Parent: Error });
var $g = Jr(B);
var gg = Lr(B);
var eg = Er(B);
var lg = Gr(B);
var cg = Bn(B);
var Ig = Hn(B);
var bg = Mn(B);
var _g = Rn(B);
var Ug = xn(B);
var kg = Zn(B);
var Dg = dn(B);
var wg = Cn(B);
var P = c("ZodType", (r, i) => {
  return z.init(r, i), Object.assign(r["~standard"], { jsonSchema: { input: xr(r, "input"), output: xr(r, "output") } }), r.toJSONSchema = w$(r, {}), r.def = i, r.type = i.type, Object.defineProperty(r, "_def", { value: i }), r.check = (...o) => {
    return r.clone(D.mergeDefs(i, { checks: [...i.checks ?? [], ...o.map((t) => typeof t === "function" ? { _zod: { check: t, def: { check: "custom" }, onattach: [] } } : t)] }), { parent: true });
  }, r.with = r.check, r.clone = (o, t) => q(r, o, t), r.brand = () => r, r.register = (o, t) => {
    return o.add(r, t), r;
  }, r.parse = (o, t) => $g(r, o, t, { callee: r.parse }), r.safeParse = (o, t) => eg(r, o, t), r.parseAsync = async (o, t) => gg(r, o, t, { callee: r.parseAsync }), r.safeParseAsync = async (o, t) => lg(r, o, t), r.spa = r.safeParseAsync, r.encode = (o, t) => cg(r, o, t), r.decode = (o, t) => Ig(r, o, t), r.encodeAsync = async (o, t) => bg(r, o, t), r.decodeAsync = async (o, t) => _g(r, o, t), r.safeEncode = (o, t) => Ug(r, o, t), r.safeDecode = (o, t) => kg(r, o, t), r.safeEncodeAsync = async (o, t) => Dg(r, o, t), r.safeDecodeAsync = async (o, t) => wg(r, o, t), r.refine = (o, t) => r.check(ge(o, t)), r.superRefine = (o) => r.check(ee(o)), r.overwrite = (o) => r.check(d(o)), r.optional = () => Jn(r), r.exactOptional = () => xg(r), r.nullable = () => Ln(r), r.nullish = () => Jn(Ln(r)), r.nonoptional = (o) => yg(r, o), r.array = () => Xn(r), r.or = (o) => ev([r, o]), r.and = (o) => qg(r, o), r.transform = (o) => En(r, cv(o)), r.default = (o) => Cg(r, o), r.prefault = (o) => hg(r, o), r.catch = (o) => sg(r, o), r.pipe = (o) => En(r, o), r.readonly = () => ie(r), r.describe = (o) => {
    let t = r.clone();
    return A.add(t, { description: o }), t;
  }, Object.defineProperty(r, "description", { get() {
    return A.get(r)?.description;
  }, configurable: true }), r.meta = (...o) => {
    if (o.length === 0) return A.get(r);
    let t = r.clone();
    return A.add(t, o[0]), t;
  }, r.isOptional = () => r.safeParse(void 0).success, r.isNullable = () => r.safeParse(null).success, r.apply = (o) => o(r), r;
});
var xi = c("_ZodString", (r, i) => {
  Ur.init(r, i), P.init(r, i), r._zod.processJSONSchema = (t, n, v) => N$(r, t, n, v);
  let o = r._zod.bag;
  r.format = o.format ?? null, r.minLength = o.minimum ?? null, r.maxLength = o.maximum ?? null, r.regex = (...t) => r.check(Vr(...t)), r.includes = (...t) => r.check(qr(...t)), r.startsWith = (...t) => r.check(Yr(...t)), r.endsWith = (...t) => r.check(Qr(...t)), r.min = (...t) => r.check(nr(...t)), r.max = (...t) => r.check(Dr(...t)), r.length = (...t) => r.check(wr(...t)), r.nonempty = (...t) => r.check(nr(1, ...t)), r.lowercase = (t) => r.check(Ar(t)), r.uppercase = (t) => r.check(Kr(t)), r.trim = () => r.check(Fr()), r.normalize = (...t) => r.check(Tr(...t)), r.toLowerCase = () => r.check(Br()), r.toUpperCase = () => r.check(Hr()), r.slugify = () => r.check(Mr());
});
var Cr = c("ZodString", (r, i) => {
  Ur.init(r, i), xi.init(r, i), r.email = (o) => r.check(gi(Zi, o)), r.url = (o) => r.check(zn(Gn, o)), r.jwt = (o) => r.check(Ei(uv, o)), r.emoji = (o) => r.check(bi(di, o)), r.guid = (o) => r.check(Sn(jn, o)), r.uuid = (o) => r.check(ei(p, o)), r.uuidv4 = (o) => r.check(li(p, o)), r.uuidv6 = (o) => r.check(ci(p, o)), r.uuidv7 = (o) => r.check(Ii(p, o)), r.nanoid = (o) => r.check(_i(Ci, o)), r.guid = (o) => r.check(Sn(jn, o)), r.cuid = (o) => r.check(Ui(fi, o)), r.cuid2 = (o) => r.check(ki(hi, o)), r.ulid = (o) => r.check(Di(yi, o)), r.base64 = (o) => r.check(ji(vv, o)), r.base64url = (o) => r.check(Ji(ov, o)), r.xid = (o) => r.check(wi(ai, o)), r.ksuid = (o) => r.check(Ni(pi, o)), r.ipv4 = (o) => r.check(Oi(si, o)), r.ipv6 = (o) => r.check(Si(rv, o)), r.cidrv4 = (o) => r.check(zi(nv, o)), r.cidrv6 = (o) => r.check(Pi(iv, o)), r.e164 = (o) => r.check(Li(tv, o)), r.datetime = (o) => r.check(vg(o)), r.date = (o) => r.check(og(o)), r.time = (o) => r.check(tg(o)), r.duration = (o) => r.check(ug(o));
});
function Mi(r) {
  return Ku(Cr, r);
}
var G = c("ZodStringFormat", (r, i) => {
  E.init(r, i), xi.init(r, i);
});
var Zi = c("ZodEmail", (r, i) => {
  Xo.init(r, i), G.init(r, i);
});
function ul(r) {
  return gi(Zi, r);
}
var jn = c("ZodGUID", (r, i) => {
  Go.init(r, i), G.init(r, i);
});
function $l(r) {
  return Sn(jn, r);
}
var p = c("ZodUUID", (r, i) => {
  Wo.init(r, i), G.init(r, i);
});
function gl(r) {
  return ei(p, r);
}
function el(r) {
  return li(p, r);
}
function ll(r) {
  return ci(p, r);
}
function cl(r) {
  return Ii(p, r);
}
var Gn = c("ZodURL", (r, i) => {
  Vo.init(r, i), G.init(r, i);
});
function Il(r) {
  return zn(Gn, r);
}
function bl(r) {
  return zn(Gn, { protocol: /^https?$/, hostname: x.domain, ...D.normalizeParams(r) });
}
var di = c("ZodEmoji", (r, i) => {
  Ao.init(r, i), G.init(r, i);
});
function _l(r) {
  return bi(di, r);
}
var Ci = c("ZodNanoID", (r, i) => {
  Ko.init(r, i), G.init(r, i);
});
function Ul(r) {
  return _i(Ci, r);
}
var fi = c("ZodCUID", (r, i) => {
  qo.init(r, i), G.init(r, i);
});
function kl(r) {
  return Ui(fi, r);
}
var hi = c("ZodCUID2", (r, i) => {
  Yo.init(r, i), G.init(r, i);
});
function Dl(r) {
  return ki(hi, r);
}
var yi = c("ZodULID", (r, i) => {
  Qo.init(r, i), G.init(r, i);
});
function wl(r) {
  return Di(yi, r);
}
var ai = c("ZodXID", (r, i) => {
  mo.init(r, i), G.init(r, i);
});
function Nl(r) {
  return wi(ai, r);
}
var pi = c("ZodKSUID", (r, i) => {
  To.init(r, i), G.init(r, i);
});
function Ol(r) {
  return Ni(pi, r);
}
var si = c("ZodIPv4", (r, i) => {
  Ro.init(r, i), G.init(r, i);
});
function Sl(r) {
  return Oi(si, r);
}
var Ng = c("ZodMAC", (r, i) => {
  Zo.init(r, i), G.init(r, i);
});
function zl(r) {
  return Yu(Ng, r);
}
var rv = c("ZodIPv6", (r, i) => {
  xo.init(r, i), G.init(r, i);
});
function Pl(r) {
  return Si(rv, r);
}
var nv = c("ZodCIDRv4", (r, i) => {
  Co.init(r, i), G.init(r, i);
});
function jl(r) {
  return zi(nv, r);
}
var iv = c("ZodCIDRv6", (r, i) => {
  fo.init(r, i), G.init(r, i);
});
function Jl(r) {
  return Pi(iv, r);
}
var vv = c("ZodBase64", (r, i) => {
  yo.init(r, i), G.init(r, i);
});
function Ll(r) {
  return ji(vv, r);
}
var ov = c("ZodBase64URL", (r, i) => {
  ao.init(r, i), G.init(r, i);
});
function El(r) {
  return Ji(ov, r);
}
var tv = c("ZodE164", (r, i) => {
  po.init(r, i), G.init(r, i);
});
function Gl(r) {
  return Li(tv, r);
}
var uv = c("ZodJWT", (r, i) => {
  so.init(r, i), G.init(r, i);
});
function Wl(r) {
  return Ei(uv, r);
}
var fr = c("ZodCustomStringFormat", (r, i) => {
  rt.init(r, i), G.init(r, i);
});
function Xl(r, i, o = {}) {
  return Rr(fr, r, i, o);
}
function Vl(r) {
  return Rr(fr, "hostname", x.hostname, r);
}
function Al(r) {
  return Rr(fr, "hex", x.hex, r);
}
function Kl(r, i) {
  let o = i?.enc ?? "hex", t = `${r}_${o}`, n = x[t];
  if (!n) throw Error(`Unrecognized hash format: ${t}`);
  return Rr(fr, t, n, i);
}
var hr = c("ZodNumber", (r, i) => {
  vi.init(r, i), P.init(r, i), r._zod.processJSONSchema = (t, n, v) => O$(r, t, n, v), r.gt = (t, n) => r.check(y(t, n)), r.gte = (t, n) => r.check(Y(t, n)), r.min = (t, n) => r.check(Y(t, n)), r.lt = (t, n) => r.check(h(t, n)), r.lte = (t, n) => r.check(M(t, n)), r.max = (t, n) => r.check(M(t, n)), r.int = (t) => r.check(Ri(t)), r.safe = (t) => r.check(Ri(t)), r.positive = (t) => r.check(y(0, t)), r.nonnegative = (t) => r.check(Y(0, t)), r.negative = (t) => r.check(h(0, t)), r.nonpositive = (t) => r.check(M(0, t)), r.multipleOf = (t, n) => r.check($r(t, n)), r.step = (t, n) => r.check($r(t, n)), r.finite = () => r;
  let o = r._zod.bag;
  r.minValue = Math.max(o.minimum ?? Number.NEGATIVE_INFINITY, o.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, r.maxValue = Math.min(o.maximum ?? Number.POSITIVE_INFINITY, o.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, r.isInt = (o.format ?? "").includes("int") || Number.isSafeInteger(o.multipleOf ?? 0.5), r.isFinite = true, r.format = o.format ?? null;
});
function Og(r) {
  return Hu(hr, r);
}
var Or = c("ZodNumberFormat", (r, i) => {
  nt.init(r, i), hr.init(r, i);
});
function Ri(r) {
  return Ru(Or, r);
}
function ql(r) {
  return xu(Or, r);
}
function Yl(r) {
  return Zu(Or, r);
}
function Ql(r) {
  return du(Or, r);
}
function ml(r) {
  return Cu(Or, r);
}
var yr = c("ZodBoolean", (r, i) => {
  bn.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => S$(r, o, t, n);
});
function Sg(r) {
  return fu(yr, r);
}
var ar = c("ZodBigInt", (r, i) => {
  oi.init(r, i), P.init(r, i), r._zod.processJSONSchema = (t, n, v) => z$(r, t, n, v), r.gte = (t, n) => r.check(Y(t, n)), r.min = (t, n) => r.check(Y(t, n)), r.gt = (t, n) => r.check(y(t, n)), r.gte = (t, n) => r.check(Y(t, n)), r.min = (t, n) => r.check(Y(t, n)), r.lt = (t, n) => r.check(h(t, n)), r.lte = (t, n) => r.check(M(t, n)), r.max = (t, n) => r.check(M(t, n)), r.positive = (t) => r.check(y(BigInt(0), t)), r.negative = (t) => r.check(h(BigInt(0), t)), r.nonpositive = (t) => r.check(M(BigInt(0), t)), r.nonnegative = (t) => r.check(Y(BigInt(0), t)), r.multipleOf = (t, n) => r.check($r(t, n));
  let o = r._zod.bag;
  r.minValue = o.minimum ?? null, r.maxValue = o.maximum ?? null, r.format = o.format ?? null;
});
function Tl(r) {
  return yu(ar, r);
}
var $v = c("ZodBigIntFormat", (r, i) => {
  it.init(r, i), ar.init(r, i);
});
function Fl(r) {
  return pu($v, r);
}
function Bl(r) {
  return su($v, r);
}
var zg = c("ZodSymbol", (r, i) => {
  vt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => P$(r, o, t, n);
});
function Hl(r) {
  return r$(zg, r);
}
var Pg = c("ZodUndefined", (r, i) => {
  ot.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => J$(r, o, t, n);
});
function Ml(r) {
  return n$(Pg, r);
}
var jg = c("ZodNull", (r, i) => {
  tt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => j$(r, o, t, n);
});
function Jg(r) {
  return i$(jg, r);
}
var Lg = c("ZodAny", (r, i) => {
  ut.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => G$(r, o, t, n);
});
function Rl() {
  return v$(Lg);
}
var Eg = c("ZodUnknown", (r, i) => {
  $t.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => W$(r, o, t, n);
});
function Nr() {
  return o$(Eg);
}
var Gg = c("ZodNever", (r, i) => {
  gt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => E$(r, o, t, n);
});
function gv(r) {
  return t$(Gg, r);
}
var Wg = c("ZodVoid", (r, i) => {
  et.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => L$(r, o, t, n);
});
function xl(r) {
  return u$(Wg, r);
}
var Wn = c("ZodDate", (r, i) => {
  lt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (t, n, v) => X$(r, t, n, v), r.min = (t, n) => r.check(Y(t, n)), r.max = (t, n) => r.check(M(t, n));
  let o = r._zod.bag;
  r.minDate = o.minimum ? new Date(o.minimum) : null, r.maxDate = o.maximum ? new Date(o.maximum) : null;
});
function Zl(r) {
  return $$(Wn, r);
}
var Xg = c("ZodArray", (r, i) => {
  ct.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => M$(r, o, t, n), r.element = i.element, r.min = (o, t) => r.check(nr(o, t)), r.nonempty = (o) => r.check(nr(1, o)), r.max = (o, t) => r.check(Dr(o, t)), r.length = (o, t) => r.check(wr(o, t)), r.unwrap = () => r.element;
});
function Xn(r, i) {
  return l$(Xg, r, i);
}
function dl(r) {
  let i = r._zod.def.shape;
  return lv(Object.keys(i));
}
var Vn = c("ZodObject", (r, i) => {
  It.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => R$(r, o, t, n), D.defineLazy(r, "shape", () => {
    return i.shape;
  }), r.keyof = () => lv(Object.keys(r._zod.def.shape)), r.catchall = (o) => r.clone({ ...r._zod.def, catchall: o }), r.passthrough = () => r.clone({ ...r._zod.def, catchall: Nr() }), r.loose = () => r.clone({ ...r._zod.def, catchall: Nr() }), r.strict = () => r.clone({ ...r._zod.def, catchall: gv() }), r.strip = () => r.clone({ ...r._zod.def, catchall: void 0 }), r.extend = (o) => {
    return D.extend(r, o);
  }, r.safeExtend = (o) => {
    return D.safeExtend(r, o);
  }, r.merge = (o) => D.merge(r, o), r.pick = (o) => D.pick(r, o), r.omit = (o) => D.omit(r, o), r.partial = (...o) => D.partial(Iv, r, o[0]), r.required = (...o) => D.required(bv, r, o[0]);
});
function Cl(r, i) {
  let o = { type: "object", shape: r ?? {}, ...D.normalizeParams(i) };
  return new Vn(o);
}
function fl(r, i) {
  return new Vn({ type: "object", shape: r, catchall: gv(), ...D.normalizeParams(i) });
}
function hl(r, i) {
  return new Vn({ type: "object", shape: r, catchall: Nr(), ...D.normalizeParams(i) });
}
var An = c("ZodUnion", (r, i) => {
  _n.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => qi(r, o, t, n), r.options = i.options;
});
function ev(r, i) {
  return new An({ type: "union", options: r, ...D.normalizeParams(i) });
}
var Vg = c("ZodXor", (r, i) => {
  An.init(r, i), bt.init(r, i), r._zod.processJSONSchema = (o, t, n) => qi(r, o, t, n), r.options = i.options;
});
function yl(r, i) {
  return new Vg({ type: "union", options: r, inclusive: false, ...D.normalizeParams(i) });
}
var Ag = c("ZodDiscriminatedUnion", (r, i) => {
  An.init(r, i), _t.init(r, i);
});
function al(r, i, o) {
  return new Ag({ type: "union", options: i, discriminator: r, ...D.normalizeParams(o) });
}
var Kg = c("ZodIntersection", (r, i) => {
  Ut.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => x$(r, o, t, n);
});
function qg(r, i) {
  return new Kg({ type: "intersection", left: r, right: i });
}
var Yg = c("ZodTuple", (r, i) => {
  ti.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => Z$(r, o, t, n), r.rest = (o) => r.clone({ ...r._zod.def, rest: o });
});
function Qg(r, i, o) {
  let t = i instanceof z, n = t ? o : i;
  return new Yg({ type: "tuple", items: r, rest: t ? i : null, ...D.normalizeParams(n) });
}
var Kn = c("ZodRecord", (r, i) => {
  kt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => d$(r, o, t, n), r.keyType = i.keyType, r.valueType = i.valueType;
});
function mg(r, i, o) {
  return new Kn({ type: "record", keyType: r, valueType: i, ...D.normalizeParams(o) });
}
function pl(r, i, o) {
  let t = q(r);
  return t._zod.values = void 0, new Kn({ type: "record", keyType: t, valueType: i, ...D.normalizeParams(o) });
}
function sl(r, i, o) {
  return new Kn({ type: "record", keyType: r, valueType: i, mode: "loose", ...D.normalizeParams(o) });
}
var Tg = c("ZodMap", (r, i) => {
  Dt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => B$(r, o, t, n), r.keyType = i.keyType, r.valueType = i.valueType, r.min = (...o) => r.check(a(...o)), r.nonempty = (o) => r.check(a(1, o)), r.max = (...o) => r.check(gr(...o)), r.size = (...o) => r.check(kr(...o));
});
function rc(r, i, o) {
  return new Tg({ type: "map", keyType: r, valueType: i, ...D.normalizeParams(o) });
}
var Fg = c("ZodSet", (r, i) => {
  wt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => H$(r, o, t, n), r.min = (...o) => r.check(a(...o)), r.nonempty = (o) => r.check(a(1, o)), r.max = (...o) => r.check(gr(...o)), r.size = (...o) => r.check(kr(...o));
});
function nc(r, i) {
  return new Fg({ type: "set", valueType: r, ...D.normalizeParams(i) });
}
var dr = c("ZodEnum", (r, i) => {
  Nt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (t, n, v) => V$(r, t, n, v), r.enum = i.entries, r.options = Object.values(i.entries);
  let o = new Set(Object.keys(i.entries));
  r.extract = (t, n) => {
    let v = {};
    for (let u of t) if (o.has(u)) v[u] = i.entries[u];
    else throw Error(`Key ${u} not found in enum`);
    return new dr({ ...i, checks: [], ...D.normalizeParams(n), entries: v });
  }, r.exclude = (t, n) => {
    let v = { ...i.entries };
    for (let u of t) if (o.has(u)) delete v[u];
    else throw Error(`Key ${u} not found in enum`);
    return new dr({ ...i, checks: [], ...D.normalizeParams(n), entries: v });
  };
});
function lv(r, i) {
  let o = Array.isArray(r) ? Object.fromEntries(r.map((t) => [t, t])) : r;
  return new dr({ type: "enum", entries: o, ...D.normalizeParams(i) });
}
function ic(r, i) {
  return new dr({ type: "enum", entries: r, ...D.normalizeParams(i) });
}
var Bg = c("ZodLiteral", (r, i) => {
  Ot.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => A$(r, o, t, n), r.values = new Set(i.values), Object.defineProperty(r, "value", { get() {
    if (i.values.length > 1) throw Error("This schema contains multiple valid literal values. Use `.values` instead.");
    return i.values[0];
  } });
});
function vc(r, i) {
  return new Bg({ type: "literal", values: Array.isArray(r) ? r : [r], ...D.normalizeParams(i) });
}
var Hg = c("ZodFile", (r, i) => {
  St.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => Y$(r, o, t, n), r.min = (o, t) => r.check(a(o, t)), r.max = (o, t) => r.check(gr(o, t)), r.mime = (o, t) => r.check(mr(Array.isArray(o) ? o : [o], t));
});
function oc(r) {
  return c$(Hg, r);
}
var Mg = c("ZodTransform", (r, i) => {
  zt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => F$(r, o, t, n), r._zod.parse = (o, t) => {
    if (t.direction === "backward") throw new Ir(r.constructor.name);
    o.addIssue = (v) => {
      if (typeof v === "string") o.issues.push(D.issue(v, o.value, i));
      else {
        let u = v;
        if (u.fatal) u.continue = false;
        u.code ?? (u.code = "custom"), u.input ?? (u.input = o.value), u.inst ?? (u.inst = r), o.issues.push(D.issue(u));
      }
    };
    let n = i.transform(o.value, o);
    if (n instanceof Promise) return n.then((v) => {
      return o.value = v, o;
    });
    return o.value = n, o;
  };
});
function cv(r) {
  return new Mg({ type: "transform", transform: r });
}
var Iv = c("ZodOptional", (r, i) => {
  ui.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => Yi(r, o, t, n), r.unwrap = () => r._zod.def.innerType;
});
function Jn(r) {
  return new Iv({ type: "optional", innerType: r });
}
var Rg = c("ZodExactOptional", (r, i) => {
  Pt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => Yi(r, o, t, n), r.unwrap = () => r._zod.def.innerType;
});
function xg(r) {
  return new Rg({ type: "optional", innerType: r });
}
var Zg = c("ZodNullable", (r, i) => {
  jt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => C$(r, o, t, n), r.unwrap = () => r._zod.def.innerType;
});
function Ln(r) {
  return new Zg({ type: "nullable", innerType: r });
}
function tc(r) {
  return Jn(Ln(r));
}
var dg = c("ZodDefault", (r, i) => {
  Jt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => h$(r, o, t, n), r.unwrap = () => r._zod.def.innerType, r.removeDefault = r.unwrap;
});
function Cg(r, i) {
  return new dg({ type: "default", innerType: r, get defaultValue() {
    return typeof i === "function" ? i() : D.shallowClone(i);
  } });
}
var fg = c("ZodPrefault", (r, i) => {
  Lt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => y$(r, o, t, n), r.unwrap = () => r._zod.def.innerType;
});
function hg(r, i) {
  return new fg({ type: "prefault", innerType: r, get defaultValue() {
    return typeof i === "function" ? i() : D.shallowClone(i);
  } });
}
var bv = c("ZodNonOptional", (r, i) => {
  Et.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => f$(r, o, t, n), r.unwrap = () => r._zod.def.innerType;
});
function yg(r, i) {
  return new bv({ type: "nonoptional", innerType: r, ...D.normalizeParams(i) });
}
var ag = c("ZodSuccess", (r, i) => {
  Gt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => Q$(r, o, t, n), r.unwrap = () => r._zod.def.innerType;
});
function uc(r) {
  return new ag({ type: "success", innerType: r });
}
var pg = c("ZodCatch", (r, i) => {
  Wt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => a$(r, o, t, n), r.unwrap = () => r._zod.def.innerType, r.removeCatch = r.unwrap;
});
function sg(r, i) {
  return new pg({ type: "catch", innerType: r, catchValue: typeof i === "function" ? i : () => i });
}
var re = c("ZodNaN", (r, i) => {
  Xt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => K$(r, o, t, n);
});
function $c(r) {
  return e$(re, r);
}
var _v = c("ZodPipe", (r, i) => {
  Vt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => p$(r, o, t, n), r.in = i.in, r.out = i.out;
});
function En(r, i) {
  return new _v({ type: "pipe", in: r, out: i });
}
var Uv = c("ZodCodec", (r, i) => {
  _v.init(r, i), Un.init(r, i);
});
function gc(r, i, o) {
  return new Uv({ type: "pipe", in: r, out: i, transform: o.decode, reverseTransform: o.encode });
}
var ne = c("ZodReadonly", (r, i) => {
  At.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => s$(r, o, t, n), r.unwrap = () => r._zod.def.innerType;
});
function ie(r) {
  return new ne({ type: "readonly", innerType: r });
}
var ve = c("ZodTemplateLiteral", (r, i) => {
  Kt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => q$(r, o, t, n);
});
function ec(r, i) {
  return new ve({ type: "template_literal", parts: r, ...D.normalizeParams(i) });
}
var oe = c("ZodLazy", (r, i) => {
  Qt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => ng(r, o, t, n), r.unwrap = () => r._zod.def.getter();
});
function te(r) {
  return new oe({ type: "lazy", getter: r });
}
var ue = c("ZodPromise", (r, i) => {
  Yt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => rg(r, o, t, n), r.unwrap = () => r._zod.def.innerType;
});
function lc(r) {
  return new ue({ type: "promise", innerType: r });
}
var $e = c("ZodFunction", (r, i) => {
  qt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => T$(r, o, t, n);
});
function cc(r) {
  return new $e({ type: "function", input: Array.isArray(r?.input) ? Qg(r?.input) : r?.input ?? Xn(Nr()), output: r?.output ?? Nr() });
}
var qn = c("ZodCustom", (r, i) => {
  mt.init(r, i), P.init(r, i), r._zod.processJSONSchema = (o, t, n) => m$(r, o, t, n);
});
function Ic(r) {
  let i = new W({ check: "custom" });
  return i._zod.check = r, i;
}
function bc(r, i) {
  return I$(qn, r ?? (() => true), i);
}
function ge(r, i = {}) {
  return b$(qn, r, i);
}
function ee(r) {
  return _$(r);
}
var _c = U$;
var Uc = k$;
function kc(r, i = {}) {
  let o = new qn({ type: "custom", check: "custom", fn: (t) => t instanceof r, abort: true, ...D.normalizeParams(i) });
  return o._zod.bag.Class = r, o._zod.check = (t) => {
    if (!(t.value instanceof r)) t.issues.push({ code: "invalid_type", expected: r.name, input: t.value, inst: o, path: [...o._zod.def.path ?? []] });
  }, o;
}
var Dc = (...r) => D$({ Codec: Uv, Boolean: yr, String: Cr }, ...r);
function wc(r) {
  let i = te(() => {
    return ev([Mi(r), Og(), Sg(), Jg(), Xn(i), mg(Mi(), i)]);
  });
  return i;
}
function Nc(r, i) {
  return En(cv(r), i);
}
var j6 = { invalid_type: "invalid_type", too_big: "too_big", too_small: "too_small", invalid_format: "invalid_format", not_multiple_of: "not_multiple_of", unrecognized_keys: "unrecognized_keys", invalid_union: "invalid_union", invalid_key: "invalid_key", invalid_element: "invalid_element", invalid_value: "invalid_value", custom: "custom" };
function J6(r) {
  V({ customError: r });
}
function L6() {
  return V().customError;
}
var le;
/* @__PURE__ */ (function(r) {
})(le || (le = {}));
var S = { ...Pn, ...mi, iso: Zr };
var E6 = /* @__PURE__ */ new Set(["$schema", "$ref", "$defs", "definitions", "$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor", "type", "enum", "const", "anyOf", "oneOf", "allOf", "not", "properties", "required", "additionalProperties", "patternProperties", "propertyNames", "minProperties", "maxProperties", "items", "prefixItems", "additionalItems", "minItems", "maxItems", "uniqueItems", "contains", "minContains", "maxContains", "minLength", "maxLength", "pattern", "format", "minimum", "maximum", "exclusiveMinimum", "exclusiveMaximum", "multipleOf", "description", "default", "contentEncoding", "contentMediaType", "contentSchema", "unevaluatedItems", "unevaluatedProperties", "if", "then", "else", "dependentSchemas", "dependentRequired", "nullable", "readOnly"]);
function G6(r, i) {
  let o = r.$schema;
  if (o === "https://json-schema.org/draft/2020-12/schema") return "draft-2020-12";
  if (o === "http://json-schema.org/draft-07/schema#") return "draft-7";
  if (o === "http://json-schema.org/draft-04/schema#") return "draft-4";
  return i ?? "draft-2020-12";
}
function W6(r, i) {
  if (!r.startsWith("#")) throw Error("External $ref is not supported, only local refs (#/...) are allowed");
  let o = r.slice(1).split("/").filter(Boolean);
  if (o.length === 0) return i.rootSchema;
  let t = i.version === "draft-2020-12" ? "$defs" : "definitions";
  if (o[0] === t) {
    let n = o[1];
    if (!n || !i.defs[n]) throw Error(`Reference not found: ${r}`);
    return i.defs[n];
  }
  throw Error(`Reference not found: ${r}`);
}
function Oc(r, i) {
  if (r.not !== void 0) {
    if (typeof r.not === "object" && Object.keys(r.not).length === 0) return S.never();
    throw Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (r.unevaluatedItems !== void 0) throw Error("unevaluatedItems is not supported");
  if (r.unevaluatedProperties !== void 0) throw Error("unevaluatedProperties is not supported");
  if (r.if !== void 0 || r.then !== void 0 || r.else !== void 0) throw Error("Conditional schemas (if/then/else) are not supported");
  if (r.dependentSchemas !== void 0 || r.dependentRequired !== void 0) throw Error("dependentSchemas and dependentRequired are not supported");
  if (r.$ref) {
    let n = r.$ref;
    if (i.refs.has(n)) return i.refs.get(n);
    if (i.processing.has(n)) return S.lazy(() => {
      if (!i.refs.has(n)) throw Error(`Circular reference not resolved: ${n}`);
      return i.refs.get(n);
    });
    i.processing.add(n);
    let v = W6(n, i), u = K(v, i);
    return i.refs.set(n, u), i.processing.delete(n), u;
  }
  if (r.enum !== void 0) {
    let n = r.enum;
    if (i.version === "openapi-3.0" && r.nullable === true && n.length === 1 && n[0] === null) return S.null();
    if (n.length === 0) return S.never();
    if (n.length === 1) return S.literal(n[0]);
    if (n.every((u) => typeof u === "string")) return S.enum(n);
    let v = n.map((u) => S.literal(u));
    if (v.length < 2) return v[0];
    return S.union([v[0], v[1], ...v.slice(2)]);
  }
  if (r.const !== void 0) return S.literal(r.const);
  let o = r.type;
  if (Array.isArray(o)) {
    let n = o.map((v) => {
      let u = { ...r, type: v };
      return Oc(u, i);
    });
    if (n.length === 0) return S.never();
    if (n.length === 1) return n[0];
    return S.union(n);
  }
  if (!o) return S.any();
  let t;
  switch (o) {
    case "string": {
      let n = S.string();
      if (r.format) {
        let v = r.format;
        if (v === "email") n = n.check(S.email());
        else if (v === "uri" || v === "uri-reference") n = n.check(S.url());
        else if (v === "uuid" || v === "guid") n = n.check(S.uuid());
        else if (v === "date-time") n = n.check(S.iso.datetime());
        else if (v === "date") n = n.check(S.iso.date());
        else if (v === "time") n = n.check(S.iso.time());
        else if (v === "duration") n = n.check(S.iso.duration());
        else if (v === "ipv4") n = n.check(S.ipv4());
        else if (v === "ipv6") n = n.check(S.ipv6());
        else if (v === "mac") n = n.check(S.mac());
        else if (v === "cidr") n = n.check(S.cidrv4());
        else if (v === "cidr-v6") n = n.check(S.cidrv6());
        else if (v === "base64") n = n.check(S.base64());
        else if (v === "base64url") n = n.check(S.base64url());
        else if (v === "e164") n = n.check(S.e164());
        else if (v === "jwt") n = n.check(S.jwt());
        else if (v === "emoji") n = n.check(S.emoji());
        else if (v === "nanoid") n = n.check(S.nanoid());
        else if (v === "cuid") n = n.check(S.cuid());
        else if (v === "cuid2") n = n.check(S.cuid2());
        else if (v === "ulid") n = n.check(S.ulid());
        else if (v === "xid") n = n.check(S.xid());
        else if (v === "ksuid") n = n.check(S.ksuid());
      }
      if (typeof r.minLength === "number") n = n.min(r.minLength);
      if (typeof r.maxLength === "number") n = n.max(r.maxLength);
      if (r.pattern) n = n.regex(new RegExp(r.pattern));
      t = n;
      break;
    }
    case "number":
    case "integer": {
      let n = o === "integer" ? S.number().int() : S.number();
      if (typeof r.minimum === "number") n = n.min(r.minimum);
      if (typeof r.maximum === "number") n = n.max(r.maximum);
      if (typeof r.exclusiveMinimum === "number") n = n.gt(r.exclusiveMinimum);
      else if (r.exclusiveMinimum === true && typeof r.minimum === "number") n = n.gt(r.minimum);
      if (typeof r.exclusiveMaximum === "number") n = n.lt(r.exclusiveMaximum);
      else if (r.exclusiveMaximum === true && typeof r.maximum === "number") n = n.lt(r.maximum);
      if (typeof r.multipleOf === "number") n = n.multipleOf(r.multipleOf);
      t = n;
      break;
    }
    case "boolean": {
      t = S.boolean();
      break;
    }
    case "null": {
      t = S.null();
      break;
    }
    case "object": {
      let n = {}, v = r.properties || {}, u = new Set(r.required || []);
      for (let [l, e] of Object.entries(v)) {
        let I = K(e, i);
        n[l] = u.has(l) ? I : I.optional();
      }
      if (r.propertyNames) {
        let l = K(r.propertyNames, i), e = r.additionalProperties && typeof r.additionalProperties === "object" ? K(r.additionalProperties, i) : S.any();
        if (Object.keys(n).length === 0) {
          t = S.record(l, e);
          break;
        }
        let I = S.object(n).passthrough(), _ = S.looseRecord(l, e);
        t = S.intersection(I, _);
        break;
      }
      if (r.patternProperties) {
        let l = r.patternProperties, e = Object.keys(l), I = [];
        for (let N of e) {
          let O = K(l[N], i), J = S.string().regex(new RegExp(N));
          I.push(S.looseRecord(J, O));
        }
        let _ = [];
        if (Object.keys(n).length > 0) _.push(S.object(n).passthrough());
        if (_.push(...I), _.length === 0) t = S.object({}).passthrough();
        else if (_.length === 1) t = _[0];
        else {
          let N = S.intersection(_[0], _[1]);
          for (let O = 2; O < _.length; O++) N = S.intersection(N, _[O]);
          t = N;
        }
        break;
      }
      let $ = S.object(n);
      if (r.additionalProperties === false) t = $.strict();
      else if (typeof r.additionalProperties === "object") t = $.catchall(K(r.additionalProperties, i));
      else t = $.passthrough();
      break;
    }
    case "array": {
      let { prefixItems: n, items: v } = r;
      if (n && Array.isArray(n)) {
        let u = n.map((l) => K(l, i)), $ = v && typeof v === "object" && !Array.isArray(v) ? K(v, i) : void 0;
        if ($) t = S.tuple(u).rest($);
        else t = S.tuple(u);
        if (typeof r.minItems === "number") t = t.check(S.minLength(r.minItems));
        if (typeof r.maxItems === "number") t = t.check(S.maxLength(r.maxItems));
      } else if (Array.isArray(v)) {
        let u = v.map((l) => K(l, i)), $ = r.additionalItems && typeof r.additionalItems === "object" ? K(r.additionalItems, i) : void 0;
        if ($) t = S.tuple(u).rest($);
        else t = S.tuple(u);
        if (typeof r.minItems === "number") t = t.check(S.minLength(r.minItems));
        if (typeof r.maxItems === "number") t = t.check(S.maxLength(r.maxItems));
      } else if (v !== void 0) {
        let u = K(v, i), $ = S.array(u);
        if (typeof r.minItems === "number") $ = $.min(r.minItems);
        if (typeof r.maxItems === "number") $ = $.max(r.maxItems);
        t = $;
      } else t = S.array(S.any());
      break;
    }
    default:
      throw Error(`Unsupported type: ${o}`);
  }
  if (r.description) t = t.describe(r.description);
  if (r.default !== void 0) t = t.default(r.default);
  return t;
}
function K(r, i) {
  if (typeof r === "boolean") return r ? S.any() : S.never();
  let o = Oc(r, i), t = r.type || r.enum !== void 0 || r.const !== void 0;
  if (r.anyOf && Array.isArray(r.anyOf)) {
    let $ = r.anyOf.map((e) => K(e, i)), l = S.union($);
    o = t ? S.intersection(o, l) : l;
  }
  if (r.oneOf && Array.isArray(r.oneOf)) {
    let $ = r.oneOf.map((e) => K(e, i)), l = S.xor($);
    o = t ? S.intersection(o, l) : l;
  }
  if (r.allOf && Array.isArray(r.allOf)) if (r.allOf.length === 0) o = t ? o : S.any();
  else {
    let $ = t ? o : K(r.allOf[0], i), l = t ? 0 : 1;
    for (let e = l; e < r.allOf.length; e++) $ = S.intersection($, K(r.allOf[e], i));
    o = $;
  }
  if (r.nullable === true && i.version === "openapi-3.0") o = S.nullable(o);
  if (r.readOnly === true) o = S.readonly(o);
  let n = {}, v = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (let $ of v) if ($ in r) n[$] = r[$];
  let u = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (let $ of u) if ($ in r) n[$] = r[$];
  for (let $ of Object.keys(r)) if (!E6.has($)) n[$] = r[$];
  if (Object.keys(n).length > 0) i.registry.add(o, n);
  return o;
}
function Sc(r, i) {
  if (typeof r === "boolean") return r ? S.any() : S.never();
  let o = G6(r, i?.defaultTarget), t = r.$defs || r.definitions || {}, n = { version: o, defs: t, refs: /* @__PURE__ */ new Map(), processing: /* @__PURE__ */ new Set(), rootSchema: r, registry: i?.registry ?? A };
  return K(r, n);
}
var ce = {};
s(ce, { string: () => X6, number: () => V6, date: () => q6, boolean: () => A6, bigint: () => K6 });
function X6(r) {
  return qu(Cr, r);
}
function V6(r) {
  return Mu(hr, r);
}
function A6(r) {
  return hu(yr, r);
}
function K6(r) {
  return au(ar, r);
}
function q6(r) {
  return g$(Wn, r);
}
V(kn());
var jc = g.union([g.literal("light"), g.literal("dark")]).describe("Color theme preference for the host environment.");
var pr = g.union([g.literal("inline"), g.literal("fullscreen"), g.literal("pip")]).describe("Display mode for UI presentation.");
var T6 = g.union([g.literal("--color-background-primary"), g.literal("--color-background-secondary"), g.literal("--color-background-tertiary"), g.literal("--color-background-inverse"), g.literal("--color-background-ghost"), g.literal("--color-background-info"), g.literal("--color-background-danger"), g.literal("--color-background-success"), g.literal("--color-background-warning"), g.literal("--color-background-disabled"), g.literal("--color-text-primary"), g.literal("--color-text-secondary"), g.literal("--color-text-tertiary"), g.literal("--color-text-inverse"), g.literal("--color-text-ghost"), g.literal("--color-text-info"), g.literal("--color-text-danger"), g.literal("--color-text-success"), g.literal("--color-text-warning"), g.literal("--color-text-disabled"), g.literal("--color-text-ghost"), g.literal("--color-border-primary"), g.literal("--color-border-secondary"), g.literal("--color-border-tertiary"), g.literal("--color-border-inverse"), g.literal("--color-border-ghost"), g.literal("--color-border-info"), g.literal("--color-border-danger"), g.literal("--color-border-success"), g.literal("--color-border-warning"), g.literal("--color-border-disabled"), g.literal("--color-ring-primary"), g.literal("--color-ring-secondary"), g.literal("--color-ring-inverse"), g.literal("--color-ring-info"), g.literal("--color-ring-danger"), g.literal("--color-ring-success"), g.literal("--color-ring-warning"), g.literal("--font-sans"), g.literal("--font-mono"), g.literal("--font-weight-normal"), g.literal("--font-weight-medium"), g.literal("--font-weight-semibold"), g.literal("--font-weight-bold"), g.literal("--font-text-xs-size"), g.literal("--font-text-sm-size"), g.literal("--font-text-md-size"), g.literal("--font-text-lg-size"), g.literal("--font-heading-xs-size"), g.literal("--font-heading-sm-size"), g.literal("--font-heading-md-size"), g.literal("--font-heading-lg-size"), g.literal("--font-heading-xl-size"), g.literal("--font-heading-2xl-size"), g.literal("--font-heading-3xl-size"), g.literal("--font-text-xs-line-height"), g.literal("--font-text-sm-line-height"), g.literal("--font-text-md-line-height"), g.literal("--font-text-lg-line-height"), g.literal("--font-heading-xs-line-height"), g.literal("--font-heading-sm-line-height"), g.literal("--font-heading-md-line-height"), g.literal("--font-heading-lg-line-height"), g.literal("--font-heading-xl-line-height"), g.literal("--font-heading-2xl-line-height"), g.literal("--font-heading-3xl-line-height"), g.literal("--border-radius-xs"), g.literal("--border-radius-sm"), g.literal("--border-radius-md"), g.literal("--border-radius-lg"), g.literal("--border-radius-xl"), g.literal("--border-radius-full"), g.literal("--border-width-regular"), g.literal("--shadow-hairline"), g.literal("--shadow-sm"), g.literal("--shadow-md"), g.literal("--shadow-lg")]).describe("CSS variable keys available to MCP apps for theming.");
var F6 = g.record(T6.describe(`Style variables for theming MCP apps.

Individual style keys are optional - hosts may provide any subset of these values.
Values are strings containing CSS values (colors, sizes, font stacks, etc.).

Note: This type uses \`Record<K, string | undefined>\` rather than \`Partial<Record<K, string>>\`
for compatibility with Zod schema generation. Both are functionally equivalent for validation.`), g.union([g.string(), g.undefined()]).describe(`Style variables for theming MCP apps.

Individual style keys are optional - hosts may provide any subset of these values.
Values are strings containing CSS values (colors, sizes, font stacks, etc.).

Note: This type uses \`Record<K, string | undefined>\` rather than \`Partial<Record<K, string>>\`
for compatibility with Zod schema generation. Both are functionally equivalent for validation.`)).describe(`Style variables for theming MCP apps.

Individual style keys are optional - hosts may provide any subset of these values.
Values are strings containing CSS values (colors, sizes, font stacks, etc.).

Note: This type uses \`Record<K, string | undefined>\` rather than \`Partial<Record<K, string>>\`
for compatibility with Zod schema generation. Both are functionally equivalent for validation.`);
var B6 = g.object({ method: g.literal("ui/open-link"), params: g.object({ url: g.string().describe("URL to open in the host's browser") }) });
var be = g.object({ isError: g.boolean().optional().describe("True if the host failed to open the URL (e.g., due to security policy).") }).passthrough();
var _e = g.object({ isError: g.boolean().optional().describe("True if the host rejected or failed to deliver the message.") }).passthrough();
var H6 = g.object({ method: g.literal("ui/notifications/sandbox-proxy-ready"), params: g.object({}) });
var kv = g.object({ connectDomains: g.array(g.string()).optional().describe("Origins for network requests (fetch/XHR/WebSocket)."), resourceDomains: g.array(g.string()).optional().describe("Origins for static resources (scripts, images, styles, fonts)."), frameDomains: g.array(g.string()).optional().describe("Origins for nested iframes (frame-src directive)."), baseUriDomains: g.array(g.string()).optional().describe("Allowed base URIs for the document (base-uri directive).") });
var Dv = g.object({ camera: g.object({}).optional().describe("Request camera access (Permission Policy `camera` feature)."), microphone: g.object({}).optional().describe("Request microphone access (Permission Policy `microphone` feature)."), geolocation: g.object({}).optional().describe("Request geolocation access (Permission Policy `geolocation` feature)."), clipboardWrite: g.object({}).optional().describe("Request clipboard write access (Permission Policy `clipboard-write` feature).") });
var M6 = g.object({ method: g.literal("ui/notifications/size-changed"), params: g.object({ width: g.number().optional().describe("New width in pixels."), height: g.number().optional().describe("New height in pixels.") }) });
var Ue = g.object({ method: g.literal("ui/notifications/tool-input"), params: g.object({ arguments: g.record(g.string(), g.unknown().describe("Complete tool call arguments as key-value pairs.")).optional().describe("Complete tool call arguments as key-value pairs.") }) });
var ke = g.object({ method: g.literal("ui/notifications/tool-input-partial"), params: g.object({ arguments: g.record(g.string(), g.unknown().describe("Partial tool call arguments (incomplete, may change).")).optional().describe("Partial tool call arguments (incomplete, may change).") }) });
var De = g.object({ method: g.literal("ui/notifications/tool-cancelled"), params: g.object({ reason: g.string().optional().describe('Optional reason for the cancellation (e.g., "user action", "timeout").') }) });
var Jc = g.object({ fonts: g.string().optional() });
var Lc = g.object({ variables: F6.optional().describe("CSS variables for theming the app."), css: Jc.optional().describe("CSS blocks that apps can inject.") });
var we = g.object({ method: g.literal("ui/resource-teardown"), params: g.object({}) });
var R6 = g.record(g.string(), g.unknown());
var Ie = g.object({ text: g.object({}).optional().describe("Host supports text content blocks."), image: g.object({}).optional().describe("Host supports image content blocks."), audio: g.object({}).optional().describe("Host supports audio content blocks."), resource: g.object({}).optional().describe("Host supports resource content blocks."), resourceLink: g.object({}).optional().describe("Host supports resource link content blocks."), structuredContent: g.object({}).optional().describe("Host supports structured content.") });
var Ec = g.object({ experimental: g.object({}).optional().describe("Experimental features (structure TBD)."), openLinks: g.object({}).optional().describe("Host supports opening external URLs."), serverTools: g.object({ listChanged: g.boolean().optional().describe("Host supports tools/list_changed notifications.") }).optional().describe("Host can proxy tool calls to the MCP server."), serverResources: g.object({ listChanged: g.boolean().optional().describe("Host supports resources/list_changed notifications.") }).optional().describe("Host can proxy resource reads to the MCP server."), logging: g.object({}).optional().describe("Host accepts log messages."), sandbox: g.object({ permissions: Dv.optional().describe("Permissions granted by the host (camera, microphone, geolocation)."), csp: kv.optional().describe("CSP domains approved by the host.") }).optional().describe("Sandbox configuration applied by the host."), updateModelContext: Ie.optional().describe("Host accepts context updates (ui/update-model-context) to be included in the model's context for future turns."), message: Ie.optional().describe("Host supports receiving content messages (ui/message) from the view.") });
var Gc = g.object({ experimental: g.object({}).optional().describe("Experimental features (structure TBD)."), tools: g.object({ listChanged: g.boolean().optional().describe("App supports tools/list_changed notifications.") }).optional().describe("App exposes MCP-style tools that the host can call."), availableDisplayModes: g.array(pr).optional().describe("Display modes the app supports.") });
var x6 = g.object({ method: g.literal("ui/notifications/initialized"), params: g.object({}).optional() });
var Z6 = g.object({ csp: kv.optional().describe("Content Security Policy configuration."), permissions: Dv.optional().describe("Sandbox permissions requested by the UI."), domain: g.string().optional().describe("Dedicated origin for view sandbox."), prefersBorder: g.boolean().optional().describe("Visual boundary preference - true if UI prefers a visible border.") });
var d6 = g.object({ method: g.literal("ui/request-display-mode"), params: g.object({ mode: pr.describe("The display mode being requested.") }) });
var Ne = g.object({ mode: pr.describe("The display mode that was actually set. May differ from requested if not supported.") }).passthrough();
var Wc = g.union([g.literal("model"), g.literal("app")]).describe("Tool visibility scope - who can access the tool.");
var C6 = g.object({ resourceUri: g.string().optional(), visibility: g.array(Wc).optional().describe(`Who can access this tool. Default: ["model", "app"]
- "model": Tool visible to and callable by the agent
- "app": Tool callable by the app from this server only`) });
var uk = g.object({ mimeTypes: g.array(g.string()).optional().describe('Array of supported MIME types for UI resources.\nMust include `"text/html;profile=mcp-app"` for MCP Apps support.') });
var f6 = g.object({ method: g.literal("ui/message"), params: g.object({ role: g.literal("user").describe('Message role, currently only "user" is supported.'), content: g.array(ContentBlockSchema).describe("Message content blocks (text, image, etc.).") }) });
var h6 = g.object({ method: g.literal("ui/notifications/sandbox-resource-ready"), params: g.object({ html: g.string().describe("HTML content to load into the inner iframe."), sandbox: g.string().optional().describe("Optional override for the inner iframe's sandbox attribute."), csp: kv.optional().describe("CSP configuration from resource metadata."), permissions: Dv.optional().describe("Sandbox permissions from resource metadata.") }) });
var Oe = g.object({ method: g.literal("ui/notifications/tool-result"), params: CallToolResultSchema.describe("Standard MCP tool execution result.") });
var Se = g.object({ toolInfo: g.object({ id: RequestIdSchema.optional().describe("JSON-RPC id of the tools/call request."), tool: ToolSchema.describe("Tool definition including name, inputSchema, etc.") }).optional().describe("Metadata of the tool call that instantiated this App."), theme: jc.optional().describe("Current color theme preference."), styles: Lc.optional().describe("Style configuration for theming the app."), displayMode: pr.optional().describe("How the UI is currently displayed."), availableDisplayModes: g.array(pr).optional().describe("Display modes the host supports."), containerDimensions: g.union([g.object({ height: g.number().describe("Fixed container height in pixels.") }), g.object({ maxHeight: g.union([g.number(), g.undefined()]).optional().describe("Maximum container height in pixels.") })]).and(g.union([g.object({ width: g.number().describe("Fixed container width in pixels.") }), g.object({ maxWidth: g.union([g.number(), g.undefined()]).optional().describe("Maximum container width in pixels.") })])).optional().describe(`Container dimensions. Represents the dimensions of the iframe or other
container holding the app. Specify either width or maxWidth, and either height or maxHeight.`), locale: g.string().optional().describe("User's language and region preference in BCP 47 format."), timeZone: g.string().optional().describe("User's timezone in IANA format."), userAgent: g.string().optional().describe("Host application identifier."), platform: g.union([g.literal("web"), g.literal("desktop"), g.literal("mobile")]).optional().describe("Platform type for responsive design decisions."), deviceCapabilities: g.object({ touch: g.boolean().optional().describe("Whether the device supports touch input."), hover: g.boolean().optional().describe("Whether the device supports hover interactions.") }).optional().describe("Device input capabilities."), safeAreaInsets: g.object({ top: g.number().describe("Top safe area inset in pixels."), right: g.number().describe("Right safe area inset in pixels."), bottom: g.number().describe("Bottom safe area inset in pixels."), left: g.number().describe("Left safe area inset in pixels.") }).optional().describe("Mobile safe area boundaries in pixels.") }).passthrough();
var ze = g.object({ method: g.literal("ui/notifications/host-context-changed"), params: Se.describe("Partial context update containing only changed fields.") });
var y6 = g.object({ method: g.literal("ui/update-model-context"), params: g.object({ content: g.array(ContentBlockSchema).optional().describe("Context content blocks (text, image, etc.)."), structuredContent: g.record(g.string(), g.unknown().describe("Structured content for machine-readable context data.")).optional().describe("Structured content for machine-readable context data.") }) });
var a6 = g.object({ method: g.literal("ui/initialize"), params: g.object({ appInfo: ImplementationSchema.describe("App identification (name and version)."), appCapabilities: Gc.describe("Features and capabilities this app provides."), protocolVersion: g.string().describe("Protocol version this app supports.") }) });
var Pe = g.object({ protocolVersion: g.string().describe('Negotiated protocol version string (e.g., "2025-11-21").'), hostInfo: ImplementationSchema.describe("Host application identification and version."), hostCapabilities: Ec.describe("Features and capabilities provided by the host."), hostContext: Se.describe("Rich context about the host environment.") }).passthrough();
var Bk = "text/html;profile=mcp-app";

// node_modules/mcp-use/dist/chunk-YEK7642C.js
var VERSION = "1.20.5";
function getPackageVersion() {
  return VERSION;
}
__name(getPackageVersion, "getPackageVersion");
var _a2;
var BaseTelemetryEvent = (_a2 = class {
}, __name(_a2, "BaseTelemetryEvent"), _a2);
var _a3;
var MCPAgentExecutionEvent = (_a3 = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  get name() {
    return "mcp_agent_execution";
  }
  get properties() {
    return {
      // Core execution info
      execution_method: this.data.executionMethod,
      query: this.data.query,
      query_length: this.data.query.length,
      success: this.data.success,
      // Agent configuration
      model_provider: this.data.modelProvider,
      model_name: this.data.modelName,
      server_count: this.data.serverCount,
      server_identifiers: this.data.serverIdentifiers,
      total_tools_available: this.data.totalToolsAvailable,
      tools_available_names: this.data.toolsAvailableNames,
      max_steps_configured: this.data.maxStepsConfigured,
      memory_enabled: this.data.memoryEnabled,
      use_server_manager: this.data.useServerManager,
      // Execution parameters (always include, even if null)
      max_steps_used: this.data.maxStepsUsed,
      manage_connector: this.data.manageConnector,
      external_history_used: this.data.externalHistoryUsed,
      // Execution results (always include, even if null)
      steps_taken: this.data.stepsTaken ?? null,
      tools_used_count: this.data.toolsUsedCount ?? null,
      tools_used_names: this.data.toolsUsedNames ?? null,
      response: this.data.response ?? null,
      response_length: this.data.response ? this.data.response.length : null,
      execution_time_ms: this.data.executionTimeMs ?? null,
      error_type: this.data.errorType ?? null,
      conversation_history_length: this.data.conversationHistoryLength ?? null
    };
  }
}, __name(_a3, "MCPAgentExecutionEvent"), _a3);
function createServerRunEventData(server, transport) {
  const toolRegistrations = Array.from(server.registrations.tools.values());
  const promptRegistrations = Array.from(server.registrations.prompts.values());
  const resourceRegistrations = Array.from(
    server.registrations.resources.values()
  );
  const templateRegistrations = Array.from(
    server.registrations.resourceTemplates.values()
  );
  const allResources = resourceRegistrations.map((r) => ({
    name: r.config.name,
    title: r.config.title ?? null,
    description: r.config.description ?? null,
    uri: r.config.uri ?? null,
    mime_type: r.config.mimeType ?? null
  }));
  const appsSdkResources = allResources.filter(
    (r) => r.mime_type === "text/html+skybridge"
  );
  const mcpUiResources = allResources.filter(
    (r) => r.mime_type === "text/uri-list" || r.mime_type === "text/html"
  );
  const mcpAppsResources = allResources.filter(
    (r) => r.mime_type === Bk
  );
  return {
    transport,
    toolsNumber: server.registeredTools.length,
    resourcesNumber: server.registeredResources.length,
    promptsNumber: server.registeredPrompts.length,
    auth: !!server.oauthProvider,
    name: server.config.name,
    description: server.config.description ?? null,
    baseUrl: server.serverBaseUrl ?? null,
    toolNames: server.registeredTools.length > 0 ? server.registeredTools : null,
    resourceNames: server.registeredResources.length > 0 ? server.registeredResources : null,
    promptNames: server.registeredPrompts.length > 0 ? server.registeredPrompts : null,
    tools: toolRegistrations.length > 0 ? toolRegistrations.map((r) => ({
      name: r.config.name,
      title: r.config.title ?? null,
      description: r.config.description ?? null,
      input_schema: r.config.schema ? JSON.stringify(r.config.schema) : null,
      output_schema: r.config.outputSchema ? JSON.stringify(r.config.outputSchema) : null
    })) : null,
    resources: allResources.length > 0 ? allResources : null,
    prompts: promptRegistrations.length > 0 ? promptRegistrations.map((r) => ({
      name: r.config.name,
      title: r.config.title ?? null,
      description: r.config.description ?? null,
      args: r.config.args ? JSON.stringify(r.config.args) : null
    })) : null,
    templates: templateRegistrations.length > 0 ? templateRegistrations.map((r) => ({
      name: r.config.name,
      title: r.config.title ?? null,
      description: r.config.description ?? null
    })) : null,
    capabilities: {
      logging: true,
      resources: { subscribe: true, listChanged: true }
    },
    appsSdkResources: appsSdkResources.length > 0 ? appsSdkResources : null,
    appsSdkResourcesNumber: appsSdkResources.length,
    mcpUiResources: mcpUiResources.length > 0 ? mcpUiResources : null,
    mcpUiResourcesNumber: mcpUiResources.length,
    mcpAppsResources: mcpAppsResources.length > 0 ? mcpAppsResources : null,
    mcpAppsResourcesNumber: mcpAppsResources.length
  };
}
__name(createServerRunEventData, "createServerRunEventData");
var _a4;
var ServerRunEvent = (_a4 = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  get name() {
    return "server_run";
  }
  get properties() {
    return {
      transport: this.data.transport,
      tools_number: this.data.toolsNumber,
      resources_number: this.data.resourcesNumber,
      prompts_number: this.data.promptsNumber,
      auth: this.data.auth,
      name: this.data.name,
      description: this.data.description ?? null,
      base_url: this.data.baseUrl ?? null,
      tool_names: this.data.toolNames ?? null,
      resource_names: this.data.resourceNames ?? null,
      prompt_names: this.data.promptNames ?? null,
      tools: this.data.tools ?? null,
      resources: this.data.resources ?? null,
      prompts: this.data.prompts ?? null,
      templates: this.data.templates ?? null,
      capabilities: this.data.capabilities ? JSON.stringify(this.data.capabilities) : null,
      apps_sdk_resources: this.data.appsSdkResources ? JSON.stringify(this.data.appsSdkResources) : null,
      apps_sdk_resources_number: this.data.appsSdkResourcesNumber ?? 0,
      mcp_ui_resources: this.data.mcpUiResources ? JSON.stringify(this.data.mcpUiResources) : null,
      mcp_ui_resources_number: this.data.mcpUiResourcesNumber ?? 0,
      mcp_apps_resources: this.data.mcpAppsResources ? JSON.stringify(this.data.mcpAppsResources) : null,
      mcp_apps_resources_number: this.data.mcpAppsResourcesNumber ?? 0
    };
  }
}, __name(_a4, "ServerRunEvent"), _a4);
var _a5;
var ServerInitializeEvent = (_a5 = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  get name() {
    return "server_initialize_call";
  }
  get properties() {
    return {
      protocol_version: this.data.protocolVersion,
      client_info: JSON.stringify(this.data.clientInfo),
      client_capabilities: JSON.stringify(this.data.clientCapabilities),
      session_id: this.data.sessionId ?? null
    };
  }
}, __name(_a5, "ServerInitializeEvent"), _a5);
var _a6;
var ServerToolCallEvent = (_a6 = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  get name() {
    return "server_tool_call";
  }
  get properties() {
    return {
      tool_name: this.data.toolName,
      length_input_argument: this.data.lengthInputArgument,
      success: this.data.success,
      error_type: this.data.errorType ?? null,
      execution_time_ms: this.data.executionTimeMs ?? null
    };
  }
}, __name(_a6, "ServerToolCallEvent"), _a6);
var _a7;
var ServerResourceCallEvent = (_a7 = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  get name() {
    return "server_resource_call";
  }
  get properties() {
    return {
      name: this.data.name,
      description: this.data.description,
      contents: this.data.contents,
      success: this.data.success,
      error_type: this.data.errorType ?? null
    };
  }
}, __name(_a7, "ServerResourceCallEvent"), _a7);
var _a8;
var ServerPromptCallEvent = (_a8 = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  get name() {
    return "server_prompt_call";
  }
  get properties() {
    return {
      name: this.data.name,
      description: this.data.description,
      success: this.data.success,
      error_type: this.data.errorType ?? null
    };
  }
}, __name(_a8, "ServerPromptCallEvent"), _a8);
var _a9;
var ServerContextEvent = (_a9 = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  get name() {
    return `server_context_${this.data.contextType}`;
  }
  get properties() {
    return {
      context_type: this.data.contextType,
      notification_type: this.data.notificationType ?? null
    };
  }
}, __name(_a9, "ServerContextEvent"), _a9);
var _a10;
var MCPClientInitEvent = (_a10 = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  get name() {
    return "mcpclient_init";
  }
  get properties() {
    return {
      code_mode: this.data.codeMode,
      sandbox: this.data.sandbox,
      all_callbacks: this.data.allCallbacks,
      verify: this.data.verify,
      servers: this.data.servers,
      num_servers: this.data.numServers,
      is_browser: this.data.isBrowser
    };
  }
}, __name(_a10, "MCPClientInitEvent"), _a10);
var _a11;
var ConnectorInitEvent = (_a11 = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  get name() {
    return "connector_init";
  }
  get properties() {
    return {
      connector_type: this.data.connectorType,
      server_command: this.data.serverCommand ?? null,
      server_args: this.data.serverArgs ?? null,
      server_url: this.data.serverUrl ?? null,
      public_identifier: this.data.publicIdentifier ?? null
    };
  }
}, __name(_a11, "ConnectorInitEvent"), _a11);
var _a12;
var ClientAddServerEvent = (_a12 = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  get name() {
    return "client_add_server";
  }
  get properties() {
    const { serverName, serverConfig } = this.data;
    const url = serverConfig.url;
    return {
      server_name: serverName,
      server_url_domain: url ? this._extractHostname(url) : null,
      transport: serverConfig.transport ?? null,
      has_auth: !!(serverConfig.authToken || serverConfig.authProvider)
    };
  }
  _extractHostname(url) {
    try {
      return new URL(url).hostname;
    } catch {
      return null;
    }
  }
}, __name(_a12, "ClientAddServerEvent"), _a12);
var _a13;
var ClientRemoveServerEvent = (_a13 = class extends BaseTelemetryEvent {
  constructor(data) {
    super();
    this.data = data;
  }
  get name() {
    return "client_remove_server";
  }
  get properties() {
    return {
      server_name: this.data.serverName
    };
  }
}, __name(_a13, "ClientRemoveServerEvent"), _a13);
function getModelProvider(llm) {
  return llm._llm_type || llm.constructor.name.toLowerCase();
}
__name(getModelProvider, "getModelProvider");
function getModelName(llm) {
  if ("_identifyingParams" in llm) {
    const identifyingParams = llm._identifyingParams;
    if (typeof identifyingParams === "object" && identifyingParams !== null) {
      for (const key of [
        "model",
        "modelName",
        "model_name",
        "modelId",
        "model_id",
        "deploymentName",
        "deployment_name"
      ]) {
        if (key in identifyingParams) {
          return String(identifyingParams[key]);
        }
      }
    }
  }
  return llm.model || llm.modelName || llm.constructor.name;
}
__name(getModelName, "getModelName");
function extractModelInfo(llm) {
  return [getModelProvider(llm), getModelName(llm)];
}
__name(extractModelInfo, "extractModelInfo");
function generateUUID() {
  if (typeof globalThis !== "undefined" && globalThis.crypto && typeof globalThis.crypto.randomUUID === "function") {
    return globalThis.crypto.randomUUID();
  }
  if (typeof globalThis !== "undefined" && globalThis.crypto && typeof globalThis.crypto.getRandomValues === "function") {
    const array2 = new Uint8Array(16);
    globalThis.crypto.getRandomValues(array2);
    const hex = Array.from(array2, (v) => v.toString(16).padStart(2, "0")).join(
      ""
    );
    return `${hex.substring(0, 8)}-${hex.substring(8, 12)}-${hex.substring(12, 16)}-${hex.substring(16, 20)}-${hex.substring(20)}`;
  }
  return `${Date.now()}-${Math.random().toString(36).substring(2, 15)}-${Math.random().toString(36).substring(2, 15)}`;
}
__name(generateUUID, "generateUUID");
function secureRandomString() {
  if (typeof window !== "undefined" && window.crypto && typeof window.crypto.getRandomValues === "function") {
    const array2 = new Uint8Array(8);
    window.crypto.getRandomValues(array2);
    return Array.from(array2, (v) => v.toString(16).padStart(2, "0")).join("");
  }
  if (typeof globalThis !== "undefined" && globalThis.crypto && typeof globalThis.crypto.getRandomValues === "function") {
    const array2 = new Uint8Array(8);
    globalThis.crypto.getRandomValues(array2);
    return Array.from(array2, (v) => v.toString(16).padStart(2, "0")).join("");
  }
  return Math.random().toString(36).substring(2, 15);
}
__name(secureRandomString, "secureRandomString");
var USER_ID_STORAGE_KEY = "mcp_use_user_id";
function isLocalStorageFunctional() {
  return typeof localStorage !== "undefined" && typeof localStorage.getItem === "function" && typeof localStorage.setItem === "function" && typeof localStorage.removeItem === "function";
}
__name(isLocalStorageFunctional, "isLocalStorageFunctional");
function detectRuntimeEnvironment() {
  try {
    if (typeof window !== "undefined" && typeof document !== "undefined") {
      return "browser";
    }
    return "unknown";
  } catch {
    return "unknown";
  }
}
__name(detectRuntimeEnvironment, "detectRuntimeEnvironment");
function getStorageCapability(env) {
  if (env === "browser") {
    try {
      if (isLocalStorageFunctional()) {
        localStorage.setItem("__mcp_use_test__", "1");
        localStorage.removeItem("__mcp_use_test__");
        return "localStorage";
      }
    } catch {
    }
  }
  return "session-only";
}
__name(getStorageCapability, "getStorageCapability");
var cachedEnvironment = null;
function getRuntimeEnvironment() {
  if (cachedEnvironment === null) {
    cachedEnvironment = detectRuntimeEnvironment();
  }
  return cachedEnvironment;
}
__name(getRuntimeEnvironment, "getRuntimeEnvironment");
var _a14;
var Telemetry = (_a14 = class {
  PROJECT_API_KEY = "phc_lyTtbYwvkdSbrcMQNPiKiiRWrrM1seyKIMjycSvItEI";
  HOST = "https://eu.i.posthog.com";
  UNKNOWN_USER_ID = "UNKNOWN_USER_ID";
  _currUserId = null;
  _posthogBrowserClient = null;
  _posthogLoading = null;
  _runtimeEnvironment;
  _storageCapability;
  _source;
  constructor() {
    this._runtimeEnvironment = getRuntimeEnvironment();
    this._storageCapability = getStorageCapability(this._runtimeEnvironment);
    this._source = this._getSourceFromLocalStorage() || this._runtimeEnvironment;
    const telemetryDisabled = this._checkTelemetryDisabled();
    const canSupportTelemetry = this._runtimeEnvironment !== "unknown";
    if (telemetryDisabled) {
      this._posthogBrowserClient = null;
      logger.debug("Telemetry disabled via localStorage");
    } else if (!canSupportTelemetry) {
      this._posthogBrowserClient = null;
      logger.debug(
        `Telemetry disabled - unknown environment: ${this._runtimeEnvironment}`
      );
    } else {
      logger.info(
        "Anonymized telemetry enabled. Set MCP_USE_ANONYMIZED_TELEMETRY=false in localStorage to disable."
      );
      this._posthogLoading = this._initPostHogBrowser();
    }
  }
  _getSourceFromLocalStorage() {
    try {
      if (isLocalStorageFunctional()) {
        return localStorage.getItem("MCP_USE_TELEMETRY_SOURCE");
      }
    } catch {
    }
    return null;
  }
  _checkTelemetryDisabled() {
    if (isLocalStorageFunctional() && localStorage.getItem("MCP_USE_ANONYMIZED_TELEMETRY") === "false") {
      return true;
    }
    return false;
  }
  async _initPostHogBrowser() {
    try {
      const posthogModule = await import("./module-2ZI3WVBG.js");
      const posthogModuleTyped = posthogModule;
      const posthog = posthogModuleTyped.default || posthogModuleTyped.posthog;
      if (!posthog || typeof posthog.init !== "function") {
        throw new Error("posthog-js module did not export expected interface");
      }
      posthog.init(this.PROJECT_API_KEY, {
        api_host: this.HOST,
        persistence: "localStorage",
        autocapture: false,
        // We only want explicit captures
        capture_pageview: false,
        // We don't want automatic pageview tracking
        disable_session_recording: true,
        // No session recording
        loaded: __name(() => {
          logger.debug("PostHog browser client initialized");
        }, "loaded")
      });
      this._posthogBrowserClient = posthog;
    } catch (e) {
      logger.warn(`Failed to initialize PostHog browser telemetry: ${e}`);
      this._posthogBrowserClient = null;
    }
  }
  /**
   * Get the detected runtime environment
   */
  get runtimeEnvironment() {
    return this._runtimeEnvironment;
  }
  /**
   * Get the storage capability for this environment
   */
  get storageCapability() {
    return this._storageCapability;
  }
  static getInstance() {
    if (!_a14.instance) {
      _a14.instance = new _a14();
    }
    return _a14.instance;
  }
  /**
   * Set the source identifier for telemetry events.
   * This allows tracking usage from different applications.
   * @param source - The source identifier (e.g., "my-app", "cli", "vs-code-extension")
   */
  setSource(source) {
    this._source = source;
    try {
      if (isLocalStorageFunctional()) {
        localStorage.setItem("MCP_USE_TELEMETRY_SOURCE", source);
      }
    } catch {
    }
    logger.debug(`Telemetry source set to: ${source}`);
  }
  /**
   * Get the current source identifier.
   */
  getSource() {
    return this._source;
  }
  /**
   * Check if telemetry is enabled.
   */
  get isEnabled() {
    return this._posthogBrowserClient !== null;
  }
  get userId() {
    if (this._currUserId) {
      return this._currUserId;
    }
    try {
      switch (this._storageCapability) {
        case "localStorage":
          this._currUserId = this._getUserIdFromLocalStorage();
          break;
        case "session-only":
        default:
          try {
            this._currUserId = `session-${generateUUID()}`;
          } catch (uuidError) {
            this._currUserId = `session-${Date.now()}-${secureRandomString()}`;
          }
          break;
      }
    } catch (e) {
      this._currUserId = this.UNKNOWN_USER_ID;
    }
    return this._currUserId;
  }
  /**
   * Get or create user ID from localStorage (Browser)
   */
  _getUserIdFromLocalStorage() {
    try {
      if (!isLocalStorageFunctional()) {
        throw new Error("localStorage is not available or not functional");
      }
      localStorage.setItem("__mcp_use_test__", "1");
      localStorage.removeItem("__mcp_use_test__");
      let userId = localStorage.getItem(USER_ID_STORAGE_KEY);
      if (!userId) {
        try {
          userId = generateUUID();
        } catch (uuidError) {
          userId = `${Date.now()}-${secureRandomString()}`;
        }
        localStorage.setItem(USER_ID_STORAGE_KEY, userId);
      }
      return userId;
    } catch (e) {
      logger.debug(`Failed to access localStorage for user ID: ${e}`);
      let sessionId;
      try {
        sessionId = `session-${generateUUID()}`;
      } catch (uuidError) {
        sessionId = `session-${Date.now()}-${secureRandomString()}`;
      }
      return sessionId;
    }
  }
  async capture(event) {
    if (this._posthogLoading) {
      await this._posthogLoading;
    }
    if (!this._posthogBrowserClient) {
      return;
    }
    const currentUserId = this.userId;
    const properties = { ...event.properties };
    properties.mcp_use_version = getPackageVersion();
    properties.language = "typescript";
    properties.source = this._source;
    properties.runtime = this._runtimeEnvironment;
    if (this._posthogBrowserClient) {
      try {
        this._posthogBrowserClient.capture(event.name, {
          ...properties,
          distinct_id: currentUserId
        });
      } catch (e) {
        logger.debug(
          `Failed to track PostHog Browser event ${event.name}: ${e}`
        );
      }
    }
  }
  // ============================================================================
  // Agent Events
  // ============================================================================
  async trackAgentExecution(data) {
    if (!this.isEnabled) return;
    const event = new MCPAgentExecutionEvent(data);
    await this.capture(event);
  }
  // ============================================================================
  // Server Events
  // ============================================================================
  /**
   * Track server run event directly from an MCPServer instance.
   */
  async trackServerRunFromServer(server, transport) {
    if (!this.isEnabled) return;
    const data = createServerRunEventData(server, transport);
    const event = new ServerRunEvent(data);
    await this.capture(event);
  }
  async trackServerInitialize(data) {
    if (!this.isEnabled) return;
    const event = new ServerInitializeEvent(data);
    await this.capture(event);
  }
  async trackServerToolCall(data) {
    if (!this.isEnabled) return;
    const event = new ServerToolCallEvent(data);
    await this.capture(event);
  }
  async trackServerResourceCall(data) {
    if (!this.isEnabled) return;
    const event = new ServerResourceCallEvent(data);
    await this.capture(event);
  }
  async trackServerPromptCall(data) {
    if (!this.isEnabled) return;
    const event = new ServerPromptCallEvent(data);
    await this.capture(event);
  }
  async trackServerContext(data) {
    if (!this.isEnabled) return;
    const event = new ServerContextEvent(data);
    await this.capture(event);
  }
  // ============================================================================
  // Client Events
  // ============================================================================
  async trackMCPClientInit(data) {
    if (!this.isEnabled) return;
    const event = new MCPClientInitEvent(data);
    await this.capture(event);
  }
  async trackConnectorInit(data) {
    if (!this.isEnabled) return;
    const event = new ConnectorInitEvent(data);
    await this.capture(event);
  }
  async trackClientAddServer(serverName, serverConfig) {
    if (!this.isEnabled) return;
    const event = new ClientAddServerEvent({ serverName, serverConfig });
    await this.capture(event);
  }
  async trackClientRemoveServer(serverName) {
    if (!this.isEnabled) return;
    const event = new ClientRemoveServerEvent({ serverName });
    await this.capture(event);
  }
  // ============================================================================
  // React Hook / Browser specific events
  // ============================================================================
  async trackUseMcpConnection(data) {
    if (!this.isEnabled) return;
    await this.capture({
      name: "usemcp_connection",
      properties: {
        url_domain: new URL(data.url).hostname,
        // Only domain for privacy
        transport_type: data.transportType,
        success: data.success,
        error_type: data.errorType ?? null,
        connection_time_ms: data.connectionTimeMs ?? null,
        has_oauth: data.hasOAuth,
        has_sampling: data.hasSampling,
        has_elicitation: data.hasElicitation
      }
    });
  }
  async trackUseMcpToolCall(data) {
    if (!this.isEnabled) return;
    await this.capture({
      name: "usemcp_tool_call",
      properties: {
        tool_name: data.toolName,
        success: data.success,
        error_type: data.errorType ?? null,
        execution_time_ms: data.executionTimeMs ?? null
      }
    });
  }
  async trackUseMcpResourceRead(data) {
    if (!this.isEnabled) return;
    await this.capture({
      name: "usemcp_resource_read",
      properties: {
        resource_uri_scheme: data.resourceUri.split(":")[0],
        // Only scheme for privacy
        success: data.success,
        error_type: data.errorType ?? null
      }
    });
  }
  // ============================================================================
  // Browser-specific Methods
  // ============================================================================
  /**
   * Identify the current user (useful for linking sessions)
   * Browser only
   */
  identify(userId, properties) {
    if (this._posthogBrowserClient) {
      try {
        this._posthogBrowserClient.identify(userId, properties);
      } catch (e) {
        logger.debug(`Failed to identify user: ${e}`);
      }
    }
  }
  /**
   * Reset the user identity (useful for logout)
   * Browser only
   */
  reset() {
    if (this._posthogBrowserClient) {
      try {
        this._posthogBrowserClient.reset();
      } catch (e) {
        logger.debug(`Failed to reset user: ${e}`);
      }
    }
    this._currUserId = null;
  }
  // ============================================================================
  // Node.js-specific Methods (no-ops in browser)
  // ============================================================================
  /**
   * Flush the telemetry queue (Node.js only - no-op in browser)
   */
  flush() {
  }
  /**
   * Shutdown the telemetry client (Node.js only - no-op in browser)
   */
  shutdown() {
  }
  /**
   * Track package download event (Node.js only - no-op in browser)
   */
  async trackPackageDownload(properties) {
  }
}, __name(_a14, "Telemetry"), __publicField(_a14, "instance", null), _a14);
var Tel = Telemetry;
function setTelemetrySource(source) {
  Tel.getInstance().setSource(source);
}
__name(setTelemetrySource, "setTelemetrySource");

// node_modules/mcp-use/dist/chunk-ZAA33UB5.js
var _a15;
var BaseConnector = (_a15 = class {
  client = null;
  connectionManager = null;
  toolsCache = null;
  capabilitiesCache = null;
  serverInfoCache = null;
  connected = false;
  opts;
  notificationHandlers = [];
  rootsCache = [];
  constructor(opts = {}) {
    const finalOpts = {
      ...opts,
      onSampling: opts.onSampling ?? opts.samplingCallback,
      onElicitation: opts.onElicitation ?? opts.elicitationCallback
    };
    if (opts.samplingCallback && !opts.onSampling) {
      logger.warn(
        '[BaseConnector] The "samplingCallback" option is deprecated. Use "onSampling" instead.'
      );
    }
    if (opts.elicitationCallback && !opts.onElicitation) {
      console.warn(
        '[BaseConnector] The "elicitationCallback" option is deprecated. Use "onElicitation" instead.'
      );
    }
    this.opts = finalOpts;
    if (finalOpts.roots) {
      this.rootsCache = [...finalOpts.roots];
    }
    if (finalOpts.onNotification) {
      this.notificationHandlers.push(finalOpts.onNotification);
    }
  }
  /**
   * Track connector initialization event
   * Should be called by subclasses after successful connection
   */
  trackConnectorInit(data) {
    const connectorType = this.constructor.name;
    Telemetry.getInstance().trackConnectorInit({
      connectorType,
      ...data
    }).catch((e) => logger.debug(`Failed to track connector init: ${e}`));
  }
  /**
   * Register a handler for server notifications
   *
   * @param handler - Function to call when a notification is received
   *
   * @example
   * ```typescript
   * connector.onNotification((notification) => {
   *   console.log(`Received: ${notification.method}`, notification.params);
   * });
   * ```
   */
  onNotification(handler) {
    this.notificationHandlers.push(handler);
    if (this.client) {
      this.setupNotificationHandler();
    }
  }
  /**
   * Internal: wire notification handlers to the SDK client
   * Includes automatic handling for list_changed notifications per MCP spec
   */
  setupNotificationHandler() {
    if (!this.client) return;
    this.client.fallbackNotificationHandler = async (notification) => {
      switch (notification.method) {
        case "notifications/tools/list_changed":
          await this.refreshToolsCache();
          break;
        case "notifications/resources/list_changed":
          await this.onResourcesListChanged();
          break;
        case "notifications/prompts/list_changed":
          await this.onPromptsListChanged();
          break;
        default:
          break;
      }
      for (const handler of this.notificationHandlers) {
        try {
          await handler(notification);
        } catch (err) {
          logger.error("Error in notification handler:", err);
        }
      }
    };
  }
  /**
   * Auto-refresh tools cache when server sends tools/list_changed notification
   */
  async refreshToolsCache() {
    if (!this.client) return;
    try {
      logger.debug(
        "[Auto] Refreshing tools cache due to list_changed notification"
      );
      const result = await this.client.listTools();
      this.toolsCache = result.tools ?? [];
      logger.debug(
        `[Auto] Refreshed tools cache: ${this.toolsCache.length} tools`
      );
    } catch (err) {
      logger.warn("[Auto] Failed to refresh tools cache:", err);
    }
  }
  /**
   * Called when server sends resources/list_changed notification
   * Resources aren't cached by default, but we log for user awareness
   */
  async onResourcesListChanged() {
    logger.debug(
      "[Auto] Resources list changed - clients should re-fetch if needed"
    );
  }
  /**
   * Called when server sends prompts/list_changed notification
   * Prompts aren't cached by default, but we log for user awareness
   */
  async onPromptsListChanged() {
    logger.debug(
      "[Auto] Prompts list changed - clients should re-fetch if needed"
    );
  }
  /**
   * Set roots and notify the server.
   * Roots represent directories or files that the client has access to.
   *
   * @param roots - Array of Root objects with `uri` (must start with "file://") and optional `name`
   *
   * @example
   * ```typescript
   * await connector.setRoots([
   *   { uri: "file:///home/user/project", name: "My Project" },
   *   { uri: "file:///home/user/data" }
   * ]);
   * ```
   */
  async setRoots(roots) {
    this.rootsCache = [...roots];
    if (this.client) {
      logger.debug(
        `Sending roots/list_changed notification with ${roots.length} root(s)`
      );
      await this.client.sendRootsListChanged();
    }
  }
  /**
   * Get the current roots.
   */
  getRoots() {
    return [...this.rootsCache];
  }
  /**
   * Internal: set up roots/list request handler.
   * This is called after the client connects to register the handler for server requests.
   */
  setupRootsHandler() {
    if (!this.client) return;
    this.client.setRequestHandler(
      ListRootsRequestSchema,
      async (_request, _extra) => {
        logger.debug(
          `Server requested roots list, returning ${this.rootsCache.length} root(s)`
        );
        return { roots: this.rootsCache };
      }
    );
  }
  /**
   * Internal: set up sampling/createMessage request handler.
   * This is called after the client connects to register the handler for sampling requests.
   */
  setupSamplingHandler() {
    if (!this.client) {
      logger.debug("setupSamplingHandler: No client available");
      return;
    }
    const samplingCallback = this.opts.onSampling ?? this.opts.samplingCallback;
    if (!samplingCallback) {
      logger.debug("setupSamplingHandler: No sampling callback provided");
      return;
    }
    logger.debug("setupSamplingHandler: Setting up sampling request handler");
    this.client.setRequestHandler(
      CreateMessageRequestSchema,
      async (request, _extra) => {
        logger.debug("Server requested sampling, forwarding to callback");
        return await samplingCallback(request.params);
      }
    );
    logger.debug(
      "setupSamplingHandler: Sampling handler registered successfully"
    );
  }
  /**
   * Internal: set up elicitation/create request handler.
   * This is called after the client connects to register the handler for elicitation requests.
   */
  setupElicitationHandler() {
    if (!this.client) {
      logger.debug("setupElicitationHandler: No client available");
      return;
    }
    const elicitationCallback = this.opts.onElicitation ?? this.opts.elicitationCallback;
    if (!elicitationCallback) {
      logger.debug("setupElicitationHandler: No elicitation callback provided");
      return;
    }
    logger.debug(
      "setupElicitationHandler: Setting up elicitation request handler"
    );
    this.client.setRequestHandler(
      ElicitRequestSchema,
      async (request, _extra) => {
        logger.debug("Server requested elicitation, forwarding to callback");
        return await elicitationCallback(request.params);
      }
    );
    logger.debug(
      "setupElicitationHandler: Elicitation handler registered successfully"
    );
  }
  /** Disconnect and release resources. */
  async disconnect() {
    if (!this.connected) {
      logger.debug("Not connected to MCP implementation");
      return;
    }
    logger.debug("Disconnecting from MCP implementation");
    await this.cleanupResources();
    this.connected = false;
    logger.debug("Disconnected from MCP implementation");
  }
  /** Check if the client is connected */
  get isClientConnected() {
    return this.client != null;
  }
  /**
   * Initialise the MCP session **after** `connect()` has succeeded.
   *
   * In the SDK, `Client.connect(transport)` automatically performs the
   * protocollevel `initialize` handshake, so we only need to cache the list of
   * tools and expose some server info.
   */
  async initialize(defaultRequestOptions = this.opts.defaultRequestOptions ?? {}) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug("Caching server capabilities & tools");
    const capabilities = this.client.getServerCapabilities();
    this.capabilitiesCache = capabilities || null;
    const serverInfo = this.client.getServerVersion();
    this.serverInfoCache = serverInfo || null;
    try {
      const listToolsRes = await this.client.listTools(
        void 0,
        defaultRequestOptions
      );
      this.toolsCache = listToolsRes.tools ?? [];
      logger.debug(`Fetched ${this.toolsCache.length} tools from server`);
    } catch (err) {
      const error = err;
      if (error.code === -32601) {
        logger.debug("Server does not implement tools/list, assuming no tools");
      } else {
        logger.debug("Failed to list tools, assuming empty:", error.message);
      }
      this.toolsCache = [];
    }
    logger.debug("Server capabilities:", capabilities);
    logger.debug("Server info:", serverInfo);
    return capabilities;
  }
  /** Lazily expose the cached tools list. */
  get tools() {
    if (!this.toolsCache) {
      throw new Error("MCP client is not initialized; call initialize() first");
    }
    return this.toolsCache;
  }
  /** Expose cached server capabilities. */
  get serverCapabilities() {
    return this.capabilitiesCache || {};
  }
  /** Expose cached server info. */
  get serverInfo() {
    return this.serverInfoCache;
  }
  /** Call a tool on the server. */
  async callTool(name, args, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    const enhancedOptions = options ? { ...options } : void 0;
    if (enhancedOptions?.resetTimeoutOnProgress && !enhancedOptions.onprogress) {
      enhancedOptions.onprogress = () => {
      };
      logger.debug(
        `[BaseConnector] Added onprogress callback for tool '${name}' to enable progressToken`
      );
    }
    logger.debug(`Calling tool '${name}' with args`, args);
    const res = await this.client.callTool(
      { name, arguments: args },
      void 0,
      enhancedOptions
    );
    logger.debug(`Tool '${name}' returned`, res);
    return res;
  }
  /**
   * List all available tools from the MCP server.
   * This method fetches fresh tools from the server, unlike the `tools` getter which returns cached tools.
   *
   * @param options - Optional request options
   * @returns Array of available tools
   */
  async listTools(options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug("[listTools] Fetching fresh tools from server...");
    const result = await this.client.listTools(void 0, options);
    const tools = result.tools ? [...result.tools] : [];
    logger.debug(
      `[listTools] Returned ${tools.length} tools:`,
      tools.map((t) => t.name)
    );
    return tools;
  }
  /**
   * List resources from the server with optional pagination
   *
   * @param cursor - Optional cursor for pagination
   * @param options - Request options
   * @returns Resource list with optional nextCursor for pagination
   */
  async listResources(cursor, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug("Listing resources", cursor ? `with cursor: ${cursor}` : "");
    return await this.client.listResources({ cursor }, options);
  }
  /**
   * List all resources from the server, automatically handling pagination
   *
   * @param options - Request options
   * @returns Complete list of all resources
   */
  async listAllResources(options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    if (!this.capabilitiesCache?.resources) {
      logger.debug("Server does not advertise resources capability, skipping");
      return { resources: [] };
    }
    try {
      logger.debug("Listing all resources (with auto-pagination)");
      const allResources = [];
      let cursor = void 0;
      do {
        const result = await this.client.listResources({ cursor }, options);
        allResources.push(...result.resources || []);
        cursor = result.nextCursor;
      } while (cursor);
      return { resources: allResources };
    } catch (err) {
      const error = err;
      if (error.code === -32601) {
        logger.debug("Server advertised resources but method not found");
        return { resources: [] };
      }
      throw err;
    }
  }
  /**
   * List resource templates from the server
   *
   * @param options - Request options
   * @returns List of available resource templates
   */
  async listResourceTemplates(options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug("Listing resource templates");
    return await this.client.listResourceTemplates(void 0, options);
  }
  /** Read a resource by URI. */
  async readResource(uri, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Reading resource ${uri}`);
    const res = await this.client.readResource({ uri }, options);
    return res;
  }
  /**
   * Subscribe to resource updates
   *
   * @param uri - URI of the resource to subscribe to
   * @param options - Request options
   */
  async subscribeToResource(uri, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Subscribing to resource: ${uri}`);
    return await this.client.subscribeResource({ uri }, options);
  }
  /**
   * Unsubscribe from resource updates
   *
   * @param uri - URI of the resource to unsubscribe from
   * @param options - Request options
   */
  async unsubscribeFromResource(uri, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Unsubscribing from resource: ${uri}`);
    return await this.client.unsubscribeResource({ uri }, options);
  }
  async listPrompts() {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    if (!this.capabilitiesCache?.prompts) {
      logger.debug("Server does not advertise prompts capability, skipping");
      return { prompts: [] };
    }
    try {
      logger.debug("Listing prompts");
      return await this.client.listPrompts();
    } catch (err) {
      const error = err;
      if (error.code === -32601) {
        logger.debug("Server advertised prompts but method not found");
        return { prompts: [] };
      }
      throw err;
    }
  }
  async getPrompt(name, args) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Getting prompt ${name}`);
    return await this.client.getPrompt({ name, arguments: args });
  }
  /** Send a raw request through the client. */
  async request(method, params = null, options) {
    if (!this.client) {
      throw new Error("MCP client is not connected");
    }
    logger.debug(`Sending raw request '${method}' with params`, params);
    return await this.client.request(
      { method, params: params ?? {} },
      void 0,
      options
    );
  }
  /**
   * Helper to tear down the client & connection manager safely.
   */
  async cleanupResources() {
    const issues = [];
    if (this.client) {
      try {
        if (typeof this.client.close === "function") {
          await this.client.close();
        }
      } catch (e) {
        const msg = `Error closing client: ${e}`;
        logger.warn(msg);
        issues.push(msg);
      } finally {
        this.client = null;
      }
    }
    if (this.connectionManager) {
      try {
        await this.connectionManager.stop();
      } catch (e) {
        const msg = `Error stopping connection manager: ${e}`;
        logger.warn(msg);
        issues.push(msg);
      } finally {
        this.connectionManager = null;
      }
    }
    this.toolsCache = null;
    if (issues.length) {
      logger.warn(`Resource cleanup finished with ${issues.length} issue(s)`);
    }
  }
}, __name(_a15, "BaseConnector"), _a15);

// node_modules/@modelcontextprotocol/sdk/dist/esm/validation/ajv-provider.js
var import_ajv = __toESM(require_ajv(), 1);
var import_ajv_formats = __toESM(require_dist(), 1);
function createDefaultAjvInstance() {
  const ajv = new import_ajv.default({
    strict: false,
    validateFormats: true,
    validateSchema: false,
    allErrors: true
  });
  const addFormats = import_ajv_formats.default;
  addFormats(ajv);
  return ajv;
}
var AjvJsonSchemaValidator = class {
  /**
   * Create an AJV validator
   *
   * @param ajv - Optional pre-configured AJV instance. If not provided, a default instance will be created.
   *
   * @example
   * ```typescript
   * // Use default configuration (recommended for most cases)
   * import { AjvJsonSchemaValidator } from '@modelcontextprotocol/sdk/validation/ajv';
   * const validator = new AjvJsonSchemaValidator();
   *
   * // Or provide custom AJV instance for advanced configuration
   * import { Ajv } from 'ajv';
   * import addFormats from 'ajv-formats';
   *
   * const ajv = new Ajv({ validateFormats: true });
   * addFormats(ajv);
   * const validator = new AjvJsonSchemaValidator(ajv);
   * ```
   */
  constructor(ajv) {
    this._ajv = ajv ?? createDefaultAjvInstance();
  }
  /**
   * Create a validator for the given JSON Schema
   *
   * The validator is compiled once and can be reused multiple times.
   * If the schema has an $id, it will be cached by AJV automatically.
   *
   * @param schema - Standard JSON Schema object
   * @returns A validator function that validates input data
   */
  getValidator(schema) {
    const ajvValidator = "$id" in schema && typeof schema.$id === "string" ? this._ajv.getSchema(schema.$id) ?? this._ajv.compile(schema) : this._ajv.compile(schema);
    return (input) => {
      const valid = ajvValidator(input);
      if (valid) {
        return {
          valid: true,
          data: input,
          errorMessage: void 0
        };
      } else {
        return {
          valid: false,
          data: void 0,
          errorMessage: this._ajv.errorsText(ajvValidator.errors)
        };
      }
    };
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/client.js
var ExperimentalClientTasks = class {
  constructor(_client) {
    this._client = _client;
  }
  /**
   * Calls a tool and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * This method provides streaming access to tool execution, allowing you to
   * observe intermediate task status updates for long-running tool calls.
   * Automatically validates structured output if the tool has an outputSchema.
   *
   * @example
   * ```typescript
   * const stream = client.experimental.tasks.callToolStream({ name: 'myTool', arguments: {} });
   * for await (const message of stream) {
   *   switch (message.type) {
   *     case 'taskCreated':
   *       console.log('Tool execution started:', message.task.taskId);
   *       break;
   *     case 'taskStatus':
   *       console.log('Tool status:', message.task.status);
   *       break;
   *     case 'result':
   *       console.log('Tool result:', message.result);
   *       break;
   *     case 'error':
   *       console.error('Tool error:', message.error);
   *       break;
   *   }
   * }
   * ```
   *
   * @param params - Tool call parameters (name and arguments)
   * @param resultSchema - Zod schema for validating the result (defaults to CallToolResultSchema)
   * @param options - Optional request options (timeout, signal, task creation params, etc.)
   * @returns AsyncGenerator that yields ResponseMessage objects
   *
   * @experimental
   */
  async *callToolStream(params, resultSchema = CallToolResultSchema, options) {
    const clientInternal = this._client;
    const optionsWithTask = {
      ...options,
      // We check if the tool is known to be a task during auto-configuration, but assume
      // the caller knows what they're doing if they pass this explicitly
      task: options?.task ?? (clientInternal.isToolTask(params.name) ? {} : void 0)
    };
    const stream = clientInternal.requestStream({ method: "tools/call", params }, resultSchema, optionsWithTask);
    const validator = clientInternal.getToolOutputValidator(params.name);
    for await (const message of stream) {
      if (message.type === "result" && validator) {
        const result = message.result;
        if (!result.structuredContent && !result.isError) {
          yield {
            type: "error",
            error: new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`)
          };
          return;
        }
        if (result.structuredContent) {
          try {
            const validationResult = validator(result.structuredContent);
            if (!validationResult.valid) {
              yield {
                type: "error",
                error: new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`)
              };
              return;
            }
          } catch (error) {
            if (error instanceof McpError) {
              yield { type: "error", error };
              return;
            }
            yield {
              type: "error",
              error: new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error instanceof Error ? error.message : String(error)}`)
            };
            return;
          }
        }
      }
      yield message;
    }
  }
  /**
   * Gets the current status of a task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   * @returns The task status
   *
   * @experimental
   */
  async getTask(taskId, options) {
    return this._client.getTask({ taskId }, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @param taskId - The task identifier
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options
   * @returns The task result
   *
   * @experimental
   */
  async getTaskResult(taskId, resultSchema, options) {
    return this._client.getTaskResult({ taskId }, resultSchema, options);
  }
  /**
   * Lists tasks with optional pagination.
   *
   * @param cursor - Optional pagination cursor
   * @param options - Optional request options
   * @returns List of tasks with optional next cursor
   *
   * @experimental
   */
  async listTasks(cursor, options) {
    return this._client.listTasks(cursor ? { cursor } : void 0, options);
  }
  /**
   * Cancels a running task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   *
   * @experimental
   */
  async cancelTask(taskId, options) {
    return this._client.cancelTask({ taskId }, options);
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * This method provides streaming access to request processing, allowing you to
   * observe intermediate task status updates for task-augmented requests.
   *
   * @param request - The request to send
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options (timeout, signal, task creation params, etc.)
   * @returns AsyncGenerator that yields ResponseMessage objects
   *
   * @experimental
   */
  requestStream(request, resultSchema, options) {
    return this._client.requestStream(request, resultSchema, options);
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/helpers.js
function assertToolsCallTaskCapability(requests, method, entityName) {
  if (!requests) {
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  }
  switch (method) {
    case "tools/call":
      if (!requests.tools?.call) {
        throw new Error(`${entityName} does not support task creation for tools/call (required for ${method})`);
      }
      break;
    default:
      break;
  }
}
function assertClientRequestTaskCapability(requests, method, entityName) {
  if (!requests) {
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  }
  switch (method) {
    case "sampling/createMessage":
      if (!requests.sampling?.createMessage) {
        throw new Error(`${entityName} does not support task creation for sampling/createMessage (required for ${method})`);
      }
      break;
    case "elicitation/create":
      if (!requests.elicitation?.create) {
        throw new Error(`${entityName} does not support task creation for elicitation/create (required for ${method})`);
      }
      break;
    default:
      break;
  }
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/index.js
function applyElicitationDefaults(schema, data) {
  if (!schema || data === null || typeof data !== "object")
    return;
  if (schema.type === "object" && schema.properties && typeof schema.properties === "object") {
    const obj = data;
    const props = schema.properties;
    for (const key of Object.keys(props)) {
      const propSchema = props[key];
      if (obj[key] === void 0 && Object.prototype.hasOwnProperty.call(propSchema, "default")) {
        obj[key] = propSchema.default;
      }
      if (obj[key] !== void 0) {
        applyElicitationDefaults(propSchema, obj[key]);
      }
    }
  }
  if (Array.isArray(schema.anyOf)) {
    for (const sub of schema.anyOf) {
      if (typeof sub !== "boolean") {
        applyElicitationDefaults(sub, data);
      }
    }
  }
  if (Array.isArray(schema.oneOf)) {
    for (const sub of schema.oneOf) {
      if (typeof sub !== "boolean") {
        applyElicitationDefaults(sub, data);
      }
    }
  }
}
function getSupportedElicitationModes(capabilities) {
  if (!capabilities) {
    return { supportsFormMode: false, supportsUrlMode: false };
  }
  const hasFormCapability = capabilities.form !== void 0;
  const hasUrlCapability = capabilities.url !== void 0;
  const supportsFormMode = hasFormCapability || !hasFormCapability && !hasUrlCapability;
  const supportsUrlMode = hasUrlCapability;
  return { supportsFormMode, supportsUrlMode };
}
var Client = class extends Protocol {
  /**
   * Initializes this client with the given name and version information.
   */
  constructor(_clientInfo, options) {
    super(options);
    this._clientInfo = _clientInfo;
    this._cachedToolOutputValidators = /* @__PURE__ */ new Map();
    this._cachedKnownTaskTools = /* @__PURE__ */ new Set();
    this._cachedRequiredTaskTools = /* @__PURE__ */ new Set();
    this._listChangedDebounceTimers = /* @__PURE__ */ new Map();
    this._capabilities = options?.capabilities ?? {};
    this._jsonSchemaValidator = options?.jsonSchemaValidator ?? new AjvJsonSchemaValidator();
    if (options?.listChanged) {
      this._pendingListChangedConfig = options.listChanged;
    }
  }
  /**
   * Set up handlers for list changed notifications based on config and server capabilities.
   * This should only be called after initialization when server capabilities are known.
   * Handlers are silently skipped if the server doesn't advertise the corresponding listChanged capability.
   * @internal
   */
  _setupListChangedHandlers(config2) {
    if (config2.tools && this._serverCapabilities?.tools?.listChanged) {
      this._setupListChangedHandler("tools", ToolListChangedNotificationSchema, config2.tools, async () => {
        const result = await this.listTools();
        return result.tools;
      });
    }
    if (config2.prompts && this._serverCapabilities?.prompts?.listChanged) {
      this._setupListChangedHandler("prompts", PromptListChangedNotificationSchema, config2.prompts, async () => {
        const result = await this.listPrompts();
        return result.prompts;
      });
    }
    if (config2.resources && this._serverCapabilities?.resources?.listChanged) {
      this._setupListChangedHandler("resources", ResourceListChangedNotificationSchema, config2.resources, async () => {
        const result = await this.listResources();
        return result.resources;
      });
    }
  }
  /**
   * Access experimental features.
   *
   * WARNING: These APIs are experimental and may change without notice.
   *
   * @experimental
   */
  get experimental() {
    if (!this._experimental) {
      this._experimental = {
        tasks: new ExperimentalClientTasks(this)
      };
    }
    return this._experimental;
  }
  /**
   * Registers new capabilities. This can only be called before connecting to a transport.
   *
   * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
   */
  registerCapabilities(capabilities) {
    if (this.transport) {
      throw new Error("Cannot register capabilities after connecting to transport");
    }
    this._capabilities = mergeCapabilities(this._capabilities, capabilities);
  }
  /**
   * Override request handler registration to enforce client-side validation for elicitation.
   */
  setRequestHandler(requestSchema, handler) {
    const shape = getObjectShape(requestSchema);
    const methodSchema = shape?.method;
    if (!methodSchema) {
      throw new Error("Schema is missing a method literal");
    }
    let methodValue;
    if (isZ4Schema(methodSchema)) {
      const v4Schema = methodSchema;
      const v4Def = v4Schema._zod?.def;
      methodValue = v4Def?.value ?? v4Schema.value;
    } else {
      const v3Schema = methodSchema;
      const legacyDef = v3Schema._def;
      methodValue = legacyDef?.value ?? v3Schema.value;
    }
    if (typeof methodValue !== "string") {
      throw new Error("Schema method literal must be a string");
    }
    const method = methodValue;
    if (method === "elicitation/create") {
      const wrappedHandler = async (request, extra) => {
        const validatedRequest = safeParse2(ElicitRequestSchema, request);
        if (!validatedRequest.success) {
          const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation request: ${errorMessage}`);
        }
        const { params } = validatedRequest.data;
        params.mode = params.mode ?? "form";
        const { supportsFormMode, supportsUrlMode } = getSupportedElicitationModes(this._capabilities.elicitation);
        if (params.mode === "form" && !supportsFormMode) {
          throw new McpError(ErrorCode.InvalidParams, "Client does not support form-mode elicitation requests");
        }
        if (params.mode === "url" && !supportsUrlMode) {
          throw new McpError(ErrorCode.InvalidParams, "Client does not support URL-mode elicitation requests");
        }
        const result = await Promise.resolve(handler(request, extra));
        if (params.task) {
          const taskValidationResult = safeParse2(CreateTaskResultSchema, result);
          if (!taskValidationResult.success) {
            const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
          }
          return taskValidationResult.data;
        }
        const validationResult = safeParse2(ElicitResultSchema, result);
        if (!validationResult.success) {
          const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation result: ${errorMessage}`);
        }
        const validatedResult = validationResult.data;
        const requestedSchema = params.mode === "form" ? params.requestedSchema : void 0;
        if (params.mode === "form" && validatedResult.action === "accept" && validatedResult.content && requestedSchema) {
          if (this._capabilities.elicitation?.form?.applyDefaults) {
            try {
              applyElicitationDefaults(requestedSchema, validatedResult.content);
            } catch {
            }
          }
        }
        return validatedResult;
      };
      return super.setRequestHandler(requestSchema, wrappedHandler);
    }
    if (method === "sampling/createMessage") {
      const wrappedHandler = async (request, extra) => {
        const validatedRequest = safeParse2(CreateMessageRequestSchema, request);
        if (!validatedRequest.success) {
          const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid sampling request: ${errorMessage}`);
        }
        const { params } = validatedRequest.data;
        const result = await Promise.resolve(handler(request, extra));
        if (params.task) {
          const taskValidationResult = safeParse2(CreateTaskResultSchema, result);
          if (!taskValidationResult.success) {
            const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
          }
          return taskValidationResult.data;
        }
        const hasTools = params.tools || params.toolChoice;
        const resultSchema = hasTools ? CreateMessageResultWithToolsSchema : CreateMessageResultSchema;
        const validationResult = safeParse2(resultSchema, result);
        if (!validationResult.success) {
          const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid sampling result: ${errorMessage}`);
        }
        return validationResult.data;
      };
      return super.setRequestHandler(requestSchema, wrappedHandler);
    }
    return super.setRequestHandler(requestSchema, handler);
  }
  assertCapability(capability, method) {
    if (!this._serverCapabilities?.[capability]) {
      throw new Error(`Server does not support ${capability} (required for ${method})`);
    }
  }
  async connect(transport, options) {
    await super.connect(transport);
    if (transport.sessionId !== void 0) {
      return;
    }
    try {
      const result = await this.request({
        method: "initialize",
        params: {
          protocolVersion: LATEST_PROTOCOL_VERSION,
          capabilities: this._capabilities,
          clientInfo: this._clientInfo
        }
      }, InitializeResultSchema, options);
      if (result === void 0) {
        throw new Error(`Server sent invalid initialize result: ${result}`);
      }
      if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {
        throw new Error(`Server's protocol version is not supported: ${result.protocolVersion}`);
      }
      this._serverCapabilities = result.capabilities;
      this._serverVersion = result.serverInfo;
      if (transport.setProtocolVersion) {
        transport.setProtocolVersion(result.protocolVersion);
      }
      this._instructions = result.instructions;
      await this.notification({
        method: "notifications/initialized"
      });
      if (this._pendingListChangedConfig) {
        this._setupListChangedHandlers(this._pendingListChangedConfig);
        this._pendingListChangedConfig = void 0;
      }
    } catch (error) {
      void this.close();
      throw error;
    }
  }
  /**
   * After initialization has completed, this will be populated with the server's reported capabilities.
   */
  getServerCapabilities() {
    return this._serverCapabilities;
  }
  /**
   * After initialization has completed, this will be populated with information about the server's name and version.
   */
  getServerVersion() {
    return this._serverVersion;
  }
  /**
   * After initialization has completed, this may be populated with information about the server's instructions.
   */
  getInstructions() {
    return this._instructions;
  }
  assertCapabilityForMethod(method) {
    switch (method) {
      case "logging/setLevel":
        if (!this._serverCapabilities?.logging) {
          throw new Error(`Server does not support logging (required for ${method})`);
        }
        break;
      case "prompts/get":
      case "prompts/list":
        if (!this._serverCapabilities?.prompts) {
          throw new Error(`Server does not support prompts (required for ${method})`);
        }
        break;
      case "resources/list":
      case "resources/templates/list":
      case "resources/read":
      case "resources/subscribe":
      case "resources/unsubscribe":
        if (!this._serverCapabilities?.resources) {
          throw new Error(`Server does not support resources (required for ${method})`);
        }
        if (method === "resources/subscribe" && !this._serverCapabilities.resources.subscribe) {
          throw new Error(`Server does not support resource subscriptions (required for ${method})`);
        }
        break;
      case "tools/call":
      case "tools/list":
        if (!this._serverCapabilities?.tools) {
          throw new Error(`Server does not support tools (required for ${method})`);
        }
        break;
      case "completion/complete":
        if (!this._serverCapabilities?.completions) {
          throw new Error(`Server does not support completions (required for ${method})`);
        }
        break;
      case "initialize":
        break;
      case "ping":
        break;
    }
  }
  assertNotificationCapability(method) {
    switch (method) {
      case "notifications/roots/list_changed":
        if (!this._capabilities.roots?.listChanged) {
          throw new Error(`Client does not support roots list changed notifications (required for ${method})`);
        }
        break;
      case "notifications/initialized":
        break;
      case "notifications/cancelled":
        break;
      case "notifications/progress":
        break;
    }
  }
  assertRequestHandlerCapability(method) {
    if (!this._capabilities) {
      return;
    }
    switch (method) {
      case "sampling/createMessage":
        if (!this._capabilities.sampling) {
          throw new Error(`Client does not support sampling capability (required for ${method})`);
        }
        break;
      case "elicitation/create":
        if (!this._capabilities.elicitation) {
          throw new Error(`Client does not support elicitation capability (required for ${method})`);
        }
        break;
      case "roots/list":
        if (!this._capabilities.roots) {
          throw new Error(`Client does not support roots capability (required for ${method})`);
        }
        break;
      case "tasks/get":
      case "tasks/list":
      case "tasks/result":
      case "tasks/cancel":
        if (!this._capabilities.tasks) {
          throw new Error(`Client does not support tasks capability (required for ${method})`);
        }
        break;
      case "ping":
        break;
    }
  }
  assertTaskCapability(method) {
    assertToolsCallTaskCapability(this._serverCapabilities?.tasks?.requests, method, "Server");
  }
  assertTaskHandlerCapability(method) {
    if (!this._capabilities) {
      return;
    }
    assertClientRequestTaskCapability(this._capabilities.tasks?.requests, method, "Client");
  }
  async ping(options) {
    return this.request({ method: "ping" }, EmptyResultSchema, options);
  }
  async complete(params, options) {
    return this.request({ method: "completion/complete", params }, CompleteResultSchema, options);
  }
  async setLoggingLevel(level, options) {
    return this.request({ method: "logging/setLevel", params: { level } }, EmptyResultSchema, options);
  }
  async getPrompt(params, options) {
    return this.request({ method: "prompts/get", params }, GetPromptResultSchema, options);
  }
  async listPrompts(params, options) {
    return this.request({ method: "prompts/list", params }, ListPromptsResultSchema, options);
  }
  async listResources(params, options) {
    return this.request({ method: "resources/list", params }, ListResourcesResultSchema, options);
  }
  async listResourceTemplates(params, options) {
    return this.request({ method: "resources/templates/list", params }, ListResourceTemplatesResultSchema, options);
  }
  async readResource(params, options) {
    return this.request({ method: "resources/read", params }, ReadResourceResultSchema, options);
  }
  async subscribeResource(params, options) {
    return this.request({ method: "resources/subscribe", params }, EmptyResultSchema, options);
  }
  async unsubscribeResource(params, options) {
    return this.request({ method: "resources/unsubscribe", params }, EmptyResultSchema, options);
  }
  /**
   * Calls a tool and waits for the result. Automatically validates structured output if the tool has an outputSchema.
   *
   * For task-based execution with streaming behavior, use client.experimental.tasks.callToolStream() instead.
   */
  async callTool(params, resultSchema = CallToolResultSchema, options) {
    if (this.isToolTaskRequired(params.name)) {
      throw new McpError(ErrorCode.InvalidRequest, `Tool "${params.name}" requires task-based execution. Use client.experimental.tasks.callToolStream() instead.`);
    }
    const result = await this.request({ method: "tools/call", params }, resultSchema, options);
    const validator = this.getToolOutputValidator(params.name);
    if (validator) {
      if (!result.structuredContent && !result.isError) {
        throw new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`);
      }
      if (result.structuredContent) {
        try {
          const validationResult = validator(result.structuredContent);
          if (!validationResult.valid) {
            throw new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`);
          }
        } catch (error) {
          if (error instanceof McpError) {
            throw error;
          }
          throw new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error instanceof Error ? error.message : String(error)}`);
        }
      }
    }
    return result;
  }
  isToolTask(toolName) {
    if (!this._serverCapabilities?.tasks?.requests?.tools?.call) {
      return false;
    }
    return this._cachedKnownTaskTools.has(toolName);
  }
  /**
   * Check if a tool requires task-based execution.
   * Unlike isToolTask which includes 'optional' tools, this only checks for 'required'.
   */
  isToolTaskRequired(toolName) {
    return this._cachedRequiredTaskTools.has(toolName);
  }
  /**
   * Cache validators for tool output schemas.
   * Called after listTools() to pre-compile validators for better performance.
   */
  cacheToolMetadata(tools) {
    this._cachedToolOutputValidators.clear();
    this._cachedKnownTaskTools.clear();
    this._cachedRequiredTaskTools.clear();
    for (const tool of tools) {
      if (tool.outputSchema) {
        const toolValidator = this._jsonSchemaValidator.getValidator(tool.outputSchema);
        this._cachedToolOutputValidators.set(tool.name, toolValidator);
      }
      const taskSupport = tool.execution?.taskSupport;
      if (taskSupport === "required" || taskSupport === "optional") {
        this._cachedKnownTaskTools.add(tool.name);
      }
      if (taskSupport === "required") {
        this._cachedRequiredTaskTools.add(tool.name);
      }
    }
  }
  /**
   * Get cached validator for a tool
   */
  getToolOutputValidator(toolName) {
    return this._cachedToolOutputValidators.get(toolName);
  }
  async listTools(params, options) {
    const result = await this.request({ method: "tools/list", params }, ListToolsResultSchema, options);
    this.cacheToolMetadata(result.tools);
    return result;
  }
  /**
   * Set up a single list changed handler.
   * @internal
   */
  _setupListChangedHandler(listType, notificationSchema, options, fetcher) {
    const parseResult = ListChangedOptionsBaseSchema.safeParse(options);
    if (!parseResult.success) {
      throw new Error(`Invalid ${listType} listChanged options: ${parseResult.error.message}`);
    }
    if (typeof options.onChanged !== "function") {
      throw new Error(`Invalid ${listType} listChanged options: onChanged must be a function`);
    }
    const { autoRefresh, debounceMs } = parseResult.data;
    const { onChanged } = options;
    const refresh = async () => {
      if (!autoRefresh) {
        onChanged(null, null);
        return;
      }
      try {
        const items = await fetcher();
        onChanged(null, items);
      } catch (e) {
        const error = e instanceof Error ? e : new Error(String(e));
        onChanged(error, null);
      }
    };
    const handler = () => {
      if (debounceMs) {
        const existingTimer = this._listChangedDebounceTimers.get(listType);
        if (existingTimer) {
          clearTimeout(existingTimer);
        }
        const timer = setTimeout(refresh, debounceMs);
        this._listChangedDebounceTimers.set(listType, timer);
      } else {
        refresh();
      }
    };
    this.setNotificationHandler(notificationSchema, handler);
  }
  async sendRootsListChanged() {
    return this.notification({ method: "notifications/roots/list_changed" });
  }
};

export {
  ConnectionManager,
  LATEST_PROTOCOL_VERSION,
  isJSONRPCRequest,
  isJSONRPCResultResponse,
  JSONRPCMessageSchema,
  isInitializedNotification,
  getPackageVersion,
  Telemetry,
  Tel,
  setTelemetrySource,
  BaseConnector,
  Client
};
//# sourceMappingURL=chunk-HPUSPYJP.js.map
