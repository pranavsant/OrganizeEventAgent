import {
  require_fs,
  require_path
} from "./chunk-FBTGC2TW.js";
import "./chunk-2UERGAGQ.js";
import {
  BaseMCPClient,
  MCPSession,
  createConnectorFromConfig,
  loadConfigFile,
  normalizeClientInfo,
  resolveCallbacks
} from "./chunk-XFU367PS.js";
import {
  BaseConnector,
  Tel,
  getPackageVersion
} from "./chunk-HPUSPYJP.js";
import {
  external_exports
} from "./chunk-YIV3ILH6.js";
import {
  __name,
  __require,
  logger
} from "./chunk-WPXJGHMH.js";
import {
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/mcp-use/dist/chunk-MJ5Q62O7.js
var _a;
var CodeModeConnector = (_a = class extends BaseConnector {
  mcpClient;
  _tools;
  constructor(client) {
    super();
    this.mcpClient = client;
    this.connected = true;
    this._tools = this._createToolsList();
  }
  async connect() {
    this.connected = true;
  }
  async disconnect() {
    this.connected = false;
  }
  get publicIdentifier() {
    return { name: "code_mode", version: "1.0.0" };
  }
  _createToolsList() {
    return [
      {
        name: "execute_code",
        description: "Execute JavaScript/TypeScript code with access to MCP tools. This is the PRIMARY way to interact with MCP servers in code mode. Write code that discovers tools using search_tools(), calls tools as async functions (e.g., await github.get_pull_request(...)), processes data efficiently, and returns results. Use 'await' for async operations and 'return' to return values. Available in code: search_tools(), __tool_namespaces, and server.tool_name() functions.",
        inputSchema: {
          type: "object",
          properties: {
            code: {
              type: "string",
              description: "JavaScript/TypeScript code to execute. Use 'await' for async operations. Use 'return' to return a value. Available: search_tools(), server.tool_name(), __tool_namespaces"
            },
            timeout: {
              type: "number",
              description: "Execution timeout in milliseconds",
              default: 3e4
            }
          },
          required: ["code"]
        }
      },
      {
        name: "search_tools",
        description: "Search and discover available MCP tools across all servers. Use this to find out what tools are available before writing code. Returns tool information including names, descriptions, and schemas. Can filter by query and control detail level.",
        inputSchema: {
          type: "object",
          properties: {
            query: {
              type: "string",
              description: "Search query to filter tools by name or description",
              default: ""
            },
            detail_level: {
              type: "string",
              description: "Detail level: 'names', 'descriptions', or 'full'",
              enum: ["names", "descriptions", "full"],
              default: "full"
            }
          }
        }
      }
    ];
  }
  // Override tools getter to return static list immediately
  get tools() {
    return this._tools;
  }
  async initialize() {
    this.toolsCache = this._tools;
    return { capabilities: {}, version: "1.0.0" };
  }
  async callTool(name, args) {
    if (name === "execute_code") {
      const code = args.code;
      const timeout = args.timeout || 3e4;
      const result = await this.mcpClient.executeCode(code, timeout);
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result)
          }
        ]
      };
    } else if (name === "search_tools") {
      const query = args.query || "";
      const detailLevel = args.detail_level;
      const result = await this.mcpClient.searchTools(
        query,
        detailLevel && detailLevel in ["names", "descriptions", "full"] ? detailLevel : "full"
      );
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result)
          }
        ]
      };
    }
    throw new Error(`Unknown tool: ${name}`);
  }
}, __name(_a, "CodeModeConnector"), _a);

// node_modules/mcp-use/dist/chunk-RPN2XO5I.js
var _a2;
var JSONSchemaToZod = (_a2 = class {
  /**
   * Converts a JSON schema to a Zod schema.
   *
   * @param {JSONSchema} schema - The JSON schema.
   * @returns {ZodSchema} - The Zod schema.
   */
  static convert(schema) {
    return this.parseSchema(schema);
  }
  /**
   * Checks if data matches a condition schema.
   *
   * @param {JSONValue} data - The data to check.
   * @param {JSONSchema} condition - The condition schema.
   * @returns {boolean} - Whether the data matches the condition.
   */
  static matchesCondition(data, condition) {
    if (!condition.properties) {
      return true;
    }
    if (typeof data !== "object" || data === null || Array.isArray(data)) {
      return false;
    }
    const objectData = data;
    for (const [key, propCondition] of Object.entries(condition.properties)) {
      if (!(key in objectData)) {
        if ("const" in propCondition) {
          return false;
        }
        continue;
      }
      const value = objectData[key];
      if ("const" in propCondition && value !== propCondition["const"]) {
        return false;
      }
      if ("minimum" in propCondition && typeof value === "number" && value < propCondition["minimum"]) {
        return false;
      }
      if ("maximum" in propCondition && typeof value === "number" && value > propCondition["maximum"]) {
        return false;
      }
    }
    return true;
  }
  /**
   * Validates data against a conditional schema and adds issues to context if validation fails.
   *
   * @param {JSONValue} data - The data to validate.
   * @param {JSONSchema} schema - The conditional schema.
   * @param {z.RefinementCtx} ctx - The Zod refinement context.
   */
  static validateConditionalSchema(data, schema, ctx) {
    this.validateRequiredProperties(data, schema, ctx);
    this.validatePropertyPatterns(data, schema, ctx);
    this.validateNestedConditions(data, schema, ctx);
  }
  /**
   * Validates that all required properties are present in the data.
   *
   * @param {JSONValue} data - The data to validate.
   * @param {JSONSchema} schema - The schema containing required properties.
   * @param {z.RefinementCtx} ctx - The Zod refinement context.
   */
  static validateRequiredProperties(data, schema, ctx) {
    if (!schema.required) {
      return;
    }
    if (typeof data !== "object" || data === null) {
      for (const requiredProp of schema.required) {
        ctx.addIssue({
          code: external_exports.ZodIssueCode.custom,
          message: `Required property '${requiredProp}' is missing`,
          path: [requiredProp]
        });
      }
      return;
    }
    for (const requiredProp of schema.required) {
      if (!(requiredProp in data)) {
        ctx.addIssue({
          code: external_exports.ZodIssueCode.custom,
          message: `Required property '${requiredProp}' is missing`,
          path: [requiredProp]
        });
      }
    }
  }
  /**
   * Validates property patterns for string properties.
   *
   * @param {JSONValue} data - The data to validate.
   * @param {JSONSchema} schema - The schema containing property patterns.
   * @param {z.RefinementCtx} ctx - The Zod refinement context.
   */
  static validatePropertyPatterns(data, schema, ctx) {
    if (!schema.properties) {
      return;
    }
    if (typeof data !== "object" || data === null) {
      return;
    }
    if (Array.isArray(data)) {
      return;
    }
    const objectData = data;
    for (const [key, propSchema] of Object.entries(schema.properties)) {
      if (!(key in objectData)) {
        continue;
      }
      const value = objectData[key];
      if (propSchema["pattern"] && typeof value === "string") {
        const regex = new RegExp(propSchema["pattern"]);
        if (!regex.test(value)) {
          ctx.addIssue({
            code: external_exports.ZodIssueCode.custom,
            message: `String '${value}' does not match pattern '${propSchema["pattern"]}'`,
            path: [key]
          });
        }
      }
    }
  }
  /**
   * Validates nested if-then-else conditions.
   *
   * @param {JSONValue} data - The data to validate.
   * @param {JSONSchema} schema - The schema containing if-then-else conditions.
   * @param {z.RefinementCtx} ctx - The Zod refinement context.
   */
  static validateNestedConditions(data, schema, ctx) {
    if (!schema["if"] || !schema["then"]) {
      return;
    }
    const matchesIf = this.matchesCondition(data, schema["if"]);
    if (matchesIf) {
      this.validateConditionalSchema(data, schema["then"], ctx);
    } else if (schema["else"]) {
      this.validateConditionalSchema(data, schema["else"], ctx);
    }
  }
  /**
   * Parses a JSON schema and returns the corresponding Zod schema.
   * This is the main entry point for schema conversion.
   *
   * @param {JSONSchema} schema - The JSON schema.
   * @returns {ZodTypeAny} - The ZodTypeAny schema.
   */
  static parseSchema(schema) {
    let result;
    if (Array.isArray(schema.type)) {
      result = this.handleTypeArray(schema);
    } else if (schema.oneOf || schema.anyOf || schema.allOf) {
      result = this.parseCombinator(schema);
    } else if (schema["if"] && schema["then"]) {
      result = this.parseObject(schema);
    } else if (schema.properties && (!schema.type || schema.type === "object")) {
      result = this.parseObject(schema);
    } else {
      result = this.handleSingleType(schema);
    }
    if (schema.description && typeof result.describe === "function") {
      result = result.describe(schema.description);
    }
    return result;
  }
  /**
   * Handles schemas with an array of types.
   *
   * @param {JSONSchema} schema - The JSON schema with type array.
   * @returns {ZodTypeAny} - The ZodTypeAny schema.
   */
  static handleTypeArray(schema) {
    if (!Array.isArray(schema.type)) {
      throw new Error("Expected schema.type to be an array");
    }
    if (schema.type.includes("null")) {
      return this.handleNullableType(schema);
    }
    return this.createUnionFromTypes(schema.type, schema);
  }
  /**
   * Handles nullable types by creating a nullable schema.
   *
   * @param {JSONSchema} schema - The JSON schema with nullable type.
   * @returns {ZodTypeAny} - The nullable Zod schema.
   */
  static handleNullableType(schema) {
    if (!Array.isArray(schema.type)) {
      throw new Error("Expected schema.type to be an array");
    }
    const nonNullSchema = { ...schema };
    nonNullSchema.type = schema.type.filter((t) => t !== "null");
    if (nonNullSchema.type.length === 1) {
      const singleTypeSchema = this.handleSingleType({
        ...schema,
        type: nonNullSchema.type[0]
      });
      return singleTypeSchema.nullable();
    }
    const unionSchema = this.parseSchema(nonNullSchema);
    return unionSchema.nullable();
  }
  /**
   * Creates a union type from an array of types.
   *
   * @param {string[]} types - Array of type strings.
   * @param {JSONSchema} baseSchema - The base schema to apply to each type.
   * @returns {ZodTypeAny} - The union Zod schema.
   */
  static createUnionFromTypes(types, baseSchema) {
    const schemas = types.map((type) => {
      const singleTypeSchema = { ...baseSchema, type };
      return this.parseSchema(singleTypeSchema);
    });
    return external_exports.union(schemas);
  }
  /**
   * Handles schemas with a single type.
   *
   * @param {JSONSchema} schema - The JSON schema with single type.
   * @returns {ZodTypeAny} - The ZodTypeAny schema.
   */
  static handleSingleType(schema) {
    if (schema.type === void 0) {
      if (schema.oneOf || schema.anyOf || schema.allOf) {
        return this.parseCombinator(schema);
      }
      if (schema.properties) {
        return this.parseObject(schema);
      }
      return external_exports.any();
    }
    switch (schema.type) {
      case "string":
        return this.parseString(schema);
      case "number":
      case "integer":
        return this.parseNumberSchema(schema);
      case "boolean":
        return external_exports.boolean();
      case "array":
        return this.parseArray(schema);
      case "object":
        return this.parseObject(schema);
      default:
        throw new Error("Unsupported schema type");
    }
  }
  /**
   * Parses a number schema.
   *
   * @param {JSONSchema} schema - The JSON schema for a number.
   * @returns {ZodTypeAny} - The ZodTypeAny schema.
   */
  static parseNumberSchema(schema) {
    const numberSchema = external_exports.number();
    let result = numberSchema;
    result = this.applyNumberBounds(numberSchema, schema);
    result = this.applyNumberMultipleOf(numberSchema, schema);
    result = this.applyNumberEnum(numberSchema, schema);
    result = this.applyIntegerConstraint(numberSchema, schema);
    return result;
  }
  /**
   * Applies bounds validation to a number schema.
   *
   * @param {z.ZodNumber} numberSchema - The base number schema.
   * @param {JSONSchema} schema - The JSON schema with bounds.
   * @returns {z.ZodNumber} - The updated schema with bounds validation.
   */
  static applyNumberBounds(numberSchema, schema) {
    let result = numberSchema;
    if (schema["minimum"] !== void 0) {
      result = schema["exclusiveMinimum"] ? result.gt(schema["minimum"]) : result.gte(schema["minimum"]);
    }
    if (schema["maximum"] !== void 0) {
      result = schema["exclusiveMaximum"] ? result.lt(schema["maximum"]) : result.lte(schema["maximum"]);
    }
    return result;
  }
  /**
   * Applies multipleOf validation to a number schema.
   *
   * @param {z.ZodNumber} numberSchema - The base number schema.
   * @param {JSONSchema} schema - The JSON schema with multipleOf.
   * @returns {z.ZodNumber} - The updated schema with multipleOf validation.
   */
  static applyNumberMultipleOf(numberSchema, schema) {
    if (schema["multipleOf"] === void 0) {
      return numberSchema;
    }
    return numberSchema.refine((val) => val % schema["multipleOf"] === 0, {
      message: `Number must be a multiple of ${schema["multipleOf"]}`
    });
  }
  /**
   * Applies enum validation to a number schema.
   *
   * @param {z.ZodNumber} numberSchema - The base number schema.
   * @param {JSONSchema} schema - The JSON schema with enum.
   * @returns {z.ZodNumber} - The updated schema with enum validation.
   */
  static applyNumberEnum(numberSchema, schema) {
    if (!schema.enum) {
      return numberSchema;
    }
    const numberEnums = schema.enum.filter(
      (val) => typeof val === "number"
    );
    if (numberEnums.length === 0) {
      return numberSchema;
    }
    return numberSchema.refine((val) => numberEnums.includes(val), {
      message: `Number must be one of: ${numberEnums.join(", ")}`
    });
  }
  /**
   * Applies integer constraint to a number schema if needed.
   *
   * @param {z.ZodNumber} numberSchema - The base number schema.
   * @param {JSONSchema} schema - The JSON schema.
   * @returns {z.ZodNumber} - The updated schema with integer validation if needed.
   */
  static applyIntegerConstraint(numberSchema, schema) {
    if (schema.type !== "integer") {
      return numberSchema;
    }
    return numberSchema.refine((val) => Number.isInteger(val), {
      message: "Number must be an integer"
    });
  }
  /**
   * Parses a string schema.
   *
   * @param {JSONSchema} schema - The JSON schema for a string.
   * @returns {ZodTypeAny} - The ZodTypeAny schema.
   */
  static parseString(schema) {
    const stringSchema = external_exports.string();
    let result = stringSchema;
    if (schema.format) {
      return this.applyStringFormat(stringSchema, schema);
    } else {
      result = this.applyStringPattern(stringSchema, schema);
      result = this.applyStringLength(stringSchema, schema);
      result = this.applyStringEnum(stringSchema, schema);
    }
    return result;
  }
  /**
   * Applies format validation to a string schema.
   *
   * @param {z.ZodString} stringSchema - The base string schema.
   * @param {JSONSchema} schema - The JSON schema with format.
   * @returns {ZodTypeAny} - The updated schema with format validation.
   */
  static applyStringFormat(stringSchema, schema) {
    if (!schema.format) {
      return stringSchema;
    }
    switch (schema.format) {
      case "email":
        return stringSchema.email();
      case "date-time":
        return stringSchema.datetime();
      case "uri":
        return stringSchema.url();
      case "uuid":
        return stringSchema.uuid();
      case "date":
        return stringSchema.date();
      default:
        return stringSchema;
    }
  }
  /**
   * Applies pattern validation to a string schema.
   *
   * @param {z.ZodString} stringSchema - The base string schema.
   * @param {JSONSchema} schema - The JSON schema with pattern.
   * @returns {z.ZodString} - The updated schema with pattern validation.
   */
  static applyStringPattern(stringSchema, schema) {
    if (!schema["pattern"]) {
      return stringSchema;
    }
    const regex = new RegExp(schema["pattern"]);
    return stringSchema.regex(regex, {
      message: `String must match pattern: ${schema["pattern"]}`
    });
  }
  /**
   * Applies length constraints to a string schema.
   *
   * @param {z.ZodString} stringSchema - The base string schema.
   * @param {JSONSchema} schema - The JSON schema with length constraints.
   * @returns {z.ZodString} - The updated schema with length validation.
   */
  static applyStringLength(stringSchema, schema) {
    const result = stringSchema;
    if (schema["minLength"] !== void 0) {
      stringSchema = stringSchema.min(schema["minLength"]);
    }
    if (schema["maxLength"] !== void 0) {
      stringSchema = stringSchema.max(schema["maxLength"]);
    }
    return result;
  }
  /**
   * Applies enum validation to a string schema.
   *
   * @param {z.ZodString} stringSchema - The base string schema.
   * @param {JSONSchema} schema - The JSON schema with enum.
   * @returns {ZodTypeAny} - The updated schema with enum validation.
   */
  static applyStringEnum(stringSchema, schema) {
    if (!schema.enum) {
      return stringSchema;
    }
    return stringSchema.refine((val) => schema.enum?.includes(val), {
      message: `Value must be one of: ${schema.enum?.join(", ")}`
    });
  }
  /**
   * Parses a JSON schema of type array and returns the corresponding Zod schema.
   *
   * @param {JSONSchema} schema - The JSON schema.
   * @returns {ZodTypeAny} - The ZodTypeAny schema.
   */
  static parseArray(schema) {
    if (Array.isArray(schema.items)) {
      const tupleSchemas = schema.items.map((item) => this.parseSchema(item));
      return external_exports.union(tupleSchemas);
    }
    const itemSchema = schema.items ? this.parseSchema(schema.items) : external_exports.any();
    const arraySchema = external_exports.array(itemSchema);
    let result = arraySchema;
    result = this.applyArrayConstraints(arraySchema, schema);
    return result;
  }
  /**
   * Applies constraints to an array schema.
   *
   * @param {z.ZodArray<any>} arraySchema - The base array schema.
   * @param {JSONSchema} schema - The JSON schema with array constraints.
   * @returns {z.ZodTypeAny} - The updated array schema with constraints.
   */
  static applyArrayConstraints(arraySchema, schema) {
    if (schema["minItems"] !== void 0) {
      arraySchema = arraySchema.min(schema["minItems"]);
    }
    if (schema["maxItems"] !== void 0) {
      arraySchema = arraySchema.max(schema["maxItems"]);
    }
    if (schema["uniqueItems"]) {
      return arraySchema.refine(
        (items) => new Set(items).size === items.length,
        { message: "Array items must be unique" }
      );
    }
    return arraySchema;
  }
  /**
   * Parses an object schema.
   *
   * @param {JSONSchema} schema - The JSON schema for an object.
   * @returns {ZodTypeAny} - The ZodTypeAny schema.
   */
  static parseObject(schema) {
    if (schema["if"] && schema["then"]) {
      return this.parseConditional(schema);
    }
    if (!schema.properties && schema.additionalProperties && typeof schema.additionalProperties === "object") {
      const valueSchema = this.parseSchema(schema.additionalProperties);
      return external_exports.record(external_exports.string(), valueSchema);
    }
    const shape = {};
    this.processObjectProperties(schema, shape);
    return this.processAdditionalProperties(schema, external_exports.object(shape));
  }
  /**
   * Processes object properties and builds the shape object.
   *
   * @param {JSONSchema} schema - The JSON schema for an object.
   * @param {Record<string, ZodTypeAny>} shape - The shape object to populate.
   */
  static processObjectProperties(schema, shape) {
    const required = new Set(schema.required || []);
    if (!schema.properties) {
      return;
    }
    for (const [key, propSchema] of Object.entries(schema.properties)) {
      const zodSchema = this.parseSchema(propSchema);
      shape[key] = required.has(key) ? zodSchema : zodSchema.optional();
    }
  }
  /**
   * Processes additionalProperties configuration.
   *
   * @param {JSONSchema} schema - The JSON schema for an object.
   * @param {z.ZodObject<any, any>} objectSchema - The Zod object schema.
   * @returns {z.ZodObject<any, any>} - The updated Zod object schema.
   */
  static processAdditionalProperties(schema, objectSchema) {
    if (schema.additionalProperties === true) {
      return objectSchema.passthrough();
    } else if (schema.additionalProperties && typeof schema.additionalProperties === "object") {
      const additionalPropSchema = this.parseSchema(
        schema.additionalProperties
      );
      return objectSchema.catchall(additionalPropSchema);
    } else {
      return objectSchema.strict();
    }
  }
  /**
   * Parses a conditional schema with if-then-else.
   *
   * @param {JSONSchema} schema - The JSON schema with conditional validation.
   * @returns {ZodTypeAny} - The conditional Zod schema.
   */
  static parseConditional(schema) {
    const zodObject = this.createBaseObjectSchema(schema);
    const ifCondition = schema["if"];
    const thenSchema = schema["then"];
    const elseSchema = schema["else"];
    return zodObject.superRefine((data, ctx) => {
      const dataWithDefaults = this.applyDefaultValues(
        data,
        schema
      );
      if (this.matchesCondition(dataWithDefaults, ifCondition)) {
        this.validateConditionalSchema(dataWithDefaults, thenSchema, ctx);
      } else if (elseSchema) {
        this.validateConditionalSchema(dataWithDefaults, elseSchema, ctx);
      }
    });
  }
  /**
   * Creates a base object schema from the given JSON schema.
   *
   * @param {JSONSchema} schema - The JSON schema.
   * @returns {z.ZodObject<any, any>} - The base Zod object schema.
   */
  static createBaseObjectSchema(schema) {
    const shape = {};
    const required = new Set(schema.required || []);
    for (const [key, value] of Object.entries(schema.properties || {})) {
      const zodSchema = this.parseSchema(value);
      shape[key] = required.has(key) ? zodSchema : zodSchema.optional();
    }
    const zodObject = external_exports.object(shape);
    return this.processAdditionalProperties(schema, zodObject);
  }
  /**
   * Applies default values from schema properties to data object.
   *
   * @param {JSONValue} data - The original data object.
   * @param {JSONSchema} schema - The schema with default values.
   * @returns {JSONValue} - The data object with defaults applied.
   */
  static applyDefaultValues(data, schema) {
    if (typeof data !== "object" || data === null) {
      return data;
    }
    if (Array.isArray(data)) {
      return data;
    }
    const objectData = data;
    const dataWithDefaults = { ...objectData };
    if (!schema.properties) {
      return dataWithDefaults;
    }
    for (const [key, propSchema] of Object.entries(schema.properties)) {
      if (!(key in dataWithDefaults) && "default" in propSchema) {
        dataWithDefaults[key] = propSchema["default"];
      }
    }
    return dataWithDefaults;
  }
  /**
   * Parses a schema with combinators (oneOf, anyOf, allOf).
   * Delegates to the appropriate combinator parser based on which combinator is present.
   *
   * @param {JSONSchema} schema - The JSON schema with combinators.
   * @returns {ZodTypeAny} - The ZodTypeAny schema.
   */
  static parseCombinator(schema) {
    if (schema.oneOf) {
      return this.parseOneOf(schema.oneOf);
    }
    if (schema.anyOf) {
      return this.parseAnyOf(schema.anyOf);
    }
    if (schema.allOf) {
      return this.parseAllOf(schema.allOf);
    }
    throw new Error("Unsupported schema type");
  }
  /**
   * Parses a oneOf combinator schema.
   *
   * @param {JSONSchema[]} schemas - Array of JSON schemas in the oneOf.
   * @returns {ZodTypeAny} - The ZodTypeAny schema.
   */
  static parseOneOf(schemas) {
    return this.createUnionFromSchemas(schemas);
  }
  /**
   * Parses an anyOf combinator schema.
   *
   * @param {JSONSchema[]} schemas - Array of JSON schemas in the anyOf.
   * @returns {ZodTypeAny} - The ZodTypeAny schema.
   */
  static parseAnyOf(schemas) {
    return this.createUnionFromSchemas(schemas);
  }
  /**
   * Creates a union from an array of schemas, handling special cases.
   *
   * @param {JSONSchema[]} schemas - Array of JSON schemas to create a union from.
   * @returns {ZodTypeAny} - The union Zod schema.
   */
  static createUnionFromSchemas(schemas) {
    if (schemas.length === 0) {
      return external_exports.any();
    }
    if (schemas.length === 1) {
      return this.parseSchema(schemas[0]);
    }
    const zodSchemas = [];
    for (const subSchema of schemas) {
      if (subSchema.type === "null") {
        zodSchemas.push(external_exports.null());
      } else {
        zodSchemas.push(this.parseSchema(subSchema));
      }
    }
    if (zodSchemas.length >= 2) {
      return external_exports.union(zodSchemas);
    } else if (zodSchemas.length === 1) {
      return zodSchemas[0];
    }
    return external_exports.any();
  }
  /**
   * Parses an allOf combinator schema by merging all schemas.
   *
   * @param {JSONSchema[]} schemas - Array of JSON schemas in the allOf.
   * @returns {ZodTypeAny} - The ZodTypeAny schema.
   */
  static parseAllOf(schemas) {
    if (schemas.length === 0) {
      return external_exports.any();
    }
    if (schemas.length === 1) {
      return this.parseSchema(schemas[0]);
    }
    const mergedSchema = schemas.reduce(
      (acc, currentSchema) => this.mergeSchemas(acc, currentSchema)
    );
    return this.parseSchema(mergedSchema);
  }
  /**
   * Merges two JSON schemas together.
   *
   * @param {JSONSchema} baseSchema - The base JSON schema.
   * @param {JSONSchema} addSchema - The JSON schema to add.
   * @returns {JSONSchema} - The merged JSON schema
   */
  static mergeSchemas(baseSchema, addSchema) {
    const merged = { ...baseSchema, ...addSchema };
    if (baseSchema.properties && addSchema.properties) {
      const mergedProperties = {
        ...baseSchema.properties,
        ...addSchema.properties
      };
      merged.properties = mergedProperties;
    }
    if (baseSchema.required && addSchema.required) {
      const mergedRequired = [
        .../* @__PURE__ */ new Set([...baseSchema.required, ...addSchema.required])
      ];
      merged.required = mergedRequired;
    }
    return merged;
  }
}, __name(_a2, "JSONSchemaToZod"), _a2);

// node_modules/mcp-use/dist/chunk-7VW4PHB5.js
var import_fs = __toESM(require_fs(), 1);
var import_path = __toESM(require_path(), 1);
var _a3;
var BaseCodeExecutor = (_a3 = class {
  client;
  _connecting = false;
  constructor(client) {
    this.client = client;
  }
  /**
   * Ensure all configured MCP servers are connected before execution.
   * Prevents race conditions with a connection lock.
   */
  async ensureServersConnected() {
    const configuredServers = this.client.getServerNames();
    const activeSessions = Object.keys(this.client.getAllActiveSessions());
    const missingServers = configuredServers.filter(
      (s) => !activeSessions.includes(s)
    );
    if (missingServers.length > 0 && !this._connecting) {
      this._connecting = true;
      try {
        logger.debug(
          `Connecting to configured servers for code execution: ${missingServers.join(", ")}`
        );
        await this.client.createAllSessions();
      } finally {
        this._connecting = false;
      }
    } else if (missingServers.length > 0 && this._connecting) {
      logger.debug("Waiting for ongoing server connection...");
      const startWait = Date.now();
      while (this._connecting && Date.now() - startWait < 5e3) {
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
    }
  }
  /**
   * Get tool namespace information from all active MCP sessions.
   * Filters out the internal code_mode server.
   */
  getToolNamespaces() {
    const namespaces = [];
    const activeSessions = this.client.getAllActiveSessions();
    for (const [serverName, session] of Object.entries(activeSessions)) {
      if (serverName === "code_mode") continue;
      try {
        const connector = session.connector;
        let tools;
        try {
          tools = connector.tools;
        } catch (e) {
          logger.warn(`Tools not available for server ${serverName}: ${e}`);
          continue;
        }
        if (!tools || tools.length === 0) continue;
        namespaces.push({ serverName, tools, session });
      } catch (e) {
        logger.warn(`Failed to load tools for server ${serverName}: ${e}`);
      }
    }
    return namespaces;
  }
  /**
   * Create a search function for discovering available MCP tools.
   * Used by code execution environments to find tools at runtime.
   */
  createSearchToolsFunction() {
    return async (query = "", detailLevel = "full") => {
      const allTools = [];
      const allNamespaces = /* @__PURE__ */ new Set();
      const queryLower = query.toLowerCase();
      const activeSessions = this.client.getAllActiveSessions();
      for (const [serverName, session] of Object.entries(activeSessions)) {
        if (serverName === "code_mode") continue;
        try {
          const tools = session.connector.tools;
          if (tools && tools.length > 0) {
            allNamespaces.add(serverName);
          }
          for (const tool of tools) {
            if (detailLevel === "names") {
              allTools.push({ name: tool.name, server: serverName });
            } else if (detailLevel === "descriptions") {
              allTools.push({
                name: tool.name,
                server: serverName,
                description: tool.description
              });
            } else {
              allTools.push({
                name: tool.name,
                server: serverName,
                description: tool.description,
                input_schema: tool.inputSchema
              });
            }
          }
        } catch (e) {
          logger.warn(`Failed to search tools in server ${serverName}: ${e}`);
        }
      }
      let filteredTools = allTools;
      if (query) {
        filteredTools = allTools.filter((tool) => {
          const nameMatch = tool.name.toLowerCase().includes(queryLower);
          const descMatch = tool.description?.toLowerCase().includes(queryLower);
          const serverMatch = tool.server.toLowerCase().includes(queryLower);
          return nameMatch || descMatch || serverMatch;
        });
      }
      return {
        meta: {
          total_tools: allTools.length,
          namespaces: Array.from(allNamespaces).sort(),
          result_count: filteredTools.length
        },
        results: filteredTools
      };
    };
  }
}, __name(_a3, "BaseCodeExecutor"), _a3);
var _a4;
var E2BCodeExecutor = (_a4 = class extends BaseCodeExecutor {
  e2bApiKey;
  codeExecSandbox = null;
  SandboxClass = null;
  timeoutMs;
  constructor(client, options) {
    super(client);
    this.e2bApiKey = options.apiKey;
    this.timeoutMs = options.timeoutMs ?? 3e5;
  }
  /**
   * Lazy load E2B Sandbox class.
   * This allows the library to work without E2B installed.
   */
  async ensureSandboxClass() {
    if (this.SandboxClass) return;
    try {
      const e2b = await import("./code-interpreter_mcp-use_false-VLOFK2YC.js");
      this.SandboxClass = e2b.Sandbox;
    } catch (error) {
      throw new Error(
        "@e2b/code-interpreter is not installed. The E2B code executor requires this optional dependency. Install it with: yarn add @e2b/code-interpreter"
      );
    }
  }
  /**
   * Get or create a dedicated sandbox for code execution.
   */
  async getOrCreateCodeExecSandbox() {
    if (this.codeExecSandbox) return this.codeExecSandbox;
    await this.ensureSandboxClass();
    logger.debug("Starting E2B sandbox for code execution...");
    this.codeExecSandbox = await this.SandboxClass.create("base", {
      apiKey: this.e2bApiKey,
      timeoutMs: this.timeoutMs
    });
    return this.codeExecSandbox;
  }
  /**
   * Generate the shim code that exposes tools to the sandbox environment.
   * Creates a bridge that intercepts tool calls and sends them back to host.
   */
  generateShim(tools) {
    let shim = `
// MCP Bridge Shim
global.__callMcpTool = async (server, tool, args) => {
    const id = Math.random().toString(36).substring(7);
    console.log(JSON.stringify({
        type: '__MCP_TOOL_CALL__',
        id,
        server,
        tool,
        args
    }));
    
    const resultPath = \`/tmp/mcp_result_\${id}.json\`;
    const fs = require('fs');
    
    // Poll for result file
    let attempts = 0;
    while (attempts < 300) { // 30 seconds timeout
        if (fs.existsSync(resultPath)) {
            const content = fs.readFileSync(resultPath, 'utf8');
            const result = JSON.parse(content);
            fs.unlinkSync(resultPath); // Clean up
            
            if (result.error) {
                throw new Error(result.error);
            }
            return result.data;
        }
        await new Promise(resolve => setTimeout(resolve, 100));
        attempts++;
    }
    throw new Error('Tool execution timed out');
};

// Global search_tools helper
global.search_tools = async (query, detailLevel = 'full') => {
    const allTools = ${JSON.stringify(
      Object.entries(tools).flatMap(
        ([server, serverTools]) => serverTools.map((tool) => ({
          name: tool.name,
          description: tool.description,
          server,
          input_schema: tool.inputSchema
        }))
      )
    )};
    
    const filtered = allTools.filter(tool => {
        if (!query) return true;
        const q = query.toLowerCase();
        return tool.name.toLowerCase().includes(q) || 
               (tool.description && tool.description.toLowerCase().includes(q));
    });
    
    if (detailLevel === 'names') {
        return filtered.map(t => ({ name: t.name, server: t.server }));
    } else if (detailLevel === 'descriptions') {
        return filtered.map(t => ({ name: t.name, server: t.server, description: t.description }));
    }
    return filtered;
};
`;
    for (const [serverName, serverTools] of Object.entries(tools)) {
      if (!serverTools || serverTools.length === 0) continue;
      const safeServerName = serverName.replace(/[^a-zA-Z0-9_]/g, "_");
      shim += `
global['${serverName}'] = {`;
      for (const tool of serverTools) {
        shim += `
    '${tool.name}': async (args) => await global.__callMcpTool('${serverName}', '${tool.name}', args),`;
      }
      shim += `
};

// Also expose as safe name if different
if ('${safeServerName}' !== '${serverName}') {
    global['${safeServerName}'] = global['${serverName}'];
}
`;
    }
    return shim;
  }
  /**
   * Build the tool catalog for the shim.
   * Returns a map of server names to their available tools.
   */
  buildToolCatalog() {
    const catalog = {};
    const namespaces = this.getToolNamespaces();
    for (const { serverName, tools } of namespaces) {
      catalog[serverName] = tools;
    }
    return catalog;
  }
  /**
   * Execute JavaScript/TypeScript code in an E2B sandbox with MCP tool access.
   * Tool calls are proxied back to the host via the bridge pattern.
   *
   * @param code - Code to execute
   * @param timeout - Execution timeout in milliseconds (default: 30000)
   */
  async execute(code, timeout = 3e4) {
    const startTime = Date.now();
    let result = null;
    let error = null;
    let logs = [];
    try {
      await this.ensureServersConnected();
      const sandbox = await this.getOrCreateCodeExecSandbox();
      const toolCatalog = this.buildToolCatalog();
      const shim = this.generateShim(toolCatalog);
      const wrappedCode = `
${shim}

(async () => {
    try {
        const func = async () => {
            ${code}
        };
        const result = await func();
        console.log('__MCP_RESULT_START__');
        console.log(JSON.stringify(result));
        console.log('__MCP_RESULT_END__');
    } catch (e) {
        console.error(e);
        process.exit(1);
    }
})();
`;
      const filename = `exec_${Date.now()}.js`;
      await sandbox.files.write(filename, wrappedCode);
      const execution = await sandbox.commands.run(`node ${filename}`, {
        timeoutMs: timeout,
        onStdout: __name(async (data) => {
          try {
            const lines = data.split("\n");
            for (const line of lines) {
              if (line.trim().startsWith('{"type":"__MCP_TOOL_CALL__"')) {
                const call = JSON.parse(line);
                if (call.type === "__MCP_TOOL_CALL__") {
                  try {
                    logger.debug(
                      `[E2B Bridge] Calling tool ${call.server}.${call.tool}`
                    );
                    const activeSessions = this.client.getAllActiveSessions();
                    const session = activeSessions[call.server];
                    if (!session) {
                      throw new Error(`Server ${call.server} not found`);
                    }
                    const toolResult = await session.connector.callTool(
                      call.tool,
                      call.args
                    );
                    let extractedResult = toolResult;
                    if (toolResult.content && toolResult.content.length > 0) {
                      const item = toolResult.content[0];
                      if (item.type === "text") {
                        try {
                          extractedResult = JSON.parse(item.text);
                        } catch {
                          extractedResult = item.text;
                        }
                      } else {
                        extractedResult = item;
                      }
                    }
                    const resultPath = `/tmp/mcp_result_${call.id}.json`;
                    await sandbox.files.write(
                      resultPath,
                      JSON.stringify({ data: extractedResult })
                    );
                  } catch (err) {
                    logger.error(
                      `[E2B Bridge] Tool execution failed: ${err.message}`
                    );
                    const resultPath = `/tmp/mcp_result_${call.id}.json`;
                    await sandbox.files.write(
                      resultPath,
                      JSON.stringify({
                        error: err.message || String(err)
                      })
                    );
                  }
                }
              }
            }
          } catch (e) {
          }
        }, "onStdout")
      });
      logs = [execution.stdout, execution.stderr].filter(Boolean);
      if (execution.exitCode !== 0) {
        error = execution.stderr || "Execution failed";
      } else {
        const stdout = execution.stdout;
        const startMarker = "__MCP_RESULT_START__";
        const endMarker = "__MCP_RESULT_END__";
        const startIndex = stdout.indexOf(startMarker);
        const endIndex = stdout.indexOf(endMarker);
        if (startIndex !== -1 && endIndex !== -1) {
          const jsonStr = stdout.substring(startIndex + startMarker.length, endIndex).trim();
          try {
            result = JSON.parse(jsonStr);
          } catch (e) {
            result = jsonStr;
          }
          logs = logs.map((log) => {
            let cleaned = log.replace(
              new RegExp(startMarker + "[\\s\\S]*?" + endMarker),
              "[Result captured]"
            );
            cleaned = cleaned.split("\n").filter((l) => !l.includes("__MCP_TOOL_CALL__")).join("\n");
            return cleaned;
          });
        }
      }
    } catch (e) {
      error = e.message || String(e);
      if (error && (error.includes("timeout") || error.includes("timed out"))) {
        error = "Script execution timed out";
      }
    }
    return {
      result,
      logs,
      error,
      execution_time: (Date.now() - startTime) / 1e3
    };
  }
  /**
   * Clean up the E2B sandbox.
   * Should be called when the executor is no longer needed.
   */
  async cleanup() {
    if (this.codeExecSandbox) {
      try {
        await this.codeExecSandbox.kill();
        this.codeExecSandbox = null;
        logger.debug("E2B code execution sandbox stopped");
      } catch (error) {
        logger.error("Failed to stop E2B code execution sandbox:", error);
      }
    }
  }
}, __name(_a4, "E2BCodeExecutor"), _a4);
var vm = null;
var vmCheckAttempted = false;
function getVMModuleName() {
  return ["node", "vm"].join(":");
}
__name(getVMModuleName, "getVMModuleName");
function tryLoadVM() {
  if (vmCheckAttempted) {
    return vm !== null;
  }
  vmCheckAttempted = true;
  try {
    const nodeRequire = typeof __require !== "undefined" ? __require : null;
    if (nodeRequire) {
      vm = nodeRequire(getVMModuleName());
      return true;
    }
  } catch (error) {
    logger.debug("node:vm module not available via require");
  }
  return false;
}
__name(tryLoadVM, "tryLoadVM");
async function tryLoadVMAsync() {
  if (vm !== null) {
    return true;
  }
  if (!vmCheckAttempted) {
    if (tryLoadVM()) {
      return true;
    }
  }
  try {
    vm = await import(
      /* @vite-ignore */
      getVMModuleName()
    );
    return true;
  } catch (error) {
    logger.debug(
      "node:vm module not available in this environment (e.g., Deno)"
    );
    return false;
  }
}
__name(tryLoadVMAsync, "tryLoadVMAsync");
function isVMAvailable() {
  tryLoadVM();
  return vm !== null;
}
__name(isVMAvailable, "isVMAvailable");
var _a5;
var VMCodeExecutor = (_a5 = class extends BaseCodeExecutor {
  defaultTimeout;
  memoryLimitMb;
  constructor(client, options) {
    super(client);
    this.defaultTimeout = options?.timeoutMs ?? 3e4;
    this.memoryLimitMb = options?.memoryLimitMb;
    tryLoadVM();
  }
  /**
   * Ensure VM module is loaded before execution
   */
  async ensureVMLoaded() {
    if (vm !== null) {
      return;
    }
    const loaded = await tryLoadVMAsync();
    if (!loaded) {
      throw new Error(
        "node:vm module is not available in this environment. Please use E2B executor instead or run in a Node.js environment."
      );
    }
  }
  /**
   * Execute JavaScript/TypeScript code with access to MCP tools.
   *
   * @param code - Code to execute
   * @param timeout - Execution timeout in milliseconds (default: configured timeout or 30000)
   */
  async execute(code, timeout) {
    const effectiveTimeout = timeout ?? this.defaultTimeout;
    await this.ensureVMLoaded();
    await this.ensureServersConnected();
    const logs = [];
    const startTime = Date.now();
    let result = null;
    let error = null;
    try {
      const context = await this._buildContext(logs);
      const wrappedCode = `
        (async () => {
          try {
            ${code}
          } catch (e) {
            throw e;
          }
        })()
      `;
      const script = new vm.Script(wrappedCode, {
        filename: "agent_code.js"
      });
      const promise = script.runInNewContext(context, {
        timeout: effectiveTimeout,
        displayErrors: true
      });
      result = await promise;
    } catch (e) {
      error = e.message || String(e);
      if (e.code === "ERR_SCRIPT_EXECUTION_TIMEOUT" || e.message === "Script execution timed out." || typeof error === "string" && (error.includes("timed out") || error.includes("timeout"))) {
        error = "Script execution timed out";
      }
      if (e.stack) {
        logger.debug(`Code execution error stack: ${e.stack}`);
      }
    }
    const executionTime = (Date.now() - startTime) / 1e3;
    return {
      result,
      logs,
      error,
      execution_time: executionTime
    };
  }
  /**
   * Build the VM execution context with MCP tools and standard globals.
   *
   * @param logs - Array to capture console output
   */
  async _buildContext(logs) {
    const logHandler = __name((...args) => {
      logs.push(
        args.map(
          (arg) => typeof arg === "object" ? JSON.stringify(arg, null, 2) : String(arg)
        ).join(" ")
      );
    }, "logHandler");
    const sandbox = {
      console: {
        log: logHandler,
        error: __name((...args) => {
          logHandler("[ERROR]", ...args);
        }, "error"),
        warn: __name((...args) => {
          logHandler("[WARN]", ...args);
        }, "warn"),
        info: logHandler,
        debug: logHandler
      },
      // Standard globals
      Object,
      Array,
      String,
      Number,
      Boolean,
      Date,
      Math,
      JSON,
      RegExp,
      Map,
      Set,
      Promise,
      parseInt,
      parseFloat,
      isNaN,
      isFinite,
      encodeURI,
      decodeURI,
      encodeURIComponent,
      decodeURIComponent,
      setTimeout,
      clearTimeout,
      // Helper for tools
      search_tools: this.createSearchToolsFunction(),
      __tool_namespaces: []
    };
    const toolNamespaces = {};
    const namespaceInfos = this.getToolNamespaces();
    for (const { serverName, tools, session } of namespaceInfos) {
      const serverNamespace = {};
      for (const tool of tools) {
        const toolName = tool.name;
        serverNamespace[toolName] = async (args) => {
          const result = await session.connector.callTool(toolName, args || {});
          if (result.content && result.content.length > 0) {
            const item = result.content[0];
            if (item.type === "text") {
              try {
                return JSON.parse(item.text);
              } catch {
                return item.text;
              }
            }
            return item;
          }
          return result;
        };
      }
      sandbox[serverName] = serverNamespace;
      toolNamespaces[serverName] = true;
    }
    sandbox.__tool_namespaces = Object.keys(toolNamespaces);
    return vm.createContext(sandbox);
  }
  /**
   * Clean up resources.
   * VM executor doesn't need cleanup, but method kept for interface consistency.
   */
  async cleanup() {
  }
}, __name(_a5, "VMCodeExecutor"), _a5);
function hasRequestedSchema(params) {
  return "requestedSchema" in params && params.requestedSchema != null;
}
__name(hasRequestedSchema, "hasRequestedSchema");
function getDefaults(params) {
  const content = {};
  if (!hasRequestedSchema(params)) return content;
  const schema = params.requestedSchema;
  const properties = schema.properties ?? {};
  for (const [fieldName, fieldSchema] of Object.entries(properties)) {
    const field = fieldSchema;
    if ("default" in field) {
      const v = field.default;
      if (typeof v === "string" || typeof v === "number" || typeof v === "boolean" || Array.isArray(v) && v.every((x) => typeof x === "string")) {
        content[fieldName] = v;
      }
    }
  }
  return content;
}
__name(getDefaults, "getDefaults");
function applyDefaults(params, partial) {
  const defaults = getDefaults(params);
  if (partial == null) return defaults;
  return { ...defaults, ...partial };
}
__name(applyDefaults, "applyDefaults");
function acceptWithDefaults(params) {
  return { action: "accept", content: getDefaults(params) };
}
__name(acceptWithDefaults, "acceptWithDefaults");
function accept(content) {
  return { action: "accept", content };
}
__name(accept, "accept");
function decline(_reason) {
  return { action: "decline" };
}
__name(decline, "decline");
function cancel() {
  return { action: "cancel" };
}
__name(cancel, "cancel");
function reject(reason) {
  return decline(reason);
}
__name(reject, "reject");
function validate(params, content) {
  if (!hasRequestedSchema(params)) {
    return { valid: true };
  }
  try {
    const zodSchema = JSONSchemaToZod.convert(
      params.requestedSchema
    );
    const result = zodSchema.safeParse(content);
    if (result.success) {
      return { valid: true };
    }
    const messages = result.error.issues.map(
      (i) => i.path.length > 0 ? `${i.path.join(".")}: ${i.message}` : i.message
    );
    return { valid: false, errors: messages };
  } catch {
    return { valid: false, errors: ["Unsupported or invalid schema"] };
  }
}
__name(validate, "validate");
var _a6;
var MCPClient = (_a6 = class extends BaseMCPClient {
  /**
   * Gets the mcp-use package version.
   *
   * This static method returns the version string of the installed mcp-use package,
   * which is useful for debugging and compatibility checks.
   *
   * @returns The package version string (e.g., "1.13.2")
   *
   * @example
   * ```typescript
   * console.log(`mcp-use version: ${MCPClient.getPackageVersion()}`);
   * ```
   */
  static getPackageVersion() {
    return getPackageVersion();
  }
  /**
   * Indicates whether code execution mode is enabled.
   *
   * When true, the client provides special tools for executing code dynamically
   * through the {@link executeCode} and {@link searchTools} methods.
   *
   * @example
   * ```typescript
   * if (client.codeMode) {
   *   const result = await client.executeCode('return 2 + 2');
   *   console.log(result.output); // "4"
   * }
   * ```
   */
  codeMode = false;
  _codeExecutor = null;
  _customCodeExecutor = null;
  _codeExecutorConfig = "vm";
  _executorOptions;
  _globalCallbacks;
  /**
   * Creates a new MCPClient instance.
   *
   * The client can be initialized with either a configuration object, a path to
   * a configuration file, or no configuration at all (servers can be added later
   * using {@link addServer}).
   *
   * @param config - Configuration object or path to JSON config file. If omitted,
   *                 starts with empty configuration
   * @param options - Optional client behavior configuration
   * @param options.codeMode - Enable code execution mode (boolean or advanced config)
   * @param options.onSampling - Callback for handling sampling requests from servers
   * @param options.elicitationCallback - Callback for handling elicitation requests
   *
   * @example
   * ```typescript
   * // From config file
   * const client = new MCPClient('./mcp-config.json');
   * ```
   *
   * @example
   * ```typescript
   * // From inline config
   * const client = new MCPClient({
   *   mcpServers: {
   *     'my-server': {
   *       command: 'node',
   *       args: ['server.js']
   *     }
   *   }
   * });
   * ```
   *
   * @example
   * ```typescript
   * // With code mode enabled
   * const client = new MCPClient('./config.json', {
   *   codeMode: true
   * });
   * ```
   *
   * @example
   * ```typescript
   * // With sampling callback
   * const client = new MCPClient('./config.json', {
   *   onSampling: async (params) => {
   *     // Call your LLM here
   *     return anthropic.messages.create(params);
   *   }
   * });
   * ```
   *
   * @see {@link fromDict} for creating from config object (alternative syntax)
   * @see {@link fromConfigFile} for creating from file (alternative syntax)
   */
  constructor(config, options) {
    if (config) {
      if (typeof config === "string") {
        super(loadConfigFile(config));
      } else {
        super(config);
      }
    } else {
      super();
    }
    let codeModeEnabled = false;
    let executorConfig = "vm";
    let executorOptions;
    if (options?.codeMode) {
      if (typeof options.codeMode === "boolean") {
        codeModeEnabled = options.codeMode;
      } else {
        codeModeEnabled = options.codeMode.enabled;
        executorConfig = options.codeMode.executor ?? "vm";
        executorOptions = options.codeMode.executorOptions;
      }
    }
    this.codeMode = codeModeEnabled;
    this._codeExecutorConfig = executorConfig;
    this._executorOptions = executorOptions;
    const configRoot = this.config;
    this._globalCallbacks = {
      onSampling: options?.onSampling ?? options?.samplingCallback ?? configRoot?.onSampling ?? configRoot?.samplingCallback,
      samplingCallback: options?.samplingCallback ?? configRoot?.samplingCallback,
      onElicitation: options?.onElicitation ?? options?.elicitationCallback ?? configRoot?.onElicitation ?? configRoot?.elicitationCallback,
      elicitationCallback: options?.elicitationCallback ?? configRoot?.elicitationCallback,
      onNotification: options?.onNotification ?? configRoot?.onNotification
    };
    if (options?.samplingCallback && !options?.onSampling) {
      console.warn(
        '[MCPClient] The "samplingCallback" option is deprecated. Use "onSampling" instead.'
      );
    }
    if (options?.elicitationCallback && !options?.onElicitation) {
      console.warn(
        '[MCPClient] The "elicitationCallback" option is deprecated. Use "onElicitation" instead.'
      );
    }
    if (this.codeMode) {
      this._setupCodeModeConnector();
    }
    this._trackClientInit();
  }
  _trackClientInit() {
    const servers = Object.keys(this.config.mcpServers ?? {});
    const hasSamplingCallback = !!(this._globalCallbacks.onSampling ?? this._globalCallbacks.samplingCallback);
    const hasElicitationCallback = !!(this._globalCallbacks.onElicitation ?? this._globalCallbacks.elicitationCallback);
    Tel.getInstance().trackMCPClientInit({
      codeMode: this.codeMode,
      sandbox: false,
      // Sandbox not supported in TS yet
      allCallbacks: hasSamplingCallback && hasElicitationCallback,
      verify: false,
      // No verify option in TS client
      servers,
      numServers: servers.length,
      isBrowser: false
      // Node.js MCPClient
    }).catch((e) => logger.debug(`Failed to track MCPClient init: ${e}`));
  }
  /**
   * Creates a client instance from a configuration dictionary.
   *
   * This static factory method provides an alternative syntax for creating
   * a client from an inline configuration object.
   *
   * @param cfg - Configuration dictionary with server definitions
   * @param options - Optional client behavior configuration
   * @returns New MCPClient instance
   *
   * @example
   * ```typescript
   * const client = MCPClient.fromDict({
   *   mcpServers: {
   *     'filesystem': {
   *       command: 'npx',
   *       args: ['-y', '@modelcontextprotocol/server-filesystem', '/tmp']
   *     }
   *   }
   * });
   * ```
   *
   * @see {@link constructor} for direct instantiation
   * @see {@link fromConfigFile} for loading from file
   */
  static fromDict(cfg, options) {
    return new _a6(cfg, options);
  }
  /**
   * Creates a client instance from a configuration file.
   *
   * This static factory method loads MCP server configurations from a JSON
   * file and creates a new client instance.
   *
   * @param path - Path to the JSON configuration file
   * @param options - Optional client behavior configuration
   * @returns New MCPClient instance
   * @throws {Error} If the file cannot be read or parsed
   *
   * @example
   * ```typescript
   * const client = MCPClient.fromConfigFile('./mcp-config.json');
   * await client.createAllSessions();
   * ```
   *
   * @example
   * ```typescript
   * // With code mode
   * const client = MCPClient.fromConfigFile('./config.json', {
   *   codeMode: true
   * });
   * ```
   *
   * @see {@link constructor} for direct instantiation
   * @see {@link fromDict} for inline configuration
   */
  static fromConfigFile(path2, options) {
    return new _a6(loadConfigFile(path2), options);
  }
  /**
   * Saves the current configuration to a file.
   *
   * This Node.js-specific method writes the client's current configuration
   * (including all server definitions) to a JSON file. The directory will be
   * created if it doesn't exist.
   *
   * @param filepath - Path where the configuration file should be saved
   *
   * @example
   * ```typescript
   * const client = new MCPClient();
   * client.addServer('my-server', {
   *   command: 'node',
   *   args: ['server.js']
   * });
   *
   * // Save configuration for later use
   * client.saveConfig('./mcp-config.json');
   * ```
   *
   * @see {@link fromConfigFile} for loading configurations
   */
  saveConfig(filepath) {
    const dir = import_path.default.dirname(filepath);
    if (!import_fs.default.existsSync(dir)) {
      import_fs.default.mkdirSync(dir, { recursive: true });
    }
    import_fs.default.writeFileSync(filepath, JSON.stringify(this.config, null, 2), "utf-8");
  }
  /**
   * Create a connector from server configuration (Node.js version)
   * Supports all connector types including StdioConnector (lazy-loaded to avoid pulling Node-only code into browser bundles).
   */
  async createConnectorFromConfig(serverConfig) {
    const resolved = resolveCallbacks(
      serverConfig,
      this._globalCallbacks
    );
    const merged = {
      ...serverConfig,
      clientInfo: serverConfig.clientInfo ?? this.config.clientInfo
    };
    if ("command" in merged && "args" in merged) {
      const { StdioConnector } = await import("./stdio-ZKXAJGR6-FGEBEQLT.js");
      const stdioConfig = merged;
      return new StdioConnector({
        command: stdioConfig.command,
        args: stdioConfig.args,
        env: stdioConfig.env,
        clientInfo: normalizeClientInfo(merged.clientInfo),
        onSampling: resolved.onSampling,
        onElicitation: resolved.onElicitation,
        onNotification: resolved.onNotification
      });
    }
    return createConnectorFromConfig(merged, {
      onSampling: resolved.onSampling,
      onElicitation: resolved.onElicitation,
      onNotification: resolved.onNotification
    });
  }
  _setupCodeModeConnector() {
    logger.debug("Code mode connector initialized as internal meta server");
    const connector = new CodeModeConnector(this);
    const session = new MCPSession(connector);
    this.sessions["code_mode"] = session;
    this.activeSessions.push("code_mode");
  }
  _ensureCodeExecutor() {
    if (!this._codeExecutor) {
      const config = this._codeExecutorConfig;
      if (config instanceof BaseCodeExecutor) {
        this._codeExecutor = config;
      } else if (typeof config === "function") {
        this._customCodeExecutor = config;
        throw new Error(
          "Custom executor function should be handled in executeCode"
        );
      } else if (config === "e2b") {
        const opts = this._executorOptions;
        if (!opts?.apiKey) {
          logger.warn("E2B executor requires apiKey. Falling back to VM.");
          try {
            this._codeExecutor = new VMCodeExecutor(
              this,
              this._executorOptions
            );
          } catch (error) {
            throw new Error(
              "VM executor is not available in this environment and E2B API key is not provided. Please provide an E2B API key or run in a Node.js environment."
            );
          }
        } else {
          this._codeExecutor = new E2BCodeExecutor(this, opts);
        }
      } else {
        try {
          this._codeExecutor = new VMCodeExecutor(
            this,
            this._executorOptions
          );
        } catch (error) {
          const e2bOpts = this._executorOptions;
          const e2bApiKey = e2bOpts?.apiKey || process.env.E2B_API_KEY;
          if (e2bApiKey) {
            logger.info(
              "VM executor not available in this environment. Falling back to E2B."
            );
            this._codeExecutor = new E2BCodeExecutor(this, {
              ...e2bOpts,
              apiKey: e2bApiKey
            });
          } else {
            throw new Error(
              "VM executor is not available in this environment. Please provide an E2B API key via executorOptions or E2B_API_KEY environment variable, or run in a Node.js environment."
            );
          }
        }
      }
    }
    return this._codeExecutor;
  }
  /**
   * Executes JavaScript/TypeScript code in a sandboxed environment.
   *
   * This method is only available when code mode is enabled. It executes the
   * provided code in an isolated environment (VM or E2B sandbox) and returns
   * the results including stdout, stderr, and return value.
   *
   * @param code - JavaScript/TypeScript code to execute
   * @param timeout - Optional execution timeout in milliseconds
   * @returns Execution result with output, errors, and return value
   * @throws {Error} If code mode is not enabled
   *
   * @example
   * ```typescript
   * const client = new MCPClient('./config.json', { codeMode: true });
   *
   * const result = await client.executeCode(`
   *   console.log('Hello, world!');
   *   return 2 + 2;
   * `);
   *
   * console.log(result.stdout);      // "Hello, world!\n"
   * console.log(result.returnValue); // 4
   * ```
   *
   * @example
   * ```typescript
   * // With timeout
   * try {
   *   const result = await client.executeCode('while(true) {}', 1000);
   * } catch (error) {
   *   console.log('Execution timed out');
   * }
   * ```
   *
   * @see {@link searchTools} for discovering available tools in code mode
   */
  async executeCode(code, timeout) {
    if (!this.codeMode) {
      throw new Error("Code execution mode is not enabled");
    }
    if (this._customCodeExecutor) {
      return this._customCodeExecutor(code, timeout);
    }
    return this._ensureCodeExecutor().execute(code, timeout);
  }
  /**
   * Searches for available tools across all MCP servers.
   *
   * This method is only available when code mode is enabled. It searches
   * through tools from all active servers and returns matching tools based
   * on the query and detail level.
   *
   * @param query - Optional search query to filter tools (defaults to empty string for all tools)
   * @param detailLevel - Level of detail to return: "names", "descriptions", or "full"
   * @returns Tool search results with matching tools
   * @throws {Error} If code mode is not enabled
   *
   * @example
   * ```typescript
   * const client = new MCPClient('./config.json', { codeMode: true });
   * await client.createAllSessions();
   *
   * // Search for all tools
   * const allTools = await client.searchTools();
   * console.log(`Found ${allTools.tools.length} tools`);
   *
   * // Search for specific tools
   * const fileTools = await client.searchTools('file', 'descriptions');
   * ```
   *
   * @see {@link executeCode} for executing code in code mode
   */
  async searchTools(query = "", detailLevel = "full") {
    if (!this.codeMode) {
      throw new Error("Code execution mode is not enabled");
    }
    return this._ensureCodeExecutor().createSearchToolsFunction()(
      query,
      detailLevel
    );
  }
  /**
   * Gets the names of all configured MCP servers (excluding internal servers).
   *
   * This method overrides the base implementation to filter out internal
   * meta-servers like the code mode server, which is an implementation detail
   * not intended for direct user interaction.
   *
   * @returns Array of user-configured server names
   *
   * @example
   * ```typescript
   * const names = client.getServerNames();
   * console.log(`User servers: ${names.join(', ')}`);
   * // Note: 'code_mode' is excluded even if code mode is enabled
   * ```
   *
   * @see {@link activeSessions} for servers with active sessions
   */
  getServerNames() {
    const isCodeModeEnabled = this.codeMode;
    return super.getServerNames().filter((name) => {
      return !isCodeModeEnabled || name !== "code_mode";
    });
  }
  /**
   * Closes the client and cleans up all resources.
   *
   * This method performs a complete cleanup by:
   * 1. Shutting down code executors (VM or E2B sandboxes)
   * 2. Closing all active MCP sessions
   * 3. Releasing any other held resources
   *
   * Always call this method when you're done with the client to ensure
   * proper resource cleanup, especially when using E2B sandboxes which
   * have associated costs.
   *
   * @example
   * ```typescript
   * const client = new MCPClient('./config.json', { codeMode: true });
   * await client.createAllSessions();
   *
   * // Do work...
   *
   * // Clean up
   * await client.close();
   * ```
   *
   * @example
   * ```typescript
   * // Use in shutdown handler
   * process.on('SIGINT', async () => {
   *   console.log('Shutting down...');
   *   await client.close();
   *   process.exit(0);
   * });
   * ```
   *
   * @see {@link closeAllSessions} for closing just the sessions
   */
  async close() {
    if (this._codeExecutor) {
      await this._codeExecutor.cleanup();
      this._codeExecutor = null;
    }
    await this.closeAllSessions();
  }
}, __name(_a6, "MCPClient"), _a6);
export {
  BaseCodeExecutor,
  E2BCodeExecutor,
  MCPClient,
  MCPSession,
  VMCodeExecutor,
  accept,
  acceptWithDefaults,
  applyDefaults,
  cancel,
  decline,
  getDefaults,
  isVMAvailable,
  reject,
  validate
};
//# sourceMappingURL=mcp-use_client.js.map
