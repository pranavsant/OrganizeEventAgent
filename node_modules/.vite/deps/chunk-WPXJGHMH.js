import {
  __publicField,
  __require
} from "./chunk-2TUXWMP5.js";

// node_modules/mcp-use/dist/chunk-3GQAWCBQ.js
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require2 = ((x) => typeof __require !== "undefined" ? __require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof __require !== "undefined" ? __require : a)[b]
}) : x)(function(x) {
  if (typeof __require !== "undefined") return __require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// node_modules/mcp-use/dist/chunk-QWQYAQCK.js
var DEFAULT_LOGGER_NAME = "mcp-use";
function resolveLevel(env) {
  const envValue = typeof process !== "undefined" && process.env ? env : void 0;
  switch (envValue?.trim()) {
    case "2":
      return "debug";
    case "1":
      return "info";
    default:
      return "info";
  }
}
__name(resolveLevel, "resolveLevel");
function formatArgs(args) {
  if (args.length === 0) return "";
  return args.map((arg) => {
    if (typeof arg === "string") return arg;
    try {
      return JSON.stringify(arg);
    } catch {
      return String(arg);
    }
  }).join(" ");
}
__name(formatArgs, "formatArgs");
var _a;
var SimpleConsoleLogger = (_a = class {
  _level;
  name;
  format;
  constructor(name = DEFAULT_LOGGER_NAME, level = "info", format = "minimal") {
    this.name = name;
    this._level = level;
    this.format = format;
  }
  shouldLog(level) {
    if (this._level === "silent") return false;
    const levels = [
      "silent",
      "error",
      "warn",
      "info",
      "http",
      "verbose",
      "debug",
      "silly"
    ];
    const currentIndex = levels.indexOf(this._level);
    const messageIndex = levels.indexOf(level);
    return messageIndex <= currentIndex;
  }
  formatMessage(level, message, args) {
    const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", { hour12: false });
    const extraArgs = formatArgs(args);
    const fullMessage = extraArgs ? `${message} ${extraArgs}` : message;
    switch (this.format) {
      case "detailed":
        return `${timestamp} [${this.name}] ${level.toUpperCase()}: ${fullMessage}`;
      case "emoji": {
        const emojiMap = {
          silent: "",
          error: "âŒ",
          warn: "âš ï¸",
          info: "â„¹ï¸",
          http: "ðŸŒ",
          verbose: "ðŸ“",
          debug: "ðŸ”",
          silly: "ðŸ¤ª"
        };
        return `${timestamp} [${this.name}] ${emojiMap[level] || ""} ${level.toUpperCase()}: ${fullMessage}`;
      }
      case "minimal":
      default:
        return `${timestamp} [${this.name}] ${level}: ${fullMessage}`;
    }
  }
  error(message, ...args) {
    if (this.shouldLog("error")) {
      console.error(this.formatMessage("error", message, args));
    }
  }
  warn(message, ...args) {
    if (this.shouldLog("warn")) {
      console.warn(this.formatMessage("warn", message, args));
    }
  }
  info(message, ...args) {
    if (this.shouldLog("info")) {
      console.info(this.formatMessage("info", message, args));
    }
  }
  debug(message, ...args) {
    if (this.shouldLog("debug")) {
      console.debug(this.formatMessage("debug", message, args));
    }
  }
  http(message, ...args) {
    if (this.shouldLog("http")) {
      console.log(this.formatMessage("http", message, args));
    }
  }
  verbose(message, ...args) {
    if (this.shouldLog("verbose")) {
      console.log(this.formatMessage("verbose", message, args));
    }
  }
  silly(message, ...args) {
    if (this.shouldLog("silly")) {
      console.log(this.formatMessage("silly", message, args));
    }
  }
  get level() {
    return this._level;
  }
  set level(newLevel) {
    this._level = newLevel;
  }
  setFormat(format) {
    this.format = format;
  }
}, __name(_a, "SimpleConsoleLogger"), _a);
var _a2;
var Logger = (_a2 = class {
  static get(name = DEFAULT_LOGGER_NAME) {
    if (!this.instances[name]) {
      const debugEnv = typeof process !== "undefined" && process.env?.DEBUG || void 0;
      this.instances[name] = new SimpleConsoleLogger(
        name,
        resolveLevel(debugEnv),
        this.currentFormat
      );
    }
    return this.instances[name];
  }
  static configure(options = {}) {
    const { level, format = "minimal" } = options;
    const debugEnv = typeof process !== "undefined" && process.env?.DEBUG || void 0;
    const resolvedLevel = level ?? resolveLevel(debugEnv);
    this.currentFormat = format;
    Object.values(this.instances).forEach((logger2) => {
      logger2.level = resolvedLevel;
      logger2.setFormat(format);
    });
  }
  static setDebug(enabled) {
    let level;
    if (enabled === 2 || enabled === true) level = "debug";
    else if (enabled === 1) level = "info";
    else level = "info";
    Object.values(this.instances).forEach((logger2) => {
      logger2.level = level;
    });
    if (typeof process !== "undefined" && process.env) {
      process.env.DEBUG = enabled ? enabled === true ? "2" : String(enabled) : "0";
    }
  }
  static setFormat(format) {
    this.currentFormat = format;
    this.configure({ format });
  }
}, __name(_a2, "Logger"), __publicField(_a2, "instances", {}), __publicField(_a2, "currentFormat", "minimal"), _a2);
var logger = Logger.get();

export {
  __name,
  __require2 as __require,
  Logger,
  logger
};
//# sourceMappingURL=chunk-WPXJGHMH.js.map
