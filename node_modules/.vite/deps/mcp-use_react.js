import {
  clearRpcLogs,
  getAllRpcLogs,
  getRpcLogs,
  subscribeToRpcLogs
} from "./chunk-H5KJA35H.js";
import {
  require_react
} from "./chunk-CTRVV34M.js";
import {
  BaseMCPClient,
  HttpConnector,
  auth,
  discoverAuthorizationServerMetadata,
  discoverOAuthProtectedResourceMetadata,
  extractWWWAuthenticateParams,
  normalizeClientInfo,
  refreshAuthorization,
  resolveCallbacks
} from "./chunk-XFU367PS.js";
import {
  Tel,
  Telemetry,
  getPackageVersion,
  setTelemetrySource
} from "./chunk-HPUSPYJP.js";
import "./chunk-YIV3ILH6.js";
import {
  Logger,
  __name,
  logger
} from "./chunk-WPXJGHMH.js";
import {
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/mcp-use/dist/chunk-K4JZBXZM.js
function createNotification(method, params) {
  return {
    jsonrpc: "2.0",
    method,
    ...params && { params }
  };
}
__name(createNotification, "createNotification");
function createRequest(id, method, params) {
  return {
    jsonrpc: "2.0",
    id,
    method,
    ...params && { params }
  };
}
__name(createRequest, "createRequest");

// node_modules/mcp-use/dist/chunk-RYMNQ23J.js
function isLocalServer(domain) {
  return domain === "localhost" || domain === "127.0.0.1" || domain.startsWith("127.") || domain.startsWith("192.168.") || domain.startsWith("10.") || domain.startsWith("172.");
}
__name(isLocalServer, "isLocalServer");
function getSubdomainLevels(hostname) {
  const parts = hostname.split(".");
  const levels = [];
  for (let i = 0; i < parts.length - 1; i++) {
    levels.push(parts.slice(i).join("."));
  }
  return levels;
}
__name(getSubdomainLevels, "getSubdomainLevels");
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      resolve(reader.result);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}
__name(blobToBase64, "blobToBase64");
async function detectFavicon(serverUrl) {
  console.debug(
    "[favicon-detector] Starting favicon detection for:",
    serverUrl
  );
  try {
    let domain;
    if (serverUrl.startsWith("http://") || serverUrl.startsWith("https://")) {
      domain = new URL(serverUrl).hostname;
    } else if (serverUrl.includes("://")) {
      domain = serverUrl.split("://")[1].split("/")[0];
    } else {
      domain = serverUrl.split("/")[0];
    }
    console.debug("[favicon-detector] Extracted domain:", domain);
    if (isLocalServer(domain)) {
      console.debug("[favicon-detector] Skipping local server:", domain);
      return null;
    }
    const domainsToTry = getSubdomainLevels(domain);
    console.debug("[favicon-detector] Domains to try:", domainsToTry);
    for (const currentDomain of domainsToTry) {
      try {
        const faviconApiUrl = `https://favicon.tools.mcp-use.com/${currentDomain}?response=json`;
        console.debug(
          "[favicon-detector] Attempting to fetch favicon metadata for:",
          currentDomain,
          "from:",
          faviconApiUrl
        );
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 2e3);
        try {
          const response = await fetch(faviconApiUrl, {
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (!response.ok) {
            console.debug(
              "[favicon-detector] Fetch failed for",
              currentDomain,
              "with status:",
              response.status
            );
            continue;
          }
          const data = await response.json();
          console.debug(
            "[favicon-detector] Retrieved favicon metadata for:",
            currentDomain,
            "source:",
            data.source
          );
          const imageUrl = data.url.replace(/^http:\/\//, "https://");
          const imageResponse = await fetch(imageUrl);
          if (!imageResponse.ok) {
            console.debug(
              "[favicon-detector] Failed to fetch favicon image for",
              currentDomain,
              "status:",
              imageResponse.status
            );
            continue;
          }
          const blob = await imageResponse.blob();
          const base64Image = await blobToBase64(blob);
          if (data.source === "default") {
            console.debug(
              "[favicon-detector] Found default favicon for:",
              currentDomain,
              "skipping and continuing to search for non-default"
            );
            continue;
          }
          console.debug(
            "[favicon-detector] Successfully retrieved non-default favicon for:",
            currentDomain,
            "source:",
            data.source,
            "size:",
            blob.size,
            "bytes"
          );
          return base64Image;
        } catch (err) {
          clearTimeout(timeoutId);
          console.debug(
            "[favicon-detector] Fetch error for",
            currentDomain,
            ":",
            err instanceof Error ? err.message : String(err)
          );
          continue;
        }
      } catch (error) {
        console.debug(
          "[favicon-detector] Error processing domain",
          currentDomain,
          ":",
          error instanceof Error ? error.message : String(error)
        );
        continue;
      }
    }
    console.debug(
      "[favicon-detector] No non-default favicon found for:",
      serverUrl,
      "returning null to show gradient fallback"
    );
    return null;
  } catch (error) {
    console.warn("[favicon-detector] Error detecting favicon:", error);
    return null;
  }
}
__name(detectFavicon, "detectFavicon");
function applyProxyConfig(originalUrl, proxyConfig) {
  const proxyHeaders = proxyConfig?.headers ?? proxyConfig?.customHeaders ?? {};
  if (proxyConfig?.customHeaders && !proxyConfig?.headers) {
    console.warn(
      '[applyProxyConfig] The "customHeaders" option in proxyConfig is deprecated. Use "headers" instead.'
    );
  }
  if (!proxyConfig?.proxyAddress) {
    return {
      url: originalUrl,
      headers: proxyHeaders
    };
  }
  const proxyUrl = new URL(proxyConfig.proxyAddress);
  const targetUrl = new URL(originalUrl);
  const finalUrl = `${proxyUrl.origin}${proxyUrl.pathname}${targetUrl.pathname}${targetUrl.search}`;
  const headers = {
    "X-Target-URL": originalUrl,
    ...proxyHeaders
  };
  return { url: finalUrl, headers };
}
__name(applyProxyConfig, "applyProxyConfig");

// node_modules/mcp-use/dist/chunk-QCAOYQX6.js
var _a;
var BrowserMCPClient = (_a = class extends BaseMCPClient {
  /**
   * Get the mcp-use package version.
   * Works in all environments (Node.js, browser, Cloudflare Workers, Deno, etc.)
   */
  static getPackageVersion() {
    return getPackageVersion();
  }
  constructor(config) {
    super(config);
    this._trackClientInit();
  }
  _trackClientInit() {
    const servers = Object.keys(this.config.mcpServers ?? {});
    Tel.getInstance().trackMCPClientInit({
      codeMode: false,
      // Browser client doesn't support code mode
      sandbox: false,
      // Sandbox not supported in browser
      allCallbacks: false,
      // Will be set per-server
      verify: false,
      servers,
      numServers: servers.length,
      isBrowser: true
      // Browser MCPClient
    }).catch(
      (e) => logger.debug(`Failed to track BrowserMCPClient init: ${e}`)
    );
  }
  static fromDict(cfg) {
    return new _a(cfg);
  }
  /**
   * Create a connector from server configuration (Browser version)
   * Supports HTTP connector only
   */
  createConnectorFromConfig(serverConfig) {
    const {
      url,
      headers,
      fetch: fetch2,
      authToken,
      authProvider,
      wrapTransport,
      clientOptions,
      disableSseFallback,
      preferSse,
      gatewayUrl,
      serverId
    } = serverConfig;
    if (!url) {
      throw new Error("Server URL is required");
    }
    const globalDefaults = this.config;
    const resolved = resolveCallbacks(
      serverConfig,
      globalDefaults
    );
    const clientInfo = normalizeClientInfo(
      serverConfig.clientInfo ?? this.config.clientInfo
    );
    const connectorOptions = {
      headers,
      fetch: fetch2,
      authToken,
      authProvider,
      wrapTransport,
      clientOptions,
      onSampling: resolved.onSampling,
      onElicitation: resolved.onElicitation,
      onNotification: resolved.onNotification,
      disableSseFallback,
      preferSse,
      clientInfo,
      gatewayUrl,
      serverId
    };
    logger.debug(
      `[BrowserMCPClient] Connector options prepared (clientOptions: ${clientOptions ? "provided" : "none"})`
    );
    return new HttpConnector(url, connectorOptions);
  }
}, __name(_a, "BrowserMCPClient"), _a);

// node_modules/mcp-use/dist/chunk-MXENOGA5.js
async function probeAuthParams(serverUrl, fetchFn = fetch) {
  const base = serverUrl.replace(/\/$/, "");
  const url = base.endsWith("/mcp") ? base : `${base}/mcp`;
  const response = await fetchFn(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      jsonrpc: "2.0",
      method: "initialize",
      id: 1,
      params: {}
    })
  });
  if (response.status !== 401) {
    return {};
  }
  const { resourceMetadataUrl, scope } = extractWWWAuthenticateParams(response);
  return { resourceMetadataUrl, scope };
}
__name(probeAuthParams, "probeAuthParams");

// node_modules/mcp-use/dist/chunk-6KHHFWTB.js
function sanitizeUrl(raw) {
  const abort = __name(() => {
    throw new Error(`Invalid url to pass to open(): ${raw}`);
  }, "abort");
  let url;
  try {
    url = new URL(raw);
  } catch (_) {
    abort();
  }
  if (url.protocol !== "https:" && url.protocol !== "http:") abort();
  if (url.hostname !== encodeURIComponent(url.hostname)) abort();
  if (url.username) url.username = encodeURIComponent(url.username);
  if (url.password) url.password = encodeURIComponent(url.password);
  url.pathname = url.pathname.slice(0, 1) + encodeURIComponent(url.pathname.slice(1)).replace(/%2f/gi, "/");
  url.search = url.search.slice(0, 1) + Array.from(url.searchParams.entries()).map(sanitizeParam).join("&");
  url.hash = url.hash.slice(0, 1) + encodeURIComponent(url.hash.slice(1));
  return url.href;
}
__name(sanitizeUrl, "sanitizeUrl");
function sanitizeParam([k, v]) {
  return `${encodeURIComponent(k)}${v.length > 0 ? `=${encodeURIComponent(v)}` : ""}`;
}
__name(sanitizeParam, "sanitizeParam");
async function serializeBody(body) {
  if (typeof body === "string") return body;
  if (body instanceof URLSearchParams || body instanceof FormData) {
    return Object.fromEntries(body.entries());
  }
  if (body instanceof Blob) return await body.text();
  return body;
}
__name(serializeBody, "serializeBody");
var _a2;
var BrowserOAuthClientProvider = (_a2 = class {
  serverUrl;
  storageKeyPrefix;
  serverUrlHash;
  clientName;
  clientUri;
  logoUri;
  callbackUrl;
  preventAutoAuth;
  useRedirectFlow;
  oauthProxyUrl;
  connectionUrl;
  // MCP proxy URL that client connected to
  originalFetch;
  _cachedAuthServerUrl = null;
  _cachedMetadata = null;
  _refreshPromise = null;
  onPopupWindow;
  constructor(serverUrl, options = {}) {
    this.serverUrl = serverUrl;
    this.storageKeyPrefix = options.storageKeyPrefix || "mcp:auth";
    this.serverUrlHash = this.hashString(serverUrl);
    this.clientName = options.clientName || "mcp-use";
    this.clientUri = options.clientUri || (typeof window !== "undefined" ? window.location.origin : "");
    this.logoUri = options.logoUri || "https://mcp-use.com/logo.png";
    this.callbackUrl = sanitizeUrl(
      options.callbackUrl || (typeof window !== "undefined" ? new URL("/oauth/callback", window.location.origin).toString() : "/oauth/callback")
    );
    this.preventAutoAuth = options.preventAutoAuth;
    this.useRedirectFlow = options.useRedirectFlow;
    this.oauthProxyUrl = options.oauthProxyUrl;
    this.connectionUrl = options.connectionUrl;
    this.onPopupWindow = options.onPopupWindow;
  }
  /**
   * Install fetch interceptor to proxy OAuth requests through the backend
   */
  installFetchInterceptor() {
    if (!this.oauthProxyUrl) {
      console.warn(
        "[BrowserOAuthProvider] No OAuth proxy URL configured, skipping fetch interceptor installation"
      );
      return;
    }
    if (!this.originalFetch) {
      this.originalFetch = window.fetch;
    } else {
      console.warn(
        "[BrowserOAuthProvider] Fetch interceptor already installed"
      );
      return;
    }
    const oauthProxyUrl = this.oauthProxyUrl;
    const connectionUrl = this.connectionUrl;
    const serverUrl = this.serverUrl;
    const originalFetch = this.originalFetch;
    console.log(
      `[BrowserOAuthProvider] Installing fetch interceptor with proxy: ${oauthProxyUrl}`
    );
    window.fetch = __name(async function interceptedFetch(input, init) {
      const url = typeof input === "string" ? input : input instanceof URL ? input.toString() : input.url;
      const isOAuthRequest = url.includes("/.well-known/") || url.match(/\/(register|token|authorize)$/);
      if (!isOAuthRequest) {
        return await originalFetch(input, init);
      }
      try {
        const urlObj = new URL(url);
        const proxyUrlObj = new URL(oauthProxyUrl);
        if (urlObj.origin === proxyUrlObj.origin && (urlObj.pathname.startsWith(proxyUrlObj.pathname) || url.includes("/inspector/api/oauth"))) {
          return await originalFetch(input, init);
        }
      } catch {
      }
      try {
        const isMetadata = url.includes("/.well-known/");
        let metadataUrl = url;
        if (isMetadata && serverUrl) {
          try {
            const urlObj = new URL(url);
            const serverUrlObj = new URL(serverUrl);
            if (urlObj.protocol === "http:" && serverUrlObj.protocol === "https:") {
              const pathMatch = urlObj.pathname.match(/(\/.well-known\/[^/]+)/);
              const wellKnownPath = pathMatch ? pathMatch[1] : urlObj.pathname;
              metadataUrl = `${serverUrlObj.origin}${wellKnownPath}`;
              console.log(
                `[OAuth Proxy] Rewrote gateway metadata URL ${url} to server URL ${metadataUrl}`
              );
            } else if (connectionUrl) {
              const connectionUrlObj = new URL(connectionUrl);
              if (urlObj.origin === connectionUrlObj.origin && urlObj.origin !== serverUrlObj.origin) {
                const pathMatch = urlObj.pathname.match(
                  /(\/.well-known\/[^/]+)/
                );
                const wellKnownPath = pathMatch ? pathMatch[1] : urlObj.pathname;
                metadataUrl = `${serverUrlObj.origin}${wellKnownPath}`;
                console.log(
                  `[OAuth Proxy] Rewrote gateway metadata URL ${url} to server URL ${metadataUrl}`
                );
              }
            }
          } catch (e) {
            console.error(`[OAuth Proxy] Error rewriting metadata URL:`, e);
          }
        }
        const proxyEndpoint = isMetadata ? `${oauthProxyUrl}/metadata?url=${encodeURIComponent(metadataUrl)}` : `${oauthProxyUrl}/proxy`;
        console.log(
          `[OAuth Proxy] Routing ${isMetadata ? "metadata" : "request"} through: ${proxyEndpoint}`
        );
        if (isMetadata) {
          const headers = {
            ...init?.headers ? Object.fromEntries(new Headers(init.headers)) : {}
          };
          if (connectionUrl) {
            headers["X-Connection-URL"] = connectionUrl;
          }
          const proxyUrl = new URL(proxyEndpoint);
          if (serverUrl) {
            proxyUrl.searchParams.set("mcp_url", serverUrl);
          }
          return await originalFetch(proxyUrl.toString(), {
            ...init,
            method: "GET",
            headers
          });
        }
        let requestUrl = url;
        if (url.includes("/authorize") && serverUrl) {
          try {
            const urlObj = new URL(url);
            const resourceParam = urlObj.searchParams.get("resource");
            if (resourceParam && connectionUrl) {
              const connectionUrlObj = new URL(connectionUrl);
              if (resourceParam.startsWith(connectionUrlObj.origin) || resourceParam === connectionUrl) {
                urlObj.searchParams.set("resource", serverUrl);
                requestUrl = urlObj.toString();
                console.log(
                  `[OAuth Proxy] Rewrote authorize resource parameter from ${resourceParam} to ${serverUrl}`
                );
              }
            }
          } catch (e) {
            console.error(`[OAuth Proxy] Error rewriting authorize URL:`, e);
          }
        }
        let body = init?.body ? await serializeBody(init.body) : void 0;
        if (url.includes("/token") && serverUrl && connectionUrl && body) {
          try {
            const params = new URLSearchParams(body);
            const resourceParam = params.get("resource");
            if (resourceParam) {
              const connectionUrlObj = new URL(connectionUrl);
              if (resourceParam.startsWith(connectionUrlObj.origin) || resourceParam === connectionUrl) {
                params.set("resource", serverUrl);
                body = params.toString();
                console.log(
                  `[OAuth Proxy] Rewrote token resource parameter from ${resourceParam} to ${serverUrl}`
                );
              }
            }
          } catch (e) {
            console.error(`[OAuth Proxy] Error rewriting token body:`, e);
          }
        }
        const response = await originalFetch(proxyEndpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            url: requestUrl,
            method: init?.method || "POST",
            headers: init?.headers ? Object.fromEntries(new Headers(init.headers)) : {},
            body
          })
        });
        const data = await response.json();
        return new Response(JSON.stringify(data.body), {
          status: data.status,
          statusText: data.statusText,
          headers: new Headers(data.headers)
        });
      } catch (error) {
        console.error(
          "[OAuth Proxy] Request failed, falling back to direct fetch:",
          error
        );
        return await originalFetch(input, init);
      }
    }, "interceptedFetch");
  }
  /**
   * Restore original fetch after OAuth flow completes
   */
  restoreFetch() {
    if (this.originalFetch) {
      console.log("[BrowserOAuthProvider] Restoring original fetch");
      window.fetch = this.originalFetch;
      this.originalFetch = void 0;
    }
  }
  // --- SDK Interface Methods ---
  get redirectUrl() {
    return sanitizeUrl(this.callbackUrl);
  }
  get clientMetadata() {
    return {
      redirect_uris: [this.redirectUrl],
      token_endpoint_auth_method: "none",
      // Public client
      grant_types: ["authorization_code", "refresh_token"],
      response_types: ["code"],
      client_name: this.clientName,
      client_uri: this.clientUri,
      logo_uri: this.logoUri
      // scope: 'openid profile email mcp', // Example scopes, adjust as needed
    };
  }
  async clientInformation() {
    const key = this.getKey("client_info");
    const data = localStorage.getItem(key);
    if (!data) return void 0;
    try {
      return JSON.parse(data);
    } catch (e) {
      console.warn(
        `[${this.storageKeyPrefix}] Failed to parse client information:`,
        e
      );
      localStorage.removeItem(key);
      return void 0;
    }
  }
  // NOTE: The SDK's auth() function uses this if dynamic registration is needed.
  // Ensure your OAuthClientInformationFull matches the expected structure if DCR is used.
  async saveClientInformation(clientInformation) {
    const key = this.getKey("client_info");
    localStorage.setItem(key, JSON.stringify(clientInformation));
  }
  async tokens() {
    const key = this.getKey("tokens");
    const data = localStorage.getItem(key);
    if (!data) return void 0;
    try {
      const tokens = JSON.parse(data);
      if (tokens.access_token && tokens.refresh_token) {
        try {
          const payload = JSON.parse(atob(tokens.access_token.split(".")[1]));
          if (payload.exp && Date.now() >= (payload.exp - 30) * 1e3) {
            console.log("[tokens] Access token expiring soon, refreshing...");
            const refreshed = await this._dedupedRefresh(tokens);
            if (refreshed) {
              console.log("[tokens] Refreshed successfully");
              return refreshed;
            }
          }
        } catch {
        }
      }
      return tokens;
    } catch (e) {
      console.warn(`[${this.storageKeyPrefix}] Failed to parse tokens:`, e);
      localStorage.removeItem(key);
      return void 0;
    }
  }
  async saveTokens(tokens) {
    const key = this.getKey("tokens");
    localStorage.setItem(key, JSON.stringify(tokens));
    localStorage.removeItem(this.getKey("code_verifier"));
    localStorage.removeItem(this.getKey("last_auth_url"));
  }
  async _refresh(tokens) {
    try {
      if (!this._cachedAuthServerUrl || !this._cachedMetadata) {
        const resourceMetadata = await discoverOAuthProtectedResourceMetadata(
          this.serverUrl
        );
        const authServerUrl = resourceMetadata.authorization_servers?.[0];
        if (!authServerUrl) return null;
        const metadata = await discoverAuthorizationServerMetadata(authServerUrl);
        if (!metadata) return null;
        this._cachedAuthServerUrl = authServerUrl;
        this._cachedMetadata = metadata;
      }
      const clientInfo = await this.clientInformation();
      if (!clientInfo) return null;
      const newTokens = await refreshAuthorization(this._cachedAuthServerUrl, {
        metadata: this._cachedMetadata,
        clientInformation: clientInfo,
        refreshToken: tokens.refresh_token
      });
      await this.saveTokens(newTokens);
      return newTokens;
    } catch {
      return null;
    }
  }
  async _dedupedRefresh(tokens) {
    if (this._refreshPromise) return this._refreshPromise;
    this._refreshPromise = this._refresh(tokens);
    try {
      return await this._refreshPromise;
    } finally {
      this._refreshPromise = null;
    }
  }
  async invalidateCredentials(scope) {
    switch (scope) {
      case "all":
        localStorage.removeItem(this.getKey("tokens"));
        localStorage.removeItem(this.getKey("client_info"));
        localStorage.removeItem(this.getKey("code_verifier"));
        localStorage.removeItem(this.getKey("last_auth_url"));
        break;
      case "client":
        localStorage.removeItem(this.getKey("client_info"));
        break;
      case "tokens":
        localStorage.removeItem(this.getKey("tokens"));
        break;
      case "verifier":
        localStorage.removeItem(this.getKey("code_verifier"));
        break;
      default:
        break;
    }
  }
  async saveCodeVerifier(codeVerifier) {
    const key = this.getKey("code_verifier");
    localStorage.setItem(key, codeVerifier);
  }
  async codeVerifier() {
    const key = this.getKey("code_verifier");
    const verifier = localStorage.getItem(key);
    if (!verifier) {
      throw new Error(
        `[${this.storageKeyPrefix}] Code verifier not found in storage for key ${key}. Auth flow likely corrupted or timed out.`
      );
    }
    return verifier;
  }
  /**
   * Generates and stores the authorization URL with state, without opening a popup.
   * Used when preventAutoAuth is enabled to provide the URL for manual navigation.
   * @param authorizationUrl The fully constructed authorization URL from the SDK.
   * @returns The full authorization URL with state parameter.
   */
  async prepareAuthorizationUrl(authorizationUrl) {
    if (this.connectionUrl && this.serverUrl) {
      const resourceParam = authorizationUrl.searchParams.get("resource");
      if (resourceParam) {
        try {
          const connectionUrlObj = new URL(this.connectionUrl);
          if (resourceParam.startsWith(connectionUrlObj.origin) || resourceParam === this.connectionUrl) {
            authorizationUrl.searchParams.set("resource", this.serverUrl);
            console.log(
              `[OAuth] Rewrote authorize resource parameter from ${resourceParam} to ${this.serverUrl}`
            );
          }
        } catch (e) {
          console.error(`[OAuth] Error rewriting resource parameter:`, e);
        }
      }
    }
    const state = globalThis.crypto.randomUUID();
    const stateKey = `${this.storageKeyPrefix}:state_${state}`;
    const stateData = {
      serverUrlHash: this.serverUrlHash,
      expiry: Date.now() + 1e3 * 60 * 10,
      // State expires in 10 minutes
      // Store provider options needed to reconstruct on callback
      providerOptions: {
        serverUrl: this.serverUrl,
        storageKeyPrefix: this.storageKeyPrefix,
        clientName: this.clientName,
        clientUri: this.clientUri,
        callbackUrl: this.callbackUrl,
        // Include OAuth proxy settings so callback can bypass CORS for token exchange
        oauthProxyUrl: this.oauthProxyUrl,
        connectionUrl: this.connectionUrl
      },
      // Store flow type so callback knows how to handle the response
      flowType: this.useRedirectFlow ? "redirect" : "popup",
      // Always store current URL so we can return to it after auth
      // This is critical for popup flow when popup is blocked and user clicks link manually
      returnUrl: typeof window !== "undefined" ? window.location.href : void 0
    };
    console.log(`[OAuth] Storing state key: ${stateKey}`);
    localStorage.setItem(stateKey, JSON.stringify(stateData));
    const verified = localStorage.getItem(stateKey);
    console.log(`[OAuth] State stored successfully: ${!!verified}`);
    authorizationUrl.searchParams.set("state", state);
    const authUrlString = authorizationUrl.toString();
    const sanitizedAuthUrl = sanitizeUrl(authUrlString);
    localStorage.setItem(this.getKey("last_auth_url"), sanitizedAuthUrl);
    return sanitizedAuthUrl;
  }
  /**
   * Redirects the user agent to the authorization URL, storing necessary state.
   * This now adheres to the SDK's void return type expectation for the interface.
   * @param authorizationUrl The fully constructed authorization URL from the SDK.
   */
  async redirectToAuthorization(authorizationUrl) {
    const sanitizedAuthUrl = await this.prepareAuthorizationUrl(authorizationUrl);
    if (this.preventAutoAuth) {
      console.info(
        `[${this.storageKeyPrefix}] Auto-auth prevented. Authorization URL stored for manual trigger.`
      );
      return;
    }
    if (this.useRedirectFlow) {
      console.info(
        `[${this.storageKeyPrefix}] Redirecting to authorization URL (full-page redirect).`
      );
      window.location.href = sanitizedAuthUrl;
      return;
    }
    const popupFeatures = "width=600,height=700,resizable=yes,scrollbars=yes,status=yes";
    try {
      const popup = window.open(
        sanitizedAuthUrl,
        `mcp_auth_${this.serverUrlHash}`,
        popupFeatures
      );
      if (this.onPopupWindow) {
        this.onPopupWindow(sanitizedAuthUrl, popupFeatures, popup);
      }
      if (!popup || popup.closed || typeof popup.closed === "undefined") {
        console.warn(
          `[${this.storageKeyPrefix}] Popup likely blocked by browser. Manual navigation might be required using the stored URL.`
        );
      } else {
        popup.focus();
        console.info(
          `[${this.storageKeyPrefix}] Redirecting to authorization URL in popup.`
        );
      }
    } catch (e) {
      console.error(
        `[${this.storageKeyPrefix}] Error opening popup window:`,
        e
      );
    }
  }
  // --- Helper Methods ---
  /**
   * Retrieves the last URL passed to `redirectToAuthorization`. Useful for manual fallback.
   */
  getLastAttemptedAuthUrl() {
    const storedUrl = localStorage.getItem(this.getKey("last_auth_url"));
    return storedUrl ? sanitizeUrl(storedUrl) : null;
  }
  clearStorage() {
    const prefixPattern = `${this.storageKeyPrefix}_${this.serverUrlHash}_`;
    const statePattern = `${this.storageKeyPrefix}:state_`;
    const keysToRemove = [];
    let count = 0;
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (!key) continue;
      if (key.startsWith(prefixPattern)) {
        keysToRemove.push(key);
      } else if (key.startsWith(statePattern)) {
        try {
          const item = localStorage.getItem(key);
          if (item) {
            const state = JSON.parse(item);
            if (state.serverUrlHash === this.serverUrlHash) {
              keysToRemove.push(key);
            }
          }
        } catch (e) {
          console.warn(
            `[${this.storageKeyPrefix}] Error parsing state key ${key} during clearStorage:`,
            e
          );
        }
      }
    }
    const uniqueKeysToRemove = [...new Set(keysToRemove)];
    uniqueKeysToRemove.forEach((key) => {
      localStorage.removeItem(key);
      count++;
    });
    return count;
  }
  hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(16);
  }
  getKey(keySuffix) {
    return `${this.storageKeyPrefix}_${this.serverUrlHash}_${keySuffix}`;
  }
}, __name(_a2, "BrowserOAuthClientProvider"), _a2);
async function onMcpAuthorization() {
  const queryParams = new URLSearchParams(window.location.search);
  const code = queryParams.get("code");
  const state = queryParams.get("state");
  const error = queryParams.get("error");
  const errorDescription = queryParams.get("error_description");
  const logPrefix = "[mcp-callback]";
  console.log(`${logPrefix} Handling callback...`, {
    code,
    state,
    error,
    errorDescription
  });
  let provider = null;
  let storedStateData = null;
  let stateKey = null;
  try {
    if (error) {
      throw new Error(
        `OAuth error: ${error} - ${errorDescription || "No description provided."}`
      );
    }
    if (!code) {
      throw new Error(
        "Authorization code not found in callback query parameters."
      );
    }
    if (!state) {
      throw new Error(
        "State parameter not found or invalid in callback query parameters."
      );
    }
    console.log(`[mcp-callback] Looking for state: ${state}`);
    console.log(
      `[mcp-callback] All localStorage keys:`,
      Object.keys(localStorage)
    );
    const defaultStateKey = `mcp:auth:state_${state}`;
    if (localStorage.getItem(defaultStateKey)) {
      stateKey = defaultStateKey;
      console.log(
        `[mcp-callback] Found state with default key: ${defaultStateKey}`
      );
    } else {
      const stateKeySuffix = `:state_${state}`;
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.endsWith(stateKeySuffix)) {
          stateKey = key;
          console.log(`[mcp-callback] Found state with dynamic key: ${key}`);
          break;
        }
      }
    }
    if (!stateKey) {
      const stateKeys = Object.keys(localStorage).filter(
        (k) => k.includes("state")
      );
      console.log(`[mcp-callback] State keys in storage:`, stateKeys);
      throw new Error(
        `Invalid or expired state parameter "${state}". No matching state found in storage.`
      );
    }
    const storedStateJSON = localStorage.getItem(stateKey);
    if (!storedStateJSON) {
      throw new Error(
        `Invalid or expired state parameter "${state}". No matching state found in storage.`
      );
    }
    try {
      storedStateData = JSON.parse(storedStateJSON);
    } catch (e) {
      throw new Error("Failed to parse stored OAuth state.");
    }
    if (!storedStateData.expiry || storedStateData.expiry < Date.now()) {
      localStorage.removeItem(stateKey);
      throw new Error(
        "OAuth state has expired. Please try initiating authentication again."
      );
    }
    if (!storedStateData.providerOptions) {
      throw new Error("Stored state is missing required provider options.");
    }
    const { serverUrl, ...providerOptions } = storedStateData.providerOptions;
    let oauthProxyUrl = providerOptions.oauthProxyUrl;
    const connectionUrl = providerOptions.connectionUrl;
    if (!oauthProxyUrl) {
      try {
        const callbackUrl = new URL(window.location.href);
        if (callbackUrl.pathname.includes("/oauth/callback")) {
          let basePath = callbackUrl.pathname.replace(
            /\/oauth\/callback.*$/,
            ""
          );
          if (!basePath || basePath === "") {
            basePath = "/inspector";
            console.log(
              `${logPrefix} Callback at root /oauth/callback, using /inspector as base path for OAuth proxy`
            );
          }
          oauthProxyUrl = `${callbackUrl.origin}${basePath}/api/oauth`;
          console.log(
            `${logPrefix} Inferred OAuth proxy URL from callback: ${oauthProxyUrl}`
          );
        }
      } catch (e) {
        console.warn(`${logPrefix} Could not infer OAuth proxy URL:`, e);
      }
    }
    console.log(
      `${logPrefix} Re-instantiating provider for server: ${serverUrl}`
    );
    provider = new BrowserOAuthClientProvider(serverUrl, {
      ...providerOptions,
      oauthProxyUrl,
      connectionUrl
    });
    if (oauthProxyUrl) {
      console.log(
        `${logPrefix} Installing fetch interceptor for token exchange (proxy: ${oauthProxyUrl})`
      );
      provider.installFetchInterceptor();
    }
    console.log(`${logPrefix} Calling SDK auth() to exchange code...`);
    const sdkServerUrl = connectionUrl || new URL(serverUrl).origin;
    console.log(
      `${logPrefix} Using SDK serverUrl: ${sdkServerUrl} (connectionUrl: ${connectionUrl || "none"})`
    );
    const authResult = await auth(provider, {
      serverUrl: sdkServerUrl,
      authorizationCode: code
    });
    if (authResult === "AUTHORIZED") {
      console.log(`${logPrefix} Authorization successful via SDK auth().`);
      const isRedirectFlow = storedStateData.flowType === "redirect";
      if (isRedirectFlow && storedStateData.returnUrl) {
        console.log(
          `${logPrefix} Redirect flow complete. Returning to: ${storedStateData.returnUrl}`
        );
        localStorage.removeItem(stateKey);
        window.location.href = storedStateData.returnUrl;
      } else if (window.opener && !window.opener.closed) {
        console.log(`${logPrefix} Popup flow complete. Notifying opener...`);
        window.opener.postMessage(
          { type: "mcp_auth_callback", success: true },
          window.location.origin
        );
        localStorage.removeItem(stateKey);
        window.close();
      } else if (storedStateData.returnUrl) {
        console.log(
          `${logPrefix} Popup flow without opener. Returning to: ${storedStateData.returnUrl}`
        );
        localStorage.removeItem(stateKey);
        window.location.href = storedStateData.returnUrl;
      } else {
        console.warn(
          `${logPrefix} No opener window or return URL detected. Redirecting to root.`
        );
        localStorage.removeItem(stateKey);
        const pathParts = window.location.pathname.split("/").filter(Boolean);
        const basePath = pathParts.length > 0 && pathParts[pathParts.length - 1] === "callback" ? "/" + pathParts.slice(0, -2).join("/") : "/";
        window.location.href = basePath || "/";
      }
    } else {
      console.warn(
        `${logPrefix} SDK auth() returned unexpected status: ${authResult}`
      );
      throw new Error(
        `Unexpected result from authentication library: ${authResult}`
      );
    }
  } catch (err) {
    console.error(`${logPrefix} Error during OAuth callback handling:`, err);
    const errorMessage = err instanceof Error ? err.message : String(err);
    if (window.opener && !window.opener.closed) {
      window.opener.postMessage(
        { type: "mcp_auth_callback", success: false, error: errorMessage },
        window.location.origin
      );
    }
    try {
      document.body.innerHTML = "";
      const container = document.createElement("div");
      container.style.fontFamily = "sans-serif";
      container.style.padding = "20px";
      const heading = document.createElement("h1");
      heading.textContent = "Authentication Error";
      container.appendChild(heading);
      const errorPara = document.createElement("p");
      errorPara.style.color = "red";
      errorPara.style.backgroundColor = "#ffebeb";
      errorPara.style.border = "1px solid red";
      errorPara.style.padding = "10px";
      errorPara.style.borderRadius = "4px";
      errorPara.textContent = errorMessage;
      container.appendChild(errorPara);
      const closePara = document.createElement("p");
      closePara.textContent = "You can close this window or ";
      const closeLink = document.createElement("a");
      closeLink.href = "#";
      closeLink.textContent = "click here to close";
      closeLink.onclick = (e) => {
        e.preventDefault();
        window.close();
        return false;
      };
      closePara.appendChild(closeLink);
      closePara.appendChild(document.createTextNode("."));
      container.appendChild(closePara);
      if (err instanceof Error && err.stack) {
        const stackPre = document.createElement("pre");
        stackPre.style.fontSize = "0.8em";
        stackPre.style.color = "#555";
        stackPre.style.marginTop = "20px";
        stackPre.style.whiteSpace = "pre-wrap";
        stackPre.textContent = err.stack;
        container.appendChild(stackPre);
      }
      document.body.appendChild(container);
    } catch (displayError) {
      console.error(
        `${logPrefix} Could not display error in callback window:`,
        displayError
      );
    }
    if (stateKey) {
      localStorage.removeItem(stateKey);
    }
    if (provider) {
      localStorage.removeItem(provider.getKey("code_verifier"));
      localStorage.removeItem(provider.getKey("last_auth_url"));
    }
  }
}
__name(onMcpAuthorization, "onMcpAuthorization");

// node_modules/mcp-use/dist/chunk-H475Z7T5.js
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_react7 = __toESM(require_react(), 1);
var import_react8 = __toESM(require_react(), 1);
var import_react9 = __toESM(require_react(), 1);
function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
__name(assert, "assert");
var USE_MCP_SERVER_NAME = "inspector-server";
function deriveOAuthClientConfigFromClientInfo(clientInfo) {
  return {
    name: clientInfo.name,
    version: clientInfo.version,
    uri: clientInfo.websiteUrl,
    logo_uri: clientInfo.icons?.[0]?.src
  };
}
__name(deriveOAuthClientConfigFromClientInfo, "deriveOAuthClientConfigFromClientInfo");
function isOAuthDiscoveryFailure(error) {
  const errorMessage = error instanceof Error ? error.message : String(error);
  const msg = errorMessage.toLowerCase();
  return msg.includes("oauth discovery failed") || msg.includes("oauth-authorization-server") || msg.includes("not valid json") || msg.includes("404") && (msg.includes("openid-configuration") || msg.includes("oauth-protected-resources") || msg.includes("oauth-authorization-url") || msg.includes("register")) || msg.includes("invalid oauth error response") && msg.includes("not found");
}
__name(isOAuthDiscoveryFailure, "isOAuthDiscoveryFailure");
function deriveOAuthProxyUrl(gatewayUrl) {
  if (!gatewayUrl) {
    return void 0;
  }
  const gatewayUrlObj = new URL(gatewayUrl);
  const basePath = gatewayUrlObj.pathname.replace(/\/proxy\/?$/, "");
  return `${gatewayUrlObj.origin}${basePath}/oauth`;
}
__name(deriveOAuthProxyUrl, "deriveOAuthProxyUrl");
function createBrowserOAuthProvider(params) {
  const oauthProxyUrl = deriveOAuthProxyUrl(params.gatewayUrl);
  const provider = new BrowserOAuthClientProvider(params.effectiveOAuthUrl, {
    storageKeyPrefix: params.storageKeyPrefix,
    clientName: params.oauthClientConfig.name,
    clientUri: params.oauthClientConfig.uri,
    logoUri: params.oauthClientConfig.logo_uri || "https://mcp-use.com/logo.png",
    callbackUrl: params.callbackUrl,
    preventAutoAuth: params.preventAutoAuth,
    useRedirectFlow: params.useRedirectFlow,
    oauthProxyUrl,
    connectionUrl: params.gatewayUrl,
    onPopupWindow: params.onPopupWindow
  });
  if (oauthProxyUrl && params.installFetchInterceptor) {
    provider.installFetchInterceptor();
  }
  return { provider, oauthProxyUrl };
}
__name(createBrowserOAuthProvider, "createBrowserOAuthProvider");
function startConnectionHealthMonitoring(params) {
  let healthCheckInterval = null;
  let lastSuccessfulCheck = Date.now();
  const healthCheckIntervalMs = params.healthCheckIntervalMs ?? 1e4;
  const healthCheckTimeoutMs = params.healthCheckTimeoutMs ?? 3e4;
  const checkConnectionHealth = __name(async () => {
    if (!params.isMountedRef.current || params.stateRef.current !== "ready") {
      if (healthCheckInterval) {
        clearInterval(healthCheckInterval);
        healthCheckInterval = null;
      }
      return;
    }
    try {
      const healthCheckUrl = params.gatewayUrl || params.url;
      if (!healthCheckUrl) {
        return;
      }
      const authHeaders = params.getAuthHeaders ? await params.getAuthHeaders() : {};
      const response = await fetch(healthCheckUrl, {
        method: "HEAD",
        headers: { ...params.allHeaders, ...authHeaders },
        signal: AbortSignal.timeout(5e3)
      });
      if (response.ok || response.status < 500) {
        lastSuccessfulCheck = Date.now();
      } else {
        throw new Error(`Server returned ${response.status}`);
      }
    } catch {
      const timeSinceLastSuccess = Date.now() - lastSuccessfulCheck;
      if (timeSinceLastSuccess > healthCheckTimeoutMs) {
        params.addLog(
          "warn",
          `Connection appears to be broken (no response for ${Math.round(timeSinceLastSuccess / 1e3)}s), attempting to reconnect...`
        );
        if (healthCheckInterval) {
          clearInterval(healthCheckInterval);
          healthCheckInterval = null;
        }
        if (params.autoReconnectRef.current && params.isMountedRef.current) {
          params.setState("discovering");
          params.addLog("info", "Auto-reconnecting to MCP server...");
          setTimeout(
            () => {
              if (params.isMountedRef.current && params.stateRef.current === "discovering") {
                params.connect();
              }
            },
            typeof params.autoReconnectRef.current === "number" ? params.autoReconnectRef.current : params.defaultReconnectDelay
          );
        }
      }
    }
  }, "checkConnectionHealth");
  healthCheckInterval = setInterval(
    checkConnectionHealth,
    healthCheckIntervalMs
  );
  return () => {
    if (healthCheckInterval) {
      clearInterval(healthCheckInterval);
      healthCheckInterval = null;
    }
  };
}
__name(startConnectionHealthMonitoring, "startConnectionHealthMonitoring");
var DEFAULT_RECONNECT_DELAY = 3e3;
var DEFAULT_RETRY_DELAY = 5e3;
function useMcp(options) {
  const {
    url,
    enabled = true,
    callbackUrl = typeof window !== "undefined" ? sanitizeUrl(
      new URL("/oauth/callback", window.location.origin).toString()
    ) : "/oauth/callback",
    storageKeyPrefix = "mcp:auth",
    clientConfig = {},
    authProvider: providedAuthProvider,
    headers: headersOption,
    customHeaders: customHeadersOption,
    proxyConfig,
    autoProxyFallback = true,
    debug: _debug = false,
    logLevel: logLevelOption,
    autoRetry = false,
    autoReconnect = DEFAULT_RECONNECT_DELAY,
    transportType = "auto",
    preventAutoAuth = true,
    // Default to true - require explicit user action for OAuth
    useRedirectFlow = false,
    // Default to false for backward compatibility (use popup)
    onPopupWindow,
    timeout = 3e4,
    // 30 seconds default for connection timeout
    sseReadTimeout = 3e5,
    // 5 minutes default for SSE read timeout
    wrapTransport,
    fetch: customFetch,
    clientOptions,
    onNotification,
    onSampling: onSamplingOption,
    samplingCallback: samplingCallbackOption,
    onElicitation: onElicitationOption,
    elicitationCallback: elicitationCallbackOption
  } = options;
  const instanceLogger = (0, import_react.useMemo)(() => {
    const name = `useMcp:${url || "no-url"}`;
    const inst = Logger.get(name);
    if (logLevelOption) {
      inst.level = logLevelOption;
    } else if (_debug) {
      inst.level = "debug";
    }
    return inst;
  }, [url, logLevelOption, _debug]);
  const headers = headersOption ?? customHeadersOption ?? {};
  if (customHeadersOption && !headersOption) {
    instanceLogger.warn(
      '[useMcp] The "customHeaders" option is deprecated. Use "headers" instead.'
    );
  }
  const onSampling = onSamplingOption ?? samplingCallbackOption;
  if (samplingCallbackOption && !onSamplingOption) {
    instanceLogger.warn(
      '[useMcp] The "samplingCallback" option is deprecated. Use "onSampling" instead.'
    );
  }
  const onElicitation = onElicitationOption ?? elicitationCallbackOption;
  if (elicitationCallbackOption && !onElicitationOption) {
    logger.warn(
      '[useMcp] The "elicitationCallback" option is deprecated. Use "onElicitation" instead.'
    );
  }
  const defaultClientInfo = (0, import_react.useMemo)(
    () => ({
      name: "mcp-use",
      title: "mcp-use",
      version: getPackageVersion(),
      description: "mcp-use is a complete TypeScript framework for building and using MCP",
      icons: [
        {
          src: "https://mcp-use.com/logo.png"
        }
      ],
      websiteUrl: "https://mcp-use.com"
    }),
    []
  );
  const mergedClientInfo = (0, import_react.useMemo)(
    () => options.clientInfo ? { ...defaultClientInfo, ...options.clientInfo } : defaultClientInfo,
    [options.clientInfo, defaultClientInfo]
  );
  const derivedOAuthClientConfig = (0, import_react.useMemo)(
    () => deriveOAuthClientConfigFromClientInfo(mergedClientInfo),
    [mergedClientInfo]
  );
  const oauthClientConfig = (0, import_react.useMemo)(() => {
    if (clientConfig && Object.keys(clientConfig).length > 0) {
      instanceLogger.warn(
        "[useMcp] The 'clientConfig' option is deprecated and will be removed in a future version. Use 'clientInfo' instead. The clientConfig will be automatically derived from clientInfo."
      );
      return { ...derivedOAuthClientConfig, ...clientConfig };
    }
    return derivedOAuthClientConfig;
  }, [clientConfig, derivedOAuthClientConfig]);
  const autoProxyFallbackConfig = (0, import_react.useMemo)(() => {
    if (!autoProxyFallback) {
      return { enabled: false, proxyAddress: void 0 };
    }
    if (typeof autoProxyFallback === "boolean") {
      return {
        enabled: autoProxyFallback,
        proxyAddress: "https://inspector.mcp-use.com/inspector/api/proxy"
      };
    }
    return {
      enabled: autoProxyFallback.enabled !== false,
      proxyAddress: autoProxyFallback.proxyAddress || "https://inspector.mcp-use.com/inspector/api/proxy"
    };
  }, [autoProxyFallback]);
  const hasTriedProxyFallbackRef = (0, import_react.useRef)(false);
  const [effectiveProxyConfig, setEffectiveProxyConfig] = (0, import_react.useState)(proxyConfig);
  (0, import_react.useEffect)(() => {
    setEffectiveProxyConfig(proxyConfig);
  }, [proxyConfig]);
  const { gatewayUrl, proxyHeaders } = (0, import_react.useMemo)(() => {
    const result = applyProxyConfig(url || "", proxyConfig);
    return {
      gatewayUrl: proxyConfig?.proxyAddress,
      proxyHeaders: result.headers
    };
  }, [url, proxyConfig]);
  const effectiveOAuthUrl = (0, import_react.useMemo)(() => {
    return url || "";
  }, [url]);
  const allHeaders = (0, import_react.useMemo)(
    () => ({ ...proxyHeaders, ...headers }),
    [proxyHeaders, headers]
  );
  const [state, setState] = (0, import_react.useState)("discovering");
  const [tools, setTools] = (0, import_react.useState)([]);
  const [resources, setResources] = (0, import_react.useState)([]);
  const [resourceTemplates, setResourceTemplates] = (0, import_react.useState)([]);
  const [prompts, setPrompts] = (0, import_react.useState)([]);
  const [serverInfo, setServerInfo] = (0, import_react.useState)(
    // Only use cached metadata if it has at least a name
    options._initialServerInfo?.name ? options._initialServerInfo : void 0
  );
  const [capabilities, setCapabilities] = (0, import_react.useState)();
  const [error, setError] = (0, import_react.useState)(void 0);
  const [log, setLog] = (0, import_react.useState)([]);
  const [authUrl, setAuthUrl] = (0, import_react.useState)(void 0);
  const [authTokens, setAuthTokens] = (0, import_react.useState)(void 0);
  const clientRef = (0, import_react.useRef)(null);
  const authProviderRef = (0, import_react.useRef)(
    providedAuthProvider ?? null
  );
  const iconLoadingPromiseRef = (0, import_react.useRef)(null);
  const connectingRef = (0, import_react.useRef)(false);
  const isMountedRef = (0, import_react.useRef)(true);
  const connectAttemptRef = (0, import_react.useRef)(0);
  const authTimeoutRef = (0, import_react.useRef)(null);
  const retryScheduledRef = (0, import_react.useRef)(false);
  const stateRef = (0, import_react.useRef)(state);
  const autoReconnectRef = (0, import_react.useRef)(autoReconnect);
  const successfulTransportRef = (0, import_react.useRef)(null);
  const connectRef = (0, import_react.useRef)(null);
  const failConnectionRef = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(() => {
    stateRef.current = state;
    autoReconnectRef.current = autoReconnect;
  }, [state, autoReconnect]);
  (0, import_react.useEffect)(() => {
    authProviderRef.current = providedAuthProvider ?? null;
  }, [providedAuthProvider]);
  const addLog = (0, import_react.useCallback)(
    (level, message, ...args) => {
      const fullMessage = args.length > 0 ? `${message} ${args.map((arg) => JSON.stringify(arg)).join(" ")}` : message;
      const logMsg = `[useMcp] ${fullMessage}`;
      switch (level) {
        case "error":
          instanceLogger.error(logMsg);
          break;
        case "warn":
          instanceLogger.warn(logMsg);
          break;
        case "info":
          instanceLogger.info(logMsg);
          break;
        case "debug":
          instanceLogger.debug(logMsg);
          break;
        default:
          instanceLogger.info(logMsg);
      }
      if (isMountedRef.current) {
        setLog((prevLog) => [
          ...prevLog.slice(-100),
          { level, message: fullMessage, timestamp: Date.now() }
        ]);
      }
    },
    [instanceLogger]
  );
  const disconnect = (0, import_react.useCallback)(
    async (quiet = false) => {
      if (!quiet) addLog("info", "Disconnecting...");
      connectingRef.current = false;
      if (authTimeoutRef.current) clearTimeout(authTimeoutRef.current);
      authTimeoutRef.current = null;
      if (clientRef.current) {
        try {
          const serverName = USE_MCP_SERVER_NAME;
          const session = clientRef.current.getSession(serverName);
          if (session && session._healthCheckCleanup) {
            session._healthCheckCleanup();
            session._healthCheckCleanup = null;
          }
          if (session) {
            await clientRef.current.closeSession(serverName);
          }
        } catch (err) {
          if (!quiet) addLog("warn", "Error closing session:", err);
        }
      }
      clientRef.current = null;
      if (isMountedRef.current && !quiet) {
        setState("discovering");
        setTools([]);
        setResources([]);
        setResourceTemplates([]);
        setPrompts([]);
        setError(void 0);
        setAuthUrl(void 0);
      }
    },
    [addLog]
  );
  const failConnection = (0, import_react.useCallback)(
    (errorMessage, connectionError) => {
      addLog("error", errorMessage, connectionError ?? "");
      const errorCode = connectionError && "code" in connectionError ? connectionError.code : void 0;
      const shouldTryProxyFallback = autoProxyFallbackConfig.enabled && !effectiveProxyConfig?.proxyAddress;
      const isCorsError = errorMessage.includes("CORS") || errorMessage.includes("blocked by CORS policy") || errorMessage.includes("Failed to fetch");
      const is400Error = errorCode === 400;
      const hasOther4xxError = typeof errorCode === "number" && errorCode >= 404 && errorCode < 500;
      const isAuthError = errorCode === 401 || errorCode === 403;
      const shouldFallback = shouldTryProxyFallback && (isCorsError || is400Error || hasOther4xxError) && !isAuthError;
      if (shouldFallback) {
        const errorType = isCorsError ? "CORS error" : is400Error ? "HTTP 400 (Bad Request)" : "HTTP 4xx error";
        addLog(
          "info",
          `Direct connection failed with ${errorType}. Trying with proxy...`
        );
        clientRef.current = null;
        if (!providedAuthProvider) {
          authProviderRef.current = null;
        }
        addLog("debug", "Cleared client and auth provider for proxy fallback");
        setEffectiveProxyConfig({
          proxyAddress: autoProxyFallbackConfig.proxyAddress
        });
        if (isMountedRef.current) {
          setState("discovering");
        }
        setTimeout(() => {
          if (isMountedRef.current) {
            connectRef.current?.();
          }
        }, 1e3);
        return true;
      }
      if (isMountedRef.current) {
        addLog("info", "Setting state to FAILED:", errorMessage);
        setState("failed");
        setError(errorMessage);
        const manualUrl = authProviderRef.current?.getLastAttemptedAuthUrl?.();
        if (manualUrl) {
          setAuthUrl(manualUrl);
          addLog(
            "info",
            "Manual authentication URL may be available.",
            manualUrl
          );
        }
      }
      connectingRef.current = false;
      if (url) {
        Tel.getInstance().trackUseMcpConnection({
          url,
          transportType,
          success: false,
          errorType: connectionError?.name || "UnknownError",
          hasOAuth: !!authProviderRef.current,
          hasSampling: !!onSampling,
          hasElicitation: !!onElicitation
        }).catch(() => {
        });
      }
      return false;
    },
    [
      addLog,
      url,
      transportType,
      onSampling,
      onElicitation,
      autoProxyFallbackConfig,
      effectiveProxyConfig,
      providedAuthProvider
    ]
  );
  const connect = (0, import_react.useCallback)(async () => {
    if (!enabled || !url) {
      addLog(
        "debug",
        enabled ? "No server URL provided, skipping connection." : "Connection disabled via enabled flag."
      );
      return;
    }
    if (connectingRef.current) {
      addLog("debug", "Connection attempt already in progress.");
      return;
    }
    if (!isMountedRef.current) {
      addLog("debug", "Connect called after unmount, aborting.");
      return;
    }
    connectingRef.current = true;
    connectAttemptRef.current += 1;
    setError(void 0);
    setAuthUrl(void 0);
    successfulTransportRef.current = null;
    setState("discovering");
    addLog(
      "info",
      `Connecting attempt #${connectAttemptRef.current} to ${url}...`
    );
    if (!authProviderRef.current) {
      const { provider, oauthProxyUrl } = createBrowserOAuthProvider({
        effectiveOAuthUrl,
        storageKeyPrefix,
        oauthClientConfig,
        callbackUrl,
        preventAutoAuth,
        useRedirectFlow,
        gatewayUrl,
        onPopupWindow,
        installFetchInterceptor: true
      });
      authProviderRef.current = provider;
      if (oauthProxyUrl) {
        addLog(
          "debug",
          `OAuth proxy URL derived from gateway: ${oauthProxyUrl}`
        );
      }
      addLog(
        "debug",
        `BrowserOAuthClientProvider initialized with URL: ${effectiveOAuthUrl}, proxy: ${oauthProxyUrl ? "enabled" : "disabled"}, gateway: ${gatewayUrl ? "enabled" : "disabled"}`
      );
    }
    if (!clientRef.current) {
      clientRef.current = new BrowserMCPClient();
      addLog("debug", "BrowserMCPClient initialized in connect.");
    } else {
      addLog("debug", "BrowserMCPClient already exists, reusing.");
    }
    const tryConnectWithTransport = __name(async (transportTypeParam) => {
      if (!isMountedRef.current) {
        addLog("debug", "Connection attempt aborted - component unmounted");
        return "failed";
      }
      addLog(
        "info",
        `Attempting connection with transport: ${transportTypeParam}`
      );
      addLog(
        "debug",
        `Client ref status at start of tryConnectWithTransport: ${clientRef.current ? "initialized" : "NULL"}`
      );
      try {
        const serverName = USE_MCP_SERVER_NAME;
        const serverConfig = {
          url,
          // Use original URL, not transformed proxy URL
          transport: transportTypeParam === "sse" ? "http" : transportTypeParam,
          // Only disable SSE fallback when user explicitly set transportType: "http"
          // Don't disable it when we're in auto mode and just trying HTTP first
          disableSseFallback: transportType === "http",
          // Use SSE transport when explicitly requested
          preferSse: transportTypeParam === "sse",
          clientInfo: mergedClientInfo,
          // Pass custom fetch if provided (e.g., OAuth retry fetch for scope-step-up)
          ...customFetch && { fetch: customFetch },
          // Pass clientOptions for custom capabilities (e.g., MCP Apps extension)
          ...clientOptions && { clientOptions }
        };
        if (gatewayUrl) {
          serverConfig.gatewayUrl = gatewayUrl;
          addLog(
            "debug",
            `Using proxy gateway: ${gatewayUrl} for target: ${url}`
          );
        }
        if (allHeaders && Object.keys(allHeaders).length > 0) {
          serverConfig.headers = allHeaders;
        }
        if (!clientRef.current) {
          if (!isMountedRef.current) {
            addLog(
              "debug",
              "Connection aborted - component unmounted, client cleaned up"
            );
            return "failed";
          }
          const initError = new Error(
            "Client not initialized - this is a bug in the connection flow"
          );
          addLog(
            "error",
            "Client ref is null in tryConnectWithTransport but component is still mounted"
          );
          throw initError;
        }
        clientRef.current.addServer(serverName, {
          ...serverConfig,
          authProvider: authProviderRef.current,
          onSampling,
          onElicitation,
          wrapTransport: wrapTransport ? (transport) => {
            addLog(
              "debug",
              "Applying transport wrapper for server:",
              serverName,
              "url:",
              url
            );
            return wrapTransport(transport, url);
          } : void 0
        });
        const session = await clientRef.current.createSession(
          serverName,
          false
        );
        if (!isMountedRef.current) {
          addLog(
            "debug",
            "Connection aborted after session creation - component unmounted"
          );
          return "failed";
        }
        session.on("notification", (notification) => {
          addLog(
            "debug",
            "Notification received:",
            notification.method,
            notification
          );
          onNotification?.(notification);
          if (notification.method === "notifications/tools/list_changed") {
            addLog("info", "Tools list changed, auto-refreshing...");
            refreshTools().catch((err) => {
              addLog("warn", "Auto-refresh tools failed:", err);
            });
          } else if (notification.method === "notifications/resources/list_changed") {
            addLog("info", "Resources list changed, auto-refreshing...");
            refreshResources().catch(
              (err) => addLog("warn", "Auto-refresh resources failed:", err)
            );
          } else if (notification.method === "notifications/prompts/list_changed") {
            addLog("info", "Prompts list changed, auto-refreshing...");
            refreshPrompts().catch(
              (err) => addLog("warn", "Auto-refresh prompts failed:", err)
            );
          }
        });
        await session.initialize();
        if (!isMountedRef.current) {
          addLog(
            "debug",
            "Connection completed but component unmounted, aborting"
          );
          return "failed";
        }
        addLog("info", " Successfully connected to MCP server");
        addLog("info", "Server info:", session.connector.serverInfo);
        addLog(
          "info",
          "Server capabilities:",
          session.connector.serverCapabilities
        );
        if (!isMountedRef.current) {
          addLog("debug", "Skipping state update - component unmounted");
          return "failed";
        }
        setState("ready");
        successfulTransportRef.current = transportTypeParam;
        if (autoReconnect) {
          const cleanup = startConnectionHealthMonitoring({
            gatewayUrl,
            url,
            allHeaders,
            getAuthHeaders: __name(async () => {
              try {
                const tokens = await authProviderRef.current?.tokens?.();
                if (tokens?.access_token) {
                  const tokenType = tokens.token_type || "bearer";
                  return {
                    Authorization: `${tokenType.charAt(0).toUpperCase() + tokenType.slice(1)} ${tokens.access_token}`
                  };
                }
              } catch {
              }
              return {};
            }, "getAuthHeaders"),
            isMountedRef,
            stateRef,
            autoReconnectRef,
            setState,
            addLog,
            connect,
            defaultReconnectDelay: DEFAULT_RECONNECT_DELAY
          });
          session._healthCheckCleanup = cleanup;
        }
        Tel.getInstance().trackUseMcpConnection({
          url,
          transportType: transportTypeParam,
          success: true,
          hasOAuth: !!authProviderRef.current,
          hasSampling: !!onSampling,
          hasElicitation: !!onElicitation
        }).catch(() => {
        });
        setTools(session.connector.tools || []);
        const resourcesResult = await session.connector.listAllResources();
        if (!isMountedRef.current) {
          addLog(
            "debug",
            "Connection aborted after listing resources - component unmounted"
          );
          return "failed";
        }
        setResources(resourcesResult.resources || []);
        const promptsResult = await session.connector.listPrompts();
        if (!isMountedRef.current) {
          addLog(
            "debug",
            "Connection aborted after listing prompts - component unmounted"
          );
          return "failed";
        }
        setPrompts(promptsResult.prompts || []);
        const serverInfo2 = session.connector.serverInfo;
        const capabilities2 = session.connector.serverCapabilities;
        if (serverInfo2) {
          addLog("debug", "Server info:", serverInfo2);
          if (!isMountedRef.current) {
            addLog("debug", "Skipping state update - component unmounted");
            return "failed";
          }
          setServerInfo(serverInfo2);
          const loadIconPromise = (async () => {
            try {
              const serverIcons = serverInfo2.icons;
              if (serverIcons && Array.isArray(serverIcons) && serverIcons.length > 0) {
                const iconUrl = serverIcons[0].src || serverIcons[0].url;
                if (iconUrl) {
                  addLog("info", "Server provided icon:", iconUrl);
                  const res = await fetch(iconUrl);
                  const blob = await res.blob();
                  const base64 = await new Promise(
                    (resolve, reject) => {
                      const reader = new FileReader();
                      reader.onloadend = () => resolve(reader.result);
                      reader.onerror = reject;
                      reader.readAsDataURL(blob);
                    }
                  );
                  if (isMountedRef.current) {
                    setServerInfo(
                      (prev) => prev ? { ...prev, icon: base64 } : void 0
                    );
                    addLog("debug", "Server icon converted to base64");
                  }
                  return base64;
                }
              }
              if (url) {
                const faviconBase64 = await detectFavicon(url);
                if (!isMountedRef.current) {
                  addLog(
                    "debug",
                    "Connection aborted after favicon detection - component unmounted"
                  );
                  return null;
                }
                if (faviconBase64) {
                  setServerInfo(
                    (prev) => prev ? { ...prev, icon: faviconBase64 } : void 0
                  );
                  addLog("debug", "Favicon detected and added to serverInfo");
                  return faviconBase64;
                }
              }
              return null;
            } catch (err) {
              addLog("debug", "Icon loading failed (non-critical):", err);
              return null;
            }
          })();
          iconLoadingPromiseRef.current = loadIconPromise;
        }
        if (capabilities2) {
          addLog("debug", "Server capabilities:", capabilities2);
          if (!isMountedRef.current) {
            addLog("debug", "Skipping state update - component unmounted");
            return "failed";
          }
          setCapabilities(capabilities2);
        }
        if (authProviderRef.current) {
          const tokens = await authProviderRef.current.tokens?.();
          if (!isMountedRef.current) {
            addLog(
              "debug",
              "Connection aborted after token fetch for auth tokens - component unmounted"
            );
            return "failed";
          }
          if (tokens?.access_token) {
            const expiresAt = tokens.expires_in ? Date.now() + tokens.expires_in * 1e3 : void 0;
            if (!isMountedRef.current) {
              addLog("debug", "Skipping state update - component unmounted");
              return "failed";
            }
            setAuthTokens({
              access_token: tokens.access_token,
              token_type: tokens.token_type || "Bearer",
              expires_at: expiresAt,
              refresh_token: tokens.refresh_token,
              scope: tokens.scope
            });
          }
        }
        return "success";
      } catch (err) {
        const error2 = err;
        const errorMessage = error2?.message || String(err);
        const oauthDiscoveryFailed = isOAuthDiscoveryFailure(err);
        const is401Error = error2.code === 401 || errorMessage.includes("401") || errorMessage.includes("Unauthorized");
        if (oauthDiscoveryFailed && headers && Object.keys(headers).length > 0) {
          failConnection(
            "Authentication failed (HTTP 401). Server does not support OAuth. Check your Authorization header value is correct."
          );
          return "failed";
        }
        if (oauthDiscoveryFailed && (!headers || Object.keys(headers).length === 0)) {
          failConnection(
            "Authentication required (HTTP 401). Server does not support OAuth. Add an Authorization header in the Custom Headers section (e.g., Authorization: Bearer YOUR_API_KEY)."
          );
          return "failed";
        }
        if (is401Error) {
          if (oauthDiscoveryFailed) {
            failConnection(
              "Authentication required (HTTP 401). Server does not support OAuth. Add an Authorization header in the Custom Headers section (e.g., Authorization: Bearer YOUR_API_KEY)."
            );
            return "failed";
          }
          if (authProviderRef.current) {
            addLog(
              "info",
              "Authentication required. OAuth provider available."
            );
            if (preventAutoAuth) {
              addLog(
                "info",
                "Waiting for user to initiate authentication flow..."
              );
              if (isMountedRef.current) {
                setState("pending_auth");
                const storedAuthUrl = authProviderRef.current?.getLastAttemptedAuthUrl?.();
                if (storedAuthUrl) {
                  setAuthUrl(storedAuthUrl);
                  addLog(
                    "info",
                    "Retrieved stored auth URL for manual authentication"
                  );
                }
              }
              connectingRef.current = false;
              return "auth_redirect";
            } else {
              addLog(
                "info",
                "Triggering automatic OAuth authentication flow..."
              );
              try {
                const { resourceMetadataUrl, scope } = await probeAuthParams(url);
                const authResult = await auth(authProviderRef.current, {
                  serverUrl: url,
                  ...resourceMetadataUrl && { resourceMetadataUrl },
                  ...scope && { scope }
                });
                if (authResult === "REDIRECT") {
                  const authCode = await authProviderRef.current.getAuthorizationCode?.();
                  if (!authCode) {
                    throw new Error(
                      "Authorization code not captured by headless provider"
                    );
                  }
                  await auth(authProviderRef.current, {
                    serverUrl: url,
                    ...resourceMetadataUrl && { resourceMetadataUrl },
                    ...scope && { scope },
                    authorizationCode: authCode
                  });
                }
                addLog("info", "OAuth flow completed, reconnecting...");
                return await tryConnectWithTransport(transportTypeParam);
              } catch (authError) {
                const authErrorMessage = authError instanceof Error ? authError.message : String(authError);
                failConnection(
                  `Automatic OAuth authentication failed: ${authErrorMessage}`,
                  authError instanceof Error ? authError : new Error(String(authError))
                );
                return "failed";
              }
            }
          }
          if (headers && Object.keys(headers).length > 0) {
            failConnection(
              "Authentication failed: Server returned 401 Unauthorized. Check your Authorization header value is correct."
            );
            return "failed";
          }
          failConnection(
            "Authentication required: Server returned 401 Unauthorized. Add an Authorization header in the Custom Headers section (e.g., Authorization: Bearer YOUR_API_KEY)."
          );
          return "failed";
        }
        const isRetryingWithProxy = failConnection(
          errorMessage,
          error2 instanceof Error ? error2 : new Error(String(error2))
        );
        return isRetryingWithProxy ? "auth_redirect" : "failed";
      }
    }, "tryConnectWithTransport");
    let finalStatus = "failed";
    if (transportType === "sse") {
      addLog("debug", "Using SSE-only transport mode");
      finalStatus = await tryConnectWithTransport("sse");
    } else if (transportType === "http") {
      addLog("debug", "Using HTTP-only transport mode");
      finalStatus = await tryConnectWithTransport("http");
    } else {
      addLog("debug", "Using auto transport mode (HTTP with SSE fallback)");
      const httpResult = await tryConnectWithTransport("http");
      if (httpResult === "fallback" && isMountedRef.current && stateRef.current !== "authenticating") {
        addLog("info", "HTTP failed, attempting SSE fallback...");
        const sseResult = await tryConnectWithTransport("sse");
        finalStatus = sseResult;
      } else {
        finalStatus = httpResult;
      }
    }
    if (finalStatus === "success" || finalStatus === "failed" || finalStatus === "auth_redirect") {
      connectingRef.current = false;
    }
    addLog("debug", `Connection sequence finished with status: ${finalStatus}`);
  }, [
    addLog,
    failConnection,
    disconnect,
    url,
    storageKeyPrefix,
    callbackUrl,
    oauthClientConfig.name,
    oauthClientConfig.version,
    oauthClientConfig.uri,
    oauthClientConfig.logo_uri,
    headers,
    transportType,
    preventAutoAuth,
    useRedirectFlow,
    onPopupWindow,
    enabled,
    timeout,
    sseReadTimeout,
    mergedClientInfo,
    // IMPORTANT: Include proxy-related dependencies so connect() uses updated values after fallback
    gatewayUrl,
    allHeaders,
    effectiveOAuthUrl
  ]);
  (0, import_react.useEffect)(() => {
    connectRef.current = connect;
    failConnectionRef.current = failConnection;
  }, [connect, failConnection]);
  const callTool = (0, import_react.useCallback)(
    async (name, args, options2) => {
      if (stateRef.current !== "ready" || !clientRef.current) {
        throw new Error(
          `MCP client is not ready (current state: ${state}). Cannot call tool "${name}".`
        );
      }
      addLog("info", `Calling tool: ${name}`, args);
      const startTime = Date.now();
      try {
        const serverName = USE_MCP_SERVER_NAME;
        const session = clientRef.current.getSession(serverName);
        if (!session) {
          throw new Error("No active session found");
        }
        const result = await session.connector.callTool(
          name,
          args || {},
          options2
        );
        addLog("info", `Tool "${name}" call successful:`, result);
        Tel.getInstance().trackUseMcpToolCall({
          toolName: name,
          success: true,
          executionTimeMs: Date.now() - startTime
        }).catch(() => {
        });
        return result;
      } catch (err) {
        addLog("error", `Tool "${name}" call failed:`, err);
        Tel.getInstance().trackUseMcpToolCall({
          toolName: name,
          success: false,
          errorType: err instanceof Error ? err.name : "UnknownError",
          executionTimeMs: Date.now() - startTime
        }).catch(() => {
        });
        throw err;
      }
    },
    [state]
  );
  const retry = (0, import_react.useCallback)(() => {
    if (stateRef.current === "failed") {
      addLog("info", "Retry requested...");
      connectRef.current?.();
    } else {
      addLog(
        "warn",
        `Retry called but state is not 'failed' (state: ${stateRef.current}). Ignoring.`
      );
    }
  }, [addLog]);
  const authenticate = (0, import_react.useCallback)(async () => {
    addLog("info", "Manual authentication requested...");
    const currentState = stateRef.current;
    if (currentState === "failed") {
      addLog("info", "Attempting to reconnect and authenticate via retry...");
      retry();
    } else if (currentState === "pending_auth") {
      addLog("info", "Proceeding with authentication from pending state...");
      try {
        assert(
          authProviderRef.current,
          "Auth Provider not available for manual auth"
        );
        assert(url, "Server URL is required for authentication");
        if (providedAuthProvider) {
          addLog(
            "info",
            "Using provided authProvider for manual authentication"
          );
          const baseUrl2 = new URL(url).origin;
          await auth(authProviderRef.current, {
            serverUrl: baseUrl2
          });
          connectRef.current?.();
          return;
        }
        const clearedCount = authProviderRef.current.clearStorage?.() ?? 0;
        addLog(
          "info",
          `Cleared ${clearedCount} OAuth storage item(s) for fresh authentication`
        );
        setState("authenticating");
        const { provider: freshAuthProvider, oauthProxyUrl } = createBrowserOAuthProvider({
          effectiveOAuthUrl,
          storageKeyPrefix,
          oauthClientConfig,
          callbackUrl,
          preventAutoAuth: false,
          useRedirectFlow,
          gatewayUrl,
          onPopupWindow,
          installFetchInterceptor: !gatewayUrl
        });
        if (oauthProxyUrl && !gatewayUrl) {
          addLog("info", "Installed OAuth fetch interceptor for manual auth");
        } else if (oauthProxyUrl && gatewayUrl) {
          addLog(
            "info",
            "Using MCP gateway proxy for OAuth (no fetch interceptor needed)"
          );
        }
        authProviderRef.current = freshAuthProvider;
        addLog("info", "Triggering fresh OAuth authorization...");
        const baseUrl = new URL(url).origin;
        try {
          await auth(freshAuthProvider, {
            serverUrl: baseUrl
          });
          addLog("info", "OAuth flow completed (tokens obtained)");
        } catch (err) {
          addLog(
            "info",
            "OAuth flow initiated (popup/redirect):",
            err instanceof Error ? err.message : "Redirecting..."
          );
        }
        const newAuthUrl = freshAuthProvider.getLastAttemptedAuthUrl?.();
        if (newAuthUrl) {
          setAuthUrl(newAuthUrl);
          addLog("info", "Updated auth URL for fallback:", newAuthUrl);
        }
      } catch (authError) {
        if (!isMountedRef.current) return;
        setState("pending_auth");
        addLog(
          "error",
          `Manual authentication failed: ${authError instanceof Error ? authError.message : String(authError)}`
        );
      }
    } else if (currentState === "authenticating") {
      addLog(
        "warn",
        "Already attempting authentication. Check for blocked popups or wait for timeout."
      );
      const manualUrl = authProviderRef.current?.getLastAttemptedAuthUrl?.();
      if (manualUrl && !authUrl) {
        setAuthUrl(manualUrl);
        addLog("info", "Manual authentication URL retrieved:", manualUrl);
      }
    } else {
      addLog(
        "info",
        `Client not in a state requiring manual authentication trigger (state: ${currentState}). If needed, try disconnecting and reconnecting.`
      );
    }
  }, [
    addLog,
    retry,
    authUrl,
    url,
    useRedirectFlow,
    onPopupWindow,
    storageKeyPrefix,
    oauthClientConfig.name,
    oauthClientConfig.uri,
    oauthClientConfig.logo_uri,
    callbackUrl,
    mergedClientInfo,
    providedAuthProvider
  ]);
  const clearStorage = (0, import_react.useCallback)(() => {
    if (authProviderRef.current?.clearStorage) {
      const count = authProviderRef.current.clearStorage();
      addLog("info", `Cleared ${count} item(s) from localStorage for ${url}.`);
      setAuthUrl(void 0);
      disconnect();
    } else {
      addLog("warn", "Auth provider not initialized, cannot clear storage.");
    }
  }, [url, addLog, disconnect]);
  const listResources = (0, import_react.useCallback)(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      throw new Error(
        `MCP client is not ready (current state: ${state}). Cannot list resources.`
      );
    }
    addLog("info", "Listing resources");
    try {
      const serverName = USE_MCP_SERVER_NAME;
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        throw new Error("No active session found");
      }
      const resourcesResult = await session.connector.listAllResources();
      setResources(resourcesResult.resources || []);
      addLog("info", "Resources listed successfully");
    } catch (err) {
      addLog("error", "List resources failed:", err);
      throw err;
    }
  }, [state]);
  const readResource = (0, import_react.useCallback)(
    async (uri) => {
      if (stateRef.current !== "ready" || !clientRef.current) {
        throw new Error(
          `MCP client is not ready (current state: ${state}). Cannot read resource.`
        );
      }
      addLog("info", `Reading resource: ${uri}`);
      try {
        const serverName = USE_MCP_SERVER_NAME;
        const session = clientRef.current.getSession(serverName);
        if (!session) {
          throw new Error("No active session found");
        }
        const result = await session.connector.readResource(uri);
        addLog("info", "Resource read successful:", result);
        Tel.getInstance().trackUseMcpResourceRead({
          resourceUri: uri,
          success: true
        }).catch(() => {
        });
        return result;
      } catch (err) {
        addLog("error", "Resource read failed:", err);
        Tel.getInstance().trackUseMcpResourceRead({
          resourceUri: uri,
          success: false,
          errorType: err instanceof Error ? err.name : "UnknownError"
        }).catch(() => {
        });
        throw err;
      }
    },
    [state]
  );
  const listPrompts = (0, import_react.useCallback)(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      throw new Error(
        `MCP client is not ready (current state: ${state}). Cannot list prompts.`
      );
    }
    addLog("info", "Listing prompts");
    try {
      const serverName = USE_MCP_SERVER_NAME;
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        throw new Error("No active session found");
      }
      const promptsResult = await session.connector.listPrompts();
      setPrompts(promptsResult.prompts || []);
      addLog("info", "Prompts listed successfully");
    } catch (err) {
      addLog("error", "List prompts failed:", err);
      throw err;
    }
  }, [state]);
  const refreshTools = (0, import_react.useCallback)(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      addLog(
        "debug",
        "Cannot refresh tools - client not ready. State:",
        stateRef.current
      );
      return;
    }
    addLog("debug", "Refreshing tools list");
    try {
      const serverName = USE_MCP_SERVER_NAME;
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        addLog("warn", "No active session found for tools refresh");
        return;
      }
      addLog("debug", "Calling listTools...");
      const toolsResult = await session.connector.listTools();
      addLog("debug", "listTools returned:", toolsResult?.length, "tools");
      setTools(toolsResult || []);
      addLog("info", "Tools list refreshed successfully");
    } catch (err) {
      addLog("error", "Failed to refresh tools:", err);
    }
  }, [addLog]);
  const refreshResources = (0, import_react.useCallback)(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      addLog("debug", "Cannot refresh resources - client not ready");
      return;
    }
    addLog("debug", "Refreshing resources list");
    try {
      const serverName = USE_MCP_SERVER_NAME;
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        addLog("warn", "No active session found for resources refresh");
        return;
      }
      const resourcesResult = await session.connector.listAllResources();
      setResources(resourcesResult.resources || []);
      addLog("info", "Resources list refreshed successfully");
    } catch (err) {
      addLog("warn", "Failed to refresh resources:", err);
    }
  }, [addLog]);
  const refreshPrompts = (0, import_react.useCallback)(async () => {
    if (stateRef.current !== "ready" || !clientRef.current) {
      addLog("debug", "Cannot refresh prompts - client not ready");
      return;
    }
    addLog("debug", "Refreshing prompts list");
    try {
      const serverName = USE_MCP_SERVER_NAME;
      const session = clientRef.current.getSession(serverName);
      if (!session) {
        addLog("warn", "No active session found for prompts refresh");
        return;
      }
      const promptsResult = await session.connector.listPrompts();
      setPrompts(promptsResult.prompts || []);
      addLog("info", "Prompts list refreshed successfully");
    } catch (err) {
      addLog("warn", "Failed to refresh prompts:", err);
    }
  }, [addLog]);
  const refreshAll = (0, import_react.useCallback)(async () => {
    addLog("info", "Refreshing all lists (tools, resources, prompts)");
    await Promise.all([refreshTools(), refreshResources(), refreshPrompts()]);
  }, [refreshTools, refreshResources, refreshPrompts, addLog]);
  const getPrompt = (0, import_react.useCallback)(
    async (name, args) => {
      if (stateRef.current !== "ready" || !clientRef.current) {
        throw new Error(
          `MCP client is not ready (current state: ${state}). Cannot get prompt.`
        );
      }
      addLog("info", `Getting prompt: ${name}`, args);
      try {
        const serverName = USE_MCP_SERVER_NAME;
        const session = clientRef.current.getSession(serverName);
        if (!session) {
          throw new Error("No active session found");
        }
        const result = await session.connector.getPrompt(name, args || {});
        addLog("info", `Prompt "${name}" retrieved successfully:`, result);
        return result;
      } catch (err) {
        addLog("error", `Prompt "${name}" retrieval failed:`, err);
        throw err;
      }
    },
    [state]
  );
  (0, import_react.useEffect)(() => {
    const messageHandler = __name((event) => {
      if (event.origin !== window.location.origin) return;
      if (event.data?.type === "mcp_auth_callback") {
        addLog("info", "Received auth callback message.", event.data);
        if (authTimeoutRef.current) clearTimeout(authTimeoutRef.current);
        authTimeoutRef.current = null;
        if (event.data.success) {
          addLog(
            "info",
            "Authentication successful via popup. Reconnecting client..."
          );
          if (connectingRef.current) {
            addLog(
              "debug",
              "Connection attempt already in progress, resetting flag to allow reconnection."
            );
          }
          connectingRef.current = false;
          setTimeout(() => {
            if (isMountedRef.current) {
              addLog(
                "debug",
                "Initiating reconnection after successful auth callback."
              );
              connectRef.current?.();
            }
          }, 100);
        } else {
          failConnectionRef.current?.(
            `Authentication failed in callback: ${event.data.error || "Unknown reason."}`
          );
        }
      }
    }, "messageHandler");
    window.addEventListener("message", messageHandler);
    addLog("debug", "Auth callback message listener added.");
    return () => {
      window.removeEventListener("message", messageHandler);
      addLog("debug", "Auth callback message listener removed.");
      if (authTimeoutRef.current) clearTimeout(authTimeoutRef.current);
    };
  }, [addLog]);
  (0, import_react.useEffect)(() => {
    hasTriedProxyFallbackRef.current = false;
    setEffectiveProxyConfig(proxyConfig);
  }, [url, proxyConfig]);
  (0, import_react.useEffect)(() => {
    isMountedRef.current = true;
    if (!enabled || !url) {
      addLog(
        "debug",
        enabled ? "No server URL provided, skipping connection." : "Connection disabled via enabled flag."
      );
      setState("discovering");
      return () => {
        isMountedRef.current = false;
      };
    }
    addLog("debug", "useMcp mounted, initiating connection.");
    connectAttemptRef.current = 0;
    if (providedAuthProvider) {
      authProviderRef.current = providedAuthProvider;
      addLog("debug", "Using externally provided authProvider");
    } else if (!authProviderRef.current || authProviderRef.current.serverUrl !== effectiveOAuthUrl) {
      const { provider, oauthProxyUrl } = createBrowserOAuthProvider({
        effectiveOAuthUrl,
        storageKeyPrefix,
        oauthClientConfig,
        callbackUrl,
        preventAutoAuth,
        useRedirectFlow,
        gatewayUrl,
        onPopupWindow,
        installFetchInterceptor: true
      });
      authProviderRef.current = provider;
      if (oauthProxyUrl) {
        addLog(
          "debug",
          `OAuth proxy URL derived from gateway: ${oauthProxyUrl}`
        );
      }
      addLog(
        "debug",
        `BrowserOAuthClientProvider initialized/updated with URL: ${effectiveOAuthUrl}, proxy: ${oauthProxyUrl ? "enabled" : "disabled"}, gateway: ${gatewayUrl ? "enabled" : "disabled"}`
      );
    }
    connect();
    return () => {
      isMountedRef.current = false;
      addLog("debug", "useMcp unmounting, disconnecting.");
      if ((stateRef.current === "authenticating" || stateRef.current === "pending_auth") && authProviderRef.current) {
        try {
          const count = authProviderRef.current.clearStorage?.() ?? 0;
          if (count > 0) {
            addLog(
              "debug",
              `Cleared ${count} OAuth state item(s) during unmount to prevent corruption`
            );
          }
        } catch (err) {
          addLog("debug", "Error clearing OAuth state during unmount:", err);
        }
      }
      disconnect(true);
    };
  }, [
    url,
    enabled,
    storageKeyPrefix,
    callbackUrl,
    oauthClientConfig.name,
    oauthClientConfig.version,
    oauthClientConfig.uri,
    oauthClientConfig.logo_uri,
    useRedirectFlow,
    mergedClientInfo,
    effectiveOAuthUrl,
    // Triggers reconnection when proxy fallback changes OAuth URL
    proxyConfig,
    // Triggers reconnection when proxy config (including headers) changes
    providedAuthProvider
  ]);
  const retryRef = (0, import_react.useRef)(retry);
  const addLogRef = (0, import_react.useRef)(addLog);
  (0, import_react.useEffect)(() => {
    retryRef.current = retry;
    addLogRef.current = addLog;
  }, [retry, addLog]);
  (0, import_react.useEffect)(() => {
    let retryTimeoutId = null;
    if (state === "failed" && autoRetry && connectAttemptRef.current > 0) {
      if (!retryScheduledRef.current) {
        retryScheduledRef.current = true;
        const delay = typeof autoRetry === "number" ? autoRetry : DEFAULT_RETRY_DELAY;
        addLogRef.current(
          "info",
          `Connection failed, auto-retrying in ${delay}ms...`
        );
        retryTimeoutId = setTimeout(() => {
          retryScheduledRef.current = false;
          if (isMountedRef.current && stateRef.current === "failed") {
            retryRef.current();
          }
        }, delay);
      }
    } else if (state !== "failed") {
      retryScheduledRef.current = false;
    }
    return () => {
      if (retryTimeoutId) {
        clearTimeout(retryTimeoutId);
        retryScheduledRef.current = false;
      }
    };
  }, [state, autoRetry]);
  const ensureIconLoaded = (0, import_react.useCallback)(async () => {
    if (stateRef.current !== "ready") {
      addLog("warn", "Cannot ensure icon loaded - not connected");
      return null;
    }
    if (serverInfo?.icon) {
      return serverInfo.icon;
    }
    if (iconLoadingPromiseRef.current) {
      addLog("debug", "Waiting for icon to finish loading...");
      const icon = await iconLoadingPromiseRef.current;
      return icon;
    }
    addLog("debug", "No icon available and no loading in progress");
    return null;
  }, [serverInfo, addLog]);
  return {
    state,
    name: serverInfo?.name || url || "",
    tools,
    resources,
    resourceTemplates,
    prompts,
    serverInfo,
    capabilities,
    error,
    log,
    authUrl,
    authTokens,
    client: clientRef.current,
    callTool,
    readResource,
    listResources,
    listPrompts,
    getPrompt,
    refreshTools,
    refreshResources,
    refreshPrompts,
    refreshAll,
    retry,
    disconnect,
    authenticate,
    clearStorage,
    ensureIconLoaded
  };
}
__name(useMcp, "useMcp");
var logger2 = Logger.get("ErrorBoundary");
var _a3;
var ErrorBoundary = (_a3 = class extends import_react2.default.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidCatch(error, errorInfo) {
    logger2.error("Widget Error:", error, errorInfo);
  }
  render() {
    if (this.state.hasError) {
      return import_react2.default.createElement("div", { className: "p-4 border border-red-500 bg-red-50 text-red-900 rounded-md dark:bg-red-900/20 dark:text-red-100" }, import_react2.default.createElement("h3", { className: "font-bold mb-2" }, "Widget Error"), import_react2.default.createElement("pre", { className: "text-sm whitespace-pre-wrap" }, this.state.error?.message));
    }
    return this.props.children;
  }
}, __name(_a3, "ErrorBoundary"), _a3);
var Image = __name(({ src, ...props }) => {
  const publicUrl = typeof window !== "undefined" ? window.__mcpPublicAssetsUrl || window.__mcpPublicUrl || "" : "";
  const getFinalSrc = __name((source) => {
    if (!source) return source;
    if (source.startsWith("http://") || source.startsWith("https://") || source.startsWith("data:")) {
      return source;
    }
    if (!publicUrl) {
      return source;
    }
    const cleanSrc = source.startsWith("/") ? source.slice(1) : source;
    return `${publicUrl}/${cleanSrc}`;
  }, "getFinalSrc");
  const finalSrc = getFinalSrc(src);
  return import_react3.default.createElement("img", { src: finalSrc, ...props });
}, "Image");
var WIDGET_DEFAULTS = {
  /** Polling interval for checking window.openai availability (ms) */
  POLL_INTERVAL: 100,
  /** Maximum timeout for window.openai availability check (ms) */
  MAX_TIMEOUT: 5e3,
  /** Default maximum height for widgets */
  MAX_HEIGHT: 600,
  /** Default locale */
  LOCALE: "en"
};
var MCP_APPS_BRIDGE_CONFIG = {
  /** Request timeout (ms) */
  REQUEST_TIMEOUT: 3e4,
  /** App name for identification */
  APP_NAME: "mcp-use-widget",
  /** App version */
  APP_VERSION: "1.0.0",
  /** MCP Apps protocol version */
  PROTOCOL_VERSION: "2025-06-18"
};
var _a4;
var McpAppsBridge = (_a4 = class {
  connected = false;
  connectPromise = null;
  requestId = 1;
  pendingRequests = /* @__PURE__ */ new Map();
  listeners = /* @__PURE__ */ new Set();
  // State
  toolInput = null;
  partialToolInput = null;
  toolOutput = null;
  toolResponseMetadata = null;
  hostContext = null;
  initialized = false;
  // Event handlers
  toolInputHandlers = /* @__PURE__ */ new Set();
  toolInputPartialHandlers = /* @__PURE__ */ new Set();
  toolResultHandlers = /* @__PURE__ */ new Set();
  hostContextHandlers = /* @__PURE__ */ new Set();
  constructor() {
    if (typeof window === "undefined") return;
    const handleMessage = __name((event) => {
      const message = event.data;
      if (!message || message.jsonrpc !== "2.0") return;
      if ("result" in message || "error" in message) {
        const response = message;
        if (response.id !== null && response.id !== void 0) {
          const pending = this.pendingRequests.get(response.id);
          if (pending) {
            this.pendingRequests.delete(response.id);
            if ("error" in response && response.error) {
              pending.reject(new Error(response.error.message));
            } else {
              pending.resolve(response.result);
            }
          }
        }
        return;
      }
      if ("method" in message && !("id" in message)) {
        this.handleNotification(message);
      }
    }, "handleMessage");
    window.addEventListener("message", handleMessage);
    this.listeners.add(handleMessage);
    this.interceptConsole();
  }
  /**
   * Intercept console methods and proxy to MCP Apps host
   */
  interceptConsole() {
    if (typeof window === "undefined" || typeof console === "undefined") return;
    const originalConsole = {
      log: console.log.bind(console),
      warn: console.warn.bind(console),
      error: console.error.bind(console),
      info: console.info.bind(console),
      debug: console.debug.bind(console)
    };
    const consoleLevelToRfc5424 = {
      log: "info",
      warn: "warning",
      error: "error",
      info: "info",
      debug: "debug"
    };
    const serializeForPostMessage = __name((value, seen = /* @__PURE__ */ new WeakSet()) => {
      if (value === null || value === void 0) return value;
      if (typeof value !== "object") return value;
      if (seen.has(value)) return "[Circular]";
      if (value instanceof Response) {
        return {
          __type: "Response",
          status: value.status,
          statusText: value.statusText,
          ok: value.ok,
          url: value.url,
          headers: Object.fromEntries(value.headers.entries())
        };
      }
      if (value instanceof Request) {
        return {
          __type: "Request",
          method: value.method,
          url: value.url,
          headers: Object.fromEntries(value.headers.entries())
        };
      }
      if (value instanceof Error) {
        return {
          __type: "Error",
          name: value.name,
          message: value.message,
          stack: value.stack
        };
      }
      if (value instanceof Event) {
        return {
          __type: "Event",
          type: value.type,
          target: value.target?.constructor?.name
        };
      }
      if (typeof HTMLElement !== "undefined" && value instanceof HTMLElement) {
        return {
          __type: "HTMLElement",
          tagName: value.tagName,
          id: value.id,
          className: value.className
        };
      }
      if (typeof value === "function") {
        return `[Function: ${value.name || "anonymous"}]`;
      }
      if (Array.isArray(value)) {
        seen.add(value);
        return value.map((item) => serializeForPostMessage(item, seen));
      }
      try {
        seen.add(value);
        const serialized = {};
        for (const key in value) {
          if (Object.prototype.hasOwnProperty.call(value, key)) {
            try {
              serialized[key] = serializeForPostMessage(value[key], seen);
            } catch {
              serialized[key] = "[Unserializable]";
            }
          }
        }
        return serialized;
      } catch {
        return "[Object]";
      }
    }, "serializeForPostMessage");
    const sendLog = __name((level, args) => {
      try {
        const serializedArgs = args.map((arg) => serializeForPostMessage(arg));
        this.sendNotification("notifications/message", {
          level: consoleLevelToRfc5424[level] || "info",
          logger: "console",
          data: serializedArgs.length === 1 ? serializedArgs[0] : serializedArgs
        });
      } catch (error) {
        originalConsole.warn(
          "[MCP Apps Bridge] Failed to forward console message:",
          error
        );
      }
    }, "sendLog");
    console.log = (...args) => {
      sendLog("log", args);
      originalConsole.log(...args);
    };
    console.warn = (...args) => {
      sendLog("warn", args);
      originalConsole.warn(...args);
    };
    console.error = (...args) => {
      sendLog("error", args);
      originalConsole.error(...args);
    };
    console.info = (...args) => {
      sendLog("info", args);
      originalConsole.info(...args);
    };
    console.debug = (...args) => {
      sendLog("debug", args);
      originalConsole.debug(...args);
    };
  }
  handleNotification(notification) {
    console.log(
      "[MCP Apps Bridge] Received notification:",
      notification.method,
      notification.params
    );
    switch (notification.method) {
      case "ui/notifications/tool-input": {
        const params = notification.params;
        console.log("[MCP Apps Bridge] Tool input received:", params.arguments);
        this.toolInput = params.arguments;
        this.toolInputHandlers.forEach((handler) => handler(params.arguments));
        break;
      }
      case "ui/notifications/tool-input-partial": {
        const params = notification.params;
        console.log(
          "[MCP Apps Bridge] Partial tool input received:",
          params.arguments
        );
        this.partialToolInput = params.arguments;
        this.toolInputPartialHandlers.forEach(
          (handler) => handler(params.arguments)
        );
        break;
      }
      case "ui/notifications/tool-result": {
        const params = notification.params;
        const output = params.structuredContent || this.parseTextContent(params);
        const meta = params._meta || null;
        this.toolOutput = output;
        this.toolResponseMetadata = meta;
        this.partialToolInput = null;
        this.toolResultHandlers.forEach((handler) => handler(output));
        break;
      }
      case "ui/notifications/host-context-changed": {
        const context = notification.params;
        console.log("[MCP Apps Bridge] Host context changed:", context);
        this.hostContext = { ...this.hostContext, ...context };
        console.log("[MCP Apps Bridge] Merged hostContext:", this.hostContext);
        console.log(
          "[MCP Apps Bridge] Calling handlers:",
          this.hostContextHandlers.size
        );
        this.hostContextHandlers.forEach(
          (handler) => handler(this.hostContext)
        );
        break;
      }
      case "ui/notifications/initialized": {
        this.initialized = true;
        break;
      }
      default:
        break;
    }
  }
  parseTextContent(result) {
    if (result.content && Array.isArray(result.content)) {
      for (const block of result.content) {
        if (block.type === "text" && block.text) {
          try {
            const parsed = JSON.parse(block.text);
            if (parsed && typeof parsed === "object" && !Array.isArray(parsed)) {
              return parsed;
            }
          } catch {
          }
        }
      }
    }
    return {};
  }
  sendRequest(method, params) {
    if (typeof window === "undefined" || !window.parent) {
      return Promise.reject(new Error("Not in iframe context"));
    }
    const id = this.requestId++;
    const message = createRequest(
      id,
      method,
      params
    );
    return new Promise((resolve, reject) => {
      this.pendingRequests.set(id, { resolve, reject });
      window.parent.postMessage(message, "*");
      setTimeout(() => {
        if (this.pendingRequests.has(id)) {
          this.pendingRequests.delete(id);
          reject(new Error(`Request timeout: ${method}`));
        }
      }, MCP_APPS_BRIDGE_CONFIG.REQUEST_TIMEOUT);
    });
  }
  sendNotification(method, params) {
    if (typeof window === "undefined" || !window.parent) return;
    const message = createNotification(
      method,
      params
    );
    window.parent.postMessage(message, "*");
  }
  /**
   * Initialize connection with MCP Apps host.
   * Concurrent calls share the same in-flight connection attempt so that
   * React StrictMode double-invocations and multiple useWidget() hooks
   * only produce a single ui/initialize request.
   */
  async connect() {
    if (this.connected) return;
    if (typeof window === "undefined" || window === window.parent) {
      console.log("[MCP Apps Bridge] Not in iframe, skipping connection");
      return;
    }
    if (!this.connectPromise) {
      this.connectPromise = this.doConnect();
      this.connectPromise.catch(() => {
        this.connectPromise = null;
      });
    }
    return this.connectPromise;
  }
  async doConnect() {
    console.log("[MCP Apps Bridge] Connecting to MCP Apps host...");
    try {
      const result = await this.sendRequest("ui/initialize", {
        appCapabilities: {},
        appInfo: {
          name: MCP_APPS_BRIDGE_CONFIG.APP_NAME,
          version: MCP_APPS_BRIDGE_CONFIG.APP_VERSION
        },
        protocolVersion: MCP_APPS_BRIDGE_CONFIG.PROTOCOL_VERSION
      });
      console.log("[MCP Apps Bridge] Initialize result:", result);
      if (result.hostContext) {
        this.hostContext = result.hostContext;
        console.log("[MCP Apps Bridge] Host context:", this.hostContext);
      }
      this.sendNotification("ui/notifications/initialized", {});
      this.connected = true;
      console.log("[MCP Apps Bridge] Successfully connected");
    } catch (error) {
      console.error("[MCP Apps Bridge] Failed to connect:", error);
      throw error;
    }
  }
  /**
   * Check if connected to MCP Apps host
   */
  isConnected() {
    return this.connected;
  }
  /**
   * Get current tool input (props)
   */
  getToolInput() {
    return this.toolInput;
  }
  /**
   * Get current partial/streaming tool input
   */
  getPartialToolInput() {
    return this.partialToolInput;
  }
  /**
   * Get current tool output (structuredContent from tool result)
   */
  getToolOutput() {
    return this.toolOutput;
  }
  /**
   * Get tool response metadata (_meta from tool result)
   */
  getToolResponseMetadata() {
    return this.toolResponseMetadata;
  }
  /**
   * Get host context
   */
  getHostContext() {
    return this.hostContext;
  }
  /**
   * Subscribe to tool input changes
   */
  onToolInput(handler) {
    this.toolInputHandlers.add(handler);
    return () => this.toolInputHandlers.delete(handler);
  }
  /**
   * Subscribe to partial/streaming tool input changes
   */
  onToolInputPartial(handler) {
    this.toolInputPartialHandlers.add(handler);
    return () => this.toolInputPartialHandlers.delete(handler);
  }
  /**
   * Subscribe to tool result changes
   */
  onToolResult(handler) {
    this.toolResultHandlers.add(handler);
    return () => this.toolResultHandlers.delete(handler);
  }
  /**
   * Subscribe to host context changes
   */
  onHostContextChange(handler) {
    this.hostContextHandlers.add(handler);
    return () => this.hostContextHandlers.delete(handler);
  }
  /**
   * Call a tool on the server
   */
  async callTool(name, args) {
    return this.sendRequest("tools/call", { name, arguments: args });
  }
  /**
   * Send a message to the conversation
   */
  async sendMessage(content) {
    const contentArray = Array.isArray(content) ? content : [content];
    await this.sendRequest("ui/message", {
      role: "user",
      content: contentArray
    });
  }
  /**
   * Open an external link
   */
  async openLink(url) {
    await this.sendRequest("ui/open-link", { url });
  }
  /**
   * Request display mode change
   */
  async requestDisplayMode(mode) {
    const result = await this.sendRequest("ui/request-display-mode", { mode });
    return result;
  }
  /**
   * Update the host's model context (SEP-1865 ui/update-model-context).
   * The host will include this data in the model's context on future turns.
   * Each call overwrites the previous context.
   */
  async updateModelContext(params) {
    await this.sendRequest("ui/update-model-context", params);
  }
  /**
   * Notify host about size changes for auto-sizing
   * Sends ui/notifications/size-changed notification per SEP-1865
   */
  sendSizeChanged(params) {
    this.sendNotification("ui/notifications/size-changed", params);
  }
  /**
   * Cleanup
   */
  disconnect() {
    this.listeners.forEach((listener) => {
      if (typeof window !== "undefined") {
        window.removeEventListener("message", listener);
      }
    });
    this.listeners.clear();
    this.pendingRequests.clear();
    this.toolInputHandlers.clear();
    this.toolInputPartialHandlers.clear();
    this.toolResultHandlers.clear();
    this.hostContextHandlers.clear();
    this.connected = false;
    this.connectPromise = null;
  }
}, __name(_a4, "McpAppsBridge"), _a4);
var bridgeInstance = null;
function getMcpAppsBridge() {
  if (!bridgeInstance) {
    bridgeInstance = new McpAppsBridge();
  }
  return bridgeInstance;
}
__name(getMcpAppsBridge, "getMcpAppsBridge");
function normalizeCallToolResponse(raw) {
  if (raw && typeof raw === "object" && "result" in raw) {
    return raw;
  }
  const content = raw?.content || [];
  const structuredContent = raw?.structuredContent || {};
  const result = content.filter((block) => block.type === "text" && block.text).map((block) => block.text).join("\n");
  const isError = raw?.isError ?? false;
  const _meta = raw?._meta;
  return {
    content,
    structuredContent,
    isError,
    result,
    _meta
  };
}
__name(normalizeCallToolResponse, "normalizeCallToolResponse");
var SET_GLOBALS_EVENT_TYPE = "openai:set_globals";
function useOpenAiGlobal(key) {
  return (0, import_react5.useSyncExternalStore)(
    (onChange) => {
      let lastValue = typeof window !== "undefined" && window.openai ? window.openai[key] : void 0;
      const handleSetGlobal = __name((event) => {
        const customEvent = event;
        const value = customEvent.detail.globals[key];
        if (value === void 0) {
          return;
        }
        if (value === lastValue) return;
        lastValue = value;
        onChange();
      }, "handleSetGlobal");
      if (typeof window !== "undefined") {
        window.addEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobal);
      }
      return () => {
        if (typeof window !== "undefined") {
          window.removeEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobal);
        }
      };
    },
    () => typeof window !== "undefined" && window.openai ? window.openai[key] : void 0
  );
}
__name(useOpenAiGlobal, "useOpenAiGlobal");
function useWidget(defaultProps) {
  const [isOpenAiAvailable, setIsOpenAiAvailable] = (0, import_react5.useState)(
    () => typeof window !== "undefined" && !!window.openai
  );
  const [isMcpAppsConnected, setIsMcpAppsConnected] = (0, import_react5.useState)(false);
  const [mcpAppsToolInput, setMcpAppsToolInput] = (0, import_react5.useState)(null);
  const [mcpAppsToolOutput, setMcpAppsToolOutput] = (0, import_react5.useState)(null);
  const [mcpAppsResponseMetadata, setMcpAppsResponseMetadata] = (0, import_react5.useState)(null);
  const [mcpAppsPartialToolInput, setMcpAppsPartialToolInput] = (0, import_react5.useState)(null);
  const [mcpAppsHostContext, setMcpAppsHostContext] = (0, import_react5.useState)(null);
  (0, import_react5.useEffect)(() => {
    if (typeof window !== "undefined" && window.openai) {
      setIsOpenAiAvailable(true);
      return;
    }
    const checkInterval = setInterval(() => {
      if (typeof window !== "undefined" && window.openai) {
        setIsOpenAiAvailable(true);
        clearInterval(checkInterval);
      }
    }, 100);
    const handleSetGlobals = __name(() => {
      if (typeof window !== "undefined" && window.openai) {
        setIsOpenAiAvailable(true);
        clearInterval(checkInterval);
      }
    }, "handleSetGlobals");
    if (typeof window !== "undefined") {
      window.addEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobals);
    }
    const timeout = setTimeout(() => {
      clearInterval(checkInterval);
      if (typeof window !== "undefined") {
        window.removeEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobals);
      }
    }, 5e3);
    return () => {
      clearInterval(checkInterval);
      clearTimeout(timeout);
      if (typeof window !== "undefined") {
        window.removeEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobals);
      }
    };
  }, []);
  (0, import_react5.useEffect)(() => {
    if (typeof window === "undefined" || window.openai || window === window.parent) {
      return;
    }
    const bridge = getMcpAppsBridge();
    bridge.connect().then(() => {
      setIsMcpAppsConnected(true);
      const toolInput2 = bridge.getToolInput();
      const toolOutput2 = bridge.getToolOutput();
      const responseMeta = bridge.getToolResponseMetadata();
      const hostContext = bridge.getHostContext();
      const partialToolInput2 = bridge.getPartialToolInput();
      if (toolInput2) setMcpAppsToolInput(toolInput2);
      if (toolOutput2) setMcpAppsToolOutput(toolOutput2);
      if (responseMeta) setMcpAppsResponseMetadata(responseMeta);
      if (partialToolInput2) setMcpAppsPartialToolInput(partialToolInput2);
      if (hostContext) setMcpAppsHostContext(hostContext);
    }).catch((error) => {
      console.warn("[useWidget] Failed to connect to MCP Apps host:", error);
    });
    const unsubToolInput = bridge.onToolInput((input) => {
      setMcpAppsToolInput(input);
    });
    const unsubToolInputPartial = bridge.onToolInputPartial((input) => {
      setMcpAppsPartialToolInput(input);
    });
    const unsubToolResult = bridge.onToolResult((result) => {
      setMcpAppsToolOutput(result);
      setMcpAppsResponseMetadata(bridge.getToolResponseMetadata());
      setMcpAppsPartialToolInput(null);
    });
    const unsubHostContext = bridge.onHostContextChange((context) => {
      console.log("[useWidget] Host context change received:", context);
      setMcpAppsHostContext(context);
    });
    return () => {
      unsubToolInput();
      unsubToolInputPartial();
      unsubToolResult();
      unsubHostContext();
    };
  }, []);
  const provider = (0, import_react5.useMemo)(() => {
    if (isOpenAiAvailable) return "openai";
    if (isMcpAppsConnected) return "mcp-apps";
    return "mcp-ui";
  }, [isOpenAiAvailable, isMcpAppsConnected]);
  const searchString = typeof window !== "undefined" ? window.location.search : "";
  const urlParams = (0, import_react5.useMemo)(() => {
    const urlParams2 = new URLSearchParams(searchString);
    if (urlParams2.has("mcpUseParams")) {
      return JSON.parse(urlParams2.get("mcpUseParams"));
    }
    return {
      toolInput: {},
      toolOutput: {},
      toolId: ""
    };
  }, [searchString]);
  const openaiToolInput = useOpenAiGlobal("toolInput");
  const openaiToolOutput = useOpenAiGlobal("toolOutput");
  const toolResponseMetadata = useOpenAiGlobal("toolResponseMetadata");
  const widgetState = useOpenAiGlobal("widgetState");
  const openaiTheme = useOpenAiGlobal("theme");
  const openaiDisplayMode = useOpenAiGlobal("displayMode");
  const openaiSafeArea = useOpenAiGlobal("safeArea");
  const openaiMaxHeight = useOpenAiGlobal("maxHeight");
  const openaiUserAgent = useOpenAiGlobal("userAgent");
  const openaiLocale = useOpenAiGlobal("locale");
  const toolInput = (0, import_react5.useMemo)(() => {
    if (provider === "openai") return openaiToolInput;
    if (provider === "mcp-apps")
      return mcpAppsToolInput;
    return urlParams.toolInput;
  }, [provider, openaiToolInput, mcpAppsToolInput, urlParams.toolInput]);
  const toolOutput = (0, import_react5.useMemo)(() => {
    if (provider === "openai") {
      const raw = openaiToolOutput;
      if (raw && raw.structuredContent && typeof raw.structuredContent === "object") {
        return raw.structuredContent;
      }
      return openaiToolOutput;
    }
    if (provider === "mcp-apps")
      return mcpAppsToolOutput;
    return urlParams.toolOutput;
  }, [provider, openaiToolOutput, mcpAppsToolOutput, urlParams.toolOutput]);
  const widgetProps = (0, import_react5.useMemo)(() => {
    const ti = toolInput || {};
    const base = defaultProps || {};
    let structuredContent;
    if (provider === "openai" && openaiToolOutput) {
      const raw = openaiToolOutput;
      if (raw.structuredContent && typeof raw.structuredContent === "object") {
        structuredContent = raw.structuredContent;
      } else {
        structuredContent = raw;
      }
    } else if (provider === "mcp-apps" && mcpAppsToolOutput) {
      structuredContent = mcpAppsToolOutput;
    } else if (provider === "mcp-ui" && urlParams.toolOutput) {
      structuredContent = urlParams.toolOutput;
    }
    const merged = { ...base, ...ti, ...structuredContent || {} };
    return merged;
  }, [
    provider,
    toolInput,
    openaiToolOutput,
    mcpAppsToolOutput,
    urlParams.toolOutput,
    defaultProps
  ]);
  const theme = (0, import_react5.useMemo)(() => {
    if (provider === "openai") return openaiTheme;
    if (provider === "mcp-apps" && mcpAppsHostContext) {
      return mcpAppsHostContext.theme;
    }
    return void 0;
  }, [provider, openaiTheme, mcpAppsHostContext]);
  const displayMode = (0, import_react5.useMemo)(() => {
    if (provider === "openai") return openaiDisplayMode;
    if (provider === "mcp-apps" && mcpAppsHostContext) {
      return mcpAppsHostContext.displayMode;
    }
    return void 0;
  }, [provider, openaiDisplayMode, mcpAppsHostContext]);
  const safeArea = (0, import_react5.useMemo)(() => {
    if (provider === "openai") return openaiSafeArea;
    if (provider === "mcp-apps" && mcpAppsHostContext?.safeAreaInsets) {
      return {
        insets: mcpAppsHostContext.safeAreaInsets
      };
    }
    return void 0;
  }, [provider, openaiSafeArea, mcpAppsHostContext]);
  const maxHeight = (0, import_react5.useMemo)(() => {
    if (provider === "openai") return openaiMaxHeight;
    if (provider === "mcp-apps" && mcpAppsHostContext?.containerDimensions) {
      return mcpAppsHostContext.containerDimensions.maxHeight;
    }
    return void 0;
  }, [provider, openaiMaxHeight, mcpAppsHostContext]);
  const maxWidth = (0, import_react5.useMemo)(() => {
    if (provider === "openai") {
      return void 0;
    }
    if (provider === "mcp-apps" && mcpAppsHostContext?.containerDimensions) {
      return mcpAppsHostContext.containerDimensions.maxWidth;
    }
    return void 0;
  }, [provider, mcpAppsHostContext]);
  const userAgent = (0, import_react5.useMemo)(() => {
    if (provider === "openai") return openaiUserAgent;
    if (provider === "mcp-apps" && mcpAppsHostContext) {
      return {
        device: {
          type: mcpAppsHostContext.platform === "mobile" ? "mobile" : "desktop"
        },
        capabilities: {
          hover: mcpAppsHostContext.deviceCapabilities?.hover ?? false,
          touch: mcpAppsHostContext.deviceCapabilities?.touch ?? false
        }
      };
    }
    return void 0;
  }, [provider, openaiUserAgent, mcpAppsHostContext]);
  const locale = (0, import_react5.useMemo)(() => {
    if (provider === "openai") return openaiLocale;
    if (provider === "mcp-apps" && mcpAppsHostContext) {
      return mcpAppsHostContext.locale;
    }
    return void 0;
  }, [provider, openaiLocale, mcpAppsHostContext]);
  const timeZone = (0, import_react5.useMemo)(() => {
    if (provider === "openai") {
      return typeof window !== "undefined" ? Intl.DateTimeFormat().resolvedOptions().timeZone : void 0;
    }
    if (provider === "mcp-apps" && mcpAppsHostContext) {
      return mcpAppsHostContext.timeZone;
    }
    return void 0;
  }, [provider, mcpAppsHostContext]);
  const mcp_url = (0, import_react5.useMemo)(() => {
    if (typeof window !== "undefined" && window.__mcpPublicUrl) {
      return window.__mcpPublicUrl.replace(/\/mcp-use\/public$/, "");
    }
    return "";
  }, []);
  const [localWidgetState, setLocalWidgetState] = (0, import_react5.useState)(null);
  (0, import_react5.useEffect)(() => {
    if (widgetState !== void 0) {
      setLocalWidgetState(widgetState);
    }
  }, [widgetState]);
  const callTool = (0, import_react5.useCallback)(
    async (name, args) => {
      if (provider === "mcp-apps") {
        const bridge = getMcpAppsBridge();
        const raw2 = await bridge.callTool(name, args);
        return normalizeCallToolResponse(raw2);
      }
      if (!window.openai?.callTool) {
        throw new Error("window.openai.callTool is not available");
      }
      const raw = await window.openai.callTool(name, args);
      return normalizeCallToolResponse(raw);
    },
    [provider]
  );
  const sendFollowUpMessage = (0, import_react5.useCallback)(
    async (prompt) => {
      if (provider === "mcp-apps") {
        const bridge = getMcpAppsBridge();
        await bridge.sendMessage({ type: "text", text: prompt });
        return;
      }
      if (!window.openai?.sendFollowUpMessage) {
        throw new Error("window.openai.sendFollowUpMessage is not available");
      }
      return window.openai.sendFollowUpMessage({ prompt });
    },
    [provider]
  );
  const openExternal = (0, import_react5.useCallback)(
    (href) => {
      if (provider === "mcp-apps") {
        const bridge = getMcpAppsBridge();
        bridge.openLink(href).catch((error) => {
          console.error("Failed to open link:", error);
        });
        return;
      }
      if (!window.openai?.openExternal) {
        throw new Error("window.openai.openExternal is not available");
      }
      window.openai.openExternal({ href });
    },
    [provider]
  );
  const requestDisplayMode = (0, import_react5.useCallback)(
    async (mode) => {
      if (provider === "mcp-apps") {
        const bridge = getMcpAppsBridge();
        return await bridge.requestDisplayMode(mode);
      }
      if (!window.openai?.requestDisplayMode) {
        throw new Error("window.openai.requestDisplayMode is not available");
      }
      return window.openai.requestDisplayMode({ mode });
    },
    [provider]
  );
  const setState = (0, import_react5.useCallback)(
    async (state) => {
      if (provider === "mcp-apps") {
        const currentState2 = localWidgetState;
        const newState2 = typeof state === "function" ? state(currentState2) : state;
        setLocalWidgetState(newState2);
        const bridge = getMcpAppsBridge();
        bridge.updateModelContext({
          structuredContent: newState2,
          content: [{ type: "text", text: JSON.stringify(newState2) }]
        }).catch((err) => {
          console.warn("[useWidget] Failed to update model context:", err);
        });
        return;
      }
      if (!window.openai?.setWidgetState) {
        throw new Error("window.openai.setWidgetState is not available");
      }
      const currentState = widgetState !== void 0 ? widgetState : localWidgetState;
      const newState = typeof state === "function" ? state(currentState) : state;
      setLocalWidgetState(newState);
      return window.openai.setWidgetState(newState);
    },
    [provider, widgetState, localWidgetState]
  );
  const isPending = (0, import_react5.useMemo)(() => {
    if (provider === "openai") {
      return openaiToolOutput === null && toolResponseMetadata === null;
    }
    if (provider === "mcp-apps") {
      return mcpAppsToolOutput === null;
    }
    if (provider === "mcp-ui") {
      if (typeof window !== "undefined" && window !== window.parent && !urlParams.toolId) {
        return true;
      }
      return toolOutput === null || toolOutput === void 0;
    }
    return false;
  }, [
    provider,
    openaiToolOutput,
    toolResponseMetadata,
    mcpAppsToolOutput,
    toolOutput,
    urlParams.toolId
  ]);
  const partialToolInput = (0, import_react5.useMemo)(() => {
    if (provider === "mcp-apps" && mcpAppsPartialToolInput) {
      return mcpAppsPartialToolInput;
    }
    return null;
  }, [provider, mcpAppsPartialToolInput]);
  const isStreaming = (0, import_react5.useMemo)(() => {
    if (provider === "mcp-apps") {
      return mcpAppsPartialToolInput !== null;
    }
    return false;
  }, [provider, mcpAppsPartialToolInput]);
  return {
    // Props and state (with defaults)
    props: widgetProps,
    toolInput: toolInput || {},
    output: toolOutput ?? null,
    metadata: provider === "mcp-apps" ? mcpAppsResponseMetadata ?? null : toolResponseMetadata ?? null,
    state: localWidgetState,
    setState,
    // Layout and theme (with safe defaults)
    theme: theme || "light",
    displayMode: displayMode || "inline",
    safeArea: safeArea || { insets: { top: 0, bottom: 0, left: 0, right: 0 } },
    maxHeight: maxHeight || 600,
    maxWidth,
    userAgent: userAgent || {
      device: { type: "desktop" },
      capabilities: { hover: true, touch: false }
    },
    locale: locale || WIDGET_DEFAULTS.LOCALE,
    timeZone: timeZone || (typeof window !== "undefined" ? Intl.DateTimeFormat().resolvedOptions().timeZone : "UTC"),
    mcp_url,
    // Actions
    callTool,
    sendFollowUpMessage,
    openExternal,
    requestDisplayMode,
    // Availability
    isAvailable: isOpenAiAvailable || isMcpAppsConnected,
    isPending,
    // Streaming
    partialToolInput,
    isStreaming
  };
}
__name(useWidget, "useWidget");
function useWidgetProps(defaultProps) {
  const { props } = useWidget(defaultProps);
  return props;
}
__name(useWidgetProps, "useWidgetProps");
function useWidgetTheme() {
  const { theme } = useWidget();
  return theme;
}
__name(useWidgetTheme, "useWidgetTheme");
function useWidgetState(defaultState) {
  const { state, setState } = useWidget();
  (0, import_react5.useEffect)(() => {
    if (state === null && defaultState !== void 0 && window.openai?.setWidgetState) {
      setState(defaultState);
    }
  }, []);
  return [state, setState];
}
__name(useWidgetState, "useWidgetState");
var ThemeProvider = __name(({
  children
}) => {
  const { theme, isAvailable } = useWidget();
  const [systemPreference, setSystemPreference] = (0, import_react4.useState)(
    () => {
      if (typeof window === "undefined") return "light";
      return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
  );
  (0, import_react4.useEffect)(() => {
    if (typeof window === "undefined") return;
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    const handleChange = __name((e) => {
      setSystemPreference(e.matches ? "dark" : "light");
    }, "handleChange");
    mediaQuery.addEventListener("change", handleChange);
    return () => mediaQuery.removeEventListener("change", handleChange);
  }, []);
  const effectiveTheme = isAvailable ? theme : systemPreference;
  (0, import_react4.useLayoutEffect)(() => {
    if (typeof document === "undefined") return;
    const root = document.documentElement;
    root.classList.remove("light", "dark");
    root.classList.add(effectiveTheme === "dark" ? "dark" : "light");
    root.setAttribute(
      "data-theme",
      effectiveTheme === "dark" ? "dark" : "light"
    );
    root.style.colorScheme = effectiveTheme === "dark" ? "dark" : "light";
  }, [effectiveTheme]);
  return import_react4.default.createElement(import_react4.default.Fragment, null, children);
}, "ThemeProvider");
function WidgetControls({
  children,
  className = "",
  position = "top-right",
  attachTo,
  showLabels = true,
  debugger: enableDebugger = false,
  viewControls = false
}) {
  const {
    props,
    output,
    metadata,
    state,
    theme,
    displayMode,
    safeArea,
    maxHeight,
    userAgent,
    locale,
    isAvailable,
    callTool,
    sendFollowUpMessage,
    openExternal,
    requestDisplayMode,
    setState
  } = useWidget();
  const [isHovered, setIsHovered] = (0, import_react6.useState)(false);
  const [isOverlayOpen, setIsOverlayOpen] = (0, import_react6.useState)(false);
  const containerRef = (0, import_react6.useRef)(null);
  const overlayRef = (0, import_react6.useRef)(null);
  const [windowOpenAiKeys, setWindowOpenAiKeys] = (0, import_react6.useState)([]);
  const [actionResult, setActionResult] = (0, import_react6.useState)("");
  const [toolName, setToolName] = (0, import_react6.useState)("get-my-city");
  const [toolArgs, setToolArgs] = (0, import_react6.useState)("{}");
  const [followUpMessage, setFollowUpMessage] = (0, import_react6.useState)(
    "Test follow-up message"
  );
  const [externalUrl, setExternalUrl] = (0, import_react6.useState)(
    "https://mcp-use.com/docs"
  );
  const isFullscreen = displayMode === "fullscreen" && isAvailable;
  const isPip = displayMode === "pip" && isAvailable;
  const isInInspector = typeof window !== "undefined" && window.location.pathname.includes("/inspector/api/");
  (0, import_react6.useEffect)(() => {
    const timeoutId = setTimeout(() => {
      if (typeof window !== "undefined" && window.openai) {
        try {
          const keys = Object.keys(window.openai);
          setWindowOpenAiKeys(keys);
        } catch (e) {
          setWindowOpenAiKeys([]);
        }
      } else {
        setWindowOpenAiKeys([]);
      }
    }, 100);
    return () => {
      clearTimeout(timeoutId);
    };
  }, []);
  const isDark = theme === "dark";
  const getPositionClasses = __name(() => {
    const baseClasses = [
      "absolute",
      "z-[1000]",
      "flex",
      "gap-2",
      "transition-opacity",
      "duration-200",
      "ease-in-out",
      isHovered ? "opacity-100" : "opacity-0",
      isHovered ? "pointer-events-auto" : "pointer-events-none"
    ];
    switch (position) {
      case "top-left":
        return [...baseClasses, "top-4", "left-4"];
      case "top-center":
        return [...baseClasses, "top-4", "left-1/2", "-translate-x-1/2"];
      case "top-right":
        return [...baseClasses, "top-4", "right-4"];
      case "center-left":
        return [...baseClasses, "top-1/2", "left-4", "-translate-y-1/2"];
      case "center-right":
        return [...baseClasses, "top-1/2", "right-4", "-translate-y-1/2"];
      case "bottom-left":
        return [...baseClasses, "bottom-4", "left-4"];
      case "bottom-center":
        return [...baseClasses, "bottom-4", "left-1/2", "-translate-x-1/2"];
      case "bottom-right":
        return [...baseClasses, "bottom-4", "right-4"];
      default:
        return [...baseClasses, "top-4", "right-4"];
    }
  }, "getPositionClasses");
  const getPositionOffsetStyles = __name(() => {
    const baseOffset = 16;
    const topOffset = safeArea?.insets?.top ? Math.max(baseOffset, safeArea.insets.top + 8) : baseOffset;
    const rightOffset = safeArea?.insets?.right ? Math.max(baseOffset, safeArea.insets.right + 8) : baseOffset;
    const bottomOffset = safeArea?.insets?.bottom ? Math.max(baseOffset, safeArea.insets.bottom + 8) : baseOffset;
    const leftOffset = safeArea?.insets?.left ? Math.max(baseOffset, safeArea.insets.left + 8) : baseOffset;
    const styles = {};
    switch (position) {
      case "top-left":
        styles.top = `${topOffset}px`;
        styles.left = `${leftOffset}px`;
        break;
      case "top-center":
        styles.top = `${topOffset}px`;
        break;
      case "top-right":
        styles.top = `${topOffset}px`;
        styles.right = `${rightOffset}px`;
        break;
      case "center-left":
        styles.left = `${leftOffset}px`;
        break;
      case "center-right":
        styles.right = `${rightOffset}px`;
        break;
      case "bottom-left":
        styles.bottom = `${bottomOffset}px`;
        styles.left = `${leftOffset}px`;
        break;
      case "bottom-center":
        styles.bottom = `${bottomOffset}px`;
        break;
      case "bottom-right":
        styles.bottom = `${bottomOffset}px`;
        styles.right = `${rightOffset}px`;
        break;
      default:
        styles.top = `${topOffset}px`;
        styles.right = `${rightOffset}px`;
        break;
    }
    return styles;
  }, "getPositionOffsetStyles");
  (0, import_react6.useEffect)(() => {
    if (!attachTo) return;
    const handleMouseEnter = __name(() => setIsHovered(true), "handleMouseEnter");
    const handleMouseLeave = __name(() => setIsHovered(false), "handleMouseLeave");
    attachTo.addEventListener("mouseenter", handleMouseEnter);
    attachTo.addEventListener("mouseleave", handleMouseLeave);
    return () => {
      attachTo.removeEventListener("mouseenter", handleMouseEnter);
      attachTo.removeEventListener("mouseleave", handleMouseLeave);
    };
  }, [attachTo]);
  (0, import_react6.useEffect)(() => {
    if (!isOverlayOpen) return;
    const handleClickOutside = __name((event) => {
      if (overlayRef.current && !overlayRef.current.contains(event.target)) {
        setIsOverlayOpen(false);
      }
    }, "handleClickOutside");
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [isOverlayOpen]);
  (0, import_react6.useEffect)(() => {
    if (isOverlayOpen) {
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = "";
    }
    return () => {
      document.body.style.overflow = "";
    };
  }, [isOverlayOpen]);
  const handleToggleOverlay = __name(() => {
    setIsOverlayOpen(!isOverlayOpen);
  }, "handleToggleOverlay");
  const handleCallTool = __name(async () => {
    try {
      setActionResult("Calling tool...");
      const args = toolArgs.trim() ? JSON.parse(toolArgs) : {};
      const result = await callTool(toolName, args);
      setActionResult(`Success: ${JSON.stringify(result, null, 2)}`);
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleCallTool");
  const handleSendFollowUpMessage = __name(async () => {
    try {
      setActionResult("Sending follow-up message...");
      await sendFollowUpMessage(followUpMessage);
      setActionResult("Follow-up message sent successfully");
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleSendFollowUpMessage");
  const handleOpenExternal = __name(() => {
    try {
      openExternal(externalUrl);
      setActionResult(`Opened external link: ${externalUrl}`);
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleOpenExternal");
  const handleRequestDisplayMode = __name(async (mode) => {
    try {
      setActionResult(`Requesting display mode: ${mode}...`);
      const result = await requestDisplayMode(mode);
      setActionResult(`Display mode granted: ${result.mode}`);
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleRequestDisplayMode");
  const handleSetState = __name(async () => {
    try {
      const newState = state ? { ...state, debugTimestamp: (/* @__PURE__ */ new Date()).toISOString() } : { debugTimestamp: (/* @__PURE__ */ new Date()).toISOString() };
      setActionResult("Setting state...");
      await setState(newState);
      setActionResult(`State updated: ${JSON.stringify(newState, null, 2)}`);
    } catch (error) {
      const err = error;
      setActionResult(`Error: ${err.message}`);
    }
  }, "handleSetState");
  const handleFullscreen = __name(async () => {
    try {
      await requestDisplayMode("fullscreen");
    } catch (error) {
      console.error("Failed to go fullscreen:", error);
    }
  }, "handleFullscreen");
  const handlePip = __name(async () => {
    try {
      await requestDisplayMode("pip");
    } catch (error) {
      console.error("Failed to go pip:", error);
    }
  }, "handlePip");
  const getTooltipClasses = __name(() => {
    const baseClasses = [
      "absolute",
      "px-2",
      "py-1",
      "bg-black/90",
      "text-white",
      "rounded",
      "text-xs",
      "whitespace-nowrap",
      "pointer-events-none",
      "transition-opacity",
      "duration-200",
      "ease-in-out"
    ];
    switch (position) {
      case "top-right":
        return [...baseClasses, "top-full", "right-0", "mt-2"];
      case "top-left":
        return [...baseClasses, "top-full", "left-0", "mt-2"];
      case "top-center":
        return [
          ...baseClasses,
          "top-full",
          "left-1/2",
          "-translate-x-1/2",
          "mt-2"
        ];
      case "bottom-right":
        return [...baseClasses, "bottom-full", "right-0", "mb-2"];
      case "bottom-left":
        return [...baseClasses, "bottom-full", "left-0", "mb-2"];
      case "bottom-center":
        return [
          ...baseClasses,
          "bottom-full",
          "left-1/2",
          "-translate-x-1/2",
          "mb-2"
        ];
      case "center-left":
        return [
          ...baseClasses,
          "left-full",
          "top-1/2",
          "-translate-y-1/2",
          "ml-2"
        ];
      case "center-right":
        return [
          ...baseClasses,
          "right-full",
          "top-1/2",
          "-translate-y-1/2",
          "mr-2"
        ];
      default:
        return [...baseClasses, "top-full", "right-0", "mt-2"];
    }
  }, "getTooltipClasses");
  const IconButton = __name(({
    onClick,
    label,
    children: icon
  }) => {
    const [isButtonHovered, setIsButtonHovered] = (0, import_react6.useState)(false);
    const tooltipClasses = getTooltipClasses();
    return import_react6.default.createElement(
      "button",
      {
        className: `p-2 ${isDark ? "bg-white/10 hover:bg-white/20" : "bg-black/70 hover:bg-black/90"} text-white border-none rounded-lg cursor-pointer flex items-center justify-center w-8 h-8 transition-colors duration-200 backdrop-blur-md ${isDark ? "shadow-[0_2px_8px_rgba(0,0,0,0.3)]" : "shadow-[0_2px_8px_rgba(0,0,0,0.2)]"} relative`,
        onMouseEnter: () => setIsButtonHovered(true),
        onMouseLeave: () => setIsButtonHovered(false),
        onClick,
        "aria-label": label
      },
      import_react6.default.createElement(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          width: "16",
          height: "16",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          className: "block"
        },
        icon
      ),
      showLabels && import_react6.default.createElement(
        "span",
        {
          className: `${tooltipClasses.join(" ")} ${isButtonHovered ? "opacity-100" : "opacity-0"}`
        },
        label
      )
    );
  }, "IconButton");
  const formatValue = __name((value) => {
    if (value === null) return "null";
    if (value === void 0) return "undefined";
    if (typeof value === "object") {
      try {
        return JSON.stringify(value, null, 2);
      } catch {
        return String(value);
      }
    }
    return String(value);
  }, "formatValue");
  const formatUserAgent = __name((ua) => {
    if (!ua) return "N/A";
    return `${ua.device?.type || "unknown"}`;
  }, "formatUserAgent");
  const formatSafeArea = __name((sa) => {
    if (!sa?.insets) return "N/A";
    const { top, bottom, left, right } = sa.insets;
    return `T:${top} B:${bottom} L:${left} R:${right}`;
  }, "formatSafeArea");
  return import_react6.default.createElement(import_react6.default.Fragment, null, import_react6.default.createElement(
    "div",
    {
      ref: containerRef,
      className: `${className} relative h-fit`,
      onMouseEnter: () => !attachTo && setIsHovered(true),
      onMouseLeave: () => !attachTo && setIsHovered(false)
    },
    import_react6.default.createElement(
      "div",
      {
        className: getPositionClasses().join(" "),
        style: getPositionOffsetStyles()
      },
      !isInInspector && import_react6.default.createElement(import_react6.default.Fragment, null, !isFullscreen && !isPip && import_react6.default.createElement(import_react6.default.Fragment, null, (viewControls === true || viewControls === "fullscreen") && import_react6.default.createElement(IconButton, { onClick: handleFullscreen, label: "Fullscreen" }, import_react6.default.createElement("path", { d: "M15 3h6v6" }), import_react6.default.createElement("path", { d: "m21 3-7 7" }), import_react6.default.createElement("path", { d: "m3 21 7-7" }), import_react6.default.createElement("path", { d: "M9 21H3v-6" })), (viewControls === true || viewControls === "pip") && import_react6.default.createElement(IconButton, { onClick: handlePip, label: "Picture in Picture" }, import_react6.default.createElement("path", { d: "M21 9V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v10c0 1.1.9 2 2 2h4" }), import_react6.default.createElement("rect", { width: "10", height: "7", x: "12", y: "13", rx: "2" }))), enableDebugger && import_react6.default.createElement(IconButton, { onClick: handleToggleOverlay, label: "Debug Info" }, import_react6.default.createElement("path", { d: "M12 20v-9" }), import_react6.default.createElement("path", { d: "M14 7a4 4 0 0 1 4 4v3a6 6 0 0 1-12 0v-3a4 4 0 0 1 4-4z" }), import_react6.default.createElement("path", { d: "M14.12 3.88 16 2" }), import_react6.default.createElement("path", { d: "M21 21a4 4 0 0 0-3.81-4" }), import_react6.default.createElement("path", { d: "M21 5a4 4 0 0 1-3.55 3.97" }), import_react6.default.createElement("path", { d: "M22 13h-4" }), import_react6.default.createElement("path", { d: "M3 21a4 4 0 0 1 3.81-4" }), import_react6.default.createElement("path", { d: "M3 5a4 4 0 0 0 3.55 3.97" }), import_react6.default.createElement("path", { d: "M6 13H2" }), import_react6.default.createElement("path", { d: "m8 2 1.88 1.88" }), import_react6.default.createElement("path", { d: "M9 7.13V6a3 3 0 1 1 6 0v1.13" })))
    ),
    children
  ), isOverlayOpen && enableDebugger && import_react6.default.createElement(
    "div",
    {
      ref: overlayRef,
      className: "fixed inset-0 bg-black text-white font-mono text-xs z-[10000] overflow-auto p-4",
      onClick: (e) => {
        if (e.target === overlayRef.current) {
          setIsOverlayOpen(false);
        }
      }
    },
    import_react6.default.createElement(
      "button",
      {
        onClick: () => setIsOverlayOpen(false),
        className: "absolute top-4 right-4 bg-white/10 text-white border-none rounded w-8 h-8 cursor-pointer flex items-center justify-center text-lg leading-none",
        "aria-label": "Close"
      },
      ""
    ),
    import_react6.default.createElement("div", { className: "max-w-[1200px] mx-auto pt-10" }, import_react6.default.createElement("h1", { className: "text-lg font-bold mb-4 border-b border-gray-700 pb-2" }, "Debug Info"), import_react6.default.createElement("table", { className: "w-full border-collapse border-spacing-0" }, import_react6.default.createElement("tbody", null, import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Props"), import_react6.default.createElement("td", { className: "p-2 whitespace-pre-wrap break-all" }, formatValue(props))), import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Output"), import_react6.default.createElement("td", { className: "p-2 whitespace-pre-wrap break-all" }, formatValue(output))), import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Metadata"), import_react6.default.createElement("td", { className: "p-2 whitespace-pre-wrap break-all" }, formatValue(metadata))), import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "State"), import_react6.default.createElement("td", { className: "p-2 whitespace-pre-wrap break-all" }, formatValue(state))), import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Theme"), import_react6.default.createElement("td", { className: "p-2" }, theme)), import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Display Mode"), import_react6.default.createElement("td", { className: "p-2" }, displayMode)), import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Locale"), import_react6.default.createElement("td", { className: "p-2" }, locale)), import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Max Height"), import_react6.default.createElement("td", { className: "p-2" }, maxHeight, "px")), import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "User Agent"), import_react6.default.createElement("td", { className: "p-2" }, formatUserAgent(userAgent))), import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "Safe Area"), import_react6.default.createElement("td", { className: "p-2" }, formatSafeArea(safeArea))), import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "API Available"), import_react6.default.createElement("td", { className: "p-2" }, isAvailable ? "Yes" : "No")), import_react6.default.createElement("tr", { className: "border-b border-gray-700" }, import_react6.default.createElement("td", { className: "p-2 font-bold w-[200px] align-top" }, "window.openai Keys"), import_react6.default.createElement("td", { className: "p-2" }, windowOpenAiKeys.length > 0 ? windowOpenAiKeys.join(", ") : "N/A")))), import_react6.default.createElement("h2", { className: "text-base font-bold mt-8 mb-4 border-b border-gray-700 pb-2" }, "Actions"), import_react6.default.createElement("div", { className: "flex flex-col gap-3" }, import_react6.default.createElement("div", { className: "flex gap-2 items-center" }, import_react6.default.createElement(
      "input",
      {
        type: "text",
        value: toolName,
        onChange: (e) => setToolName(e.target.value),
        placeholder: "Tool name",
        className: "py-1.5 px-2 bg-[#1a1a1a] text-white border border-gray-700 rounded font-mono text-xs w-[150px]"
      }
    ), import_react6.default.createElement(
      "input",
      {
        type: "text",
        value: toolArgs,
        onChange: (e) => setToolArgs(e.target.value),
        placeholder: '{"key": "value"}',
        className: "py-1.5 px-2 bg-[#1a1a1a] text-white border border-gray-700 rounded font-mono text-xs flex-1"
      }
    ), import_react6.default.createElement(
      "button",
      {
        onClick: handleCallTool,
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs"
      },
      "Call Tool"
    )), import_react6.default.createElement("div", { className: "flex gap-2 items-center" }, import_react6.default.createElement(
      "input",
      {
        type: "text",
        value: followUpMessage,
        onChange: (e) => setFollowUpMessage(e.target.value),
        placeholder: "Follow-up message",
        className: "py-1.5 px-2 bg-[#1a1a1a] text-white border border-gray-700 rounded font-mono text-xs flex-1"
      }
    ), import_react6.default.createElement(
      "button",
      {
        onClick: handleSendFollowUpMessage,
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs"
      },
      "Send Follow-Up"
    )), import_react6.default.createElement("div", { className: "flex gap-2 items-center" }, import_react6.default.createElement(
      "input",
      {
        type: "text",
        value: externalUrl,
        onChange: (e) => setExternalUrl(e.target.value),
        placeholder: "External URL",
        className: "py-1.5 px-2 bg-[#1a1a1a] text-white border border-gray-700 rounded font-mono text-xs flex-1"
      }
    ), import_react6.default.createElement(
      "button",
      {
        onClick: handleOpenExternal,
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs"
      },
      "Open Link"
    )), import_react6.default.createElement("div", { className: "flex gap-2 items-center" }, import_react6.default.createElement("span", { className: "w-[150px] text-xs" }, "Display Mode:"), import_react6.default.createElement(
      "button",
      {
        onClick: () => handleRequestDisplayMode("inline"),
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs flex-1"
      },
      "Inline"
    ), import_react6.default.createElement(
      "button",
      {
        onClick: () => handleRequestDisplayMode("pip"),
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs flex-1"
      },
      "PiP"
    ), import_react6.default.createElement(
      "button",
      {
        onClick: () => handleRequestDisplayMode("fullscreen"),
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs flex-1"
      },
      "Fullscreen"
    )), import_react6.default.createElement("div", { className: "flex gap-2 items-center" }, import_react6.default.createElement(
      "button",
      {
        onClick: handleSetState,
        className: "py-1.5 px-3 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-xs"
      },
      "Set State (Add Timestamp)"
    )), actionResult && import_react6.default.createElement("div", { className: "mt-2 p-2 bg-[#1a1a1a] border border-gray-700 rounded whitespace-pre-wrap break-all text-[11px] max-h-[200px] overflow-auto" }, import_react6.default.createElement("div", { className: "font-bold mb-1 text-gray-400" }, "Result:"), actionResult, import_react6.default.createElement(
      "button",
      {
        onClick: () => setActionResult(""),
        className: "mt-2 py-1 px-2 bg-gray-800 text-white border border-gray-600 rounded cursor-pointer font-mono text-[11px]"
      },
      "Clear"
    ))))
  ));
}
__name(WidgetControls, "WidgetControls");
var HEIGHT_DEBOUNCE_MS = 150;
var MIN_HEIGHT_CHANGE_PX = 5;
function McpUseProvider({
  children,
  debugger: enableDebugger = false,
  viewControls = false,
  autoSize = true
}) {
  const [containerElement, setContainerElement] = (0, import_react7.useState)(null);
  const lastHeightRef = (0, import_react7.useRef)(0);
  const debounceTimeoutRef = (0, import_react7.useRef)(null);
  const notificationInProgressRef = (0, import_react7.useRef)(false);
  const notifyHeight = (0, import_react7.useCallback)((height) => {
    if (typeof window === "undefined") return;
    notificationInProgressRef.current = true;
    if (window.openai?.notifyIntrinsicHeight) {
      window.openai.notifyIntrinsicHeight(height).then(() => {
        notificationInProgressRef.current = false;
      }).catch((error) => {
        notificationInProgressRef.current = false;
        console.error(
          "[McpUseProvider] Failed to notify intrinsic height (ChatGPT):",
          error
        );
      });
      return;
    }
    try {
      const bridge = getMcpAppsBridge();
      bridge.sendSizeChanged({ height });
      console.log("[McpUseProvider] Sent size-changed notification:", height);
      notificationInProgressRef.current = false;
    } catch (error) {
      notificationInProgressRef.current = false;
      console.error(
        "[McpUseProvider] Failed to notify size change (MCP Apps):",
        error
      );
    }
  }, []);
  const debouncedNotifyHeight = (0, import_react7.useCallback)(
    (height) => {
      if (debounceTimeoutRef.current) {
        clearTimeout(debounceTimeoutRef.current);
      }
      debounceTimeoutRef.current = setTimeout(() => {
        const heightDiff = Math.abs(height - lastHeightRef.current);
        if (heightDiff >= MIN_HEIGHT_CHANGE_PX && height > 0) {
          lastHeightRef.current = height;
          notifyHeight(height);
        }
      }, HEIGHT_DEBOUNCE_MS);
    },
    [notifyHeight]
  );
  (0, import_react7.useEffect)(() => {
    if (!autoSize) {
      console.log("[McpUseProvider] autoSize is disabled");
      return;
    }
    if (!containerElement) {
      console.log("[McpUseProvider] No container element found for autoSize");
      return;
    }
    if (typeof ResizeObserver === "undefined") {
      console.log("[McpUseProvider] ResizeObserver not available");
      return;
    }
    console.log("[McpUseProvider] Setting up ResizeObserver for autoSize");
    const observer = new ResizeObserver((entries) => {
      if (notificationInProgressRef.current) {
        console.log(
          "[McpUseProvider] Skipping resize - notification in progress"
        );
        return;
      }
      for (const entry of entries) {
        const height = entry.contentRect.height;
        const scrollHeight = entry.target.scrollHeight;
        const intrinsicHeight = Math.max(height, scrollHeight);
        console.log("[McpUseProvider] ResizeObserver fired:", {
          height,
          scrollHeight,
          intrinsicHeight
        });
        debouncedNotifyHeight(intrinsicHeight);
      }
    });
    observer.observe(containerElement);
    const initialHeight = Math.max(
      containerElement.offsetHeight,
      containerElement.scrollHeight
    );
    console.log("[McpUseProvider] Initial height measurement:", initialHeight);
    if (initialHeight > 0) {
      debouncedNotifyHeight(initialHeight);
    }
    return () => {
      console.log("[McpUseProvider] Cleaning up ResizeObserver");
      observer.disconnect();
      if (debounceTimeoutRef.current) {
        clearTimeout(debounceTimeoutRef.current);
        debounceTimeoutRef.current = null;
      }
      notificationInProgressRef.current = false;
    };
  }, [autoSize, containerElement, debouncedNotifyHeight]);
  let content = children;
  content = import_react7.default.createElement(ErrorBoundary, null, content);
  if (enableDebugger || viewControls) {
    content = import_react7.default.createElement(WidgetControls, { debugger: enableDebugger, viewControls }, content);
  }
  content = import_react7.default.createElement(ThemeProvider, null, content);
  if (autoSize) {
    const containerStyle = {
      width: "100%",
      minHeight: 0
    };
    content = import_react7.default.createElement("div", { ref: setContainerElement, style: containerStyle }, content);
  }
  return import_react7.default.createElement(import_react7.StrictMode, null, content);
}
__name(McpUseProvider, "McpUseProvider");
function useCallTool(name) {
  const [{ status, data, error }, setCallToolState] = (0, import_react8.useState)({ status: "idle", data: void 0, error: void 0 });
  const callIdRef = (0, import_react8.useRef)(0);
  const execute = __name(async (args) => {
    const callId = ++callIdRef.current;
    setCallToolState({ status: "pending", data: void 0, error: void 0 });
    try {
      let raw;
      if (typeof window !== "undefined") {
        if (window.openai?.callTool) {
          raw = await window.openai.callTool(
            name,
            args
          );
        } else if (window !== window.parent) {
          const bridge = getMcpAppsBridge();
          raw = await bridge.callTool(name, args);
        } else {
          throw new Error("No tool calling interface available");
        }
      } else {
        throw new Error("useCallTool can only be used in browser environment");
      }
      const normalized = normalizeCallToolResponse(raw);
      if (callId === callIdRef.current) {
        setCallToolState({
          status: "success",
          data: normalized,
          error: void 0
        });
      }
      return normalized;
    } catch (error2) {
      if (callId === callIdRef.current) {
        setCallToolState({ status: "error", data: void 0, error: error2 });
      }
      throw error2;
    }
  }, "execute");
  const callToolAsync = (0, import_react8.useCallback)(
    ((args) => {
      if (args === void 0) {
        return execute(null);
      }
      return execute(args);
    }),
    [name]
  );
  const callTool = (0, import_react8.useCallback)(
    ((firstArg, sideEffects) => {
      let args;
      if (firstArg && typeof firstArg === "object" && ("onSuccess" in firstArg || "onError" in firstArg || "onSettled" in firstArg)) {
        args = null;
        sideEffects = firstArg;
      } else {
        args = firstArg === void 0 ? null : firstArg;
      }
      execute(args).then((data2) => {
        sideEffects?.onSuccess?.(data2, args);
        sideEffects?.onSettled?.(data2, void 0, args);
      }).catch((error2) => {
        sideEffects?.onError?.(error2, args);
        sideEffects?.onSettled?.(void 0, error2, args);
      });
    }),
    [name]
  );
  const callToolState = {
    status,
    data,
    error,
    isIdle: status === "idle",
    isPending: status === "pending",
    isSuccess: status === "success",
    isError: status === "error"
  };
  return {
    ...callToolState,
    callTool,
    callToolAsync
  };
}
__name(useCallTool, "useCallTool");
function generateHelpers() {
  const useCallTool2 = __name((name) => {
    return useCallTool(
      name
    );
  }, "useCallTool");
  const useToolInfo = __name(() => {
    return useWidget();
  }, "useToolInfo");
  return {
    useCallTool: useCallTool2,
    useToolInfo
  };
}
__name(generateHelpers, "generateHelpers");
var providerLogger = Logger.get("McpClientProvider");
var McpClientContext = (0, import_react9.createContext)(null);
var MAX_NOTIFICATIONS = 500;
function McpServerWrapper({
  id,
  options,
  defaultProxyConfig,
  defaultAutoProxyFallback,
  clientInfo: providerClientInfo,
  cachedMetadata,
  onUpdate,
  rpcWrapTransport,
  onGlobalSamplingRequest,
  onGlobalElicitationRequest
}) {
  const {
    name,
    onSamplingRequest,
    onElicitationRequest,
    onNotificationReceived,
    wrapTransport: optionsWrapTransport
  } = options;
  const mcpOptions = (0, import_react9.useMemo)(() => {
    const {
      name: _name,
      onSamplingRequest: _onSamplingRequest,
      onElicitationRequest: _onElicitationRequest,
      onNotificationReceived: _onNotificationReceived,
      wrapTransport: _wrapTransport,
      ...rest
    } = options;
    return {
      ...rest,
      // Use server-specific proxyConfig if provided, otherwise use default
      proxyConfig: rest.proxyConfig || defaultProxyConfig,
      // Use server-specific autoProxyFallback if provided, otherwise use default
      autoProxyFallback: rest.autoProxyFallback !== void 0 ? rest.autoProxyFallback : defaultAutoProxyFallback,
      // Merge provider clientInfo with server-specific clientInfo
      // Server-specific takes precedence
      clientInfo: rest.clientInfo ? providerClientInfo ? { ...providerClientInfo, ...rest.clientInfo } : rest.clientInfo : providerClientInfo,
      // Pass cached metadata as initial server info if available
      _initialServerInfo: cachedMetadata
    };
  }, [
    options,
    defaultProxyConfig,
    defaultAutoProxyFallback,
    providerClientInfo,
    cachedMetadata
  ]);
  const combinedWrapTransport = (0, import_react9.useMemo)(() => {
    if (!rpcWrapTransport && !optionsWrapTransport) return void 0;
    return (transport) => {
      let wrapped = transport;
      if (rpcWrapTransport) {
        wrapped = rpcWrapTransport(wrapped, id);
      }
      if (optionsWrapTransport) {
        wrapped = optionsWrapTransport(wrapped, id);
      }
      return wrapped;
    };
  }, [rpcWrapTransport, optionsWrapTransport, id]);
  const [notifications, setNotifications] = (0, import_react9.useState)([]);
  const [pendingSamplingRequests, setPendingSamplingRequests] = (0, import_react9.useState)([]);
  const samplingIdCounter = (0, import_react9.useRef)(0);
  const [pendingElicitationRequests, setPendingElicitationRequests] = (0, import_react9.useState)([]);
  const elicitationIdCounter = (0, import_react9.useRef)(0);
  const markNotificationRead = (0, import_react9.useCallback)((notificationId) => {
    setNotifications(
      (prev) => prev.map((n) => n.id === notificationId ? { ...n, read: true } : n)
    );
  }, []);
  const markAllNotificationsRead = (0, import_react9.useCallback)(() => {
    setNotifications((prev) => prev.map((n) => ({ ...n, read: true })));
  }, []);
  const clearNotifications = (0, import_react9.useCallback)(() => {
    setNotifications([]);
  }, []);
  const handleNotification = (0, import_react9.useCallback)(
    (notification) => {
      const mcpNotification = {
        id: globalThis.crypto?.randomUUID?.() || `${Date.now()}-${Math.random()}`,
        method: notification.method,
        params: notification.params,
        timestamp: Date.now(),
        read: false
      };
      setNotifications((prev) => {
        const updated = [mcpNotification, ...prev];
        if (updated.length > MAX_NOTIFICATIONS) {
          return updated.slice(0, MAX_NOTIFICATIONS);
        }
        return updated;
      });
      onNotificationReceived?.(mcpNotification);
    },
    [onNotificationReceived]
  );
  const approveSampling = (0, import_react9.useCallback)(
    (requestId, result) => {
      setPendingSamplingRequests((prev) => {
        const request = prev.find((r) => r.id === requestId);
        if (request) {
          request.resolve(result);
          return prev.filter((r) => r.id !== requestId);
        }
        return prev;
      });
    },
    []
  );
  const rejectSampling = (0, import_react9.useCallback)((requestId, error) => {
    setPendingSamplingRequests((prev) => {
      const request = prev.find((r) => r.id === requestId);
      if (request) {
        request.reject(new Error(error || "User rejected sampling request"));
        return prev.filter((r) => r.id !== requestId);
      }
      return prev;
    });
  }, []);
  const samplingCallback = (0, import_react9.useCallback)(
    async (params) => {
      return new Promise((resolve, reject) => {
        const requestId = `sampling-${samplingIdCounter.current++}`;
        const request = {
          id: requestId,
          request: { method: "sampling/createMessage", params },
          timestamp: Date.now(),
          serverName: name || id
        };
        const newRequest = {
          ...request,
          resolve,
          reject
        };
        setPendingSamplingRequests((prev) => [...prev, newRequest]);
        onSamplingRequest?.(request);
        onGlobalSamplingRequest?.(
          request,
          id,
          name || id,
          approveSampling,
          rejectSampling
        );
      });
    },
    [
      id,
      name,
      onSamplingRequest,
      onGlobalSamplingRequest,
      approveSampling,
      rejectSampling
    ]
  );
  const approveElicitation = (0, import_react9.useCallback)(
    (requestId, result) => {
      setPendingElicitationRequests((prev) => {
        const request = prev.find((r) => r.id === requestId);
        if (request) {
          request.resolve(result);
          return prev.filter((r) => r.id !== requestId);
        }
        return prev;
      });
    },
    []
  );
  const rejectElicitation = (0, import_react9.useCallback)((requestId, error) => {
    setPendingElicitationRequests((prev) => {
      const request = prev.find((r) => r.id === requestId);
      if (request) {
        request.reject(new Error(error || "User rejected elicitation request"));
        return prev.filter((r) => r.id !== requestId);
      }
      return prev;
    });
  }, []);
  const elicitationCallback = (0, import_react9.useCallback)(
    async (params) => {
      return new Promise((resolve, reject) => {
        const requestId = `elicitation-${elicitationIdCounter.current++}`;
        const request = {
          id: requestId,
          request: params,
          timestamp: Date.now(),
          serverName: name || id
        };
        const newRequest = {
          ...request,
          resolve,
          reject
        };
        setPendingElicitationRequests((prev) => [...prev, newRequest]);
        onElicitationRequest?.(request);
        onGlobalElicitationRequest?.(
          request,
          id,
          name || id,
          approveElicitation,
          rejectElicitation
        );
      });
    },
    [
      id,
      name,
      onElicitationRequest,
      onGlobalElicitationRequest,
      approveElicitation,
      rejectElicitation
    ]
  );
  const mcp = useMcp({
    ...mcpOptions,
    onNotification: handleNotification,
    onSampling: samplingCallback,
    onElicitation: elicitationCallback,
    wrapTransport: combinedWrapTransport
  });
  const publicSamplingRequests = (0, import_react9.useMemo)(
    () => pendingSamplingRequests.map((r) => ({
      id: r.id,
      request: r.request,
      timestamp: r.timestamp,
      serverName: r.serverName
    })),
    [pendingSamplingRequests]
  );
  const publicElicitationRequests = (0, import_react9.useMemo)(
    () => pendingElicitationRequests.map((r) => ({
      id: r.id,
      request: r.request,
      timestamp: r.timestamp,
      serverName: r.serverName
    })),
    [pendingElicitationRequests]
  );
  const unreadNotificationCount = (0, import_react9.useMemo)(
    () => notifications.filter((n) => !n.read).length,
    [notifications]
  );
  const toolsFingerprint = (0, import_react9.useMemo)(() => {
    const fingerprint = JSON.stringify(
      mcp.tools.map((t) => ({
        name: t.name,
        description: t.description,
        inputSchema: t.inputSchema,
        _meta: t._meta
      })).sort((a, b) => a.name.localeCompare(b.name))
    );
    return fingerprint;
  }, [mcp.tools, id]);
  const resourcesFingerprint = (0, import_react9.useMemo)(
    () => JSON.stringify(
      mcp.resources.map((r) => ({
        uri: r.uri,
        name: r.name,
        description: r.description,
        mimeType: r.mimeType
      })).sort((a, b) => a.uri.localeCompare(b.uri))
    ),
    [mcp.resources]
  );
  const promptsFingerprint = (0, import_react9.useMemo)(
    () => JSON.stringify(
      mcp.prompts.map((p) => ({
        name: p.name,
        description: p.description,
        arguments: p.arguments
      })).sort((a, b) => a.name.localeCompare(b.name))
    ),
    [mcp.prompts]
  );
  const onUpdateRef = (0, import_react9.useRef)(onUpdate);
  const prevServerRef = (0, import_react9.useRef)(null);
  const prevFingerprintsRef = (0, import_react9.useRef)({ tools: "", resources: "", prompts: "" });
  (0, import_react9.useEffect)(() => {
    onUpdateRef.current = onUpdate;
  }, [onUpdate]);
  (0, import_react9.useEffect)(() => {
    const server = {
      ...mcp,
      id,
      url: options.url || "",
      name: name || id,
      notifications,
      unreadNotificationCount,
      markNotificationRead,
      markAllNotificationsRead,
      clearNotifications,
      pendingSamplingRequests: publicSamplingRequests,
      approveSampling,
      rejectSampling,
      pendingElicitationRequests: publicElicitationRequests,
      approveElicitation,
      rejectElicitation
    };
    const prevServer = prevServerRef.current;
    const prevFingerprints = prevFingerprintsRef.current;
    const toolsChanged = prevFingerprints.tools !== toolsFingerprint;
    const resourcesChanged = prevFingerprints.resources !== resourcesFingerprint;
    const promptsChanged = prevFingerprints.prompts !== promptsFingerprint;
    if (!prevServer || prevServer.state !== server.state || prevServer.error !== server.error || prevServer.authUrl !== server.authUrl || toolsChanged || resourcesChanged || promptsChanged || prevServer.serverInfo !== server.serverInfo || prevServer.capabilities !== server.capabilities || prevServer.notifications.length !== server.notifications.length || prevServer.unreadNotificationCount !== server.unreadNotificationCount || prevServer.pendingSamplingRequests.length !== server.pendingSamplingRequests.length || prevServer.pendingElicitationRequests.length !== server.pendingElicitationRequests.length || !prevServer.client) {
      prevServerRef.current = server;
      prevFingerprintsRef.current = {
        tools: toolsFingerprint,
        resources: resourcesFingerprint,
        prompts: promptsFingerprint
      };
      onUpdateRef.current(server);
    } else {
      providerLogger.debug(
        `[McpServerWrapper ${id}] No meaningful changes detected, skipping onUpdate`
      );
    }
  }, [
    id,
    name,
    options.url,
    // Primitive values that indicate meaningful state changes
    mcp.state,
    mcp.error,
    mcp.authUrl,
    // Use fingerprints to detect content changes (including renames)
    toolsFingerprint,
    resourcesFingerprint,
    promptsFingerprint,
    // serverInfo and capabilities - include for reference comparison
    mcp.serverInfo,
    mcp.capabilities,
    // Functions excluded - they're stable via useCallback in useMcp
    // mcp.log excluded - log changes shouldn't trigger provider updates
    // mcp.client excluded - client reference stability handled by manual check
    notifications.length,
    unreadNotificationCount,
    publicSamplingRequests.length,
    publicElicitationRequests.length,
    // Callback functions are stable via useCallback
    markNotificationRead,
    markAllNotificationsRead,
    clearNotifications,
    approveSampling,
    rejectSampling,
    approveElicitation,
    rejectElicitation
  ]);
  return null;
}
__name(McpServerWrapper, "McpServerWrapper");
function McpClientProvider({
  children,
  mcpServers,
  defaultProxyConfig,
  defaultAutoProxyFallback = true,
  clientInfo,
  storageProvider,
  enableRpcLogging = false,
  onServerAdded,
  onServerRemoved,
  onServerStateChange,
  onSamplingRequest,
  onElicitationRequest
}) {
  const [serverConfigs, setServerConfigs] = (0, import_react9.useState)([]);
  const [servers, setServers] = (0, import_react9.useState)([]);
  const [storageLoaded, setStorageLoaded] = (0, import_react9.useState)(false);
  const cachedMetadataRef = (0, import_react9.useRef)({});
  const [rpcWrapTransport, setRpcWrapTransport] = (0, import_react9.useState)(void 0);
  const [rpcLoggingReady, setRpcLoggingReady] = (0, import_react9.useState)(false);
  (0, import_react9.useEffect)(() => {
    if (!enableRpcLogging || typeof window === "undefined") {
      setRpcWrapTransport(void 0);
      setRpcLoggingReady(true);
      return;
    }
    import("./rpc-logger-TPNV75J4-6JXXRSP3.js").then((module) => {
      providerLogger.debug("[McpClientProvider] RPC logger loaded");
      setRpcWrapTransport(() => module.wrapTransportForLogging);
      setRpcLoggingReady(true);
    }).catch((err) => {
      providerLogger.error(
        "[McpClientProvider] Failed to load RPC logger:",
        err
      );
      setRpcWrapTransport(void 0);
      setRpcLoggingReady(true);
    });
  }, [enableRpcLogging]);
  (0, import_react9.useEffect)(() => {
    if (!rpcLoggingReady) {
      providerLogger.debug(
        "[McpClientProvider] Waiting for RPC logging to be ready before loading servers"
      );
      return;
    }
    const loadServers = __name(async () => {
      providerLogger.debug(
        "[McpClientProvider] Loading servers, storageProvider:",
        !!storageProvider,
        "mcpServers:",
        mcpServers
      );
      if (!storageProvider) {
        if (mcpServers) {
          const configs = Object.entries(mcpServers).map(([id, options]) => ({
            id,
            options
          }));
          providerLogger.debug(
            "[McpClientProvider] Loaded from mcpServers prop:",
            configs.length
          );
          setServerConfigs(configs);
        }
        setStorageLoaded(true);
        return;
      }
      try {
        const storedServers = await Promise.resolve(
          storageProvider.getServers()
        );
        providerLogger.debug(
          "[McpClientProvider] Loaded from storage:",
          Object.keys(storedServers).length
        );
        if (storageProvider.getServerMetadata) {
          try {
            const serverIds = Object.keys(storedServers);
            const metadataPromises = serverIds.map(async (id) => {
              const metadata = await Promise.resolve(
                storageProvider.getServerMetadata(id)
              );
              return [id, metadata];
            });
            const metadataEntries = await Promise.all(metadataPromises);
            cachedMetadataRef.current = Object.fromEntries(
              metadataEntries.filter(
                (entry) => entry[1] !== void 0
              )
            );
            providerLogger.debug(
              "[McpClientProvider] Loaded cached metadata for",
              Object.keys(cachedMetadataRef.current).length,
              "servers"
            );
          } catch (metadataError) {
            providerLogger.warn(
              "[McpClientProvider] Failed to load cached metadata:",
              metadataError
            );
          }
        }
        const mergedServers = { ...storedServers, ...mcpServers };
        const configs = Object.entries(mergedServers).map(([id, options]) => ({
          id,
          options
        }));
        providerLogger.debug(
          "[McpClientProvider] Total servers after merge:",
          configs.length
        );
        setServerConfigs(configs);
        setStorageLoaded(true);
      } catch (error) {
        providerLogger.error(
          "[McpClientProvider] Failed to load from storage:",
          error
        );
        if (mcpServers) {
          const configs = Object.entries(mcpServers).map(([id, options]) => ({
            id,
            options
          }));
          setServerConfigs(configs);
        }
        setStorageLoaded(true);
      }
    }, "loadServers");
    loadServers();
  }, [storageProvider, mcpServers, rpcLoggingReady]);
  (0, import_react9.useEffect)(() => {
    if (!storageProvider || !storageLoaded) return;
    const saveServers = __name(async () => {
      try {
        const serversToSave = serverConfigs.reduce(
          (acc, config) => {
            acc[config.id] = config.options;
            return acc;
          },
          {}
        );
        await Promise.resolve(storageProvider.setServers(serversToSave));
      } catch (error) {
        providerLogger.error(
          "[McpClientProvider] Failed to save to storage:",
          error
        );
      }
    }, "saveServers");
    saveServers();
  }, [serverConfigs, storageProvider, storageLoaded]);
  const handleServerUpdate = (0, import_react9.useCallback)(
    (updatedServer) => {
      providerLogger.debug(
        `[McpClientProvider] handleServerUpdate called for server ${updatedServer.id}`,
        {
          toolCount: updatedServer.tools.length,
          state: updatedServer.state
        }
      );
      const callbacksToRun = [];
      setServers((prev) => {
        const index = prev.findIndex((s) => s.id === updatedServer.id);
        const isNewServer = index === -1;
        if (isNewServer) {
          providerLogger.debug(
            `[McpClientProvider] Adding new server ${updatedServer.id} to state`
          );
          callbacksToRun.push(
            () => onServerAdded?.(updatedServer.id, updatedServer)
          );
          return [...prev, updatedServer];
        }
        const current = prev[index];
        const stateChanged = current.state !== updatedServer.state;
        const serverInfoChanged = current.serverInfo !== updatedServer.serverInfo;
        providerLogger.debug(
          `[McpClientProvider] Comparing server ${updatedServer.id}:`,
          {
            toolsChanged: current.tools !== updatedServer.tools,
            currentToolCount: current.tools.length,
            updatedToolCount: updatedServer.tools.length,
            stateChanged
          }
        );
        if (current.state === updatedServer.state && current.tools === updatedServer.tools && current.resources === updatedServer.resources && current.prompts === updatedServer.prompts && current.error === updatedServer.error && current.serverInfo === updatedServer.serverInfo && current.client === updatedServer.client && current.notifications === updatedServer.notifications && current.unreadNotificationCount === updatedServer.unreadNotificationCount && current.pendingSamplingRequests.length === updatedServer.pendingSamplingRequests.length && current.pendingElicitationRequests.length === updatedServer.pendingElicitationRequests.length) {
          providerLogger.debug(
            `[McpClientProvider] No changes detected for server ${updatedServer.id}, skipping update`
          );
          return prev;
        }
        providerLogger.debug(
          `[McpClientProvider] Updating server ${updatedServer.id} in state`
        );
        if (stateChanged) {
          callbacksToRun.push(
            () => onServerStateChange?.(updatedServer.id, updatedServer.state)
          );
        }
        if (serverInfoChanged && updatedServer.serverInfo && storageProvider?.setServerMetadata) {
          const metadata = {
            name: updatedServer.serverInfo.name,
            version: updatedServer.serverInfo.version,
            title: updatedServer.serverInfo.title,
            websiteUrl: updatedServer.serverInfo.websiteUrl,
            icons: updatedServer.serverInfo.icons,
            icon: updatedServer.serverInfo.icon
          };
          cachedMetadataRef.current[updatedServer.id] = metadata;
          Promise.resolve(
            storageProvider.setServerMetadata(updatedServer.id, metadata)
          ).catch((err) => {
            providerLogger.error(
              "[McpClientProvider] Failed to save server metadata:",
              err
            );
          });
        }
        const newServers = [...prev];
        newServers[index] = updatedServer;
        return newServers;
      });
      if (callbacksToRun.length > 0) {
        queueMicrotask(() => {
          callbacksToRun.forEach((callback) => callback());
        });
      }
    },
    [onServerAdded, onServerStateChange, storageProvider]
  );
  const addServer = (0, import_react9.useCallback)((id, options) => {
    providerLogger.debug("[McpClientProvider] addServer called:", id, options);
    setServerConfigs((prev) => {
      if (prev.find((s) => s.id === id)) {
        providerLogger.warn(
          `[McpClientProvider] Server with id "${id}" already exists`
        );
        return prev;
      }
      providerLogger.debug(
        "[McpClientProvider] Adding new server to configs:",
        id
      );
      return [...prev, { id, options }];
    });
  }, []);
  const removeServer = (0, import_react9.useCallback)(
    (id) => {
      setServers((prev) => {
        const server = prev.find((s) => s.id === id);
        if (server?.disconnect) {
          server.disconnect();
        }
        if (server?.clearStorage) {
          server.clearStorage();
        }
        return prev.filter((s) => s.id !== id);
      });
      setServerConfigs((prev) => prev.filter((s) => s.id !== id));
      onServerRemoved?.(id);
    },
    [onServerRemoved]
  );
  const updateServer = (0, import_react9.useCallback)(
    async (id, options) => {
      return new Promise((resolve) => {
        const currentConfig = serverConfigs.find((s) => s.id === id);
        if (!currentConfig) {
          providerLogger.warn(
            `[McpClientProvider] Cannot update server "${id}" - not found`
          );
          resolve();
          return;
        }
        const updatedOptions = {
          ...currentConfig.options,
          ...options,
          // Add a version counter to force React to remount the wrapper
          _updateVersion: (currentConfig.options._updateVersion || 0) + 1
        };
        setServers((prev) => {
          const server = prev.find((s) => s.id === id);
          if (server?.disconnect) {
            server.disconnect();
          }
          if (server?.clearStorage) {
            server.clearStorage();
          }
          return prev.filter((s) => s.id !== id);
        });
        setServerConfigs((prev) => {
          const updated = prev.map(
            (s) => s.id === id ? { id, options: updatedOptions } : s
          );
          setTimeout(() => resolve(), 0);
          return updated;
        });
      });
    },
    [serverConfigs]
  );
  const getServer = (0, import_react9.useCallback)(
    (id) => {
      return servers.find((s) => s.id === id);
    },
    [servers]
  );
  const contextValue = (0, import_react9.useMemo)(
    () => ({
      servers,
      addServer,
      removeServer,
      updateServer,
      getServer,
      storageLoaded
    }),
    [servers, addServer, removeServer, updateServer, getServer, storageLoaded]
  );
  return import_react9.default.createElement(McpClientContext.Provider, { value: contextValue }, children, serverConfigs.map((config) => import_react9.default.createElement(
    McpServerWrapper,
    {
      key: `${config.id}-v${config.options._updateVersion || 0}`,
      id: config.id,
      options: config.options,
      defaultProxyConfig,
      defaultAutoProxyFallback,
      clientInfo,
      cachedMetadata: cachedMetadataRef.current[config.id],
      onUpdate: handleServerUpdate,
      rpcWrapTransport,
      onGlobalSamplingRequest: onSamplingRequest,
      onGlobalElicitationRequest: onElicitationRequest
    }
  )));
}
__name(McpClientProvider, "McpClientProvider");
function useMcpClient() {
  const context = (0, import_react9.useContext)(McpClientContext);
  if (!context) {
    throw new Error("useMcpClient must be used within a McpClientProvider");
  }
  return context;
}
__name(useMcpClient, "useMcpClient");
function useMcpServer(id) {
  const { getServer } = useMcpClient();
  return getServer(id);
}
__name(useMcpServer, "useMcpServer");
var _a5;
var LocalStorageProvider = (_a5 = class {
  constructor(storageKey = "mcp-client-servers") {
    this.storageKey = storageKey;
    this.metadataKey = `${storageKey}-metadata`;
  }
  metadataKey;
  getServers() {
    try {
      const stored = localStorage.getItem(this.storageKey);
      return stored ? JSON.parse(stored) : {};
    } catch (error) {
      console.error("[LocalStorageProvider] Failed to load servers:", error);
      return {};
    }
  }
  setServers(servers) {
    try {
      localStorage.setItem(this.storageKey, JSON.stringify(servers));
    } catch (error) {
      console.error("[LocalStorageProvider] Failed to save servers:", error);
    }
  }
  setServer(id, config) {
    const servers = this.getServers();
    servers[id] = config;
    this.setServers(servers);
  }
  removeServer(id) {
    const servers = this.getServers();
    delete servers[id];
    this.setServers(servers);
    this.removeServerMetadata(id);
  }
  clear() {
    try {
      localStorage.removeItem(this.storageKey);
      localStorage.removeItem(this.metadataKey);
    } catch (error) {
      console.error("[LocalStorageProvider] Failed to clear:", error);
    }
  }
  getAllMetadata() {
    try {
      const stored = localStorage.getItem(this.metadataKey);
      return stored ? JSON.parse(stored) : {};
    } catch (error) {
      console.error("[LocalStorageProvider] Failed to load metadata:", error);
      return {};
    }
  }
  setAllMetadata(metadata) {
    try {
      localStorage.setItem(this.metadataKey, JSON.stringify(metadata));
    } catch (error) {
      console.error("[LocalStorageProvider] Failed to save metadata:", error);
    }
  }
  getServerMetadata(id) {
    const allMetadata = this.getAllMetadata();
    return allMetadata[id];
  }
  setServerMetadata(id, metadata) {
    const allMetadata = this.getAllMetadata();
    allMetadata[id] = {
      ...metadata,
      cachedAt: Date.now()
    };
    this.setAllMetadata(allMetadata);
  }
  removeServerMetadata(id) {
    const allMetadata = this.getAllMetadata();
    delete allMetadata[id];
    this.setAllMetadata(allMetadata);
  }
}, __name(_a5, "LocalStorageProvider"), _a5);
var _a6;
var MemoryStorageProvider = (_a6 = class {
  storage = {};
  metadata = {};
  getServers() {
    return { ...this.storage };
  }
  setServers(servers) {
    this.storage = { ...servers };
  }
  setServer(id, config) {
    this.storage[id] = config;
  }
  removeServer(id) {
    delete this.storage[id];
    this.removeServerMetadata(id);
  }
  clear() {
    this.storage = {};
    this.metadata = {};
  }
  getServerMetadata(id) {
    return this.metadata[id];
  }
  setServerMetadata(id, metadata) {
    this.metadata[id] = {
      ...metadata,
      cachedAt: Date.now()
    };
  }
  removeServerMetadata(id) {
    delete this.metadata[id];
  }
}, __name(_a6, "MemoryStorageProvider"), _a6);
export {
  Tel as BrowserTelemetry,
  ErrorBoundary,
  Image,
  LocalStorageProvider,
  McpClientProvider,
  McpUseProvider,
  MemoryStorageProvider,
  Tel,
  Telemetry,
  ThemeProvider,
  WidgetControls,
  clearRpcLogs,
  generateHelpers,
  getAllRpcLogs,
  getRpcLogs,
  onMcpAuthorization,
  setTelemetrySource as setBrowserTelemetrySource,
  setTelemetrySource,
  subscribeToRpcLogs,
  useCallTool,
  useMcp,
  useMcpClient,
  useMcpServer,
  useWidget,
  useWidgetProps,
  useWidgetState,
  useWidgetTheme
};
//# sourceMappingURL=mcp-use_react.js.map
