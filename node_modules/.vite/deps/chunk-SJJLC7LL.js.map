{
  "version": 3,
  "sources": ["../../lodash.debounce/index.js", "../../clsx/dist/clsx.mjs", "../../@openai/apps-sdk-ui/src/components/Transition/TransitionGroup.tsx", "../../react-merge-refs/src/index.tsx", "../../@openai/apps-sdk-ui/src/lib/helpers.ts", "../../@openai/apps-sdk-ui/src/lib/environment.ts", "../../usehooks-ts/dist/index.js", "../../@openai/apps-sdk-ui/src/components/Transition/getDisableAnimations.ts", "../../@openai/apps-sdk-ui/src/components/Transition/shared.ts", "../../@openai/apps-sdk-ui/src/components/Transition/transitionReducer.ts", "../../@openai/apps-sdk-ui/src/components/Transition/Animate.tsx", "../../@openai/apps-sdk-ui/src/components/Transition/AnimateLayout.tsx", "../../@openai/apps-sdk-ui/src/components/Transition/AnimateLayoutGroup.tsx", "../../@openai/apps-sdk-ui/src/components/Transition/SlotTransitionGroup.tsx"],
  "sourcesContent": ["/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n", "function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}export function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;", "\"use client\"\n\nimport React, {\n  Children,\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useReducer,\n  useRef,\n  useState,\n  type CSSProperties,\n} from \"react\"\nimport { mergeRefs } from \"react-merge-refs\"\n\nimport { waitForAnimationFrame } from \"../../lib/helpers\"\n\nimport clsx from \"clsx\"\nimport { useTimeout } from \"usehooks-ts\"\nimport getDisableAnimations from \"./getDisableAnimations\"\nimport {\n  assertSingleChildWhenRef,\n  ChildrenWithKeys,\n  computeNextRenderChildren,\n  noop,\n  useChildCallback,\n  type CallbackType,\n  type ReactElementWithKey,\n  type TransitionGroupChildCallbacks,\n} from \"./shared\"\nimport s from \"./TransitionGroup.module.css\"\nimport { getInitialTransitionState, transitionReducer } from \"./transitionReducer\"\n\ntype TransitionGroupChildProps = {\n  as: \"div\" | \"span\"\n  children: React.ReactNode\n  className?: string\n  transitionId?: string\n  style?: CSSProperties\n  preventMountTransition?: boolean\n  shouldRender: boolean\n  enterDuration: number\n  exitDuration: number\n  enterMountDelay?: number\n  removeChild: () => void\n  ref?: React.Ref<unknown>\n} & TransitionGroupChildCallbacks\n\nconst TransitionGroupChildInner = ({\n  ref: forwardedRef,\n  as: TagName,\n  children,\n  className,\n  transitionId,\n  style,\n  preventMountTransition,\n  shouldRender,\n  enterDuration,\n  exitDuration,\n  removeChild,\n  onEnter,\n  onEnterActive,\n  onEnterComplete,\n  onExit,\n  onExitActive,\n  onExitComplete,\n}: TransitionGroupChildProps) => {\n  const [state, dispatch] = useReducer(\n    transitionReducer,\n    getInitialTransitionState(preventMountTransition || false),\n  )\n  // Allow a child to prevent mount transition, but still experience\n  // future enter transition events, when applicable.\n  const preventedMountTransition = useRef<boolean>(false)\n  const elementRef = useRef<HTMLDivElement | null>(null)\n  // Duration values should not affect hook re-renders, so we create refs for them\n  const enterDurationRef = useRef<number>(enterDuration)\n  enterDurationRef.current = enterDuration\n  const exitDurationRef = useRef<number>(exitDuration)\n  exitDurationRef.current = exitDuration\n\n  const lastCallbackRef = useRef<CallbackType>(null)\n  const triggerCallback = useCallback(\n    (callbackType: CallbackType) => {\n      const element = elementRef.current\n\n      if (!element || callbackType === lastCallbackRef.current) {\n        return\n      }\n\n      lastCallbackRef.current = callbackType\n\n      switch (callbackType) {\n        case \"enter\":\n          onEnter(element)\n          break\n        case \"enter-active\":\n          onEnterActive(element)\n          break\n        case \"enter-complete\":\n          onEnterComplete(element)\n          break\n        case \"exit\":\n          onExit(element)\n          break\n        case \"exit-active\":\n          onExitActive(element)\n          break\n        case \"exit-complete\":\n          onExitComplete(element)\n          break\n        default:\n          callbackType satisfies never\n          break\n      }\n    },\n    [onEnter, onEnterActive, onEnterComplete, onExit, onExitActive, onExitComplete],\n  )\n\n  React.useLayoutEffect(() => {\n    // Exit transition\n    if (!shouldRender) {\n      let exitTimeout: number | undefined\n\n      dispatch({ type: \"exit-before\" })\n      triggerCallback(\"exit\")\n\n      const cancelAnimationFrame = waitForAnimationFrame(() => {\n        dispatch({ type: \"exit-active\" })\n        triggerCallback(\"exit-active\")\n\n        exitTimeout = window.setTimeout(() => {\n          triggerCallback(\"exit-complete\")\n          removeChild()\n        }, exitDurationRef.current)\n      })\n\n      return () => {\n        cancelAnimationFrame()\n        if (exitTimeout !== undefined) clearTimeout(exitTimeout)\n      }\n    }\n\n    // Enter transition\n\n    // Check if we need to prevent this specific entering cycle\n    if (preventMountTransition && !preventedMountTransition.current) {\n      // Mark initial transition as prevented and short-circuit.\n      preventedMountTransition.current = true\n      return\n    }\n\n    let enterTimeout: number | undefined\n\n    dispatch({ type: \"enter-before\" })\n    triggerCallback(\"enter\")\n\n    const cancelAnimationFrame = waitForAnimationFrame(() => {\n      dispatch({ type: \"enter-active\" })\n      triggerCallback(\"enter-active\")\n\n      enterTimeout = window.setTimeout(() => {\n        dispatch({ type: \"done\" })\n        triggerCallback(\"enter-complete\")\n      }, enterDurationRef.current)\n    })\n\n    return () => {\n      cancelAnimationFrame()\n      if (enterTimeout !== undefined) clearTimeout(enterTimeout)\n    }\n  }, [\n    shouldRender,\n    // This value is immutable after <TransitionGroup> is created, and does not change on re-renders.\n    preventMountTransition,\n    removeChild,\n    triggerCallback,\n  ])\n\n  useEffect(() => {\n    // Required for <StrictMode>, because we need to unset this token\n    // when the hooks are re-run. It's an imperative effect that we need to manage.\n    return () => {\n      preventedMountTransition.current = false\n    }\n  }, [])\n\n  return (\n    <TagName\n      ref={mergeRefs([elementRef, forwardedRef])}\n      className={clsx(className, s.TransitionGroupChild)}\n      data-transition-id={transitionId}\n      style={style}\n      data-entering={state.enter ? \"\" : undefined}\n      data-entering-active={state.enterActive ? \"\" : undefined}\n      data-exiting={state.exit ? \"\" : undefined}\n      data-exiting-active={state.exitActive ? \"\" : undefined}\n      data-interrupted={state.interrupted ? \"\" : undefined}\n    >\n      {children}\n    </TagName>\n  )\n}\n\nconst TransitionGroupChild = (props: TransitionGroupChildProps) => {\n  // Don't spread these out of props - pass all props to inner child\n  const { enterMountDelay, preventMountTransition } = props\n  // Mount gating occurs when enterMountDelay exists, and isn't initial mount\n  // Otherwise, this flag is a no-op and the TransitionChild mounts normally.\n  const mountDelay = !preventMountTransition && enterMountDelay != null ? enterMountDelay : null\n  const [mounted, setMounted] = useState(mountDelay == null)\n  useTimeout(() => setMounted(true), mounted ? null : mountDelay)\n\n  return mounted ? <TransitionGroupChildInner {...props} /> : null\n}\n\nexport type TransitionGroupProps = {\n  /** Components controlled by TransitionGroup rendering */\n  children: React.ReactNode\n  /** Determines the tag used by wrapping elements */\n  as?: \"div\" | \"span\"\n  /** Class passed to wrapping elements */\n  className?: string\n  /** Identifier passed to wrapping elements as `[data-transition-id]` */\n  transitionId?: string\n  /** Determines the amount of time that the enter state is applied during mounting */\n  enterDuration?: number\n  /** Determines the amount of time that the exit state is applied before unmounting */\n  exitDuration?: number\n  /**\n   * Determines if children should have an enter transition applied during mounting of the TransitionGroup.\n   * @default true\n   */\n  preventInitialTransition?: boolean\n  /** Delay in MS to wait before mounting a child. `null` for no delay (default). */\n  enterMountDelay?: number\n  /** Render children changes immediately, bypassing transition timings */\n  disableAnimations?: boolean\n  /** Determines how new children are added to the children array */\n  insertMethod?: \"append\" | \"prepend\"\n  /** Styles applied to wrapping elements */\n  style?: CSSProperties\n  /** Ref for the TransitionGroup */\n  ref?: React.Ref<unknown>\n} & Partial<TransitionGroupChildCallbacks>\n\ntype RenderChild = {\n  component: ReactElementWithKey\n  shouldRender: boolean\n  preventMountTransition?: boolean\n  removeChild: () => void\n} & TransitionGroupChildCallbacks\n\nexport const TransitionGroup = (props: TransitionGroupProps) => {\n  const {\n    ref: forwardedRef,\n    as: TagName = \"span\",\n    children,\n    className,\n    transitionId,\n    style,\n    enterDuration = 0,\n    exitDuration = 0,\n    preventInitialTransition = true,\n    enterMountDelay,\n    insertMethod = \"append\",\n    disableAnimations = getDisableAnimations(),\n  } = props\n  // Create stable, mutable references for all callbacks\n  const onEnter = useChildCallback(props.onEnter ?? noop)\n  const onEnterActive = useChildCallback(props.onEnterActive ?? noop)\n  const onEnterComplete = useChildCallback(props.onEnterComplete ?? noop)\n  const onExit = useChildCallback(props.onExit ?? noop)\n  const onExitActive = useChildCallback(props.onExitActive ?? noop)\n  const onExitComplete = useChildCallback(props.onExitComplete ?? noop)\n\n  // Ensure all children are provided with keys.\n  // Cannot reliably use Children.toArray() because `key` is processed: https://reactjs.org/docs/react-api.html#reactchildrentoarray\n  Children.forEach(children, (child) => {\n    // @ts-expect-error - We know `key` might not exist on certain types, that's why we're checking\n    if (child && !child.key) {\n      throw new Error(\"Child elements of <TransitionGroup /> must include a `key`\")\n    }\n  })\n\n  const createDefaultRenderChildProps = useCallback(\n    (child: ReactElementWithKey): RenderChild => ({\n      component: child,\n      shouldRender: true,\n      removeChild: () => {\n        setRenderChildren((currentRenderChildren) =>\n          currentRenderChildren.filter((c) => child.key !== c.component.key),\n        )\n      },\n      onEnter,\n      onEnterActive,\n      onEnterComplete,\n      onExit,\n      onExitActive,\n      onExitComplete,\n    }),\n    [onEnter, onEnterActive, onEnterComplete, onExit, onExitActive, onExitComplete],\n  )\n\n  const [renderChildren, setRenderChildren] = useState<RenderChild[]>((): RenderChild[] => {\n    return ChildrenWithKeys(children).map((child) => ({\n      ...createDefaultRenderChildProps(child),\n      // Lock this value to whatever the value was on initial render of the TransitionGroup.\n      // It doesn't make sense to change this once it is mounted.\n      preventMountTransition: preventInitialTransition,\n    }))\n  })\n\n  useLayoutEffect(() => {\n    setRenderChildren((currentRenderChildren): RenderChild[] => {\n      const propChildrenArray = ChildrenWithKeys(children)\n      return computeNextRenderChildren(\n        propChildrenArray,\n        currentRenderChildren,\n        createDefaultRenderChildProps,\n        insertMethod,\n      )\n    })\n  }, [children, insertMethod, createDefaultRenderChildProps])\n\n  // Prevent mistakes with forwardRef() by ensuring single child usage within the group.\n  assertSingleChildWhenRef(\"TransitionGroup\", forwardedRef, Children.count(children))\n\n  if (disableAnimations) {\n    return (\n      <>\n        {Children.map(children, (child) => (\n          <TagName\n            // @ts-expect-error -- TS is not happy about this forwardedRef, but it's fine.\n            ref={forwardedRef}\n            className={className}\n            style={style}\n            data-transition-id={transitionId}\n          >\n            {child}\n          </TagName>\n        ))}\n      </>\n    )\n  }\n\n  return (\n    <>\n      {renderChildren.map(({ component, ...restProps }) => (\n        <TransitionGroupChild\n          key={component.key}\n          {...restProps}\n          as={TagName}\n          className={className}\n          transitionId={transitionId}\n          enterDuration={enterDuration}\n          exitDuration={exitDuration}\n          enterMountDelay={enterMountDelay}\n          style={style}\n          ref={forwardedRef}\n        >\n          {component}\n        </TransitionGroupChild>\n      ))}\n    </>\n  )\n}\n", "import type * as React from \"react\";\n\nexport function mergeRefs<T = any>(\n  refs: Array<React.MutableRefObject<T> | React.LegacyRef<T> | undefined | null>\n): React.RefCallback<T> {\n  return (value) => {\n    refs.forEach((ref) => {\n      if (typeof ref === \"function\") {\n        ref(value);\n      } else if (ref != null) {\n        (ref as React.MutableRefObject<T | null>).current = value;\n      }\n    });\n  };\n}\n", "import { type CSSProperties } from \"react\"\nimport { canUseDOM, hasDocument, hasWindow } from \"./environment\"\nimport type { Pretty } from \"./utilityTypes\"\n\nexport const prefersReducedMotion = () => {\n  if (!hasWindow || typeof window.matchMedia !== \"function\") {\n    return false\n  }\n\n  return window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches\n}\n\nexport const handlePressableMouseEnter = (evt: React.MouseEvent) => {\n  const target = evt.currentTarget\n\n  // Safely coerce type to HTMLElement so TS is peaceful with `evt.target`\n  if (!(target instanceof HTMLElement)) {\n    return\n  }\n\n  const elementWidth = target.offsetWidth\n\n  let scale = 0.985\n\n  if (elementWidth <= 80) {\n    scale = 0.96\n  } else if (elementWidth <= 150) {\n    scale = 0.97\n  } else if (elementWidth <= 220) {\n    scale = 0.98\n  } else if (elementWidth > 600) {\n    scale = 0.995\n  }\n\n  target.style.setProperty(\"--scale\", scale.toString())\n}\n\ninterface CancelAnimationFrame {\n  (): void\n}\n\nexport const waitForAnimationFrame = (\n  cb: () => void,\n  options?: { frames: number },\n): CancelAnimationFrame => {\n  const runAfterTick = () => {\n    const id = setTimeout(cb)\n    return () => {\n      clearTimeout(id)\n    }\n  }\n\n  if (!canUseDOM || typeof window.requestAnimationFrame !== \"function\") {\n    return runAfterTick()\n  }\n\n  const visibilityHidden = hasDocument && document.visibilityState === \"hidden\"\n  if (visibilityHidden) {\n    return runAfterTick()\n  }\n\n  let frames = options?.frames ?? 2\n  let animationFrame = window.requestAnimationFrame(function recurse() {\n    frames -= 1\n    if (frames === 0) {\n      cb()\n    } else {\n      animationFrame = window.requestAnimationFrame(recurse)\n    }\n  })\n\n  return () => {\n    if (typeof window.cancelAnimationFrame === \"function\") {\n      window.cancelAnimationFrame(animationFrame)\n    }\n  }\n}\n\nexport const toCssVariables = (\n  variables: Record<string, string | number | undefined>,\n): CSSProperties => {\n  const formattedVariables = Object.keys(variables).reduce(\n    (acc, variable) => {\n      // Ensure value is truthy\n      const value = variables[variable]\n      // Accept 0 as a valid value\n      if (value || value === 0) {\n        // Add the prefix if it wasn't already provided\n        const prefix = variable.startsWith(\"--\") ? \"\" : \"--\"\n        const formattedValue = typeof value === \"number\" ? `${value}px` : value\n\n        acc[`${prefix}${variable}`] = formattedValue\n      }\n\n      return acc\n    },\n    {} as Record<string, string>,\n  )\n\n  // Safe casting because we know we've formatted an object of CSS Variable strings\n  return formattedVariables as CSSProperties\n}\n\nexport const toAngle = (value: number | string): string =>\n  typeof value === \"number\" ? `${value}deg` : value\n\nexport const toOpacityProperty = (opacity: number): string => String(opacity)\n\nexport const toMsDurationProperty = (duration: number): string => `${duration}ms`\n\nexport const toTransformProperty = ({\n  x,\n  y,\n  scale,\n  rotate,\n  skewX,\n  skewY,\n}: {\n  x?: number\n  y?: number\n  scale?: number\n  rotate?: number | string\n  skewX?: number | string\n  skewY?: number | string\n} = {}): string => {\n  const transforms = [\n    x == null ? null : `translateX(${x}px)`,\n    y == null ? null : `translateY(${y}px)`,\n    scale == null ? null : `scale(${scale})`,\n    rotate == null ? null : `rotate(${toAngle(rotate)})`,\n    skewX == null ? null : `skewX(${toAngle(skewX)})`,\n    skewY == null ? null : `skewY(${toAngle(skewY)})`,\n  ].filter(Boolean)\n\n  return transforms.length ? transforms.join(\" \") : \"none\"\n}\n\nexport const toFilterProperty = ({ blur }: { blur?: number | undefined } = {}) => {\n  // Maybe add more support in the future\n  const filters = [blur == null ? null : `blur(${blur}px)`].filter(Boolean)\n\n  return filters.length ? filters.join(\" \") : \"none\"\n}\n\nexport const preventDefaultHandler = (evt: Event) => {\n  evt.preventDefault()\n}\n\n/*\n * Intentionally simple selector string. Purposeful exclusions: (for now)\n * - select, because our selects are better recognized as button\n * - unused selectors like iframe, object, .etc.\n * - states like [inert]\n */\nexport const focusableElements = (element: HTMLElement) =>\n  element.querySelectorAll<HTMLElement>(\n    'a[href], input:not([disabled]):not([type=\"hidden\"]), textarea:not([disabled]), button:not([disabled]), [tabindex]:not([tabindex^=\"-\"]), [contenteditable]',\n  )\n\nexport const sleep = (ms: number): Promise<void> =>\n  new Promise((resolve) => setTimeout(resolve, ms))\n\n/**\n * Group an array of objects by a property, preserving the *first-seen* order\n * of each group.\n *\n * @example\n * groupByOrdered(people, \"team\")\n * // => [ { team: \"infra\", items:[...] }, { team:\"design\", items:[...] }, ... ]\n */\nexport function groupByProperty<T extends object, K extends keyof T, F = T[K]>(\n  items: T[],\n  key: K,\n  format: (raw: T[K], item: T) => F = (raw) => raw as F,\n) {\n  const groups: Pretty<{ [P in K]: F } & { items: T[] }>[] = []\n  const indexMap = new Map<unknown, number>() // maps group value -> index in groups array\n\n  for (const item of items) {\n    const value = format(item[key], item)\n\n    // Add to existing group\n    const existing = indexMap.get(value)\n    if (existing !== undefined) {\n      groups[existing].items.push(item)\n      continue\n    }\n\n    // Create new group\n    const group = { [key]: value, items: [item] } as { [P in K]: F } & { items: T[] }\n    indexMap.set(value, groups.length)\n    groups.push(group)\n  }\n\n  return groups\n}\n", "const META_ENV = typeof import.meta !== \"undefined\" ? import.meta.env : undefined\n\nconst NODE_ENV =\n  typeof process !== \"undefined\" && process.env?.NODE_ENV ? process.env?.NODE_ENV : \"production\"\n\nexport const isDev = NODE_ENV === \"development\" || !!META_ENV?.DEV\n\nexport const isJSDomLike =\n  (typeof navigator !== \"undefined\" && /(jsdom|happy-dom)/i.test(navigator.userAgent)) ||\n  typeof (globalThis as Record<string, unknown>).happyDOM === \"object\"\n\nexport const isTest = NODE_ENV === \"test\" || META_ENV?.MODE === \"test\" || isJSDomLike\n\nexport const hasWindow = typeof window !== \"undefined\"\nexport const hasDocument = typeof document !== \"undefined\"\nexport const canUseDOM = hasWindow && hasDocument\n", "import { useState, useCallback, useLayoutEffect, useEffect, useRef, useMemo } from 'react';\nimport debounce from 'lodash.debounce';\n\n// src/useBoolean/useBoolean.ts\nfunction useBoolean(defaultValue = false) {\n  if (typeof defaultValue !== \"boolean\") {\n    throw new Error(\"defaultValue must be `true` or `false`\");\n  }\n  const [value, setValue] = useState(defaultValue);\n  const setTrue = useCallback(() => {\n    setValue(true);\n  }, []);\n  const setFalse = useCallback(() => {\n    setValue(false);\n  }, []);\n  const toggle = useCallback(() => {\n    setValue((x) => !x);\n  }, []);\n  return { value, setValue, setTrue, setFalse, toggle };\n}\nvar useIsomorphicLayoutEffect = typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n\n// src/useEventListener/useEventListener.ts\nfunction useEventListener(eventName, handler, element, options) {\n  const savedHandler = useRef(handler);\n  useIsomorphicLayoutEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n  useEffect(() => {\n    const targetElement = (element == null ? void 0 : element.current) ?? window;\n    if (!(targetElement && targetElement.addEventListener))\n      return;\n    const listener = (event) => {\n      savedHandler.current(event);\n    };\n    targetElement.addEventListener(eventName, listener, options);\n    return () => {\n      targetElement.removeEventListener(eventName, listener, options);\n    };\n  }, [eventName, element, options]);\n}\n\n// src/useClickAnyWhere/useClickAnyWhere.ts\nfunction useClickAnyWhere(handler) {\n  useEventListener(\"click\", (event) => {\n    handler(event);\n  });\n}\nfunction useCopyToClipboard() {\n  const [copiedText, setCopiedText] = useState(null);\n  const copy = useCallback(async (text) => {\n    if (!(navigator == null ? void 0 : navigator.clipboard)) {\n      console.warn(\"Clipboard not supported\");\n      return false;\n    }\n    try {\n      await navigator.clipboard.writeText(text);\n      setCopiedText(text);\n      return true;\n    } catch (error) {\n      console.warn(\"Copy failed\", error);\n      setCopiedText(null);\n      return false;\n    }\n  }, []);\n  return [copiedText, copy];\n}\nfunction useCounter(initialValue) {\n  const [count, setCount] = useState(initialValue ?? 0);\n  const increment = useCallback(() => {\n    setCount((x) => x + 1);\n  }, []);\n  const decrement = useCallback(() => {\n    setCount((x) => x - 1);\n  }, []);\n  const reset = useCallback(() => {\n    setCount(initialValue ?? 0);\n  }, [initialValue]);\n  return {\n    count,\n    increment,\n    decrement,\n    reset,\n    setCount\n  };\n}\nfunction useInterval(callback, delay) {\n  const savedCallback = useRef(callback);\n  useIsomorphicLayoutEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n  useEffect(() => {\n    if (delay === null) {\n      return;\n    }\n    const id = setInterval(() => {\n      savedCallback.current();\n    }, delay);\n    return () => {\n      clearInterval(id);\n    };\n  }, [delay]);\n}\n\n// src/useCountdown/useCountdown.ts\nfunction useCountdown({\n  countStart,\n  countStop = 0,\n  intervalMs = 1e3,\n  isIncrement = false\n}) {\n  const {\n    count,\n    increment,\n    decrement,\n    reset: resetCounter\n  } = useCounter(countStart);\n  const {\n    value: isCountdownRunning,\n    setTrue: startCountdown,\n    setFalse: stopCountdown\n  } = useBoolean(false);\n  const resetCountdown = useCallback(() => {\n    stopCountdown();\n    resetCounter();\n  }, [stopCountdown, resetCounter]);\n  const countdownCallback = useCallback(() => {\n    if (count === countStop) {\n      stopCountdown();\n      return;\n    }\n    if (isIncrement) {\n      increment();\n    } else {\n      decrement();\n    }\n  }, [count, countStop, decrement, increment, isIncrement, stopCountdown]);\n  useInterval(countdownCallback, isCountdownRunning ? intervalMs : null);\n  return [count, { startCountdown, stopCountdown, resetCountdown }];\n}\nfunction useEventCallback(fn) {\n  const ref = useRef(() => {\n    throw new Error(\"Cannot call an event handler while rendering.\");\n  });\n  useIsomorphicLayoutEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n  return useCallback((...args) => {\n    var _a;\n    return (_a = ref.current) == null ? void 0 : _a.call(ref, ...args);\n  }, [ref]);\n}\n\n// src/useLocalStorage/useLocalStorage.ts\nvar IS_SERVER = typeof window === \"undefined\";\nfunction useLocalStorage(key, initialValue, options = {}) {\n  const { initializeWithValue = true } = options;\n  const serializer = useCallback(\n    (value) => {\n      if (options.serializer) {\n        return options.serializer(value);\n      }\n      return JSON.stringify(value);\n    },\n    [options]\n  );\n  const deserializer = useCallback(\n    (value) => {\n      if (options.deserializer) {\n        return options.deserializer(value);\n      }\n      if (value === \"undefined\") {\n        return void 0;\n      }\n      const defaultValue = initialValue instanceof Function ? initialValue() : initialValue;\n      let parsed;\n      try {\n        parsed = JSON.parse(value);\n      } catch (error) {\n        console.error(\"Error parsing JSON:\", error);\n        return defaultValue;\n      }\n      return parsed;\n    },\n    [options, initialValue]\n  );\n  const readValue = useCallback(() => {\n    const initialValueToUse = initialValue instanceof Function ? initialValue() : initialValue;\n    if (IS_SERVER) {\n      return initialValueToUse;\n    }\n    try {\n      const raw = window.localStorage.getItem(key);\n      return raw ? deserializer(raw) : initialValueToUse;\n    } catch (error) {\n      console.warn(`Error reading localStorage key \\u201C${key}\\u201D:`, error);\n      return initialValueToUse;\n    }\n  }, [initialValue, key, deserializer]);\n  const [storedValue, setStoredValue] = useState(() => {\n    if (initializeWithValue) {\n      return readValue();\n    }\n    return initialValue instanceof Function ? initialValue() : initialValue;\n  });\n  const setValue = useEventCallback((value) => {\n    if (IS_SERVER) {\n      console.warn(\n        `Tried setting localStorage key \\u201C${key}\\u201D even though environment is not a client`\n      );\n    }\n    try {\n      const newValue = value instanceof Function ? value(readValue()) : value;\n      window.localStorage.setItem(key, serializer(newValue));\n      setStoredValue(newValue);\n      window.dispatchEvent(new StorageEvent(\"local-storage\", { key }));\n    } catch (error) {\n      console.warn(`Error setting localStorage key \\u201C${key}\\u201D:`, error);\n    }\n  });\n  const removeValue = useEventCallback(() => {\n    if (IS_SERVER) {\n      console.warn(\n        `Tried removing localStorage key \\u201C${key}\\u201D even though environment is not a client`\n      );\n    }\n    const defaultValue = initialValue instanceof Function ? initialValue() : initialValue;\n    window.localStorage.removeItem(key);\n    setStoredValue(defaultValue);\n    window.dispatchEvent(new StorageEvent(\"local-storage\", { key }));\n  });\n  useEffect(() => {\n    setStoredValue(readValue());\n  }, [key]);\n  const handleStorageChange = useCallback(\n    (event) => {\n      if (event.key && event.key !== key) {\n        return;\n      }\n      setStoredValue(readValue());\n    },\n    [key, readValue]\n  );\n  useEventListener(\"storage\", handleStorageChange);\n  useEventListener(\"local-storage\", handleStorageChange);\n  return [storedValue, setValue, removeValue];\n}\nvar IS_SERVER2 = typeof window === \"undefined\";\nfunction useMediaQuery(query, {\n  defaultValue = false,\n  initializeWithValue = true\n} = {}) {\n  const getMatches = (query2) => {\n    if (IS_SERVER2) {\n      return defaultValue;\n    }\n    return window.matchMedia(query2).matches;\n  };\n  const [matches, setMatches] = useState(() => {\n    if (initializeWithValue) {\n      return getMatches(query);\n    }\n    return defaultValue;\n  });\n  function handleChange() {\n    setMatches(getMatches(query));\n  }\n  useIsomorphicLayoutEffect(() => {\n    const matchMedia = window.matchMedia(query);\n    handleChange();\n    if (matchMedia.addListener) {\n      matchMedia.addListener(handleChange);\n    } else {\n      matchMedia.addEventListener(\"change\", handleChange);\n    }\n    return () => {\n      if (matchMedia.removeListener) {\n        matchMedia.removeListener(handleChange);\n      } else {\n        matchMedia.removeEventListener(\"change\", handleChange);\n      }\n    };\n  }, [query]);\n  return matches;\n}\n\n// src/useDarkMode/useDarkMode.ts\nvar COLOR_SCHEME_QUERY = \"(prefers-color-scheme: dark)\";\nvar LOCAL_STORAGE_KEY = \"usehooks-ts-dark-mode\";\nfunction useDarkMode(options = {}) {\n  const {\n    defaultValue,\n    localStorageKey = LOCAL_STORAGE_KEY,\n    initializeWithValue = true\n  } = options;\n  const isDarkOS = useMediaQuery(COLOR_SCHEME_QUERY, {\n    initializeWithValue,\n    defaultValue\n  });\n  const [isDarkMode, setDarkMode] = useLocalStorage(\n    localStorageKey,\n    defaultValue ?? isDarkOS ?? false,\n    { initializeWithValue }\n  );\n  useIsomorphicLayoutEffect(() => {\n    if (isDarkOS !== isDarkMode) {\n      setDarkMode(isDarkOS);\n    }\n  }, [isDarkOS]);\n  return {\n    isDarkMode,\n    toggle: () => {\n      setDarkMode((prev) => !prev);\n    },\n    enable: () => {\n      setDarkMode(true);\n    },\n    disable: () => {\n      setDarkMode(false);\n    },\n    set: (value) => {\n      setDarkMode(value);\n    }\n  };\n}\nfunction useUnmount(func) {\n  const funcRef = useRef(func);\n  funcRef.current = func;\n  useEffect(\n    () => () => {\n      funcRef.current();\n    },\n    []\n  );\n}\n\n// src/useDebounceCallback/useDebounceCallback.ts\nfunction useDebounceCallback(func, delay = 500, options) {\n  const debouncedFunc = useRef();\n  useUnmount(() => {\n    if (debouncedFunc.current) {\n      debouncedFunc.current.cancel();\n    }\n  });\n  const debounced = useMemo(() => {\n    const debouncedFuncInstance = debounce(func, delay, options);\n    const wrappedFunc = (...args) => {\n      return debouncedFuncInstance(...args);\n    };\n    wrappedFunc.cancel = () => {\n      debouncedFuncInstance.cancel();\n    };\n    wrappedFunc.isPending = () => {\n      return !!debouncedFunc.current;\n    };\n    wrappedFunc.flush = () => {\n      return debouncedFuncInstance.flush();\n    };\n    return wrappedFunc;\n  }, [func, delay, options]);\n  useEffect(() => {\n    debouncedFunc.current = debounce(func, delay, options);\n  }, [func, delay, options]);\n  return debounced;\n}\nfunction useDebounceValue(initialValue, delay, options) {\n  const eq = (options == null ? void 0 : options.equalityFn) ?? ((left, right) => left === right);\n  const unwrappedInitialValue = initialValue instanceof Function ? initialValue() : initialValue;\n  const [debouncedValue, setDebouncedValue] = useState(unwrappedInitialValue);\n  const previousValueRef = useRef(unwrappedInitialValue);\n  const updateDebouncedValue = useDebounceCallback(\n    setDebouncedValue,\n    delay,\n    options\n  );\n  if (!eq(previousValueRef.current, unwrappedInitialValue)) {\n    updateDebouncedValue(unwrappedInitialValue);\n    previousValueRef.current = unwrappedInitialValue;\n  }\n  return [debouncedValue, updateDebouncedValue];\n}\nfunction useDocumentTitle(title, options = {}) {\n  const { preserveTitleOnUnmount = true } = options;\n  const defaultTitle = useRef(null);\n  useIsomorphicLayoutEffect(() => {\n    defaultTitle.current = window.document.title;\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    window.document.title = title;\n  }, [title]);\n  useUnmount(() => {\n    if (!preserveTitleOnUnmount && defaultTitle.current) {\n      window.document.title = defaultTitle.current;\n    }\n  });\n}\nfunction useHover(elementRef) {\n  const [value, setValue] = useState(false);\n  const handleMouseEnter = () => {\n    setValue(true);\n  };\n  const handleMouseLeave = () => {\n    setValue(false);\n  };\n  useEventListener(\"mouseenter\", handleMouseEnter, elementRef);\n  useEventListener(\"mouseleave\", handleMouseLeave, elementRef);\n  return value;\n}\nfunction useIntersectionObserver({\n  threshold = 0,\n  root = null,\n  rootMargin = \"0%\",\n  freezeOnceVisible = false,\n  initialIsIntersecting = false,\n  onChange\n} = {}) {\n  var _a;\n  const [ref, setRef] = useState(null);\n  const [state, setState] = useState(() => ({\n    isIntersecting: initialIsIntersecting,\n    entry: void 0\n  }));\n  const callbackRef = useRef();\n  callbackRef.current = onChange;\n  const frozen = ((_a = state.entry) == null ? void 0 : _a.isIntersecting) && freezeOnceVisible;\n  useEffect(() => {\n    if (!ref)\n      return;\n    if (!(\"IntersectionObserver\" in window))\n      return;\n    if (frozen)\n      return;\n    let unobserve;\n    const observer = new IntersectionObserver(\n      (entries) => {\n        const thresholds = Array.isArray(observer.thresholds) ? observer.thresholds : [observer.thresholds];\n        entries.forEach((entry) => {\n          const isIntersecting = entry.isIntersecting && thresholds.some((threshold2) => entry.intersectionRatio >= threshold2);\n          setState({ isIntersecting, entry });\n          if (callbackRef.current) {\n            callbackRef.current(isIntersecting, entry);\n          }\n          if (isIntersecting && freezeOnceVisible && unobserve) {\n            unobserve();\n            unobserve = void 0;\n          }\n        });\n      },\n      { threshold, root, rootMargin }\n    );\n    observer.observe(ref);\n    return () => {\n      observer.disconnect();\n    };\n  }, [\n    ref,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    JSON.stringify(threshold),\n    root,\n    rootMargin,\n    frozen,\n    freezeOnceVisible\n  ]);\n  const prevRef = useRef(null);\n  useEffect(() => {\n    var _a2;\n    if (!ref && ((_a2 = state.entry) == null ? void 0 : _a2.target) && !freezeOnceVisible && !frozen && prevRef.current !== state.entry.target) {\n      prevRef.current = state.entry.target;\n      setState({ isIntersecting: initialIsIntersecting, entry: void 0 });\n    }\n  }, [ref, state.entry, freezeOnceVisible, frozen, initialIsIntersecting]);\n  const result = [\n    setRef,\n    !!state.isIntersecting,\n    state.entry\n  ];\n  result.ref = result[0];\n  result.isIntersecting = result[1];\n  result.entry = result[2];\n  return result;\n}\nfunction useIsClient() {\n  const [isClient, setClient] = useState(false);\n  useEffect(() => {\n    setClient(true);\n  }, []);\n  return isClient;\n}\nfunction useIsMounted() {\n  const isMounted = useRef(false);\n  useEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n  return useCallback(() => isMounted.current, []);\n}\nfunction useMap(initialState = /* @__PURE__ */ new Map()) {\n  const [map, setMap] = useState(new Map(initialState));\n  const actions = {\n    set: useCallback((key, value) => {\n      setMap((prev) => {\n        const copy = new Map(prev);\n        copy.set(key, value);\n        return copy;\n      });\n    }, []),\n    setAll: useCallback((entries) => {\n      setMap(() => new Map(entries));\n    }, []),\n    remove: useCallback((key) => {\n      setMap((prev) => {\n        const copy = new Map(prev);\n        copy.delete(key);\n        return copy;\n      });\n    }, []),\n    reset: useCallback(() => {\n      setMap(() => /* @__PURE__ */ new Map());\n    }, [])\n  };\n  return [map, actions];\n}\n\n// src/useOnClickOutside/useOnClickOutside.ts\nfunction useOnClickOutside(ref, handler, eventType = \"mousedown\", eventListenerOptions = {}) {\n  useEventListener(\n    eventType,\n    (event) => {\n      const target = event.target;\n      if (!target || !target.isConnected) {\n        return;\n      }\n      const isOutside = Array.isArray(ref) ? ref.filter((r) => Boolean(r.current)).every((r) => r.current && !r.current.contains(target)) : ref.current && !ref.current.contains(target);\n      if (isOutside) {\n        handler(event);\n      }\n    },\n    void 0,\n    eventListenerOptions\n  );\n}\nvar IS_SERVER3 = typeof window === \"undefined\";\nfunction useReadLocalStorage(key, options = {}) {\n  let { initializeWithValue = true } = options;\n  if (IS_SERVER3) {\n    initializeWithValue = false;\n  }\n  const deserializer = useCallback(\n    (value) => {\n      if (options.deserializer) {\n        return options.deserializer(value);\n      }\n      if (value === \"undefined\") {\n        return void 0;\n      }\n      let parsed;\n      try {\n        parsed = JSON.parse(value);\n      } catch (error) {\n        console.error(\"Error parsing JSON:\", error);\n        return null;\n      }\n      return parsed;\n    },\n    [options]\n  );\n  const readValue = useCallback(() => {\n    if (IS_SERVER3) {\n      return null;\n    }\n    try {\n      const raw = window.localStorage.getItem(key);\n      return raw ? deserializer(raw) : null;\n    } catch (error) {\n      console.warn(`Error reading localStorage key \\u201C${key}\\u201D:`, error);\n      return null;\n    }\n  }, [key, deserializer]);\n  const [storedValue, setStoredValue] = useState(() => {\n    if (initializeWithValue) {\n      return readValue();\n    }\n    return void 0;\n  });\n  useEffect(() => {\n    setStoredValue(readValue());\n  }, [key]);\n  const handleStorageChange = useCallback(\n    (event) => {\n      if (event.key && event.key !== key) {\n        return;\n      }\n      setStoredValue(readValue());\n    },\n    [key, readValue]\n  );\n  useEventListener(\"storage\", handleStorageChange);\n  useEventListener(\"local-storage\", handleStorageChange);\n  return storedValue;\n}\nvar initialSize = {\n  width: void 0,\n  height: void 0\n};\nfunction useResizeObserver(options) {\n  const { ref, box = \"content-box\" } = options;\n  const [{ width, height }, setSize] = useState(initialSize);\n  const isMounted = useIsMounted();\n  const previousSize = useRef({ ...initialSize });\n  const onResize = useRef(void 0);\n  onResize.current = options.onResize;\n  useEffect(() => {\n    if (!ref.current)\n      return;\n    if (typeof window === \"undefined\" || !(\"ResizeObserver\" in window))\n      return;\n    const observer = new ResizeObserver(([entry]) => {\n      const boxProp = box === \"border-box\" ? \"borderBoxSize\" : box === \"device-pixel-content-box\" ? \"devicePixelContentBoxSize\" : \"contentBoxSize\";\n      const newWidth = extractSize(entry, boxProp, \"inlineSize\");\n      const newHeight = extractSize(entry, boxProp, \"blockSize\");\n      const hasChanged = previousSize.current.width !== newWidth || previousSize.current.height !== newHeight;\n      if (hasChanged) {\n        const newSize = { width: newWidth, height: newHeight };\n        previousSize.current.width = newWidth;\n        previousSize.current.height = newHeight;\n        if (onResize.current) {\n          onResize.current(newSize);\n        } else {\n          if (isMounted()) {\n            setSize(newSize);\n          }\n        }\n      }\n    });\n    observer.observe(ref.current, { box });\n    return () => {\n      observer.disconnect();\n    };\n  }, [box, ref, isMounted]);\n  return { width, height };\n}\nfunction extractSize(entry, box, sizeType) {\n  if (!entry[box]) {\n    if (box === \"contentBoxSize\") {\n      return entry.contentRect[sizeType === \"inlineSize\" ? \"width\" : \"height\"];\n    }\n    return void 0;\n  }\n  return Array.isArray(entry[box]) ? entry[box][0][sizeType] : (\n    // @ts-ignore Support Firefox's non-standard behavior\n    entry[box][sizeType]\n  );\n}\nvar IS_SERVER4 = typeof window === \"undefined\";\nfunction useScreen(options = {}) {\n  let { initializeWithValue = true } = options;\n  if (IS_SERVER4) {\n    initializeWithValue = false;\n  }\n  const readScreen = () => {\n    if (IS_SERVER4) {\n      return void 0;\n    }\n    return window.screen;\n  };\n  const [screen, setScreen] = useState(() => {\n    if (initializeWithValue) {\n      return readScreen();\n    }\n    return void 0;\n  });\n  const debouncedSetScreen = useDebounceCallback(\n    setScreen,\n    options.debounceDelay\n  );\n  function handleSize() {\n    const newScreen = readScreen();\n    const setSize = options.debounceDelay ? debouncedSetScreen : setScreen;\n    if (newScreen) {\n      const {\n        width,\n        height,\n        availHeight,\n        availWidth,\n        colorDepth,\n        orientation,\n        pixelDepth\n      } = newScreen;\n      setSize({\n        width,\n        height,\n        availHeight,\n        availWidth,\n        colorDepth,\n        orientation,\n        pixelDepth\n      });\n    }\n  }\n  useEventListener(\"resize\", handleSize);\n  useIsomorphicLayoutEffect(() => {\n    handleSize();\n  }, []);\n  return screen;\n}\nvar cachedScriptStatuses = /* @__PURE__ */ new Map();\nfunction getScriptNode(src) {\n  const node = document.querySelector(\n    `script[src=\"${src}\"]`\n  );\n  const status = node == null ? void 0 : node.getAttribute(\"data-status\");\n  return {\n    node,\n    status\n  };\n}\nfunction useScript(src, options) {\n  const [status, setStatus] = useState(() => {\n    if (!src || (options == null ? void 0 : options.shouldPreventLoad)) {\n      return \"idle\";\n    }\n    if (typeof window === \"undefined\") {\n      return \"loading\";\n    }\n    return cachedScriptStatuses.get(src) ?? \"loading\";\n  });\n  useEffect(() => {\n    if (!src || (options == null ? void 0 : options.shouldPreventLoad)) {\n      return;\n    }\n    const cachedScriptStatus = cachedScriptStatuses.get(src);\n    if (cachedScriptStatus === \"ready\" || cachedScriptStatus === \"error\") {\n      setStatus(cachedScriptStatus);\n      return;\n    }\n    const script = getScriptNode(src);\n    let scriptNode = script.node;\n    if (!scriptNode) {\n      scriptNode = document.createElement(\"script\");\n      scriptNode.src = src;\n      scriptNode.async = true;\n      if (options == null ? void 0 : options.id) {\n        scriptNode.id = options.id;\n      }\n      scriptNode.setAttribute(\"data-status\", \"loading\");\n      document.body.appendChild(scriptNode);\n      const setAttributeFromEvent = (event) => {\n        const scriptStatus = event.type === \"load\" ? \"ready\" : \"error\";\n        scriptNode == null ? void 0 : scriptNode.setAttribute(\"data-status\", scriptStatus);\n      };\n      scriptNode.addEventListener(\"load\", setAttributeFromEvent);\n      scriptNode.addEventListener(\"error\", setAttributeFromEvent);\n    } else {\n      setStatus(script.status ?? cachedScriptStatus ?? \"loading\");\n    }\n    const setStateFromEvent = (event) => {\n      const newStatus = event.type === \"load\" ? \"ready\" : \"error\";\n      setStatus(newStatus);\n      cachedScriptStatuses.set(src, newStatus);\n    };\n    scriptNode.addEventListener(\"load\", setStateFromEvent);\n    scriptNode.addEventListener(\"error\", setStateFromEvent);\n    return () => {\n      if (scriptNode) {\n        scriptNode.removeEventListener(\"load\", setStateFromEvent);\n        scriptNode.removeEventListener(\"error\", setStateFromEvent);\n      }\n      if (scriptNode && (options == null ? void 0 : options.removeOnUnmount)) {\n        scriptNode.remove();\n        cachedScriptStatuses.delete(src);\n      }\n    };\n  }, [src, options == null ? void 0 : options.shouldPreventLoad, options == null ? void 0 : options.removeOnUnmount, options == null ? void 0 : options.id]);\n  return status;\n}\nvar IS_SERVER5 = typeof window === \"undefined\";\nfunction useScrollLock(options = {}) {\n  const { autoLock = true, lockTarget, widthReflow = true } = options;\n  const [isLocked, setIsLocked] = useState(false);\n  const target = useRef(null);\n  const originalStyle = useRef(null);\n  const lock = () => {\n    if (target.current) {\n      const { overflow, paddingRight } = target.current.style;\n      originalStyle.current = { overflow, paddingRight };\n      if (widthReflow) {\n        const offsetWidth = target.current === document.body ? window.innerWidth : target.current.offsetWidth;\n        const currentPaddingRight = parseInt(window.getComputedStyle(target.current).paddingRight, 10) || 0;\n        const scrollbarWidth = offsetWidth - target.current.scrollWidth;\n        target.current.style.paddingRight = `${scrollbarWidth + currentPaddingRight}px`;\n      }\n      target.current.style.overflow = \"hidden\";\n      setIsLocked(true);\n    }\n  };\n  const unlock = () => {\n    if (target.current && originalStyle.current) {\n      target.current.style.overflow = originalStyle.current.overflow;\n      if (widthReflow) {\n        target.current.style.paddingRight = originalStyle.current.paddingRight;\n      }\n    }\n    setIsLocked(false);\n  };\n  useIsomorphicLayoutEffect(() => {\n    if (IS_SERVER5)\n      return;\n    if (lockTarget) {\n      target.current = typeof lockTarget === \"string\" ? document.querySelector(lockTarget) : lockTarget;\n    }\n    if (!target.current) {\n      target.current = document.body;\n    }\n    if (autoLock) {\n      lock();\n    }\n    return () => {\n      unlock();\n    };\n  }, [autoLock, lockTarget, widthReflow]);\n  return { isLocked, lock, unlock };\n}\nvar IS_SERVER6 = typeof window === \"undefined\";\nfunction useSessionStorage(key, initialValue, options = {}) {\n  const { initializeWithValue = true } = options;\n  const serializer = useCallback(\n    (value) => {\n      if (options.serializer) {\n        return options.serializer(value);\n      }\n      return JSON.stringify(value);\n    },\n    [options]\n  );\n  const deserializer = useCallback(\n    (value) => {\n      if (options.deserializer) {\n        return options.deserializer(value);\n      }\n      if (value === \"undefined\") {\n        return void 0;\n      }\n      const defaultValue = initialValue instanceof Function ? initialValue() : initialValue;\n      let parsed;\n      try {\n        parsed = JSON.parse(value);\n      } catch (error) {\n        console.error(\"Error parsing JSON:\", error);\n        return defaultValue;\n      }\n      return parsed;\n    },\n    [options, initialValue]\n  );\n  const readValue = useCallback(() => {\n    const initialValueToUse = initialValue instanceof Function ? initialValue() : initialValue;\n    if (IS_SERVER6) {\n      return initialValueToUse;\n    }\n    try {\n      const raw = window.sessionStorage.getItem(key);\n      return raw ? deserializer(raw) : initialValueToUse;\n    } catch (error) {\n      console.warn(`Error reading sessionStorage key \\u201C${key}\\u201D:`, error);\n      return initialValueToUse;\n    }\n  }, [initialValue, key, deserializer]);\n  const [storedValue, setStoredValue] = useState(() => {\n    if (initializeWithValue) {\n      return readValue();\n    }\n    return initialValue instanceof Function ? initialValue() : initialValue;\n  });\n  const setValue = useEventCallback((value) => {\n    if (IS_SERVER6) {\n      console.warn(\n        `Tried setting sessionStorage key \\u201C${key}\\u201D even though environment is not a client`\n      );\n    }\n    try {\n      const newValue = value instanceof Function ? value(readValue()) : value;\n      window.sessionStorage.setItem(key, serializer(newValue));\n      setStoredValue(newValue);\n      window.dispatchEvent(new StorageEvent(\"session-storage\", { key }));\n    } catch (error) {\n      console.warn(`Error setting sessionStorage key \\u201C${key}\\u201D:`, error);\n    }\n  });\n  const removeValue = useEventCallback(() => {\n    if (IS_SERVER6) {\n      console.warn(\n        `Tried removing sessionStorage key \\u201C${key}\\u201D even though environment is not a client`\n      );\n    }\n    const defaultValue = initialValue instanceof Function ? initialValue() : initialValue;\n    window.sessionStorage.removeItem(key);\n    setStoredValue(defaultValue);\n    window.dispatchEvent(new StorageEvent(\"session-storage\", { key }));\n  });\n  useEffect(() => {\n    setStoredValue(readValue());\n  }, [key]);\n  const handleStorageChange = useCallback(\n    (event) => {\n      if (event.key && event.key !== key) {\n        return;\n      }\n      setStoredValue(readValue());\n    },\n    [key, readValue]\n  );\n  useEventListener(\"storage\", handleStorageChange);\n  useEventListener(\"session-storage\", handleStorageChange);\n  return [storedValue, setValue, removeValue];\n}\nfunction useStep(maxStep) {\n  const [currentStep, setCurrentStep] = useState(1);\n  const canGoToNextStep = currentStep + 1 <= maxStep;\n  const canGoToPrevStep = currentStep - 1 > 0;\n  const setStep = useCallback(\n    (step) => {\n      const newStep = step instanceof Function ? step(currentStep) : step;\n      if (newStep >= 1 && newStep <= maxStep) {\n        setCurrentStep(newStep);\n        return;\n      }\n      throw new Error(\"Step not valid\");\n    },\n    [maxStep, currentStep]\n  );\n  const goToNextStep = useCallback(() => {\n    if (canGoToNextStep) {\n      setCurrentStep((step) => step + 1);\n    }\n  }, [canGoToNextStep]);\n  const goToPrevStep = useCallback(() => {\n    if (canGoToPrevStep) {\n      setCurrentStep((step) => step - 1);\n    }\n  }, [canGoToPrevStep]);\n  const reset = useCallback(() => {\n    setCurrentStep(1);\n  }, []);\n  return [\n    currentStep,\n    {\n      goToNextStep,\n      goToPrevStep,\n      canGoToNextStep,\n      canGoToPrevStep,\n      setStep,\n      reset\n    }\n  ];\n}\n\n// src/useTernaryDarkMode/useTernaryDarkMode.ts\nvar COLOR_SCHEME_QUERY2 = \"(prefers-color-scheme: dark)\";\nvar LOCAL_STORAGE_KEY2 = \"usehooks-ts-ternary-dark-mode\";\nfunction useTernaryDarkMode({\n  defaultValue = \"system\",\n  localStorageKey = LOCAL_STORAGE_KEY2,\n  initializeWithValue = true\n} = {}) {\n  const isDarkOS = useMediaQuery(COLOR_SCHEME_QUERY2, { initializeWithValue });\n  const [mode, setMode] = useLocalStorage(localStorageKey, defaultValue, {\n    initializeWithValue\n  });\n  const isDarkMode = mode === \"dark\" || mode === \"system\" && isDarkOS;\n  const toggleTernaryDarkMode = () => {\n    const modes = [\"light\", \"system\", \"dark\"];\n    setMode((prevMode) => {\n      const nextIndex = (modes.indexOf(prevMode) + 1) % modes.length;\n      return modes[nextIndex];\n    });\n  };\n  return {\n    isDarkMode,\n    ternaryDarkMode: mode,\n    setTernaryDarkMode: setMode,\n    toggleTernaryDarkMode\n  };\n}\nfunction useTimeout(callback, delay) {\n  const savedCallback = useRef(callback);\n  useIsomorphicLayoutEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n  useEffect(() => {\n    if (!delay && delay !== 0) {\n      return;\n    }\n    const id = setTimeout(() => {\n      savedCallback.current();\n    }, delay);\n    return () => {\n      clearTimeout(id);\n    };\n  }, [delay]);\n}\nfunction useToggle(defaultValue) {\n  const [value, setValue] = useState(!!defaultValue);\n  const toggle = useCallback(() => {\n    setValue((x) => !x);\n  }, []);\n  return [value, toggle, setValue];\n}\nvar IS_SERVER7 = typeof window === \"undefined\";\nfunction useWindowSize(options = {}) {\n  let { initializeWithValue = true } = options;\n  if (IS_SERVER7) {\n    initializeWithValue = false;\n  }\n  const [windowSize, setWindowSize] = useState(() => {\n    if (initializeWithValue) {\n      return {\n        width: window.innerWidth,\n        height: window.innerHeight\n      };\n    }\n    return {\n      width: void 0,\n      height: void 0\n    };\n  });\n  const debouncedSetWindowSize = useDebounceCallback(\n    setWindowSize,\n    options.debounceDelay\n  );\n  function handleSize() {\n    const setSize = options.debounceDelay ? debouncedSetWindowSize : setWindowSize;\n    setSize({\n      width: window.innerWidth,\n      height: window.innerHeight\n    });\n  }\n  useEventListener(\"resize\", handleSize);\n  useIsomorphicLayoutEffect(() => {\n    handleSize();\n  }, []);\n  return windowSize;\n}\n\nexport { useBoolean, useClickAnyWhere, useCopyToClipboard, useCountdown, useCounter, useDarkMode, useDebounceCallback, useDebounceValue, useDocumentTitle, useEventCallback, useEventListener, useHover, useIntersectionObserver, useInterval, useIsClient, useIsMounted, useIsomorphicLayoutEffect, useLocalStorage, useMap, useMediaQuery, useOnClickOutside, useReadLocalStorage, useResizeObserver, useScreen, useScript, useScrollLock, useSessionStorage, useStep, useTernaryDarkMode, useTimeout, useToggle, useUnmount, useWindowSize };\n", "import { isTest } from \"../../lib/constants\"\n\n// By default, all tests will treat <TransitionGroup> as `disableAnimations={true}`,\n// removing the need to be aware of misc. async animations happening across tests.\n// We could add support for things like `prefers-reduced-motion` in the future here as well.\nexport default () => isTest\n", "import React, { Children, useCallback, useRef } from \"react\"\nimport { isDev, isTest } from \"../../lib/constants\"\n\nexport type TransitionDefinition = {\n  opacity?: number\n  /** The horizontal translation value in pixels */\n  x?: number\n  /**  The horizontal vertical value in pixels */\n  y?: number\n  /** The opacity value ranging from 0 to 1. */\n  scale?: number\n  rotate?: number | string\n  skewX?: number | string\n  skewY?: number | string\n  blur?: number\n  duration?: number\n  delay?: number\n  timingFunction?: string\n}\n\nexport type InitialTransitionDefinition = Omit<\n  TransitionDefinition,\n  \"duration\" | \"delay\" | \"timingFunction\"\n>\n\nexport type LayoutTransitionDefinition = {\n  duration?: number\n  delay?: number\n  timingFunction?: string\n}\n\nexport type CallbackType =\n  | \"enter\"\n  | \"enter-active\"\n  | \"enter-complete\"\n  | \"exit\"\n  | \"exit-active\"\n  | \"exit-complete\"\n\n// Transition callbacks and types shared across implementations\nexport type TransitionGroupChildCallback = (element: HTMLDivElement) => void\n\nexport type TransitionGroupChildCallbacks = {\n  /** Callback fired when an enter animation is staged (e.g., component mounted to the DOM) */\n  onEnter: TransitionGroupChildCallback\n  /** Callback fired when an enter animation starts */\n  onEnterActive: TransitionGroupChildCallback\n  /** Callback fired when an enter animation completes */\n  onEnterComplete: TransitionGroupChildCallback\n  /** Callback fired when an exit animation is staged */\n  onExit: TransitionGroupChildCallback\n  /** Callback fired when an exit animation starts */\n  onExitActive: TransitionGroupChildCallback\n  /** Callback fired when an exit animation completes (e.g., component unmounted from the DOM) */\n  onExitComplete: TransitionGroupChildCallback\n}\n\nexport const NonNullChildren = (children: React.ReactNode) =>\n  Children.toArray(children).filter((child) => child !== null && child !== undefined)\n\n// Shared keyed-children and transition helpers\nexport interface ReactElementWithKey extends React.ReactElement {\n  key: string\n}\n\nexport const ChildrenWithKeys = (\n  children: React.ReactNode,\n  shouldThrow: boolean = false,\n  componentName: string = \"TransitionGroup\",\n): ReactElementWithKey[] => {\n  const validChildren: ReactElementWithKey[] = []\n  Children.forEach(children, (child) => {\n    if (child && typeof child === \"object\" && \"key\" in child && !!child.key) {\n      // @ts-expect-error -- The above conditional is enough coercion that the component is valid\n      validChildren.push(child)\n    } else if (shouldThrow) {\n      throw new Error(`Child elements of <${componentName} /> must include a \\`key\\``)\n    }\n  })\n  return validChildren\n}\n\nexport const noop = () => {}\n\nexport const useChildCallback = (cb: (el: HTMLDivElement) => void) => {\n  const ref = useRef(cb)\n  ref.current = cb\n  return useCallback<(el: HTMLDivElement) => void>((element) => ref.current(element), [])\n}\n\nexport type InsertMethod = \"append\" | \"prepend\"\n\nexport function computeNextRenderChildren<\n  RenderChild extends { component: ReactElementWithKey; shouldRender: boolean },\n>(\n  propChildrenArray: ReactElementWithKey[],\n  currentRenderChildren: RenderChild[],\n  createDefaultRenderChildProps: (child: ReactElementWithKey) => RenderChild,\n  insertMethod: InsertMethod,\n): RenderChild[] {\n  const propChildKeyMap = propChildrenArray.reduce<Record<string, number>>(\n    (acc, child) => ({ ...acc, [child.key]: 1 }),\n    {},\n  )\n  const currentRenderChildKeyMap = currentRenderChildren.reduce<Record<string, number>>(\n    (acc, child) => ({ ...acc, [child.component.key]: 1 }),\n    {},\n  )\n\n  const newRenderChildren: RenderChild[] = propChildrenArray\n    .filter((propChild) => !currentRenderChildKeyMap[propChild.key])\n    .map(createDefaultRenderChildProps)\n\n  const updatedCurrentChildren: RenderChild[] = currentRenderChildren.map((childProps) => ({\n    ...childProps,\n    component:\n      propChildrenArray.find(({ key }) => key === childProps.component.key) || childProps.component,\n    shouldRender: !!propChildKeyMap[childProps.component.key],\n  }))\n\n  return insertMethod === \"append\"\n    ? updatedCurrentChildren.concat(newRenderChildren)\n    : newRenderChildren.concat(updatedCurrentChildren)\n}\n\nexport function assertSingleChildWhenRef(\n  componentName: string,\n  ref: React.Ref<unknown> | undefined,\n  childrenCount: number,\n): void {\n  if ((isTest || isDev) && ref && childrenCount > 1) {\n    throw new Error(`Cannot use forwardRef with multiple children in <${componentName} />`)\n  }\n}\n", "export type TransitionState = {\n  enter: boolean\n  enterActive: boolean\n  exit: boolean\n  exitActive: boolean\n  interrupted: boolean\n}\n\nexport type TransitionStateAction =\n  | { type: \"enter-before\" }\n  | { type: \"enter-active\" }\n  | { type: \"exit-before\" }\n  | { type: \"exit-active\" }\n  | { type: \"done\" }\n\nexport const RESTING_TRANSITION_STATE: TransitionState = {\n  enter: false,\n  enterActive: false,\n  exit: false,\n  exitActive: false,\n  interrupted: false,\n}\n\nexport const getInitialTransitionState = (preventMountTransition: boolean): TransitionState => ({\n  ...RESTING_TRANSITION_STATE,\n  enter: !preventMountTransition,\n})\n\nexport const transitionReducer = (\n  state: TransitionState,\n  action: TransitionStateAction,\n): TransitionState => {\n  switch (action.type) {\n    case \"enter-before\":\n      return {\n        enter: true,\n        enterActive: false,\n        exit: false,\n        exitActive: false,\n        interrupted: state.interrupted || state.exit,\n      }\n    case \"enter-active\":\n      return {\n        enter: true,\n        enterActive: true,\n        exit: false,\n        exitActive: false,\n        interrupted: false,\n      }\n    case \"exit-before\":\n      return {\n        enter: false,\n        enterActive: false,\n        exit: true,\n        exitActive: false,\n        interrupted: state.interrupted || state.enter,\n      }\n    case \"exit-active\":\n      return {\n        enter: false,\n        enterActive: false,\n        exit: true,\n        exitActive: true,\n        interrupted: false,\n      }\n    case \"done\":\n    default:\n      return RESTING_TRANSITION_STATE\n  }\n}\n", "\"use client\"\n\nimport clsx from \"clsx\"\nimport { TransitionGroup, type TransitionGroupProps } from \"./TransitionGroup\"\n\nimport { type CSSProperties } from \"react\"\nimport {\n  toCssVariables,\n  toFilterProperty,\n  toMsDurationProperty,\n  toOpacityProperty,\n  toTransformProperty,\n} from \"../../lib/helpers\"\nimport s from \"./Animate.module.css\"\nimport { type InitialTransitionDefinition, type TransitionDefinition } from \"./shared\"\n\nexport type AnimateProps = Pick<\n  TransitionGroupProps,\n  \"as\" | \"children\" | \"className\" | \"insertMethod\" | \"preventInitialTransition\"\n> & {\n  /** Class applied to the inner TransitionGroup */\n  transitionClassName?: string\n  /** Styles applied to the enter transition */\n  enter?: TransitionDefinition\n  /** Styles applied to the exit transition */\n  exit?: TransitionDefinition\n  /** Styles applied before the enter transition occurs */\n  initial?: InitialTransitionDefinition\n  /**\n   * Determines how transition states are positioned\n   * @default absolute\n   */\n  transitionPosition?: \"absolute\" | \"static\"\n  /**\n   * Applies `will-change` to force animating elements to composite layers. Use with caution!\n   * @default false\n   */\n  forceCompositeLayer?: boolean\n}\n\nexport const Animate = (props: AnimateProps) => {\n  const {\n    as: TagName = \"span\",\n    className,\n    children,\n    preventInitialTransition,\n    insertMethod,\n    transitionClassName,\n    transitionPosition = \"absolute\",\n  } = props\n  const { enterTotalDuration, exitTotalDuration, variables } = getAnimationProperties(props)\n\n  return (\n    <TagName\n      className={clsx(\"block\", transitionPosition === \"absolute\" && \"relative\", className)}\n      data-transition-position={transitionPosition}\n      style={variables}\n    >\n      <TransitionGroup\n        as={TagName}\n        className={clsx(s.TransitionItem, transitionClassName)}\n        enterDuration={enterTotalDuration}\n        exitDuration={exitTotalDuration}\n        insertMethod={insertMethod}\n        preventInitialTransition={preventInitialTransition}\n      >\n        {children}\n      </TransitionGroup>\n    </TagName>\n  )\n}\n\n// Keep in sync with default values in Animate.module.css\nconst DEFAULT_ENTER_DURATION_MS_EASE = 400\nconst DEFAULT_ENTER_DURATION_MS_CUBIC = 500\nconst DEFAULT_EXIT_DURATION_MS_EASE = 200\nconst DEFAULT_EXIT_DURATION_MS_CUBIC = 300\n\nfunction getAnimationProperties({\n  initial: initial,\n  enter: enter,\n  exit: exit,\n  forceCompositeLayer,\n}: AnimateProps): {\n  enterTotalDuration: number\n  exitTotalDuration: number\n  variables: CSSProperties\n} {\n  // Dynamically inspect if we're transitioning transform properties, and apply cubic curves and timings as defaults\n  const initialTransform = toTransformProperty(initial)\n  const enterTransform = toTransformProperty(enter)\n  const exitTransform = toTransformProperty(exit)\n  const isCubicTransition = [initialTransform, exitTransform, enterTransform].some(\n    (t) => t !== \"none\",\n  )\n  const enterDuration =\n    enter?.duration ??\n    (isCubicTransition ? DEFAULT_ENTER_DURATION_MS_CUBIC : DEFAULT_ENTER_DURATION_MS_EASE)\n  const enterTimingFunction =\n    enter?.timingFunction ?? (isCubicTransition ? \"var(--cubic-enter)\" : \"ease\")\n  const exitDuration =\n    exit?.duration ??\n    (isCubicTransition ? DEFAULT_EXIT_DURATION_MS_CUBIC : DEFAULT_EXIT_DURATION_MS_EASE)\n  const exitTimingFunction =\n    exit?.timingFunction ?? (isCubicTransition ? \"var(--cubic-exit)\" : \"ease\")\n\n  // Generate variable overrides from props\n  const variables = toCssVariables({\n    \"tg-will-change\": forceCompositeLayer ? \"transform, opacity\" : \"auto\",\n    \"tg-enter-opacity\": toOpacityProperty(enter?.opacity ?? 1),\n    \"tg-enter-transform\": enterTransform,\n    \"tg-enter-filter\": toFilterProperty(enter),\n    \"tg-enter-duration\": toMsDurationProperty(enterDuration),\n    \"tg-enter-delay\": toMsDurationProperty(enter?.delay ?? 0),\n    \"tg-enter-timing-function\": enterTimingFunction,\n    \"tg-exit-opacity\": toOpacityProperty(exit?.opacity ?? 0),\n    \"tg-exit-transform\": exitTransform,\n    \"tg-exit-filter\": toFilterProperty(exit),\n    \"tg-exit-duration\": toMsDurationProperty(exitDuration),\n    \"tg-exit-delay\": toMsDurationProperty(exit?.delay ?? 0),\n    \"tg-exit-timing-function\": exitTimingFunction,\n    \"tg-initial-opacity\": toOpacityProperty(initial?.opacity ?? exit?.opacity ?? 0),\n    \"tg-initial-transform\": initialTransform === \"none\" ? exitTransform : initialTransform,\n    \"tg-initial-filter\": toFilterProperty(initial ?? exit ?? {}),\n  } satisfies Record<string, string>)\n\n  const enterTotalDuration = (enter?.delay ?? 0) + enterDuration\n  const exitTotalDuration = (exit?.delay ?? 0) + exitDuration\n\n  return { enterTotalDuration, exitTotalDuration, variables }\n}\n", "\"use client\"\n\nimport clsx from \"clsx\"\nimport { useRef, type CSSProperties } from \"react\"\nimport {\n  toCssVariables,\n  toFilterProperty,\n  toMsDurationProperty,\n  toOpacityProperty,\n  toTransformProperty,\n  waitForAnimationFrame,\n} from \"../../lib/helpers\"\nimport s from \"./AnimateLayout.module.css\"\nimport { TransitionGroup, type TransitionGroupProps } from \"./TransitionGroup\"\nimport {\n  type InitialTransitionDefinition,\n  type LayoutTransitionDefinition,\n  type TransitionDefinition,\n} from \"./shared\"\n\nexport type AnimateLayoutProps = Pick<\n  TransitionGroupProps,\n  \"as\" | \"children\" | \"className\" | \"insertMethod\" | \"preventInitialTransition\"\n> & {\n  /**\n   * Determines if `overflow: hidden` is applied to the wrapper element\n   * @default false\n   */\n  hideOverflow?: boolean\n  /**\n   * Determines which side of the container the items will pin to during enter/exit\n   * @default \"start\"\n   */\n  itemAnchor?: \"start\" | \"end\"\n  /**\n   * Determines which property will be animated during transitions\n   * @default \"height\"\n   */\n  dimension?: \"width\" | \"height\"\n  layoutEnter?: LayoutTransitionDefinition\n  layoutExit?: LayoutTransitionDefinition\n  layoutMove?: LayoutTransitionDefinition\n\n  enter?: TransitionDefinition\n  exit?: TransitionDefinition\n  initial?: InitialTransitionDefinition\n  /** Class applied to the inner TransitionGroup */\n  transitionClassName?: string\n  /**\n   * Applies `will-change` to force animating elements to composite layers. Use with caution!\n   * @default false\n   */\n  forceCompositeLayer?: boolean\n}\n\nexport const AnimateLayout = (props: AnimateLayoutProps) => {\n  const {\n    as: TagName = \"span\",\n    children,\n    transitionClassName,\n    insertMethod,\n    className,\n    hideOverflow = false,\n    // An initial height animation will almost never be correct. Consider carefully when overriding.\n    preventInitialTransition = true,\n    itemAnchor = \"start\",\n    dimension = \"height\",\n  } = props\n  const containerRef = useRef<HTMLDivElement | null>(null)\n  const captainRef = useRef<HTMLDivElement | null>(null)\n  const exitTimestampRef = useRef<number | null>(null)\n\n  const { enterTotalDuration, exitTotalDuration, variables } = getAnimationProperties(props)\n\n  const handleEnter = (element: HTMLDivElement) => {\n    const container = containerRef.current\n\n    if (!container) {\n      return\n    }\n\n    // If handleExit() was called >50ms ago, consider this a \"move\" and don't touch \"interrupted\" state\n    const justExited = exitTimestampRef.current && Date.now() - exitTimestampRef.current < 50\n\n    const anotherCaptain = !!captainRef.current\n    // Look at me, I'm the captain now\n    captainRef.current = element\n\n    // Recent exits are a near guarantee we are \"moving\" states\n    container.dataset.direction = justExited || anotherCaptain ? \"move\" : \"in\"\n\n    // If we just exited, don't touch the interrupted state. Exit just set it with the correct state of things\n    if (!justExited) {\n      container.dataset.interrupted = String(!!container.style[dimension])\n    }\n\n    const clientRect = container.getBoundingClientRect()\n    container.style[dimension] = `${clientRect[dimension]}px`\n  }\n\n  const handleEnterActive = (element: HTMLDivElement) => {\n    const container = containerRef.current\n\n    if (!container) {\n      return\n    }\n\n    // ~Impossible to not be the captain at this point, but check anyway.\n    const amICaptain = captainRef.current === element\n    if (!amICaptain) {\n      return\n    }\n\n    // IMPORTANT: Use clientHeight/clientWidth to measure children, in case they have scale() applied\n    const value = dimension === \"width\" ? element.clientWidth : element.clientHeight\n    container.style[dimension] = `${value}px`\n  }\n\n  const handleEnterComplete = (element: HTMLDivElement) => {\n    const container = containerRef.current\n\n    // Wait for the next tick, to ensure React has cleared `[data-entering*]` state from the DOM\n    // Without this, it's possible that we release the height from the container\n    // before the children in the DOM are naturally positioned (non-absolute).\n    waitForAnimationFrame(() => {\n      const amICaptain = captainRef.current === element\n      if (!container || !amICaptain) {\n        return\n      }\n\n      // Restore natural height to the DOM node\n      container.style[dimension] = \"\"\n    })\n  }\n\n  const handleExit = (element: HTMLDivElement) => {\n    const container = containerRef.current\n    const amICaptain = !captainRef.current || captainRef.current === element\n\n    if (!container || !amICaptain) {\n      return\n    }\n\n    // o7\n    captainRef.current = null\n    exitTimestampRef.current = Date.now()\n\n    container.dataset.direction = \"out\"\n    container.dataset.interrupted = String(!!container.style[dimension])\n\n    const clientRect = container.getBoundingClientRect()\n    container.style[dimension] = `${clientRect[dimension]}px`\n  }\n\n  const handleExitActive = (_element: HTMLDivElement) => {\n    const container = containerRef.current\n    const newCaptainExists = !!captainRef.current\n\n    // If another component has become the captain, exit early\n    if (!container || newCaptainExists) {\n      return\n    }\n\n    // Animate to zero layout\n    container.style[dimension] = \"0\"\n  }\n\n  const handleExitComplete = (_element: HTMLDivElement) => {\n    // Wait for the next tick, to ensure React has cleared `[data-exiting*]` state from the DOM\n    waitForAnimationFrame(() => {\n      const container = containerRef.current\n      const newCaptainExists = !!captainRef.current\n\n      // If another component has become the captain, exit early\n      if (!container || newCaptainExists) {\n        return\n      }\n\n      // Restore natural height to the DOM node\n      container.style[dimension] = \"\"\n    })\n  }\n\n  return (\n    <TagName\n      ref={containerRef}\n      className={clsx(s.Layout, className)}\n      style={variables}\n      data-item-anchor={itemAnchor}\n      data-clip={hideOverflow}\n      data-dimension={dimension}\n    >\n      <TransitionGroup\n        as={TagName}\n        className={clsx(s.TransitionItem, transitionClassName)}\n        insertMethod={insertMethod}\n        enterDuration={enterTotalDuration}\n        exitDuration={exitTotalDuration}\n        preventInitialTransition={preventInitialTransition}\n        onEnter={handleEnter}\n        onEnterActive={handleEnterActive}\n        onEnterComplete={handleEnterComplete}\n        onExit={handleExit}\n        onExitActive={handleExitActive}\n        onExitComplete={handleExitComplete}\n      >\n        {children}\n      </TransitionGroup>\n    </TagName>\n  )\n}\n\n// Keep in sync with default values in AnimateLayout.module.css\nconst DEFAULT_LAYOUT_ENTER_DURATION_MS = 300\nconst DEFAULT_LAYOUT_ENTER_DELAY_MS = 0\nconst DEFAULT_LAYOUT_EXIT_DURATION_MS = 300\nconst DEFAULT_LAYOUT_EXIT_DELAY_MS = 0\nconst DEFAULT_LAYOUT_MOVE_DURATION_MS = 300\nconst DEFAULT_LAYOUT_MOVE_DELAY_MS = 0\nconst DEFAULT_ENTER_DURATION_MS_EASE = 300\nconst DEFAULT_ENTER_DURATION_MS_CUBIC = 300\nconst DEFAULT_ENTER_DELAY_MS = 100\nconst DEFAULT_EXIT_DURATION_MS_EASE = 200\nconst DEFAULT_EXIT_DURATION_MS_CUBIC = 200\nconst DEFAULT_EXIT_DELAY_MS = 0\n\nfunction getAnimationProperties({\n  initial,\n  enter,\n  exit,\n  forceCompositeLayer,\n  layoutEnter,\n  layoutExit,\n  layoutMove,\n}: AnimateLayoutProps): {\n  enterTotalDuration: number\n  exitTotalDuration: number\n  variables: CSSProperties\n} {\n  // Dynamically inspect if we're transitioning transform properties, and apply cubic curves and timings as defaults\n  const initialTransform = toTransformProperty(initial)\n  const enterTransform = toTransformProperty(enter)\n  const exitTransform = toTransformProperty(exit)\n  const isCubicTransition = [initialTransform, exitTransform, enterTransform].some(\n    (t) => t !== \"none\",\n  )\n  const enterDuration =\n    enter?.duration ??\n    (isCubicTransition ? DEFAULT_ENTER_DURATION_MS_CUBIC : DEFAULT_ENTER_DURATION_MS_EASE)\n  const enterTimingFunction =\n    enter?.timingFunction ?? (isCubicTransition ? \"var(--cubic-enter)\" : \"ease\")\n  const exitDuration =\n    exit?.duration ??\n    (isCubicTransition ? DEFAULT_EXIT_DURATION_MS_CUBIC : DEFAULT_EXIT_DURATION_MS_EASE)\n  const exitTimingFunction =\n    exit?.timingFunction ?? (isCubicTransition ? \"var(--cubic-exit)\" : \"ease\")\n\n  // Generate variable overrides from props\n  const variables = toCssVariables({\n    \"tg-will-change\": forceCompositeLayer ? \"transform, opacity\" : \"auto\",\n    \"tg-enter-opacity\": toOpacityProperty(enter?.opacity ?? 1),\n    \"tg-enter-transform\": enterTransform,\n    \"tg-enter-filter\": toFilterProperty(enter),\n    \"tg-enter-duration\": toMsDurationProperty(enterDuration),\n    \"tg-enter-delay\": toMsDurationProperty(enter?.delay ?? DEFAULT_ENTER_DELAY_MS),\n    \"tg-enter-timing-function\": enterTimingFunction,\n    \"tg-exit-opacity\": toOpacityProperty(exit?.opacity ?? 0),\n    \"tg-exit-transform\": exitTransform,\n    \"tg-exit-filter\": toFilterProperty(exit ?? {}),\n    \"tg-exit-duration\": toMsDurationProperty(exitDuration),\n    \"tg-exit-delay\": toMsDurationProperty(exit?.delay ?? DEFAULT_EXIT_DELAY_MS),\n    \"tg-exit-timing-function\": exitTimingFunction,\n    \"tg-initial-opacity\": toOpacityProperty(initial?.opacity ?? exit?.opacity ?? 0),\n    \"tg-initial-transform\": initialTransform === \"none\" ? exitTransform : initialTransform,\n    \"tg-initial-filter\": toFilterProperty(initial ?? exit ?? {}),\n    \"tg-layout-enter-duration\": toMsDurationProperty(\n      layoutEnter?.duration ?? DEFAULT_LAYOUT_ENTER_DURATION_MS,\n    ),\n    \"tg-layout-enter-delay\": toMsDurationProperty(\n      layoutEnter?.delay ?? DEFAULT_LAYOUT_ENTER_DELAY_MS,\n    ),\n    \"tg-layout-enter-timing-function\": layoutEnter?.timingFunction ?? \"var(--cubic-move)\",\n    \"tg-layout-exit-duration\": toMsDurationProperty(\n      layoutExit?.duration ?? DEFAULT_LAYOUT_EXIT_DURATION_MS,\n    ),\n    \"tg-layout-exit-delay\": toMsDurationProperty(layoutExit?.delay ?? DEFAULT_LAYOUT_EXIT_DELAY_MS),\n    \"tg-layout-exit-timing-function\": layoutExit?.timingFunction ?? \"var(--cubic-move)\",\n    \"tg-layout-move-duration\": toMsDurationProperty(\n      layoutMove?.duration ?? DEFAULT_LAYOUT_MOVE_DURATION_MS,\n    ),\n    \"tg-layout-move-delay\": toMsDurationProperty(layoutMove?.delay ?? DEFAULT_LAYOUT_MOVE_DELAY_MS),\n    \"tg-layout-move-timing-function\": layoutMove?.timingFunction ?? \"var(--cubic-move)\",\n  } satisfies Record<string, string>)\n\n  const enterTotalDuration =\n    (enter?.delay ?? DEFAULT_ENTER_DELAY_MS) + (enterDuration ?? DEFAULT_ENTER_DURATION_MS_EASE)\n  const exitTotalDuration =\n    (exit?.delay ?? DEFAULT_EXIT_DELAY_MS) + (exitDuration ?? DEFAULT_EXIT_DURATION_MS_EASE)\n  const layoutEnterTotalDuration =\n    (layoutEnter?.delay ?? DEFAULT_LAYOUT_ENTER_DELAY_MS) +\n    (layoutEnter?.duration ?? DEFAULT_LAYOUT_ENTER_DURATION_MS)\n  const layoutExitTotalDuration =\n    (layoutExit?.delay ?? DEFAULT_LAYOUT_EXIT_DELAY_MS) +\n    (layoutExit?.duration ?? DEFAULT_LAYOUT_EXIT_DURATION_MS)\n  const layoutMoveTotalDuration =\n    (layoutMove?.delay ?? DEFAULT_LAYOUT_MOVE_DELAY_MS) +\n    (layoutMove?.duration ?? DEFAULT_LAYOUT_MOVE_DURATION_MS)\n\n  return {\n    // In order for us to release layout dimensions (e.g., height) to the natural DOM state,\n    // we must ensure the behaviors from the TransitionGroup callbacks are synced with the outer layout `transitions`.\n    // Setting TransitionGroup timing to the max of these durations is the simplest approach.\n    // In practice, these should only vary by about 50-200ms at most; imperceivable to end-users.\n    enterTotalDuration: Math.max(\n      enterTotalDuration,\n      layoutEnterTotalDuration,\n      layoutMoveTotalDuration,\n    ),\n    exitTotalDuration: Math.max(\n      exitTotalDuration,\n      layoutExitTotalDuration,\n      layoutMoveTotalDuration,\n    ),\n    variables,\n  }\n}\n", "\"use client\"\n\nimport { TransitionGroup, type TransitionGroupProps } from \"./TransitionGroup\"\n\nimport clsx from \"clsx\"\nimport { type CSSProperties } from \"react\"\nimport {\n  toCssVariables,\n  toFilterProperty,\n  toMsDurationProperty,\n  toOpacityProperty,\n  toTransformProperty,\n  waitForAnimationFrame,\n} from \"../../lib/helpers\"\nimport s from \"./AnimateLayoutGroup.module.css\"\nimport {\n  type InitialTransitionDefinition,\n  type LayoutTransitionDefinition,\n  NonNullChildren,\n  type TransitionDefinition,\n} from \"./shared\"\n\nexport type AnimateLayoutGroupProps = Pick<\n  TransitionGroupProps,\n  \"as\" | \"children\" | \"className\" | \"insertMethod\" | \"preventInitialTransition\"\n> & {\n  /**\n   * Determines if `overflow: hidden` is applied to the wrapper element\n   * @default false\n   */\n  hideOverflow?: boolean\n  /**\n   * Determines which side of the container the items will pin to during enter/exit\n   * @default \"start\"\n   */\n  itemAnchor?: \"start\" | \"end\"\n  /**\n   * Determines which property will be animated during transitions\n   * @default \"height\"\n   */\n  dimension?: \"width\" | \"height\"\n  layoutEnter?: LayoutTransitionDefinition\n  layoutExit?: LayoutTransitionDefinition\n  layoutMove?: LayoutTransitionDefinition\n\n  enter?: TransitionDefinition\n  exit?: TransitionDefinition\n  initial?: InitialTransitionDefinition\n  /** Class applied to the inner TransitionGroup */\n  transitionClassName?: string\n  /**\n   * Applies `will-change` to force animating elements to composite layers. Use with caution!\n   * @default false\n   */\n  forceCompositeLayer?: boolean\n}\n\nexport const AnimateLayoutGroup = (props: AnimateLayoutGroupProps) => {\n  const {\n    as: TagName = \"span\",\n    children,\n    className,\n    transitionClassName,\n    dimension = \"height\",\n  } = props\n  const { enterTotalDuration, exitTotalDuration, variables } = getAnimationProperties(props)\n\n  const handleEnter = (element: HTMLDivElement) => {\n    // Stage zero layout\n    element.style[dimension] = \"0\"\n  }\n\n  const handleEnterActive = (element: HTMLDivElement) => {\n    waitForAnimationFrame(() => {\n      // Animate to target height\n      // IMPORTANT: Use clientHeight/clientWidth to measure children, in case they have scale() applied\n      const value =\n        dimension === \"width\"\n          ? element.firstElementChild?.clientWidth\n          : element.firstElementChild?.clientHeight\n\n      element.style[dimension] = `${value ?? 0}px`\n    })\n  }\n\n  const handleEnterComplete = (element: HTMLDivElement) => {\n    waitForAnimationFrame(() => {\n      // Restore natural layout to the DOM node\n      element.style[dimension] = \"\"\n    })\n  }\n\n  const handleExit = (element: HTMLDivElement) => {\n    element.style[dimension] = `${element.getBoundingClientRect()[dimension]}px`\n  }\n\n  const handleExitActive = (element: HTMLDivElement) => {\n    waitForAnimationFrame(() => {\n      // Animate to zero layout\n      element.style[dimension] = \"0\"\n    })\n  }\n\n  return (\n    <TransitionGroup\n      as={TagName}\n      className={clsx(s.LayoutItem, className)}\n      style={variables}\n      // Adding 32ms to timers because of the additional waitForAnimationFrame() calls\n      enterDuration={enterTotalDuration + 32}\n      exitDuration={exitTotalDuration + 32}\n      onEnter={handleEnter}\n      onEnterActive={handleEnterActive}\n      onEnterComplete={handleEnterComplete}\n      onExit={handleExit}\n      onExitActive={handleExitActive}\n    >\n      {NonNullChildren(children).map((child) => (\n        // Ensure any falsy child.key value is sent specifically as `undefined`.\n        // This ensures that key is not misinterpreted as a string 'null', 'false', etc.\n        <TagName\n          className={clsx(s.TransitionItem, transitionClassName)}\n          // @ts-expect-error Pass-through the validation of `key` to <TransitionGroup>\n          key={child.key || undefined}\n          data-dimension={dimension}\n        >\n          {child}\n        </TagName>\n      ))}\n    </TransitionGroup>\n  )\n}\n\n// Keep in sync with default values in AnimateLayout.module.css\nconst DEFAULT_LAYOUT_ENTER_DURATION_MS = 300\nconst DEFAULT_LAYOUT_ENTER_DELAY_MS = 0\nconst DEFAULT_LAYOUT_EXIT_DURATION_MS = 300\nconst DEFAULT_LAYOUT_EXIT_DELAY_MS = 50\nconst DEFAULT_LAYOUT_MOVE_DURATION_MS = 300\nconst DEFAULT_LAYOUT_MOVE_DELAY_MS = 0\nconst DEFAULT_ENTER_DURATION_MS_EASE = 400\nconst DEFAULT_ENTER_DURATION_MS_CUBIC = 400\nconst DEFAULT_ENTER_DELAY_MS = 150\nconst DEFAULT_EXIT_DURATION_MS_EASE = 200\nconst DEFAULT_EXIT_DURATION_MS_CUBIC = 300\nconst DEFAULT_EXIT_DELAY_MS = 0\n\nfunction getAnimationProperties({\n  initial,\n  enter,\n  exit,\n  forceCompositeLayer,\n  layoutEnter,\n  layoutExit,\n  layoutMove,\n}: AnimateLayoutGroupProps): {\n  enterTotalDuration: number\n  exitTotalDuration: number\n  variables: CSSProperties\n} {\n  // Dynamically inspect if we're transitioning transform properties, and apply cubic curves and timings as defaults\n  const initialTransform = toTransformProperty(initial)\n  const enterTransform = toTransformProperty(enter)\n  const exitTransform = toTransformProperty(exit)\n  const isCubicTransition = [initialTransform, exitTransform, enterTransform].some(\n    (t) => t !== \"none\",\n  )\n  const enterDuration =\n    enter?.duration ??\n    (isCubicTransition ? DEFAULT_ENTER_DURATION_MS_CUBIC : DEFAULT_ENTER_DURATION_MS_EASE)\n  const enterTimingFunction =\n    enter?.timingFunction ?? (isCubicTransition ? \"var(--cubic-enter)\" : \"ease\")\n  const exitDuration =\n    exit?.duration ??\n    (isCubicTransition ? DEFAULT_EXIT_DURATION_MS_CUBIC : DEFAULT_EXIT_DURATION_MS_EASE)\n  const exitTimingFunction =\n    exit?.timingFunction ?? (isCubicTransition ? \"var(--cubic-exit)\" : \"ease\")\n\n  // Generate variable overrides from props\n  const variables = toCssVariables({\n    \"tg-will-change\": forceCompositeLayer ? \"transform, opacity\" : \"auto\",\n    \"tg-enter-opacity\": toOpacityProperty(enter?.opacity ?? 1),\n    \"tg-enter-transform\": enterTransform,\n    \"tg-enter-filter\": toFilterProperty(enter ?? {}),\n    \"tg-enter-duration\": toMsDurationProperty(enterDuration),\n    \"tg-enter-delay\": toMsDurationProperty(enter?.delay ?? DEFAULT_ENTER_DELAY_MS),\n    \"tg-enter-timing-function\": enterTimingFunction,\n    \"tg-exit-opacity\": toOpacityProperty(exit?.opacity ?? 0),\n    \"tg-exit-transform\": exitTransform,\n    \"tg-exit-filter\": toFilterProperty(exit ?? {}),\n    \"tg-exit-duration\": toMsDurationProperty(exitDuration),\n    \"tg-exit-delay\": toMsDurationProperty(exit?.delay ?? DEFAULT_EXIT_DELAY_MS),\n    \"tg-exit-timing-function\": exitTimingFunction,\n    \"tg-initial-opacity\": toOpacityProperty(initial?.opacity ?? exit?.opacity ?? 0),\n    \"tg-initial-transform\": initialTransform === \"none\" ? exitTransform : initialTransform,\n    \"tg-initial-filter\": toFilterProperty(initial ?? exit ?? {}),\n    \"tg-layout-enter-duration\": toMsDurationProperty(\n      layoutEnter?.duration ?? DEFAULT_LAYOUT_ENTER_DURATION_MS,\n    ),\n    \"tg-layout-enter-delay\": toMsDurationProperty(\n      layoutEnter?.delay ?? DEFAULT_LAYOUT_ENTER_DELAY_MS,\n    ),\n    \"tg-layout-enter-timing-function\": layoutEnter?.timingFunction ?? \"var(--cubic-move)\",\n    \"tg-layout-exit-duration\": toMsDurationProperty(\n      layoutExit?.duration ?? DEFAULT_LAYOUT_EXIT_DURATION_MS,\n    ),\n    \"tg-layout-exit-delay\": toMsDurationProperty(layoutExit?.delay ?? DEFAULT_LAYOUT_EXIT_DELAY_MS),\n    \"tg-layout-exit-timing-function\": layoutExit?.timingFunction ?? \"var(--cubic-move)\",\n    \"tg-layout-move-duration\": toMsDurationProperty(\n      layoutMove?.duration ?? DEFAULT_LAYOUT_MOVE_DURATION_MS,\n    ),\n    \"tg-layout-move-delay\": toMsDurationProperty(\n      layoutMove?.delay ?? DEFAULT_LAYOUT_MOVE_DURATION_MS,\n    ),\n    \"tg-layout-move-timing-function\": layoutMove?.timingFunction ?? \"var(--cubic-move)\",\n  } satisfies Record<string, string>)\n\n  const enterTotalDuration =\n    (enter?.delay ?? DEFAULT_ENTER_DELAY_MS) + (enterDuration ?? DEFAULT_ENTER_DURATION_MS_EASE)\n  const exitTotalDuration =\n    (exit?.delay ?? DEFAULT_EXIT_DELAY_MS) + (exitDuration ?? DEFAULT_EXIT_DURATION_MS_EASE)\n  const layoutEnterTotalDuration =\n    (layoutEnter?.delay ?? DEFAULT_LAYOUT_ENTER_DELAY_MS) +\n    (layoutEnter?.duration ?? DEFAULT_LAYOUT_ENTER_DURATION_MS)\n  const layoutExitTotalDuration =\n    (layoutExit?.delay ?? DEFAULT_LAYOUT_EXIT_DELAY_MS) +\n    (layoutExit?.duration ?? DEFAULT_LAYOUT_EXIT_DURATION_MS)\n  const layoutMoveTotalDuration =\n    (layoutMove?.delay ?? DEFAULT_LAYOUT_MOVE_DELAY_MS) +\n    (layoutMove?.duration ?? DEFAULT_LAYOUT_MOVE_DURATION_MS)\n\n  return {\n    // In order for us to release layout dimensions (e.g., height) to the natural DOM state,\n    // we must ensure the behaviors from the TransitionGroup callbacks are synced with the outer layout `transitions`.\n    // Setting TransitionGroup timing to the max of these durations is the simplest approach.\n    // In practice, these should only vary by about 50-200ms at most; imperceivable to end-users.\n    enterTotalDuration: Math.max(\n      enterTotalDuration,\n      layoutEnterTotalDuration,\n      layoutMoveTotalDuration,\n    ),\n    exitTotalDuration: Math.max(\n      exitTotalDuration,\n      layoutExitTotalDuration,\n      layoutMoveTotalDuration,\n    ),\n    variables,\n  }\n}\n", "\"use client\"\n\nimport React, {\n  Children,\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\"\nimport { mergeRefs } from \"react-merge-refs\"\n\nimport { waitForAnimationFrame } from \"../../lib/helpers\"\n\n// (no-op) clsx removed: className is not managed at group-level for slotted children\nimport { useTimeout } from \"usehooks-ts\"\nimport getDisableAnimations from \"./getDisableAnimations\"\nimport {\n  assertSingleChildWhenRef,\n  ChildrenWithKeys,\n  computeNextRenderChildren,\n  noop,\n  useChildCallback,\n  type CallbackType,\n  type ReactElementWithKey,\n  type TransitionGroupChildCallbacks,\n} from \"./shared\"\nimport { getInitialTransitionState, transitionReducer } from \"./transitionReducer\"\n\ntype SlotTransitionGroupChildProps = {\n  component: ReactElementWithKey\n  preventMountTransition?: boolean\n  shouldRender: boolean\n  enterDuration: number\n  exitDuration: number\n  enterMountDelay?: number\n  removeChild: () => void\n  ref?: React.Ref<unknown>\n} & TransitionGroupChildCallbacks\n\nconst SlotTransitionGroupChildInner = ({\n  ref,\n  component,\n  preventMountTransition,\n  shouldRender,\n  enterDuration,\n  exitDuration,\n  removeChild,\n  onEnter,\n  onEnterActive,\n  onEnterComplete,\n  onExit,\n  onExitActive,\n  onExitComplete,\n}: SlotTransitionGroupChildProps) => {\n  const [state, dispatch] = useReducer(\n    transitionReducer,\n    getInitialTransitionState(preventMountTransition || false),\n  )\n  const preventedMountTransition = useRef<boolean>(false)\n  const elementRef = useRef<HTMLDivElement | null>(null)\n  const enterDurationRef = useRef<number>(enterDuration)\n  enterDurationRef.current = enterDuration\n  const exitDurationRef = useRef<number>(exitDuration)\n  exitDurationRef.current = exitDuration\n\n  const lastCallbackRef = useRef<CallbackType>(null as unknown as CallbackType)\n  const triggerCallback = useCallback(\n    (callbackType: CallbackType) => {\n      const element = elementRef.current\n      if (!element || callbackType === lastCallbackRef.current) {\n        return\n      }\n      lastCallbackRef.current = callbackType\n      switch (callbackType) {\n        case \"enter\":\n          onEnter(element)\n          break\n        case \"enter-active\":\n          onEnterActive(element)\n          break\n        case \"enter-complete\":\n          onEnterComplete(element)\n          break\n        case \"exit\":\n          onExit(element)\n          break\n        case \"exit-active\":\n          onExitActive(element)\n          break\n        case \"exit-complete\":\n          onExitComplete(element)\n          break\n        default:\n          callbackType satisfies never\n          break\n      }\n    },\n    [onEnter, onEnterActive, onEnterComplete, onExit, onExitActive, onExitComplete],\n  )\n\n  /**\n   * IMPORTANT: `useLayoutEffect()` is used here to avoid race conditions between new SlotTransitionGroupChild components.\n   */\n  useLayoutEffect(() => {\n    // Exit transition\n    if (!shouldRender) {\n      let exitTimeout: number | undefined\n\n      dispatch({ type: \"exit-before\" })\n      triggerCallback(\"exit\")\n\n      const cancelAnimationFrame = waitForAnimationFrame(() => {\n        dispatch({ type: \"exit-active\" })\n        triggerCallback(\"exit-active\")\n\n        exitTimeout = window.setTimeout(() => {\n          triggerCallback(\"exit-complete\")\n          removeChild()\n        }, exitDurationRef.current)\n      })\n\n      return () => {\n        cancelAnimationFrame()\n        if (exitTimeout !== undefined) clearTimeout(exitTimeout)\n      }\n    }\n\n    // Enter transition\n\n    // Check if we need to prevent this specific entering cycle\n    if (preventMountTransition && !preventedMountTransition.current) {\n      // Mark initial transition as prevented and short-circuit.\n      preventedMountTransition.current = true\n      return\n    }\n\n    let enterTimeout: number | undefined\n\n    dispatch({ type: \"enter-before\" })\n    triggerCallback(\"enter\")\n\n    const cancelAnimationFrame = waitForAnimationFrame(() => {\n      dispatch({ type: \"enter-active\" })\n      triggerCallback(\"enter-active\")\n\n      enterTimeout = window.setTimeout(() => {\n        dispatch({ type: \"done\" })\n        triggerCallback(\"enter-complete\")\n      }, enterDurationRef.current)\n    })\n\n    return () => {\n      cancelAnimationFrame()\n      if (enterTimeout !== undefined) clearTimeout(enterTimeout)\n    }\n  }, [\n    shouldRender,\n    // This value is immutable after <SlotTransitionGroup> is created, and does not change on re-renders.\n    preventMountTransition,\n    removeChild,\n    triggerCallback,\n  ])\n\n  useEffect(() => {\n    // Required for <StrictMode>\n    return () => {\n      preventedMountTransition.current = false\n    }\n  }, [])\n\n  const original = component\n\n  const mergedRef = mergeRefs<unknown>([\n    elementRef as unknown as React.Ref<unknown>,\n    ref as unknown as React.Ref<unknown>,\n    ((original as unknown as { ref?: React.Ref<unknown> }).ref ?? null) as React.Ref<unknown>,\n  ])\n\n  const nextProps = {\n    \"data-entering\": state.enter ? \"\" : undefined,\n    \"data-entering-active\": state.enterActive ? \"\" : undefined,\n    \"data-exiting\": state.exit ? \"\" : undefined,\n    \"data-exiting-active\": state.exitActive ? \"\" : undefined,\n    \"data-interrupted\": state.interrupted ? \"\" : undefined,\n    \"ref\": mergedRef,\n  }\n\n  return React.isValidElement(original) ? React.cloneElement(original, nextProps) : null\n}\n\nconst SlotTransitionGroupChild = (props: SlotTransitionGroupChildProps) => {\n  const { enterMountDelay, preventMountTransition } = props\n  const mountDelay = !preventMountTransition && enterMountDelay != null ? enterMountDelay : null\n  const [mounted, setMounted] = useState(mountDelay == null)\n  useTimeout(() => setMounted(true), mounted ? null : mountDelay)\n\n  return mounted ? <SlotTransitionGroupChildInner {...props} /> : null\n}\n\nexport type SlotTransitionGroupProps = {\n  /** Components controlled by SlotTransitionGroup rendering */\n  children: React.ReactNode\n  /** Determines the amount of time that the enter state is applied during mounting */\n  enterDuration?: number\n  /** Determines the amount of time that the exit state is applied before unmounting */\n  exitDuration?: number\n  /**\n   * Determines if children should have an enter transition applied during mounting of the group.\n   * @default true\n   */\n  preventInitialTransition?: boolean\n  /** Delay in MS to wait before mounting a child. `null` for no delay (default). */\n  enterMountDelay?: number\n  /** Render children changes immediately, bypassing transition timings */\n  disableAnimations?: boolean\n  /** Determines how new children are added to the children array */\n  insertMethod?: \"append\" | \"prepend\"\n  /** Ref for the SlotTransitionGroup (applied to the single child when possible) */\n  ref?: React.Ref<unknown>\n} & Partial<TransitionGroupChildCallbacks>\n\ntype RenderChild = {\n  component: ReactElementWithKey\n  shouldRender: boolean\n  preventMountTransition?: boolean\n  removeChild: () => void\n} & TransitionGroupChildCallbacks\n\nexport const SlotTransitionGroup = (props: SlotTransitionGroupProps) => {\n  const {\n    ref,\n    children,\n    enterDuration = 0,\n    exitDuration = 0,\n    preventInitialTransition = true,\n    enterMountDelay,\n    insertMethod = \"append\",\n    disableAnimations = getDisableAnimations(),\n  } = props\n\n  // Create stable, mutable references for all callbacks\n  const onEnter = useChildCallback(props.onEnter ?? noop)\n  const onEnterActive = useChildCallback(props.onEnterActive ?? noop)\n  const onEnterComplete = useChildCallback(props.onEnterComplete ?? noop)\n  const onExit = useChildCallback(props.onExit ?? noop)\n  const onExitActive = useChildCallback(props.onExitActive ?? noop)\n  const onExitComplete = useChildCallback(props.onExitComplete ?? noop)\n\n  // Ensure all children are provided with keys.\n  Children.forEach(children, (child) => {\n    // @ts-expect-error - We know `key` might not exist on certain types, that's why we're checking\n    if (child && !child.key) {\n      throw new Error(\"Child elements of <SlotTransitionGroup /> must include a `key`\")\n    }\n  })\n\n  const createDefaultRenderChildProps = useCallback(\n    (child: ReactElementWithKey): RenderChild => ({\n      component: child,\n      shouldRender: true,\n      removeChild: () => {\n        setRenderChildren((currentRenderChildren) =>\n          currentRenderChildren.filter((c) => child.key !== c.component.key),\n        )\n      },\n      onEnter,\n      onEnterActive,\n      onEnterComplete,\n      onExit,\n      onExitActive,\n      onExitComplete,\n    }),\n    [onEnter, onEnterActive, onEnterComplete, onExit, onExitActive, onExitComplete],\n  )\n\n  const [renderChildren, setRenderChildren] = useState<RenderChild[]>((): RenderChild[] => {\n    return ChildrenWithKeys(children).map((child) => ({\n      ...createDefaultRenderChildProps(child),\n      // Lock this value to whatever the value was on initial render of the group.\n      preventMountTransition: preventInitialTransition,\n    }))\n  })\n\n  // IMPORTANT: useLayoutEffect is required to satisfy render timings for prop updates to input elements\n  useLayoutEffect(() => {\n    setRenderChildren((currentRenderChildren): RenderChild[] => {\n      const propChildrenArray = ChildrenWithKeys(children, false, \"SlotTransitionGroup\")\n      return computeNextRenderChildren(\n        propChildrenArray,\n        currentRenderChildren,\n        createDefaultRenderChildProps,\n        insertMethod,\n      )\n    })\n  }, [children, insertMethod, createDefaultRenderChildProps])\n\n  // Prevent mistakes with forwardRef() by ensuring single child usage within the group.\n  assertSingleChildWhenRef(\"SlotTransitionGroup\", ref, Children.count(children))\n\n  if (disableAnimations) {\n    // Fast path: when animations are disabled and no ref is provided, render children as-is.\n    if (!ref) {\n      return <>{children}</>\n    }\n\n    // If a ref is provided, attach it to the (single) child by cloning.\n    return (\n      <>\n        {Children.map(children, (child) => {\n          if (!React.isValidElement(child)) return child\n          const original = child as ReactElementWithKey\n          const merged = mergeRefs<unknown>([\n            ref as unknown as React.Ref<unknown>,\n            ((original as unknown as { ref?: React.Ref<unknown> }).ref ??\n              null) as React.Ref<unknown>,\n          ])\n          const nextProps = { ref: merged }\n          return React.cloneElement(original, nextProps)\n        })}\n      </>\n    )\n  }\n\n  return (\n    <>\n      {renderChildren.map(({ component, ...restProps }) => (\n        <SlotTransitionGroupChild\n          key={component.key}\n          {...restProps}\n          component={component}\n          enterDuration={enterDuration}\n          exitDuration={exitDuration}\n          enterMountDelay={enterMountDelay}\n          ref={ref}\n        />\n      ))}\n    </>\n  )\n}\n"],
  "mappings": "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",
  "names": ["debounce", "result", "o", "import_react", "mergeRefs", "refs", "value", "ref", "import_react", "import_react", "React", "cancelAnimationFrame", "_jsx", "_Fragment", "import_react", "s", "_jsx", "s", "import_react", "s", "getAnimationProperties", "_jsx", "s", "DEFAULT_ENTER_DURATION_MS_EASE", "DEFAULT_ENTER_DURATION_MS_CUBIC", "DEFAULT_EXIT_DURATION_MS_EASE", "DEFAULT_EXIT_DURATION_MS_CUBIC", "import_react", "s", "getAnimationProperties", "_jsx", "s", "DEFAULT_LAYOUT_ENTER_DURATION_MS", "DEFAULT_LAYOUT_ENTER_DELAY_MS", "DEFAULT_LAYOUT_EXIT_DURATION_MS", "DEFAULT_LAYOUT_EXIT_DELAY_MS", "DEFAULT_LAYOUT_MOVE_DURATION_MS", "DEFAULT_LAYOUT_MOVE_DELAY_MS", "DEFAULT_ENTER_DURATION_MS_EASE", "DEFAULT_ENTER_DURATION_MS_CUBIC", "DEFAULT_ENTER_DELAY_MS", "DEFAULT_EXIT_DURATION_MS_EASE", "DEFAULT_EXIT_DURATION_MS_CUBIC", "DEFAULT_EXIT_DELAY_MS", "import_react", "cancelAnimationFrame", "React", "_jsx", "_Fragment"]
}
