import {
  Check_default,
  Copy_default
} from "./chunk-AFBIFDVV.js";
import {
  Animate,
  TransitionGroup,
  clsx_default,
  handlePressableMouseEnter,
  toCssVariables
} from "./chunk-SJJLC7LL.js";
import {
  AppsSDKUIContext
} from "./chunk-BWTRBILB.js";
import {
  require_jsx_runtime
} from "./chunk-HNBNNEO4.js";
import {
  require_react
} from "./chunk-CTRVV34M.js";
import {
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/@openai/apps-sdk-ui/dist/es/components/Button/Button.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var import_react5 = __toESM(require_react());

// node_modules/@openai/apps-sdk-ui/dist/es/lib/renderHelpers.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
var flattenTextNodes = (children) => {
  const nodes = import_react.Children.toArray(children);
  const result = [];
  let buffer = "";
  const flush = () => {
    if (buffer !== "") {
      result.push(buffer);
      buffer = "";
    }
  };
  for (const node of nodes) {
    if (node == null || typeof node === "boolean") {
      continue;
    }
    if (typeof node === "string" || typeof node === "number") {
      buffer += String(node);
      continue;
    }
    flush();
    result.push(node);
  }
  flush();
  return result;
};
var wrapTextNodeSiblings = (children) => {
  const flattenedChildren = flattenTextNodes(children);
  const childrenCount = import_react.Children.count(flattenedChildren);
  return import_react.Children.map(flattenedChildren, (child) => {
    if (typeof child === "string" && !!child.trim()) {
      if (childrenCount <= 1) {
        return child;
      }
      return (0, import_jsx_runtime.jsx)("span", { children: child });
    }
    if ((0, import_react.isValidElement)(child)) {
      const element = child;
      const { children: innerChildren, ...restProps } = element.props;
      if (innerChildren != null) {
        return (0, import_react.cloneElement)(element, restProps, wrapTextNodeSiblings(innerChildren));
      }
      return element;
    }
    return child;
  });
};

// node_modules/@openai/apps-sdk-ui/dist/es/components/AppsSDKUIProvider/internal.js
var import_react2 = __toESM(require_react());
function useLinkComponent() {
  const context = (0, import_react2.useContext)(AppsSDKUIContext);
  return context?.linkComponent ?? "a";
}

// node_modules/@openai/apps-sdk-ui/dist/es/components/Indicator/CircularProgress.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_react4 = __toESM(require_react());

// node_modules/@openai/apps-sdk-ui/dist/es/hooks/useSimulatedProgress.js
var import_react3 = __toESM(require_react());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Indicator/CircularProgress.js
import s from "/Users/pranav/Documents/YChackMCP1/OrganizeEventAgent/OpsDock/node_modules/@openai/apps-sdk-ui/dist/es/components/Indicator/CircularProgress.module.css";

// node_modules/@openai/apps-sdk-ui/dist/es/components/Indicator/LoadingDots.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
import s2 from "/Users/pranav/Documents/YChackMCP1/OrganizeEventAgent/OpsDock/node_modules/@openai/apps-sdk-ui/dist/es/components/Indicator/LoadingDots.module.css";

// node_modules/@openai/apps-sdk-ui/dist/es/components/Indicator/LoadingIndicator.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
import s3 from "/Users/pranav/Documents/YChackMCP1/OrganizeEventAgent/OpsDock/node_modules/@openai/apps-sdk-ui/dist/es/components/Indicator/LoadingIndicator.module.css";
var LoadingIndicator = ({ className, size, strokeWidth, style, ...restProps }) => {
  return (0, import_jsx_runtime4.jsx)("div", { ...restProps, className: clsx_default(s3.LoadingIndicator, className), style: style || toCssVariables({
    "indicator-size": size,
    "indicator-stroke": strokeWidth
  }) });
};

// node_modules/@openai/apps-sdk-ui/dist/es/components/Button/Button.js
import s4 from "/Users/pranav/Documents/YChackMCP1/OrganizeEventAgent/OpsDock/node_modules/@openai/apps-sdk-ui/dist/es/components/Button/Button.module.css";
var Button = (props) => {
  const {
    type = "button",
    color = "primary",
    variant = "solid",
    pill = true,
    uniform = false,
    size = "md",
    iconSize,
    gutterSize,
    loading,
    selected,
    block,
    opticallyAlign,
    children,
    className,
    onClick,
    disabled,
    disabledTone,
    // Defaults to `loading` state
    inert = loading,
    ...restProps
  } = props;
  const isInert = disabled || inert;
  const handleClick = (0, import_react5.useCallback)((e) => {
    if (disabled) {
      return;
    }
    onClick?.(e);
  }, [onClick, disabled]);
  return (0, import_jsx_runtime5.jsxs)("button", {
    type,
    className: clsx_default(s4.Button, className),
    "data-color": color,
    "data-variant": variant,
    "data-pill": pill ? "" : void 0,
    "data-uniform": uniform ? "" : void 0,
    "data-size": size,
    "data-gutter-size": gutterSize,
    "data-icon-size": iconSize,
    "data-loading": loading ? "" : void 0,
    "data-selected": selected ? "" : void 0,
    "data-block": block ? "" : void 0,
    "data-optically-align": opticallyAlign,
    onPointerEnter: handlePressableMouseEnter,
    // Non-visual, accessible disablement
    // NOTE: Do not use literal `inert` because that is incorrect semantically
    disabled: isInert,
    "aria-disabled": isInert,
    tabIndex: isInert ? -1 : void 0,
    "data-disabled": disabled ? "" : void 0,
    "data-disabled-tone": disabled ? disabledTone : void 0,
    onClick: handleClick,
    ...restProps,
    children: [(0, import_jsx_runtime5.jsx)(TransitionGroup, { className: s4.ButtonLoader, enterDuration: 250, exitDuration: 150, children: loading && (0, import_jsx_runtime5.jsx)(LoadingIndicator, {}, "loader") }), (0, import_jsx_runtime5.jsx)("span", { className: s4.ButtonInner, children: wrapTextNodeSiblings(children) })]
  });
};
var ButtonLink = ((props) => {
  const { color = "primary", variant = "solid", pill = true, size = "md", gutterSize, iconSize, external, block, opticallyAlign, children, className, disabled, disabledTone, onClick, onPointerEnter, as: OverrideComponent, href, to, ...restProps } = props;
  const isExternal = external ?? /^https?:\/\//.test(href ?? to ?? "");
  const DefaultComponent = useLinkComponent();
  const LinkComponent = OverrideComponent || (isExternal ? "a" : DefaultComponent);
  const sharedProps = {
    "className": clsx_default(s4.Button, className),
    disabled,
    "aria-disabled": disabled,
    "tabIndex": disabled ? -1 : void 0,
    // Visual disablement (inert not supported in links, always applied)
    "data-disabled": disabled ? "" : void 0,
    "data-disabled-tone": disabled ? disabledTone : void 0,
    "data-color": color,
    "data-variant": variant,
    "data-pill": pill ? "" : void 0,
    "data-block": block ? "" : void 0,
    "data-optically-align": opticallyAlign,
    "data-size": size,
    "data-gutter-size": gutterSize,
    "data-icon-size": iconSize,
    "onClick": disabled ? void 0 : onClick,
    "onPointerEnter": (evt) => {
      handlePressableMouseEnter(evt);
      onPointerEnter?.(evt);
    }
  };
  if (disabled) {
    const eventProps = Object.fromEntries(Object.entries(restProps).filter(([key, value]) => key.startsWith("on") && typeof value === "function"));
    return (0, import_jsx_runtime5.jsx)("span", { role: "link", ...sharedProps, ...eventProps, children: (0, import_jsx_runtime5.jsx)("span", { className: s4.ButtonInner, children: wrapTextNodeSiblings(children) }) });
  }
  const linkProps = {
    ...isExternal ? { target: "_blank", rel: "noopener noreferrer", href: href ?? to } : { href, to },
    ...sharedProps,
    ...restProps
  };
  return (0, import_jsx_runtime5.jsx)(LinkComponent, { ...linkProps, children: (0, import_jsx_runtime5.jsx)("span", { className: s4.ButtonInner, children: wrapTextNodeSiblings(children) }) });
});

// node_modules/@openai/apps-sdk-ui/dist/es/components/Button/CopyButton.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var import_react6 = __toESM(require_react());

// node_modules/@openai/apps-sdk-ui/dist/es/lib/copyToClipboard.js
var supportsRichClipboard = () => typeof ClipboardItem !== "undefined" && !!navigator.clipboard?.write;
function toClipboardItem(content) {
  const { "text/plain": text, ...rest } = content;
  return new ClipboardItem({
    ...rest,
    ...text ? { "text/plain": new Blob([text], { type: "text/plain" }) } : null
  });
}
async function copyToClipboard(content, container = document.body) {
  if (typeof content === "string") {
    return copyText(content, container);
  }
  try {
    if (supportsRichClipboard()) {
      await navigator.clipboard.write([toClipboardItem(content)]);
      return true;
    }
    if (content["text/plain"]) {
      return copyText(content["text/plain"], container);
    }
    return false;
  } catch (error) {
    return false;
  }
}
async function copyText(text, container = document.body) {
  if (navigator.clipboard) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch (error) {
    }
  }
  const textArea = document.createElement("textarea");
  textArea.value = text;
  textArea.style.position = "fixed";
  textArea.style.top = "0";
  textArea.style.left = "0";
  textArea.style.opacity = "0";
  container.appendChild(textArea);
  textArea.focus();
  textArea.select();
  let succeeded = false;
  try {
    succeeded = document.execCommand("copy");
  } catch (error) {
  }
  container.removeChild(textArea);
  return succeeded;
}

// node_modules/@openai/apps-sdk-ui/dist/es/components/Button/CopyButton.js
var CopyButton = ({ children, copyValue, onClick, ...restProps }) => {
  const [copied, setCopied] = (0, import_react6.useState)(false);
  const copiedTimeout = (0, import_react6.useRef)(null);
  const handleClick = (evt) => {
    if (copied) {
      return;
    }
    setCopied(true);
    onClick?.(evt);
    copyToClipboard(typeof copyValue === "function" ? copyValue() : copyValue);
    copiedTimeout.current = window.setTimeout(() => {
      setCopied(false);
    }, 1300);
  };
  (0, import_react6.useEffect)(() => {
    return () => {
      if (copiedTimeout.current)
        clearTimeout(copiedTimeout.current);
    };
  }, []);
  return (0, import_jsx_runtime6.jsxs)(Button, { ...restProps, onClick: handleClick, children: [(0, import_jsx_runtime6.jsx)(Animate, { className: "w-[var(--button-icon-size)] h-[var(--button-icon-size)]", initial: { scale: 0.6 }, enter: { scale: 1, delay: 150, duration: 300 }, exit: { scale: 0.6, duration: 150 }, forceCompositeLayer: true, children: copied ? (0, import_jsx_runtime6.jsx)(Check_default, {}, "copied-icon") : (0, import_jsx_runtime6.jsx)(Copy_default, {}, "copy-icon") }), typeof children === "function" ? children({ copied }) : children] });
};
export {
  Button,
  ButtonLink,
  CopyButton
};
//# sourceMappingURL=@openai_apps-sdk-ui_components_Button.js.map
