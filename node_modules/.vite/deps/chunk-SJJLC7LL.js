import {
  require_jsx_runtime
} from "./chunk-HNBNNEO4.js";
import {
  require_react
} from "./chunk-CTRVV34M.js";
import {
  __commonJS,
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/lodash.debounce/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.debounce/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = debounce2;
  }
});

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/Animate.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());

// node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o2 = e.length;
    for (t = 0; t < o2; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o2 = arguments.length; f < o2; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_default = clsx;

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/TransitionGroup.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react4 = __toESM(require_react());

// node_modules/react-merge-refs/dist/index.mjs
function o(f) {
  return (r2) => {
    f.forEach((n) => {
      typeof n == "function" ? n(r2) : n != null && (n.current = r2);
    });
  };
}

// node_modules/@openai/apps-sdk-ui/dist/es/lib/helpers.js
var import_react = __toESM(require_react());

// node_modules/@openai/apps-sdk-ui/dist/es/lib/environment.js
var META_ENV = typeof import.meta !== "undefined" ? import.meta.env : void 0;
var NODE_ENV = typeof process !== "undefined" && "development" ? "development" : "production";
var isDev = NODE_ENV === "development" || !!META_ENV?.DEV;
var isJSDomLike = typeof navigator !== "undefined" && /(jsdom|happy-dom)/i.test(navigator.userAgent) || typeof globalThis.happyDOM === "object";
var isTest = NODE_ENV === "test" || META_ENV?.MODE === "test" || isJSDomLike;
var hasWindow = typeof window !== "undefined";
var hasDocument = typeof document !== "undefined";
var canUseDOM = hasWindow && hasDocument;

// node_modules/@openai/apps-sdk-ui/dist/es/lib/helpers.js
var handlePressableMouseEnter = (evt) => {
  const target = evt.currentTarget;
  if (!(target instanceof HTMLElement)) {
    return;
  }
  const elementWidth = target.offsetWidth;
  let scale = 0.985;
  if (elementWidth <= 80) {
    scale = 0.96;
  } else if (elementWidth <= 150) {
    scale = 0.97;
  } else if (elementWidth <= 220) {
    scale = 0.98;
  } else if (elementWidth > 600) {
    scale = 0.995;
  }
  target.style.setProperty("--scale", scale.toString());
};
var waitForAnimationFrame = (cb, options) => {
  const runAfterTick = () => {
    const id = setTimeout(cb);
    return () => {
      clearTimeout(id);
    };
  };
  if (!canUseDOM || typeof window.requestAnimationFrame !== "function") {
    return runAfterTick();
  }
  const visibilityHidden = hasDocument && document.visibilityState === "hidden";
  if (visibilityHidden) {
    return runAfterTick();
  }
  let frames = options?.frames ?? 2;
  let animationFrame = window.requestAnimationFrame(function recurse() {
    frames -= 1;
    if (frames === 0) {
      cb();
    } else {
      animationFrame = window.requestAnimationFrame(recurse);
    }
  });
  return () => {
    if (typeof window.cancelAnimationFrame === "function") {
      window.cancelAnimationFrame(animationFrame);
    }
  };
};
var toCssVariables = (variables) => {
  const formattedVariables = Object.keys(variables).reduce((acc, variable) => {
    const value = variables[variable];
    if (value || value === 0) {
      const prefix = variable.startsWith("--") ? "" : "--";
      const formattedValue = typeof value === "number" ? `${value}px` : value;
      acc[`${prefix}${variable}`] = formattedValue;
    }
    return acc;
  }, {});
  return formattedVariables;
};
var toAngle = (value) => typeof value === "number" ? `${value}deg` : value;
var toOpacityProperty = (opacity) => String(opacity);
var toMsDurationProperty = (duration) => `${duration}ms`;
var toTransformProperty = ({ x, y, scale, rotate, skewX, skewY } = {}) => {
  const transforms = [
    x == null ? null : `translateX(${x}px)`,
    y == null ? null : `translateY(${y}px)`,
    scale == null ? null : `scale(${scale})`,
    rotate == null ? null : `rotate(${toAngle(rotate)})`,
    skewX == null ? null : `skewX(${toAngle(skewX)})`,
    skewY == null ? null : `skewY(${toAngle(skewY)})`
  ].filter(Boolean);
  return transforms.length ? transforms.join(" ") : "none";
};
var toFilterProperty = ({ blur } = {}) => {
  const filters = [blur == null ? null : `blur(${blur}px)`].filter(Boolean);
  return filters.length ? filters.join(" ") : "none";
};

// node_modules/usehooks-ts/dist/index.js
var import_react2 = __toESM(require_react());
var import_lodash = __toESM(require_lodash());
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react2.useLayoutEffect : import_react2.useEffect;
function useTimeout(callback, delay) {
  const savedCallback = (0, import_react2.useRef)(callback);
  useIsomorphicLayoutEffect(() => {
    savedCallback.current = callback;
  }, [callback]);
  (0, import_react2.useEffect)(() => {
    if (!delay && delay !== 0) {
      return;
    }
    const id = setTimeout(() => {
      savedCallback.current();
    }, delay);
    return () => {
      clearTimeout(id);
    };
  }, [delay]);
}

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/getDisableAnimations.js
var getDisableAnimations_default = () => isTest;

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/shared.js
var import_react3 = __toESM(require_react());
var NonNullChildren = (children) => import_react3.Children.toArray(children).filter((child) => child !== null && child !== void 0);
var ChildrenWithKeys = (children, shouldThrow = false, componentName = "TransitionGroup") => {
  const validChildren = [];
  import_react3.Children.forEach(children, (child) => {
    if (child && typeof child === "object" && "key" in child && !!child.key) {
      validChildren.push(child);
    } else if (shouldThrow) {
      throw new Error(`Child elements of <${componentName} /> must include a \`key\``);
    }
  });
  return validChildren;
};
var noop = () => {
};
var useChildCallback = (cb) => {
  const ref = (0, import_react3.useRef)(cb);
  ref.current = cb;
  return (0, import_react3.useCallback)((element) => ref.current(element), []);
};
function computeNextRenderChildren(propChildrenArray, currentRenderChildren, createDefaultRenderChildProps, insertMethod) {
  const propChildKeyMap = propChildrenArray.reduce((acc, child) => ({ ...acc, [child.key]: 1 }), {});
  const currentRenderChildKeyMap = currentRenderChildren.reduce((acc, child) => ({ ...acc, [child.component.key]: 1 }), {});
  const newRenderChildren = propChildrenArray.filter((propChild) => !currentRenderChildKeyMap[propChild.key]).map(createDefaultRenderChildProps);
  const updatedCurrentChildren = currentRenderChildren.map((childProps) => ({
    ...childProps,
    component: propChildrenArray.find(({ key }) => key === childProps.component.key) || childProps.component,
    shouldRender: !!propChildKeyMap[childProps.component.key]
  }));
  return insertMethod === "append" ? updatedCurrentChildren.concat(newRenderChildren) : newRenderChildren.concat(updatedCurrentChildren);
}
function assertSingleChildWhenRef(componentName, ref, childrenCount) {
  if ((isTest || isDev) && ref && childrenCount > 1) {
    throw new Error(`Cannot use forwardRef with multiple children in <${componentName} />`);
  }
}

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/TransitionGroup.js
import s from "/Users/pranav/Documents/YChackMCP1/OrganizeEventAgent/OpsDock/node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/TransitionGroup.module.css";

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/transitionReducer.js
var RESTING_TRANSITION_STATE = {
  enter: false,
  enterActive: false,
  exit: false,
  exitActive: false,
  interrupted: false
};
var getInitialTransitionState = (preventMountTransition) => ({
  ...RESTING_TRANSITION_STATE,
  enter: !preventMountTransition
});
var transitionReducer = (state, action) => {
  switch (action.type) {
    case "enter-before":
      return {
        enter: true,
        enterActive: false,
        exit: false,
        exitActive: false,
        interrupted: state.interrupted || state.exit
      };
    case "enter-active":
      return {
        enter: true,
        enterActive: true,
        exit: false,
        exitActive: false,
        interrupted: false
      };
    case "exit-before":
      return {
        enter: false,
        enterActive: false,
        exit: true,
        exitActive: false,
        interrupted: state.interrupted || state.enter
      };
    case "exit-active":
      return {
        enter: false,
        enterActive: false,
        exit: true,
        exitActive: true,
        interrupted: false
      };
    case "done":
    default:
      return RESTING_TRANSITION_STATE;
  }
};

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/TransitionGroup.js
var TransitionGroupChildInner = ({ ref: forwardedRef, as: TagName, children, className, transitionId, style, preventMountTransition, shouldRender, enterDuration, exitDuration, removeChild, onEnter, onEnterActive, onEnterComplete, onExit, onExitActive, onExitComplete }) => {
  const [state, dispatch] = (0, import_react4.useReducer)(transitionReducer, getInitialTransitionState(preventMountTransition || false));
  const preventedMountTransition = (0, import_react4.useRef)(false);
  const elementRef = (0, import_react4.useRef)(null);
  const enterDurationRef = (0, import_react4.useRef)(enterDuration);
  enterDurationRef.current = enterDuration;
  const exitDurationRef = (0, import_react4.useRef)(exitDuration);
  exitDurationRef.current = exitDuration;
  const lastCallbackRef = (0, import_react4.useRef)(null);
  const triggerCallback = (0, import_react4.useCallback)((callbackType) => {
    const element = elementRef.current;
    if (!element || callbackType === lastCallbackRef.current) {
      return;
    }
    lastCallbackRef.current = callbackType;
    switch (callbackType) {
      case "enter":
        onEnter(element);
        break;
      case "enter-active":
        onEnterActive(element);
        break;
      case "enter-complete":
        onEnterComplete(element);
        break;
      case "exit":
        onExit(element);
        break;
      case "exit-active":
        onExitActive(element);
        break;
      case "exit-complete":
        onExitComplete(element);
        break;
      default:
        callbackType;
        break;
    }
  }, [onEnter, onEnterActive, onEnterComplete, onExit, onExitActive, onExitComplete]);
  import_react4.default.useLayoutEffect(() => {
    if (!shouldRender) {
      let exitTimeout;
      dispatch({ type: "exit-before" });
      triggerCallback("exit");
      const cancelAnimationFrame2 = waitForAnimationFrame(() => {
        dispatch({ type: "exit-active" });
        triggerCallback("exit-active");
        exitTimeout = window.setTimeout(() => {
          triggerCallback("exit-complete");
          removeChild();
        }, exitDurationRef.current);
      });
      return () => {
        cancelAnimationFrame2();
        if (exitTimeout !== void 0)
          clearTimeout(exitTimeout);
      };
    }
    if (preventMountTransition && !preventedMountTransition.current) {
      preventedMountTransition.current = true;
      return;
    }
    let enterTimeout;
    dispatch({ type: "enter-before" });
    triggerCallback("enter");
    const cancelAnimationFrame = waitForAnimationFrame(() => {
      dispatch({ type: "enter-active" });
      triggerCallback("enter-active");
      enterTimeout = window.setTimeout(() => {
        dispatch({ type: "done" });
        triggerCallback("enter-complete");
      }, enterDurationRef.current);
    });
    return () => {
      cancelAnimationFrame();
      if (enterTimeout !== void 0)
        clearTimeout(enterTimeout);
    };
  }, [
    shouldRender,
    // This value is immutable after <TransitionGroup> is created, and does not change on re-renders.
    preventMountTransition,
    removeChild,
    triggerCallback
  ]);
  (0, import_react4.useEffect)(() => {
    return () => {
      preventedMountTransition.current = false;
    };
  }, []);
  return (0, import_jsx_runtime.jsx)(TagName, { ref: o([elementRef, forwardedRef]), className: clsx_default(className, s.TransitionGroupChild), "data-transition-id": transitionId, style, "data-entering": state.enter ? "" : void 0, "data-entering-active": state.enterActive ? "" : void 0, "data-exiting": state.exit ? "" : void 0, "data-exiting-active": state.exitActive ? "" : void 0, "data-interrupted": state.interrupted ? "" : void 0, children });
};
var TransitionGroupChild = (props) => {
  const { enterMountDelay, preventMountTransition } = props;
  const mountDelay = !preventMountTransition && enterMountDelay != null ? enterMountDelay : null;
  const [mounted, setMounted] = (0, import_react4.useState)(mountDelay == null);
  useTimeout(() => setMounted(true), mounted ? null : mountDelay);
  return mounted ? (0, import_jsx_runtime.jsx)(TransitionGroupChildInner, { ...props }) : null;
};
var TransitionGroup = (props) => {
  const { ref: forwardedRef, as: TagName = "span", children, className, transitionId, style, enterDuration = 0, exitDuration = 0, preventInitialTransition = true, enterMountDelay, insertMethod = "append", disableAnimations = getDisableAnimations_default() } = props;
  const onEnter = useChildCallback(props.onEnter ?? noop);
  const onEnterActive = useChildCallback(props.onEnterActive ?? noop);
  const onEnterComplete = useChildCallback(props.onEnterComplete ?? noop);
  const onExit = useChildCallback(props.onExit ?? noop);
  const onExitActive = useChildCallback(props.onExitActive ?? noop);
  const onExitComplete = useChildCallback(props.onExitComplete ?? noop);
  import_react4.Children.forEach(children, (child) => {
    if (child && !child.key) {
      throw new Error("Child elements of <TransitionGroup /> must include a `key`");
    }
  });
  const createDefaultRenderChildProps = (0, import_react4.useCallback)((child) => ({
    component: child,
    shouldRender: true,
    removeChild: () => {
      setRenderChildren((currentRenderChildren) => currentRenderChildren.filter((c) => child.key !== c.component.key));
    },
    onEnter,
    onEnterActive,
    onEnterComplete,
    onExit,
    onExitActive,
    onExitComplete
  }), [onEnter, onEnterActive, onEnterComplete, onExit, onExitActive, onExitComplete]);
  const [renderChildren, setRenderChildren] = (0, import_react4.useState)(() => {
    return ChildrenWithKeys(children).map((child) => ({
      ...createDefaultRenderChildProps(child),
      // Lock this value to whatever the value was on initial render of the TransitionGroup.
      // It doesn't make sense to change this once it is mounted.
      preventMountTransition: preventInitialTransition
    }));
  });
  (0, import_react4.useLayoutEffect)(() => {
    setRenderChildren((currentRenderChildren) => {
      const propChildrenArray = ChildrenWithKeys(children);
      return computeNextRenderChildren(propChildrenArray, currentRenderChildren, createDefaultRenderChildProps, insertMethod);
    });
  }, [children, insertMethod, createDefaultRenderChildProps]);
  assertSingleChildWhenRef("TransitionGroup", forwardedRef, import_react4.Children.count(children));
  if (disableAnimations) {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: import_react4.Children.map(children, (child) => (0, import_jsx_runtime.jsx)(
      TagName,
      {
        // @ts-expect-error -- TS is not happy about this forwardedRef, but it's fine.
        ref: forwardedRef,
        className,
        style,
        "data-transition-id": transitionId,
        children: child
      }
    )) });
  }
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: renderChildren.map(({ component, ...restProps }) => (0, import_jsx_runtime.jsx)(TransitionGroupChild, { ...restProps, as: TagName, className, transitionId, enterDuration, exitDuration, enterMountDelay, style, ref: forwardedRef, children: component }, component.key)) });
};

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/Animate.js
var import_react5 = __toESM(require_react());
import s2 from "/Users/pranav/Documents/YChackMCP1/OrganizeEventAgent/OpsDock/node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/Animate.module.css";
var Animate = (props) => {
  const { as: TagName = "span", className, children, preventInitialTransition, insertMethod, transitionClassName, transitionPosition = "absolute" } = props;
  const { enterTotalDuration, exitTotalDuration, variables } = getAnimationProperties(props);
  return (0, import_jsx_runtime2.jsx)(TagName, { className: clsx_default("block", transitionPosition === "absolute" && "relative", className), "data-transition-position": transitionPosition, style: variables, children: (0, import_jsx_runtime2.jsx)(TransitionGroup, { as: TagName, className: clsx_default(s2.TransitionItem, transitionClassName), enterDuration: enterTotalDuration, exitDuration: exitTotalDuration, insertMethod, preventInitialTransition, children }) });
};
var DEFAULT_ENTER_DURATION_MS_EASE = 400;
var DEFAULT_ENTER_DURATION_MS_CUBIC = 500;
var DEFAULT_EXIT_DURATION_MS_EASE = 200;
var DEFAULT_EXIT_DURATION_MS_CUBIC = 300;
function getAnimationProperties({ initial, enter, exit, forceCompositeLayer }) {
  const initialTransform = toTransformProperty(initial);
  const enterTransform = toTransformProperty(enter);
  const exitTransform = toTransformProperty(exit);
  const isCubicTransition = [initialTransform, exitTransform, enterTransform].some((t) => t !== "none");
  const enterDuration = enter?.duration ?? (isCubicTransition ? DEFAULT_ENTER_DURATION_MS_CUBIC : DEFAULT_ENTER_DURATION_MS_EASE);
  const enterTimingFunction = enter?.timingFunction ?? (isCubicTransition ? "var(--cubic-enter)" : "ease");
  const exitDuration = exit?.duration ?? (isCubicTransition ? DEFAULT_EXIT_DURATION_MS_CUBIC : DEFAULT_EXIT_DURATION_MS_EASE);
  const exitTimingFunction = exit?.timingFunction ?? (isCubicTransition ? "var(--cubic-exit)" : "ease");
  const variables = toCssVariables({
    "tg-will-change": forceCompositeLayer ? "transform, opacity" : "auto",
    "tg-enter-opacity": toOpacityProperty(enter?.opacity ?? 1),
    "tg-enter-transform": enterTransform,
    "tg-enter-filter": toFilterProperty(enter),
    "tg-enter-duration": toMsDurationProperty(enterDuration),
    "tg-enter-delay": toMsDurationProperty(enter?.delay ?? 0),
    "tg-enter-timing-function": enterTimingFunction,
    "tg-exit-opacity": toOpacityProperty(exit?.opacity ?? 0),
    "tg-exit-transform": exitTransform,
    "tg-exit-filter": toFilterProperty(exit),
    "tg-exit-duration": toMsDurationProperty(exitDuration),
    "tg-exit-delay": toMsDurationProperty(exit?.delay ?? 0),
    "tg-exit-timing-function": exitTimingFunction,
    "tg-initial-opacity": toOpacityProperty(initial?.opacity ?? exit?.opacity ?? 0),
    "tg-initial-transform": initialTransform === "none" ? exitTransform : initialTransform,
    "tg-initial-filter": toFilterProperty(initial ?? exit ?? {})
  });
  const enterTotalDuration = (enter?.delay ?? 0) + enterDuration;
  const exitTotalDuration = (exit?.delay ?? 0) + exitDuration;
  return { enterTotalDuration, exitTotalDuration, variables };
}

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/AnimateLayout.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var import_react6 = __toESM(require_react());
import s3 from "/Users/pranav/Documents/YChackMCP1/OrganizeEventAgent/OpsDock/node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/AnimateLayout.module.css";
var AnimateLayout = (props) => {
  const {
    as: TagName = "span",
    children,
    transitionClassName,
    insertMethod,
    className,
    hideOverflow = false,
    // An initial height animation will almost never be correct. Consider carefully when overriding.
    preventInitialTransition = true,
    itemAnchor = "start",
    dimension = "height"
  } = props;
  const containerRef = (0, import_react6.useRef)(null);
  const captainRef = (0, import_react6.useRef)(null);
  const exitTimestampRef = (0, import_react6.useRef)(null);
  const { enterTotalDuration, exitTotalDuration, variables } = getAnimationProperties2(props);
  const handleEnter = (element) => {
    const container = containerRef.current;
    if (!container) {
      return;
    }
    const justExited = exitTimestampRef.current && Date.now() - exitTimestampRef.current < 50;
    const anotherCaptain = !!captainRef.current;
    captainRef.current = element;
    container.dataset.direction = justExited || anotherCaptain ? "move" : "in";
    if (!justExited) {
      container.dataset.interrupted = String(!!container.style[dimension]);
    }
    const clientRect = container.getBoundingClientRect();
    container.style[dimension] = `${clientRect[dimension]}px`;
  };
  const handleEnterActive = (element) => {
    const container = containerRef.current;
    if (!container) {
      return;
    }
    const amICaptain = captainRef.current === element;
    if (!amICaptain) {
      return;
    }
    const value = dimension === "width" ? element.clientWidth : element.clientHeight;
    container.style[dimension] = `${value}px`;
  };
  const handleEnterComplete = (element) => {
    const container = containerRef.current;
    waitForAnimationFrame(() => {
      const amICaptain = captainRef.current === element;
      if (!container || !amICaptain) {
        return;
      }
      container.style[dimension] = "";
    });
  };
  const handleExit = (element) => {
    const container = containerRef.current;
    const amICaptain = !captainRef.current || captainRef.current === element;
    if (!container || !amICaptain) {
      return;
    }
    captainRef.current = null;
    exitTimestampRef.current = Date.now();
    container.dataset.direction = "out";
    container.dataset.interrupted = String(!!container.style[dimension]);
    const clientRect = container.getBoundingClientRect();
    container.style[dimension] = `${clientRect[dimension]}px`;
  };
  const handleExitActive = (_element) => {
    const container = containerRef.current;
    const newCaptainExists = !!captainRef.current;
    if (!container || newCaptainExists) {
      return;
    }
    container.style[dimension] = "0";
  };
  const handleExitComplete = (_element) => {
    waitForAnimationFrame(() => {
      const container = containerRef.current;
      const newCaptainExists = !!captainRef.current;
      if (!container || newCaptainExists) {
        return;
      }
      container.style[dimension] = "";
    });
  };
  return (0, import_jsx_runtime3.jsx)(TagName, { ref: containerRef, className: clsx_default(s3.Layout, className), style: variables, "data-item-anchor": itemAnchor, "data-clip": hideOverflow, "data-dimension": dimension, children: (0, import_jsx_runtime3.jsx)(TransitionGroup, { as: TagName, className: clsx_default(s3.TransitionItem, transitionClassName), insertMethod, enterDuration: enterTotalDuration, exitDuration: exitTotalDuration, preventInitialTransition, onEnter: handleEnter, onEnterActive: handleEnterActive, onEnterComplete: handleEnterComplete, onExit: handleExit, onExitActive: handleExitActive, onExitComplete: handleExitComplete, children }) });
};
var DEFAULT_LAYOUT_ENTER_DURATION_MS = 300;
var DEFAULT_LAYOUT_ENTER_DELAY_MS = 0;
var DEFAULT_LAYOUT_EXIT_DURATION_MS = 300;
var DEFAULT_LAYOUT_EXIT_DELAY_MS = 0;
var DEFAULT_LAYOUT_MOVE_DURATION_MS = 300;
var DEFAULT_LAYOUT_MOVE_DELAY_MS = 0;
var DEFAULT_ENTER_DURATION_MS_EASE2 = 300;
var DEFAULT_ENTER_DURATION_MS_CUBIC2 = 300;
var DEFAULT_ENTER_DELAY_MS = 100;
var DEFAULT_EXIT_DURATION_MS_EASE2 = 200;
var DEFAULT_EXIT_DURATION_MS_CUBIC2 = 200;
var DEFAULT_EXIT_DELAY_MS = 0;
function getAnimationProperties2({ initial, enter, exit, forceCompositeLayer, layoutEnter, layoutExit, layoutMove }) {
  const initialTransform = toTransformProperty(initial);
  const enterTransform = toTransformProperty(enter);
  const exitTransform = toTransformProperty(exit);
  const isCubicTransition = [initialTransform, exitTransform, enterTransform].some((t) => t !== "none");
  const enterDuration = enter?.duration ?? (isCubicTransition ? DEFAULT_ENTER_DURATION_MS_CUBIC2 : DEFAULT_ENTER_DURATION_MS_EASE2);
  const enterTimingFunction = enter?.timingFunction ?? (isCubicTransition ? "var(--cubic-enter)" : "ease");
  const exitDuration = exit?.duration ?? (isCubicTransition ? DEFAULT_EXIT_DURATION_MS_CUBIC2 : DEFAULT_EXIT_DURATION_MS_EASE2);
  const exitTimingFunction = exit?.timingFunction ?? (isCubicTransition ? "var(--cubic-exit)" : "ease");
  const variables = toCssVariables({
    "tg-will-change": forceCompositeLayer ? "transform, opacity" : "auto",
    "tg-enter-opacity": toOpacityProperty(enter?.opacity ?? 1),
    "tg-enter-transform": enterTransform,
    "tg-enter-filter": toFilterProperty(enter),
    "tg-enter-duration": toMsDurationProperty(enterDuration),
    "tg-enter-delay": toMsDurationProperty(enter?.delay ?? DEFAULT_ENTER_DELAY_MS),
    "tg-enter-timing-function": enterTimingFunction,
    "tg-exit-opacity": toOpacityProperty(exit?.opacity ?? 0),
    "tg-exit-transform": exitTransform,
    "tg-exit-filter": toFilterProperty(exit ?? {}),
    "tg-exit-duration": toMsDurationProperty(exitDuration),
    "tg-exit-delay": toMsDurationProperty(exit?.delay ?? DEFAULT_EXIT_DELAY_MS),
    "tg-exit-timing-function": exitTimingFunction,
    "tg-initial-opacity": toOpacityProperty(initial?.opacity ?? exit?.opacity ?? 0),
    "tg-initial-transform": initialTransform === "none" ? exitTransform : initialTransform,
    "tg-initial-filter": toFilterProperty(initial ?? exit ?? {}),
    "tg-layout-enter-duration": toMsDurationProperty(layoutEnter?.duration ?? DEFAULT_LAYOUT_ENTER_DURATION_MS),
    "tg-layout-enter-delay": toMsDurationProperty(layoutEnter?.delay ?? DEFAULT_LAYOUT_ENTER_DELAY_MS),
    "tg-layout-enter-timing-function": layoutEnter?.timingFunction ?? "var(--cubic-move)",
    "tg-layout-exit-duration": toMsDurationProperty(layoutExit?.duration ?? DEFAULT_LAYOUT_EXIT_DURATION_MS),
    "tg-layout-exit-delay": toMsDurationProperty(layoutExit?.delay ?? DEFAULT_LAYOUT_EXIT_DELAY_MS),
    "tg-layout-exit-timing-function": layoutExit?.timingFunction ?? "var(--cubic-move)",
    "tg-layout-move-duration": toMsDurationProperty(layoutMove?.duration ?? DEFAULT_LAYOUT_MOVE_DURATION_MS),
    "tg-layout-move-delay": toMsDurationProperty(layoutMove?.delay ?? DEFAULT_LAYOUT_MOVE_DELAY_MS),
    "tg-layout-move-timing-function": layoutMove?.timingFunction ?? "var(--cubic-move)"
  });
  const enterTotalDuration = (enter?.delay ?? DEFAULT_ENTER_DELAY_MS) + (enterDuration ?? DEFAULT_ENTER_DURATION_MS_EASE2);
  const exitTotalDuration = (exit?.delay ?? DEFAULT_EXIT_DELAY_MS) + (exitDuration ?? DEFAULT_EXIT_DURATION_MS_EASE2);
  const layoutEnterTotalDuration = (layoutEnter?.delay ?? DEFAULT_LAYOUT_ENTER_DELAY_MS) + (layoutEnter?.duration ?? DEFAULT_LAYOUT_ENTER_DURATION_MS);
  const layoutExitTotalDuration = (layoutExit?.delay ?? DEFAULT_LAYOUT_EXIT_DELAY_MS) + (layoutExit?.duration ?? DEFAULT_LAYOUT_EXIT_DURATION_MS);
  const layoutMoveTotalDuration = (layoutMove?.delay ?? DEFAULT_LAYOUT_MOVE_DELAY_MS) + (layoutMove?.duration ?? DEFAULT_LAYOUT_MOVE_DURATION_MS);
  return {
    // In order for us to release layout dimensions (e.g., height) to the natural DOM state,
    // we must ensure the behaviors from the TransitionGroup callbacks are synced with the outer layout `transitions`.
    // Setting TransitionGroup timing to the max of these durations is the simplest approach.
    // In practice, these should only vary by about 50-200ms at most; imperceivable to end-users.
    enterTotalDuration: Math.max(enterTotalDuration, layoutEnterTotalDuration, layoutMoveTotalDuration),
    exitTotalDuration: Math.max(exitTotalDuration, layoutExitTotalDuration, layoutMoveTotalDuration),
    variables
  };
}

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/AnimateLayoutGroup.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var import_react7 = __toESM(require_react());
import s4 from "/Users/pranav/Documents/YChackMCP1/OrganizeEventAgent/OpsDock/node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/AnimateLayoutGroup.module.css";
var AnimateLayoutGroup = (props) => {
  const { as: TagName = "span", children, className, transitionClassName, dimension = "height" } = props;
  const { enterTotalDuration, exitTotalDuration, variables } = getAnimationProperties3(props);
  const handleEnter = (element) => {
    element.style[dimension] = "0";
  };
  const handleEnterActive = (element) => {
    waitForAnimationFrame(() => {
      const value = dimension === "width" ? element.firstElementChild?.clientWidth : element.firstElementChild?.clientHeight;
      element.style[dimension] = `${value ?? 0}px`;
    });
  };
  const handleEnterComplete = (element) => {
    waitForAnimationFrame(() => {
      element.style[dimension] = "";
    });
  };
  const handleExit = (element) => {
    element.style[dimension] = `${element.getBoundingClientRect()[dimension]}px`;
  };
  const handleExitActive = (element) => {
    waitForAnimationFrame(() => {
      element.style[dimension] = "0";
    });
  };
  return (0, import_jsx_runtime4.jsx)(TransitionGroup, {
    as: TagName,
    className: clsx_default(s4.LayoutItem, className),
    style: variables,
    // Adding 32ms to timers because of the additional waitForAnimationFrame() calls
    enterDuration: enterTotalDuration + 32,
    exitDuration: exitTotalDuration + 32,
    onEnter: handleEnter,
    onEnterActive: handleEnterActive,
    onEnterComplete: handleEnterComplete,
    onExit: handleExit,
    onExitActive: handleExitActive,
    children: NonNullChildren(children).map((child) => (
      // Ensure any falsy child.key value is sent specifically as `undefined`.
      // This ensures that key is not misinterpreted as a string 'null', 'false', etc.
      (0, import_jsx_runtime4.jsx)(TagName, { className: clsx_default(s4.TransitionItem, transitionClassName), "data-dimension": dimension, children: child }, child.key || void 0)
    ))
  });
};
var DEFAULT_LAYOUT_ENTER_DURATION_MS2 = 300;
var DEFAULT_LAYOUT_ENTER_DELAY_MS2 = 0;
var DEFAULT_LAYOUT_EXIT_DURATION_MS2 = 300;
var DEFAULT_LAYOUT_EXIT_DELAY_MS2 = 50;
var DEFAULT_LAYOUT_MOVE_DURATION_MS2 = 300;
var DEFAULT_LAYOUT_MOVE_DELAY_MS2 = 0;
var DEFAULT_ENTER_DURATION_MS_EASE3 = 400;
var DEFAULT_ENTER_DURATION_MS_CUBIC3 = 400;
var DEFAULT_ENTER_DELAY_MS2 = 150;
var DEFAULT_EXIT_DURATION_MS_EASE3 = 200;
var DEFAULT_EXIT_DURATION_MS_CUBIC3 = 300;
var DEFAULT_EXIT_DELAY_MS2 = 0;
function getAnimationProperties3({ initial, enter, exit, forceCompositeLayer, layoutEnter, layoutExit, layoutMove }) {
  const initialTransform = toTransformProperty(initial);
  const enterTransform = toTransformProperty(enter);
  const exitTransform = toTransformProperty(exit);
  const isCubicTransition = [initialTransform, exitTransform, enterTransform].some((t) => t !== "none");
  const enterDuration = enter?.duration ?? (isCubicTransition ? DEFAULT_ENTER_DURATION_MS_CUBIC3 : DEFAULT_ENTER_DURATION_MS_EASE3);
  const enterTimingFunction = enter?.timingFunction ?? (isCubicTransition ? "var(--cubic-enter)" : "ease");
  const exitDuration = exit?.duration ?? (isCubicTransition ? DEFAULT_EXIT_DURATION_MS_CUBIC3 : DEFAULT_EXIT_DURATION_MS_EASE3);
  const exitTimingFunction = exit?.timingFunction ?? (isCubicTransition ? "var(--cubic-exit)" : "ease");
  const variables = toCssVariables({
    "tg-will-change": forceCompositeLayer ? "transform, opacity" : "auto",
    "tg-enter-opacity": toOpacityProperty(enter?.opacity ?? 1),
    "tg-enter-transform": enterTransform,
    "tg-enter-filter": toFilterProperty(enter ?? {}),
    "tg-enter-duration": toMsDurationProperty(enterDuration),
    "tg-enter-delay": toMsDurationProperty(enter?.delay ?? DEFAULT_ENTER_DELAY_MS2),
    "tg-enter-timing-function": enterTimingFunction,
    "tg-exit-opacity": toOpacityProperty(exit?.opacity ?? 0),
    "tg-exit-transform": exitTransform,
    "tg-exit-filter": toFilterProperty(exit ?? {}),
    "tg-exit-duration": toMsDurationProperty(exitDuration),
    "tg-exit-delay": toMsDurationProperty(exit?.delay ?? DEFAULT_EXIT_DELAY_MS2),
    "tg-exit-timing-function": exitTimingFunction,
    "tg-initial-opacity": toOpacityProperty(initial?.opacity ?? exit?.opacity ?? 0),
    "tg-initial-transform": initialTransform === "none" ? exitTransform : initialTransform,
    "tg-initial-filter": toFilterProperty(initial ?? exit ?? {}),
    "tg-layout-enter-duration": toMsDurationProperty(layoutEnter?.duration ?? DEFAULT_LAYOUT_ENTER_DURATION_MS2),
    "tg-layout-enter-delay": toMsDurationProperty(layoutEnter?.delay ?? DEFAULT_LAYOUT_ENTER_DELAY_MS2),
    "tg-layout-enter-timing-function": layoutEnter?.timingFunction ?? "var(--cubic-move)",
    "tg-layout-exit-duration": toMsDurationProperty(layoutExit?.duration ?? DEFAULT_LAYOUT_EXIT_DURATION_MS2),
    "tg-layout-exit-delay": toMsDurationProperty(layoutExit?.delay ?? DEFAULT_LAYOUT_EXIT_DELAY_MS2),
    "tg-layout-exit-timing-function": layoutExit?.timingFunction ?? "var(--cubic-move)",
    "tg-layout-move-duration": toMsDurationProperty(layoutMove?.duration ?? DEFAULT_LAYOUT_MOVE_DURATION_MS2),
    "tg-layout-move-delay": toMsDurationProperty(layoutMove?.delay ?? DEFAULT_LAYOUT_MOVE_DURATION_MS2),
    "tg-layout-move-timing-function": layoutMove?.timingFunction ?? "var(--cubic-move)"
  });
  const enterTotalDuration = (enter?.delay ?? DEFAULT_ENTER_DELAY_MS2) + (enterDuration ?? DEFAULT_ENTER_DURATION_MS_EASE3);
  const exitTotalDuration = (exit?.delay ?? DEFAULT_EXIT_DELAY_MS2) + (exitDuration ?? DEFAULT_EXIT_DURATION_MS_EASE3);
  const layoutEnterTotalDuration = (layoutEnter?.delay ?? DEFAULT_LAYOUT_ENTER_DELAY_MS2) + (layoutEnter?.duration ?? DEFAULT_LAYOUT_ENTER_DURATION_MS2);
  const layoutExitTotalDuration = (layoutExit?.delay ?? DEFAULT_LAYOUT_EXIT_DELAY_MS2) + (layoutExit?.duration ?? DEFAULT_LAYOUT_EXIT_DURATION_MS2);
  const layoutMoveTotalDuration = (layoutMove?.delay ?? DEFAULT_LAYOUT_MOVE_DELAY_MS2) + (layoutMove?.duration ?? DEFAULT_LAYOUT_MOVE_DURATION_MS2);
  return {
    // In order for us to release layout dimensions (e.g., height) to the natural DOM state,
    // we must ensure the behaviors from the TransitionGroup callbacks are synced with the outer layout `transitions`.
    // Setting TransitionGroup timing to the max of these durations is the simplest approach.
    // In practice, these should only vary by about 50-200ms at most; imperceivable to end-users.
    enterTotalDuration: Math.max(enterTotalDuration, layoutEnterTotalDuration, layoutMoveTotalDuration),
    exitTotalDuration: Math.max(exitTotalDuration, layoutExitTotalDuration, layoutMoveTotalDuration),
    variables
  };
}

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/SlotTransitionGroup.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var import_react8 = __toESM(require_react());
var SlotTransitionGroupChildInner = ({ ref, component, preventMountTransition, shouldRender, enterDuration, exitDuration, removeChild, onEnter, onEnterActive, onEnterComplete, onExit, onExitActive, onExitComplete }) => {
  const [state, dispatch] = (0, import_react8.useReducer)(transitionReducer, getInitialTransitionState(preventMountTransition || false));
  const preventedMountTransition = (0, import_react8.useRef)(false);
  const elementRef = (0, import_react8.useRef)(null);
  const enterDurationRef = (0, import_react8.useRef)(enterDuration);
  enterDurationRef.current = enterDuration;
  const exitDurationRef = (0, import_react8.useRef)(exitDuration);
  exitDurationRef.current = exitDuration;
  const lastCallbackRef = (0, import_react8.useRef)(null);
  const triggerCallback = (0, import_react8.useCallback)((callbackType) => {
    const element = elementRef.current;
    if (!element || callbackType === lastCallbackRef.current) {
      return;
    }
    lastCallbackRef.current = callbackType;
    switch (callbackType) {
      case "enter":
        onEnter(element);
        break;
      case "enter-active":
        onEnterActive(element);
        break;
      case "enter-complete":
        onEnterComplete(element);
        break;
      case "exit":
        onExit(element);
        break;
      case "exit-active":
        onExitActive(element);
        break;
      case "exit-complete":
        onExitComplete(element);
        break;
      default:
        callbackType;
        break;
    }
  }, [onEnter, onEnterActive, onEnterComplete, onExit, onExitActive, onExitComplete]);
  (0, import_react8.useLayoutEffect)(() => {
    if (!shouldRender) {
      let exitTimeout;
      dispatch({ type: "exit-before" });
      triggerCallback("exit");
      const cancelAnimationFrame2 = waitForAnimationFrame(() => {
        dispatch({ type: "exit-active" });
        triggerCallback("exit-active");
        exitTimeout = window.setTimeout(() => {
          triggerCallback("exit-complete");
          removeChild();
        }, exitDurationRef.current);
      });
      return () => {
        cancelAnimationFrame2();
        if (exitTimeout !== void 0)
          clearTimeout(exitTimeout);
      };
    }
    if (preventMountTransition && !preventedMountTransition.current) {
      preventedMountTransition.current = true;
      return;
    }
    let enterTimeout;
    dispatch({ type: "enter-before" });
    triggerCallback("enter");
    const cancelAnimationFrame = waitForAnimationFrame(() => {
      dispatch({ type: "enter-active" });
      triggerCallback("enter-active");
      enterTimeout = window.setTimeout(() => {
        dispatch({ type: "done" });
        triggerCallback("enter-complete");
      }, enterDurationRef.current);
    });
    return () => {
      cancelAnimationFrame();
      if (enterTimeout !== void 0)
        clearTimeout(enterTimeout);
    };
  }, [
    shouldRender,
    // This value is immutable after <SlotTransitionGroup> is created, and does not change on re-renders.
    preventMountTransition,
    removeChild,
    triggerCallback
  ]);
  (0, import_react8.useEffect)(() => {
    return () => {
      preventedMountTransition.current = false;
    };
  }, []);
  const original = component;
  const mergedRef = o([
    elementRef,
    ref,
    original.ref ?? null
  ]);
  const nextProps = {
    "data-entering": state.enter ? "" : void 0,
    "data-entering-active": state.enterActive ? "" : void 0,
    "data-exiting": state.exit ? "" : void 0,
    "data-exiting-active": state.exitActive ? "" : void 0,
    "data-interrupted": state.interrupted ? "" : void 0,
    "ref": mergedRef
  };
  return import_react8.default.isValidElement(original) ? import_react8.default.cloneElement(original, nextProps) : null;
};
var SlotTransitionGroupChild = (props) => {
  const { enterMountDelay, preventMountTransition } = props;
  const mountDelay = !preventMountTransition && enterMountDelay != null ? enterMountDelay : null;
  const [mounted, setMounted] = (0, import_react8.useState)(mountDelay == null);
  useTimeout(() => setMounted(true), mounted ? null : mountDelay);
  return mounted ? (0, import_jsx_runtime5.jsx)(SlotTransitionGroupChildInner, { ...props }) : null;
};
var SlotTransitionGroup = (props) => {
  const { ref, children, enterDuration = 0, exitDuration = 0, preventInitialTransition = true, enterMountDelay, insertMethod = "append", disableAnimations = getDisableAnimations_default() } = props;
  const onEnter = useChildCallback(props.onEnter ?? noop);
  const onEnterActive = useChildCallback(props.onEnterActive ?? noop);
  const onEnterComplete = useChildCallback(props.onEnterComplete ?? noop);
  const onExit = useChildCallback(props.onExit ?? noop);
  const onExitActive = useChildCallback(props.onExitActive ?? noop);
  const onExitComplete = useChildCallback(props.onExitComplete ?? noop);
  import_react8.Children.forEach(children, (child) => {
    if (child && !child.key) {
      throw new Error("Child elements of <SlotTransitionGroup /> must include a `key`");
    }
  });
  const createDefaultRenderChildProps = (0, import_react8.useCallback)((child) => ({
    component: child,
    shouldRender: true,
    removeChild: () => {
      setRenderChildren((currentRenderChildren) => currentRenderChildren.filter((c) => child.key !== c.component.key));
    },
    onEnter,
    onEnterActive,
    onEnterComplete,
    onExit,
    onExitActive,
    onExitComplete
  }), [onEnter, onEnterActive, onEnterComplete, onExit, onExitActive, onExitComplete]);
  const [renderChildren, setRenderChildren] = (0, import_react8.useState)(() => {
    return ChildrenWithKeys(children).map((child) => ({
      ...createDefaultRenderChildProps(child),
      // Lock this value to whatever the value was on initial render of the group.
      preventMountTransition: preventInitialTransition
    }));
  });
  (0, import_react8.useLayoutEffect)(() => {
    setRenderChildren((currentRenderChildren) => {
      const propChildrenArray = ChildrenWithKeys(children, false, "SlotTransitionGroup");
      return computeNextRenderChildren(propChildrenArray, currentRenderChildren, createDefaultRenderChildProps, insertMethod);
    });
  }, [children, insertMethod, createDefaultRenderChildProps]);
  assertSingleChildWhenRef("SlotTransitionGroup", ref, import_react8.Children.count(children));
  if (disableAnimations) {
    if (!ref) {
      return (0, import_jsx_runtime5.jsx)(import_jsx_runtime5.Fragment, { children });
    }
    return (0, import_jsx_runtime5.jsx)(import_jsx_runtime5.Fragment, { children: import_react8.Children.map(children, (child) => {
      if (!import_react8.default.isValidElement(child))
        return child;
      const original = child;
      const merged = o([
        ref,
        original.ref ?? null
      ]);
      const nextProps = { ref: merged };
      return import_react8.default.cloneElement(original, nextProps);
    }) });
  }
  return (0, import_jsx_runtime5.jsx)(import_jsx_runtime5.Fragment, { children: renderChildren.map(({ component, ...restProps }) => (0, import_jsx_runtime5.jsx)(SlotTransitionGroupChild, { ...restProps, component, enterDuration, exitDuration, enterMountDelay, ref }, component.key)) });
};

export {
  clsx_default,
  handlePressableMouseEnter,
  toCssVariables,
  TransitionGroup,
  Animate,
  AnimateLayout,
  AnimateLayoutGroup,
  SlotTransitionGroup
};
//# sourceMappingURL=chunk-SJJLC7LL.js.map
