#!/usr/bin/env node
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/server/cli.ts
import { serve } from "@hono/node-server";
import { Hono } from "hono";
import { cors } from "hono/cors";
import { logger } from "hono/logger";
import open from "open";

// src/server/shared-routes.ts
import { mountMcpProxy, mountOAuthProxy } from "mcp-use/server";

// src/server/shared-utils.ts
function toBase64(str) {
  if (typeof window !== "undefined" && typeof window.btoa === "function") {
    return window.btoa(str);
  }
  if (typeof Buffer !== "undefined") {
    return Buffer.from(str).toString("base64");
  }
  throw new Error("No base64 encoding method available");
}
async function* handleChatRequestStream(requestBody) {
  const { mcpServerUrl, llmConfig, authConfig, messages } = requestBody;
  if (!mcpServerUrl || !llmConfig || !messages) {
    throw new Error(
      "Missing required fields: mcpServerUrl, llmConfig, messages"
    );
  }
  const { MCPAgent, MCPClient } = await import("mcp-use");
  let llm;
  if (llmConfig.provider === "openai") {
    const { ChatOpenAI } = await import("@langchain/openai");
    llm = new ChatOpenAI({
      model: llmConfig.model,
      apiKey: llmConfig.apiKey
    });
  } else if (llmConfig.provider === "anthropic") {
    const { ChatAnthropic } = await import("@langchain/anthropic");
    llm = new ChatAnthropic({
      model: llmConfig.model,
      apiKey: llmConfig.apiKey
    });
  } else if (llmConfig.provider === "google") {
    const { ChatGoogleGenerativeAI } = await import("@langchain/google-genai");
    llm = new ChatGoogleGenerativeAI({
      model: llmConfig.model,
      apiKey: llmConfig.apiKey
    });
  } else {
    throw new Error(`Unsupported LLM provider: ${llmConfig.provider}`);
  }
  const client = new MCPClient();
  const serverName = `inspector-${Date.now()}`;
  const serverConfig = {
    url: mcpServerUrl,
    preventAutoAuth: true
    // Prevent auto OAuth popup - tokens are passed via headers
  };
  if (authConfig && authConfig.type !== "none") {
    serverConfig.headers = {};
    if (authConfig.type === "basic" && authConfig.username && authConfig.password) {
      const auth = toBase64(`${authConfig.username}:${authConfig.password}`);
      serverConfig.headers.Authorization = `Basic ${auth}`;
    } else if (authConfig.type === "bearer" && authConfig.token) {
      serverConfig.headers.Authorization = `Bearer ${authConfig.token}`;
    } else if (authConfig.type === "oauth") {
      if (authConfig.oauthTokens?.access_token) {
        const tokenType = authConfig.oauthTokens.token_type ? authConfig.oauthTokens.token_type.charAt(0).toUpperCase() + authConfig.oauthTokens.token_type.slice(1) : "Bearer";
        serverConfig.headers.Authorization = `${tokenType} ${authConfig.oauthTokens.access_token}`;
      }
    }
  }
  try {
    const url = new URL(mcpServerUrl);
    if (url.username && url.password && (!authConfig || authConfig.type === "none")) {
      const auth = toBase64(`${url.username}:${url.password}`);
      serverConfig.headers = serverConfig.headers || {};
      serverConfig.headers.Authorization = `Basic ${auth}`;
      serverConfig.url = `${url.protocol}//${url.host}${url.pathname}${url.search}`;
    }
  } catch (error) {
    console.warn("Failed to parse MCP server URL for auth:", error);
  }
  client.addServer(serverName, serverConfig);
  const agent = new MCPAgent({
    llm,
    client,
    maxSteps: 10,
    memoryEnabled: false,
    // Use externalHistory instead
    exposeResourcesAsTools: false,
    exposePromptsAsTools: false,
    systemPrompt: "You are a helpful assistant with access to MCP tools. Help users interact with the MCP server."
  });
  const { HumanMessage, AIMessage } = await import("@langchain/core/messages");
  const lastUserMessageIndex = messages.map((msg, i) => ({ msg, i })).filter(({ msg }) => msg.role === "user").pop()?.i;
  if (lastUserMessageIndex === void 0) {
    throw new Error("No user message found");
  }
  const lastUserMessage = messages[lastUserMessageIndex];
  const priorMessages = messages.slice(0, lastUserMessageIndex);
  const externalHistory = priorMessages.map((msg) => {
    if (msg.role === "user") {
      if (msg.attachments && msg.attachments.length > 0) {
        const content = [
          { type: "text", text: msg.content || "[no content]" }
        ];
        for (const attachment of msg.attachments) {
          if (attachment.type === "image") {
            content.push({
              type: "image_url",
              image_url: {
                url: `data:${attachment.mimeType};base64,${attachment.data}`
              }
            });
          }
        }
        return new HumanMessage({ content });
      }
      return new HumanMessage(msg.content || "[no content]");
    }
    return new AIMessage(msg.content || "[no content]");
  });
  let messageInput;
  if (lastUserMessage.attachments && lastUserMessage.attachments.length > 0) {
    const content = [
      {
        type: "text",
        text: lastUserMessage.content || "[no content]"
      }
    ];
    for (const attachment of lastUserMessage.attachments) {
      if (attachment.type === "image") {
        content.push({
          type: "image_url",
          image_url: {
            url: `data:${attachment.mimeType};base64,${attachment.data}`
          }
        });
      }
    }
    messageInput = new HumanMessage({ content });
  } else {
    messageInput = lastUserMessage.content;
  }
  try {
    const messageId = `msg-${Date.now()}`;
    yield `data: ${JSON.stringify({ type: "message", id: messageId, role: "assistant" })}

`;
    for await (const event of agent.streamEvents(
      messageInput,
      10,
      true,
      externalHistory
    )) {
      if (event.event === "on_chat_model_stream" && event.data?.chunk?.text) {
        const text = event.data.chunk.text;
        if (typeof text === "string" && text.length > 0) {
          yield `data: ${JSON.stringify({ type: "text", id: messageId, content: text })}

`;
        }
      } else if (event.event === "on_tool_start") {
        const toolCallId = `tool-${event.name}-${Date.now()}`;
        yield `data: ${JSON.stringify({
          type: "tool-call",
          id: messageId,
          toolCallId,
          toolName: event.name,
          args: event.data?.input || {}
        })}

`;
      } else if (event.event === "on_tool_end") {
        const toolCallId = `tool-${event.name}-${Date.now()}`;
        yield `data: ${JSON.stringify({
          type: "tool-result",
          id: messageId,
          toolCallId,
          toolName: event.name,
          result: event.data?.output
        })}

`;
      }
    }
    yield `data: ${JSON.stringify({ type: "done", id: messageId })}

`;
  } finally {
    await client.closeAllSessions();
  }
}
async function handleChatRequest(requestBody) {
  const { mcpServerUrl, llmConfig, authConfig, messages } = requestBody;
  if (!mcpServerUrl || !llmConfig || !messages) {
    throw new Error(
      "Missing required fields: mcpServerUrl, llmConfig, messages"
    );
  }
  const { MCPAgent, MCPClient } = await import("mcp-use");
  let llm;
  if (llmConfig.provider === "openai") {
    const { ChatOpenAI } = await import("@langchain/openai");
    llm = new ChatOpenAI({
      model: llmConfig.model,
      apiKey: llmConfig.apiKey
    });
  } else if (llmConfig.provider === "anthropic") {
    const { ChatAnthropic } = await import("@langchain/anthropic");
    llm = new ChatAnthropic({
      model: llmConfig.model,
      apiKey: llmConfig.apiKey
    });
  } else if (llmConfig.provider === "google") {
    const { ChatGoogleGenerativeAI } = await import("@langchain/google-genai");
    llm = new ChatGoogleGenerativeAI({
      model: llmConfig.model,
      apiKey: llmConfig.apiKey
    });
  } else {
    throw new Error(`Unsupported LLM provider: ${llmConfig.provider}`);
  }
  const client = new MCPClient();
  const serverName = `inspector-${Date.now()}`;
  const serverConfig = {
    url: mcpServerUrl,
    preventAutoAuth: true
    // Prevent auto OAuth popup - tokens are passed via headers
  };
  if (authConfig && authConfig.type !== "none") {
    serverConfig.headers = {};
    if (authConfig.type === "basic" && authConfig.username && authConfig.password) {
      const auth = toBase64(`${authConfig.username}:${authConfig.password}`);
      serverConfig.headers.Authorization = `Basic ${auth}`;
    } else if (authConfig.type === "bearer" && authConfig.token) {
      serverConfig.headers.Authorization = `Bearer ${authConfig.token}`;
    } else if (authConfig.type === "oauth") {
      if (authConfig.oauthTokens?.access_token) {
        const tokenType = authConfig.oauthTokens.token_type ? authConfig.oauthTokens.token_type.charAt(0).toUpperCase() + authConfig.oauthTokens.token_type.slice(1) : "Bearer";
        serverConfig.headers.Authorization = `${tokenType} ${authConfig.oauthTokens.access_token}`;
        console.log("Using OAuth access token for MCP server authentication");
        console.log(
          "Authorization header:",
          `${tokenType} ${authConfig.oauthTokens.access_token.substring(0, 20)}...`
        );
      } else {
        console.warn("OAuth selected but no access token provided");
      }
    }
  }
  try {
    const url = new URL(mcpServerUrl);
    if (url.username && url.password && (!authConfig || authConfig.type === "none")) {
      const auth = toBase64(`${url.username}:${url.password}`);
      serverConfig.headers = serverConfig.headers || {};
      serverConfig.headers.Authorization = `Basic ${auth}`;
      serverConfig.url = `${url.protocol}//${url.host}${url.pathname}${url.search}`;
    }
  } catch (error) {
    console.warn("Failed to parse MCP server URL for auth:", error);
  }
  console.log("Adding server with config:", {
    url: serverConfig.url,
    hasHeaders: !!serverConfig.headers,
    headers: serverConfig.headers
  });
  client.addServer(serverName, serverConfig);
  const agent = new MCPAgent({
    llm,
    client,
    maxSteps: 10,
    memoryEnabled: false,
    // Use externalHistory instead
    exposeResourcesAsTools: false,
    exposePromptsAsTools: false,
    systemPrompt: "You are a helpful assistant with access to MCP tools. Help users interact with the MCP server."
  });
  const { HumanMessage, AIMessage } = await import("@langchain/core/messages");
  const lastUserMessageIndex = messages.map((msg, i) => ({ msg, i })).filter(({ msg }) => msg.role === "user").pop()?.i;
  if (lastUserMessageIndex === void 0) {
    throw new Error("No user message found");
  }
  const lastUserMessage = messages[lastUserMessageIndex];
  const priorMessages = messages.slice(0, lastUserMessageIndex);
  const externalHistory = priorMessages.map((msg) => {
    if (msg.role === "user") {
      if (msg.attachments && msg.attachments.length > 0) {
        const content = [
          { type: "text", text: msg.content || "[no content]" }
        ];
        for (const attachment of msg.attachments) {
          if (attachment.type === "image") {
            content.push({
              type: "image_url",
              image_url: {
                url: `data:${attachment.mimeType};base64,${attachment.data}`
              }
            });
          }
        }
        return new HumanMessage({ content });
      }
      return new HumanMessage(msg.content || "[no content]");
    }
    return new AIMessage(msg.content || "[no content]");
  });
  let messageInput;
  if (lastUserMessage.attachments && lastUserMessage.attachments.length > 0) {
    const content = [
      {
        type: "text",
        text: lastUserMessage.content || "[no content]"
      }
    ];
    for (const attachment of lastUserMessage.attachments) {
      if (attachment.type === "image") {
        content.push({
          type: "image_url",
          image_url: {
            url: `data:${attachment.mimeType};base64,${attachment.data}`
          }
        });
      }
    }
    messageInput = new HumanMessage({ content });
  } else {
    messageInput = lastUserMessage.content;
  }
  const response = await agent.run(messageInput, 10, true, externalHistory);
  await client.closeAllSessions();
  return {
    content: response,
    toolCalls: []
  };
}
var widgetDataStore = /* @__PURE__ */ new Map();
setInterval(
  () => {
    const now = Date.now();
    const ONE_HOUR = 60 * 60 * 1e3;
    for (const [toolId, data] of widgetDataStore.entries()) {
      if (now - data.timestamp > ONE_HOUR) {
        widgetDataStore.delete(toolId);
      }
    }
  },
  5 * 60 * 1e3
).unref();
function storeWidgetData(data) {
  const {
    serverId,
    uri,
    toolInput,
    toolOutput,
    toolResponseMetadata,
    resourceData,
    toolId,
    widgetCSP,
    mcpAppsCsp,
    mcpAppsPermissions,
    devWidgetUrl,
    devServerBaseUrl,
    theme
  } = data;
  const debugWidget = process.env.DEBUG != null && process.env.DEBUG !== "" && process.env.DEBUG !== "0" && process.env.DEBUG.toLowerCase() !== "false";
  if (debugWidget) {
    console.log("[Widget Store] Received request for toolId:", toolId);
    console.log("[Widget Store] Fields:", {
      serverId,
      uri,
      hasResourceData: !!resourceData,
      hasToolInput: !!toolInput,
      hasToolOutput: !!toolOutput,
      hasToolResponseMetadata: !!toolResponseMetadata,
      toolResponseMetadata,
      hasWidgetCSP: !!widgetCSP,
      devWidgetUrl,
      devServerBaseUrl
    });
  }
  if (!serverId || !uri || !toolId || !resourceData) {
    const missingFields = [];
    if (!serverId) missingFields.push("serverId");
    if (!uri) missingFields.push("uri");
    if (!toolId) missingFields.push("toolId");
    if (!resourceData) missingFields.push("resourceData");
    console.error("[Widget Store] Missing required fields:", missingFields);
    return {
      success: false,
      error: `Missing required fields: ${missingFields.join(", ")}`
    };
  }
  widgetDataStore.set(toolId, {
    serverId,
    uri,
    toolInput,
    toolOutput,
    toolResponseMetadata,
    resourceData,
    toolId,
    timestamp: Date.now(),
    widgetCSP,
    mcpAppsCsp,
    mcpAppsPermissions,
    devWidgetUrl,
    devServerBaseUrl,
    theme
  });
  if (debugWidget) {
    console.log("[Widget Store] Data stored successfully for toolId:", toolId);
  }
  return { success: true };
}
function getWidgetData(toolId) {
  return widgetDataStore.get(toolId);
}
function generateWidgetContainerHtml(basePath, toolId) {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <title>Loading Widget...</title>
    </head>
    <body>
      <script>
        (async function() {
          try {
            // Fetch the actual widget HTML using toolId
            const response = await fetch('${basePath}/api/resources/widget-content/${toolId}');
            const html = await response.text();

            // Replace entire document with widget HTML using proper method
            document.open();
            document.write(html);
            document.close();
          } catch (error) {
            console.error('Failed to load widget:', error);
            document.body.innerHTML = '<div style="padding: 20px; color: red;">Failed to load widget: ' + error.message + '</div>';
          }
        })();
      </script>
    </body>
    </html>
  `;
}
function generateWidgetContentHtml(widgetData) {
  const {
    serverId,
    uri,
    toolInput,
    toolOutput,
    toolResponseMetadata,
    resourceData,
    toolId,
    theme,
    playground
  } = widgetData;
  const debugWidget = process.env.DEBUG != null && process.env.DEBUG !== "" && process.env.DEBUG !== "0" && process.env.DEBUG.toLowerCase() !== "false";
  if (debugWidget) {
    console.log("[Widget Content] Using pre-fetched resource for:", {
      serverId,
      uri
    });
  }
  let htmlContent = "";
  const contentsArray = Array.isArray(resourceData?.contents) ? resourceData.contents : [];
  const firstContent = contentsArray[0];
  if (firstContent) {
    if (typeof firstContent.text === "string") {
      htmlContent = firstContent.text;
    } else if (typeof firstContent.blob === "string") {
      htmlContent = firstContent.blob;
    }
  }
  if (!htmlContent && resourceData && typeof resourceData === "object") {
    const recordContent = resourceData;
    if (typeof recordContent.text === "string") {
      htmlContent = recordContent.text;
    } else if (typeof recordContent.blob === "string") {
      htmlContent = recordContent.blob;
    }
  }
  if (!htmlContent) {
    return { html: "", error: "No HTML content found" };
  }
  const widgetStateKey = `openai-widget-state:${toolId}`;
  const safeToolInput = JSON.stringify(toolInput ?? null).replace(/</g, "\\u003c").replace(/>/g, "\\u003e");
  const safeToolOutput = JSON.stringify(toolOutput ?? null).replace(/</g, "\\u003c").replace(/>/g, "\\u003e");
  const safeToolResponseMetadata = JSON.stringify(toolResponseMetadata ?? null).replace(/</g, "\\u003c").replace(/>/g, "\\u003e");
  const safeToolId = JSON.stringify(toolId);
  const safeWidgetStateKey = JSON.stringify(widgetStateKey);
  const safeTheme = JSON.stringify(theme === "dark" ? "dark" : "light");
  const locale = playground?.locale || "en-US";
  const deviceType = playground?.deviceType || "desktop";
  const capabilities = playground?.capabilities || {
    hover: true,
    touch: false
  };
  const safeAreaInsets = playground?.safeAreaInsets || {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  const safeLocale = JSON.stringify(locale);
  const safeUserAgent = JSON.stringify({
    device: { type: deviceType },
    capabilities
  });
  const safeSafeArea = JSON.stringify({ insets: safeAreaInsets });
  const apiScript = `
    <script>
      (function() {
        'use strict';

        // Change URL to "/" for React Router compatibility.
        // Skip when loaded inside the inspector (widget-content endpoint)
        // to prevent Vite HMR reloads from navigating to "/" (inspector SPA).
        if (window.location.pathname !== '/' && !window.location.pathname.includes('/inspector/')) {
          history.replaceState(null, '', '/');
        }

        function emitWidgetRuntimeError(payload) {
          var args = [{
            message: payload && payload.message ? payload.message : "Unknown widget runtime error",
            stack: payload && payload.stack ? payload.stack : undefined,
            source: payload && payload.source ? payload.source : undefined,
            fileName: payload && payload.fileName ? payload.fileName : undefined,
            line: payload && payload.line ? payload.line : undefined,
            column: payload && payload.column ? payload.column : undefined,
            timestamp: payload && payload.timestamp ? payload.timestamp : Date.now(),
          }];
          try {
            window.parent.postMessage(
              {
                type: "iframe-console-log",
                level: "error",
                args: args,
                timestamp: new Date().toISOString(),
                url: window.location.href,
                toolId: ${safeToolId},
              },
              "*"
            );
          } catch (emitErr) {}
        }

        window.addEventListener("error", function(event) {
          var err = event && event.error;
          var message =
            (err && err.message) ||
            (event && event.message) ||
            "Unknown widget runtime error";
          emitWidgetRuntimeError({
            source: "window.error",
            message: String(message),
            stack: err && err.stack ? String(err.stack) : undefined,
            fileName: event && event.filename ? String(event.filename) : undefined,
            line: event && typeof event.lineno === "number" ? event.lineno : undefined,
            column: event && typeof event.colno === "number" ? event.colno : undefined,
            timestamp: Date.now(),
          });
        });

        window.addEventListener("unhandledrejection", function(event) {
          var reason = event ? event.reason : undefined;
          var message = "Unhandled promise rejection";
          var stack = undefined;
          if (reason && typeof reason === "object") {
            message = String(reason.message || message);
            stack = reason.stack ? String(reason.stack) : undefined;
          } else if (typeof reason === "string") {
            message = reason;
          } else if (reason != null) {
            message = String(reason);
          }
          emitWidgetRuntimeError({
            source: "window.unhandledrejection",
            message: message,
            stack: stack,
            timestamp: Date.now(),
          });
        });

        const openaiAPI = {
          toolInput: ${safeToolInput},
          toolOutput: ${safeToolOutput},
          toolResponseMetadata: ${safeToolResponseMetadata},
          displayMode: 'inline',
          maxHeight: 600,
          theme: ${safeTheme},
          locale: ${safeLocale},
          safeArea: ${safeSafeArea},
          userAgent: ${safeUserAgent},
          widgetState: null,

          async setWidgetState(state) {
            this.widgetState = state;
            try {
              localStorage.setItem(${safeWidgetStateKey}, JSON.stringify(state));
            } catch (err) {
              console.error('[OpenAI Widget] Failed to save widget state:', err);
            }
            window.parent.postMessage({
              type: 'openai:setWidgetState',
              toolId: ${safeToolId},
              state
            }, '*');
          },

          async callTool(toolName, params = {}) {
            return new Promise((resolve, reject) => {
              const requestId = \`tool_\${Date.now()}_\${Math.random()}\`;
              const handler = (event) => {
                if (event.data.type === 'openai:callTool:response' &&
                    event.data.requestId === requestId) {
                  window.removeEventListener('message', handler);
                  if (event.data.error) {
                    reject(new Error(event.data.error));
                  } else {
                    resolve(event.data.result);
                  }
                }
              };
              window.addEventListener('message', handler);
              window.parent.postMessage({
                type: 'openai:callTool',
                requestId,
                toolName,
                params
              }, '*');
              setTimeout(() => {
                window.removeEventListener('message', handler);
                reject(new Error('Tool call timeout'));
              }, 30000);
            });
          },

          async sendFollowupTurn(message) {
            const payload = typeof message === 'string'
              ? { prompt: message }
              : message;
            window.parent.postMessage({
              type: 'openai:sendFollowup',
              message: payload.prompt || payload
            }, '*');
          },

          async requestDisplayMode(options = {}) {
            const mode = options.mode || 'inline';
            this.displayMode = mode;
            window.parent.postMessage({
              type: 'openai:requestDisplayMode',
              mode
            }, '*');
            return { mode };
          },

          async sendFollowUpMessage(args) {
            const prompt = typeof args === 'string' ? args : (args?.prompt || '');
            return this.sendFollowupTurn(prompt);
          },

          async notifyIntrinsicHeight(height) {
            console.log('[OpenAI Widget] notifyIntrinsicHeight called with:', height);
            if (typeof height !== 'number' || height < 0) {
              console.error('[OpenAI Widget] Invalid height value:', height);
              throw new Error('Height must be a non-negative number');
            }
            const message = {
              type: 'openai:notifyIntrinsicHeight',
              height
            };
            console.log('[OpenAI Widget] Sending postMessage to parent:', message);
            window.parent.postMessage(message, '*');
          },

          openExternal(payload) {
            const href = typeof payload === 'string' ? payload : payload?.href;
            if (href) {
              window.open(href, '_blank', 'noopener,noreferrer');
            }
          }
        };

        // Report CSP violations to the inspector host
        document.addEventListener('securitypolicyviolation', function(e) {
          window.parent.postMessage({
            type: 'openai:csp-violation',
            toolId: ${safeToolId},
            directive: e.violatedDirective,
            effectiveDirective: e.effectiveDirective,
            blockedUri: e.blockedURI,
            sourceFile: e.sourceFile || null,
            lineNumber: e.lineNumber,
            columnNumber: e.columnNumber,
            originalPolicy: e.originalPolicy,
            disposition: e.disposition,
            timestamp: Date.now(),
          }, '*');
        });

        Object.defineProperty(window, 'openai', {
          value: openaiAPI,
          writable: false,
          configurable: false,
          enumerable: true
        });

        Object.defineProperty(window, 'webplus', {
          value: openaiAPI,
          writable: false,
          configurable: false,
          enumerable: true
        });

        // Do not fire openai:set_globals here \u2014 window.openai is already set synchronously.
        // useSyncExternalStore reads it on first render. Firing the event would cause a
        // redundant second render (double flash at pending/final state).

        // Listen for widget state requests from inspector
        window.addEventListener('message', (event) => {
          if (event.data?.type === 'mcp-inspector:getWidgetState') {
            window.parent.postMessage({
              type: 'mcp-inspector:widgetStateResponse',
              toolId: event.data.toolId,
              state: openaiAPI.widgetState
            }, '*');
            return;
          }
        });

        // Listen for globals changes from parent (for displayMode, theme, etc.)
        window.addEventListener('message', (event) => {
          // Handle new general globalsChanged message
          if (event.data?.type === 'openai:globalsChanged') {
            const updates = event.data.updates || {};
            let hasChanges = false;

            // Update displayMode
            if (updates.displayMode && ['inline', 'pip', 'fullscreen'].includes(updates.displayMode)) {
              openaiAPI.displayMode = updates.displayMode;
              hasChanges = true;
            }

            // Update theme
            if (updates.theme && ['light', 'dark'].includes(updates.theme)) {
              openaiAPI.theme = updates.theme;
              hasChanges = true;
            }

            // Update maxHeight
            if (updates.maxHeight !== undefined && typeof updates.maxHeight === 'number') {
              openaiAPI.maxHeight = updates.maxHeight;
              hasChanges = true;
            }

            // Update locale
            if (updates.locale && typeof updates.locale === 'string') {
              openaiAPI.locale = updates.locale;
              hasChanges = true;
            }

            // Update safeArea
            if (updates.safeArea && typeof updates.safeArea === 'object') {
              openaiAPI.safeArea = updates.safeArea;
              hasChanges = true;
            }

            // Update userAgent
            if (updates.userAgent !== undefined) {
              openaiAPI.userAgent = updates.userAgent;
              hasChanges = true;
            }

            // Dispatch set_globals event to notify React components if any changes occurred
            if (hasChanges) {
              try {
                const globalsEvent = new CustomEvent('openai:set_globals', {
                  detail: {
                    globals: {
                      toolInput: openaiAPI.toolInput,
                      toolOutput: openaiAPI.toolOutput,
                      toolResponseMetadata: openaiAPI.toolResponseMetadata || null,
                      widgetState: openaiAPI.widgetState,
                      displayMode: openaiAPI.displayMode,
                      maxHeight: openaiAPI.maxHeight,
                      theme: openaiAPI.theme,
                      locale: openaiAPI.locale,
                      safeArea: openaiAPI.safeArea,
                      userAgent: openaiAPI.userAgent
                    }
                  }
                });
                window.dispatchEvent(globalsEvent);
              } catch (err) {}
            }
          }
          // Handle legacy displayModeChanged message for backward compatibility
          else if (event.data?.type === 'openai:displayModeChanged') {
            const newMode = event.data.mode;
            if (newMode && ['inline', 'pip', 'fullscreen'].includes(newMode)) {
              openaiAPI.displayMode = newMode;
              // Dispatch set_globals event to notify React components
              try {
                const globalsEvent = new CustomEvent('openai:set_globals', {
                  detail: {
                    globals: {
                      toolInput: openaiAPI.toolInput,
                      toolOutput: openaiAPI.toolOutput,
                      toolResponseMetadata: openaiAPI.toolResponseMetadata || null,
                      widgetState: openaiAPI.widgetState,
                      displayMode: newMode,
                      maxHeight: openaiAPI.maxHeight,
                      theme: openaiAPI.theme,
                      locale: openaiAPI.locale,
                      safeArea: openaiAPI.safeArea,
                      userAgent: openaiAPI.userAgent
                    }
                  }
                });
                window.dispatchEvent(globalsEvent);
              } catch (err) {}
            }
          }
        });

        setTimeout(() => {
          try {
            const stored = localStorage.getItem(${safeWidgetStateKey});
            if (stored && window.openai) {
              window.openai.widgetState = JSON.parse(stored);
            }
          } catch (err) {}
        }, 0);
      })();
    </script>
  `;
  let modifiedHtml;
  if (htmlContent.includes("<html") && htmlContent.includes("<head")) {
    modifiedHtml = htmlContent.replace("<head>", `<head>${apiScript}`);
  } else {
    modifiedHtml = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  ${apiScript}
  <title>Widget</title>
</head>
<body>
  ${htmlContent}
</body>
</html>`;
  }
  if (debugWidget) {
    console.log("[Widget Content] Generated HTML length:", modifiedHtml.length);
  }
  return { html: modifiedHtml };
}
function getWidgetSecurityHeaders(widgetCSP, devServerBaseUrl, frameAncestors) {
  const trustedCdns = [
    "https://persistent.oaistatic.com",
    "https://*.oaistatic.com",
    "https://unpkg.com",
    "https://cdn.jsdelivr.net",
    "https://cdnjs.cloudflare.com",
    "https://cdn.skypack.dev",
    "https://*.openai.com"
  ];
  const prodResourceDomains = [...trustedCdns];
  if (widgetCSP?.resource_domains) {
    prodResourceDomains.push(...widgetCSP.resource_domains);
  }
  const prodResourceDomainsStr = prodResourceDomains.join(" ");
  let devServerOrigin = null;
  const allResourceDomains = [...prodResourceDomains];
  if (devServerBaseUrl) {
    try {
      devServerOrigin = new URL(devServerBaseUrl).origin;
      allResourceDomains.push(devServerOrigin);
    } catch (e) {
      console.warn(`[CSP] Invalid devServerBaseUrl: ${devServerBaseUrl}`);
    }
  }
  const resourceDomainsStr = allResourceDomains.join(" ");
  let imgSrc = "'self' data: https: blob:";
  if (devServerOrigin) {
    imgSrc = `'self' data: https: blob: ${devServerOrigin}`;
  }
  let mediaSrc = "'self' data: https: blob:";
  if (devServerOrigin) {
    mediaSrc = `'self' data: https: blob: ${devServerOrigin}`;
  }
  let fontSrc = `'self' data: ${resourceDomainsStr}`;
  if (devServerOrigin) {
    fontSrc = `'self' data: https: http: ${resourceDomainsStr}`;
  }
  let connectSrc = "'self' https: wss: ws:";
  if (widgetCSP?.connect_domains && widgetCSP.connect_domains.length > 0) {
    connectSrc = `'self' ${widgetCSP.connect_domains.join(" ")} https: wss: ws:`;
  }
  let frameSrc = "'self' blob:";
  const frameDomains = widgetCSP?.frame_domains || widgetCSP?.resource_domains;
  if (frameDomains && frameDomains.length > 0) {
    frameSrc = `'self' blob: ${frameDomains.join(" ")}`;
  }
  let frameAncestorsPolicy = "*";
  if (frameAncestors) {
    frameAncestorsPolicy = `'self' ${frameAncestors}`.trim();
  }
  const headers = {
    "Content-Security-Policy": [
      "default-src 'self'",
      `script-src 'self' 'unsafe-inline' 'unsafe-eval' ${resourceDomainsStr}`,
      "worker-src 'self' blob:",
      `child-src 'self' blob: ${frameDomains?.join(" ") || ""}`.trim(),
      `frame-src ${frameSrc}`,
      `style-src 'self' 'unsafe-inline' ${resourceDomainsStr}`,
      `img-src ${imgSrc}`,
      `media-src ${mediaSrc}`,
      `font-src ${fontSrc}`,
      `connect-src ${connectSrc}`,
      `frame-ancestors ${frameAncestorsPolicy}`
    ].join("; "),
    "X-Frame-Options": "SAMEORIGIN",
    "X-Content-Type-Options": "nosniff",
    "Cache-Control": "no-cache, no-store, must-revalidate",
    Pragma: "no-cache",
    Expires: "0"
  };
  if (devServerOrigin) {
    const prodConnectSrc = "'self' https: wss: ws:";
    let prodFrameSrc = "'self' blob:";
    const prodFrameDomains = widgetCSP?.frame_domains || widgetCSP?.resource_domains;
    if (prodFrameDomains && prodFrameDomains.length > 0) {
      prodFrameSrc = `'self' blob: ${prodFrameDomains.join(" ")}`;
    }
    headers["Content-Security-Policy-Report-Only"] = [
      "default-src 'self'",
      `script-src 'self' 'unsafe-inline' 'unsafe-eval' ${prodResourceDomainsStr}`,
      "worker-src 'self' blob:",
      `child-src 'self' blob: ${prodFrameDomains?.join(" ") || ""}`.trim(),
      `frame-src ${prodFrameSrc}`,
      `style-src 'self' 'unsafe-inline' ${prodResourceDomainsStr}`,
      "img-src 'self' data: https: blob:",
      "media-src 'self' data: https: blob:",
      `font-src 'self' data: ${prodResourceDomainsStr}`,
      `connect-src ${prodConnectSrc}`,
      `frame-ancestors ${frameAncestorsPolicy}`
    ].join("; ");
  }
  return headers;
}

// src/server/routes/mcp-apps.ts
var RESOURCE_MIME_TYPE = "text/html;profile=mcp-app";
var SANDBOX_PROXY_HTML = `<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; img-src * data: blob: 'unsafe-inline'; media-src * blob: data:; font-src * blob: data:; script-src * 'wasm-unsafe-eval' 'unsafe-inline' 'unsafe-eval' blob: data:; style-src * blob: data: 'unsafe-inline'; connect-src * data: blob: about:; frame-src * blob: data: http://localhost:* https://localhost:* http://127.0.0.1:* https://127.0.0.1:*;"
    />
    <title>MCP Apps Sandbox Proxy</title>
    <style>
      html, body { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; }
      * { box-sizing: border-box; }
      iframe { display: block; background-color: transparent; border: 0px none transparent; padding: 0px; width: 100%; height: 100%; }
    </style>
  </head>
  <body>
    <script>
      function sanitizeDomain(domain) {
        if (typeof domain !== "string") return "";
        return domain.replace(/['"<>;]/g, "").trim();
      }

      function buildAllowAttribute(permissions) {
        if (!permissions) return "";
        const allowList = [];
        if (permissions.camera) allowList.push("camera *");
        if (permissions.microphone) allowList.push("microphone *");
        if (permissions.geolocation) allowList.push("geolocation *");
        if (permissions.clipboardWrite) allowList.push("clipboard-write *");
        return allowList.join("; ");
      }

      function buildCSP(csp) {
        if (!csp) {
          return [
            "default-src 'none'",
            "script-src 'unsafe-inline'",
            "style-src 'unsafe-inline'",
            "img-src data:",
            "font-src data:",
            "media-src data:",
            "connect-src 'none'",
            "frame-src 'none'",
            "object-src 'none'",
            "base-uri 'none'",
          ].join("; ");
        }

        const connectDomains = (csp.connectDomains || []).map(sanitizeDomain).filter(Boolean);
        const resourceDomains = (csp.resourceDomains || []).map(sanitizeDomain).filter(Boolean);
        const frameDomains = (csp.frameDomains || []).map(sanitizeDomain).filter(Boolean);
        const baseUriDomains = (csp.baseUriDomains || []).map(sanitizeDomain).filter(Boolean);
        const scriptDirectives = (csp.scriptDirectives || []).filter(function(d) { return typeof d === "string" && d.length > 0; });

        const connectSrc = connectDomains.length > 0 ? connectDomains.join(" ") : "'none'";
        const resourceSrc = resourceDomains.length > 0 ? ["data:", "blob:", ...resourceDomains].join(" ") : "data: blob:";
        const frameSrc = frameDomains.length > 0 ? frameDomains.join(" ") : "'none'";
        const baseUri = baseUriDomains.length > 0 ? baseUriDomains.join(" ") : "'none'";
        const scriptSrcParts = ["'unsafe-inline'", resourceSrc];
        if (scriptDirectives.length > 0) scriptSrcParts.push(scriptDirectives.join(" "));

        return [
          "default-src 'none'",
          "script-src " + scriptSrcParts.join(" "),
          "style-src 'unsafe-inline' " + resourceSrc,
          "img-src " + resourceSrc,
          "font-src " + resourceSrc,
          "media-src " + resourceSrc,
          "connect-src " + connectSrc,
          "frame-src " + frameSrc,
          "object-src 'none'",
          "base-uri " + baseUri,
        ].join("; ");
      }

      function buildViolationListenerScript() {
        return \`<script>
document.addEventListener('securitypolicyviolation', function(e) {
  var violation = {
    type: 'mcp-apps:csp-violation',
    directive: e.violatedDirective,
    blockedUri: e.blockedURI,
    sourceFile: e.sourceFile || null,
    lineNumber: e.lineNumber || null,
    columnNumber: e.columnNumber || null,
    effectiveDirective: e.effectiveDirective,
    originalPolicy: e.originalPolicy,
    disposition: e.disposition,
    timestamp: Date.now()
  };
  console.warn('[MCP Apps CSP Violation]', violation.directive, ':', violation.blockedUri);
  window.parent.postMessage(violation, '*');
});

function serializeConsoleArgs(args) {
  try {
    return Array.from(args || []).map(function(arg) {
      if (arg instanceof Error) {
        return {
          type: 'Error',
          message: arg.message,
          stack: arg.stack,
          name: arg.name,
        };
      }
      if (typeof arg === 'object' && arg !== null) {
        try {
          return JSON.parse(JSON.stringify(arg));
        } catch (e) {
          return String(arg);
        }
      }
      return arg;
    });
  } catch (e) {
    return [String(args)];
  }
}

function sendConsoleToParent(level, args) {
  try {
    window.parent.postMessage({
      type: 'iframe-console-log',
      level: level,
      args: serializeConsoleArgs(args),
      timestamp: new Date().toISOString(),
      url: window.location.href,
    }, '*');
  } catch (e) {}
}

var originalConsoleError = console.error.bind(console);
console.error = function() {
  var args = Array.from(arguments);
  originalConsoleError.apply(console, args);
  sendConsoleToParent('error', args);
};

window.addEventListener('error', function(event) {
  sendConsoleToParent('error', [{
    message: event.message,
    filename: event.filename,
    lineno: event.lineno,
    colno: event.colno,
    error: event.error ? {
      message: event.error.message,
      stack: event.error.stack,
      name: event.error.name,
    } : null,
  }]);
});

window.addEventListener('unhandledrejection', function(event) {
  sendConsoleToParent('error', [{
    message: 'Unhandled Promise Rejection',
    reason: event.reason ? String(event.reason) : 'Unknown',
    error: event.reason instanceof Error ? {
      message: event.reason.message,
      stack: event.reason.stack,
      name: event.reason.name,
    } : null,
  }]);
});
</\` + \`script>\`;
      }

      function injectCSP(html, cspValue) {
        const cspMeta = '<meta http-equiv="Content-Security-Policy" content="' + cspValue + '">';
        const violationListener = buildViolationListenerScript();
        const injection = cspMeta + violationListener;

        if (html.includes("<head>")) {
          return html.replace("<head>", "<head>" + injection);
        } else if (html.includes("<HEAD>")) {
          return html.replace("<HEAD>", "<HEAD>" + injection);
        } else if (html.includes("<html>")) {
          return html.replace("<html>", "<html><head>" + injection + "</head>");
        } else if (html.includes("<HTML>")) {
          return html.replace("<HTML>", "<HTML><head>" + injection + "</head>");
        } else if (html.includes("<!DOCTYPE") || html.includes("<!doctype")) {
          return html.replace(/(<!DOCTYPE[^>]*>|<!doctype[^>]*>)/i, "$1<head>" + injection + "</head>");
        } else {
          return injection + html;
        }
      }

      const inner = document.createElement("iframe");
      inner.style = "width:100%; height:100%; border:none;";
      inner.setAttribute("sandbox", "allow-scripts allow-same-origin allow-forms");
      document.body.appendChild(inner);

      window.addEventListener("message", async (event) => {
        if (event.source === window.parent) {
          if (event.data && event.data.method === "ui/notifications/sandbox-resource-ready") {
            const { html, sandbox, csp, permissions, permissive } = event.data.params || {};
            if (typeof sandbox === "string") {
              inner.setAttribute("sandbox", sandbox);
            }
            const allowAttribute = buildAllowAttribute(permissions);
            if (allowAttribute) {
              inner.setAttribute("allow", allowAttribute);
            }
            if (typeof html === "string") {
              if (permissive) {
                const permissiveCsp = [
                  "default-src * 'unsafe-inline' 'unsafe-eval' data: blob: filesystem: about:",
                  "script-src * 'unsafe-inline' 'unsafe-eval' data: blob:",
                  "style-src * 'unsafe-inline' data: blob:",
                  "img-src * data: blob: https: http:",
                  "media-src * data: blob: https: http:",
                  "font-src * data: blob: https: http:",
                  "connect-src * data: blob: https: http: ws: wss: about:",
                  "frame-src * data: blob: https: http: about:",
                  "object-src * data: blob:",
                  "base-uri *",
                  "form-action *",
                ].join("; ");
                const processedHtml = injectCSP(html, permissiveCsp);
                inner.srcdoc = processedHtml;
              } else {
                const cspValue = buildCSP(csp);
                const processedHtml = injectCSP(html, cspValue);
                inner.srcdoc = processedHtml;
              }
            }
          } else {
            if (inner && inner.contentWindow) {
              inner.contentWindow.postMessage(event.data, "*");
            }
          }
        } else if (event.source === inner.contentWindow) {
          window.parent.postMessage(event.data, "*");
        }
      });

      window.parent.postMessage({
        jsonrpc: "2.0",
        method: "ui/notifications/sandbox-proxy-ready",
        params: {},
      }, "*");
    </script>
  </body>
</html>`;
function registerMcpAppsRoutes(app2) {
  app2.post("/inspector/api/mcp-apps/widget/store", async (c) => {
    try {
      const body = await c.req.json();
      const result = storeWidgetData({
        ...body,
        protocol: "mcp-apps"
        // Tag as MCP Apps protocol
      });
      if (!result.success) {
        return c.json(result, 400);
      }
      return c.json(result);
    } catch (error) {
      console.error("[MCP Apps] Error storing widget data:", error);
      return c.json(
        {
          success: false,
          error: error instanceof Error ? error.message : "Unknown error"
        },
        500
      );
    }
  });
  app2.get("/inspector/api/mcp-apps/widget-content/:toolId", async (c) => {
    try {
      const toolId = c.req.param("toolId");
      const cspModeParam = c.req.query("csp_mode");
      const widgetData = getWidgetData(toolId);
      if (!widgetData) {
        return c.json({ error: "Widget data not found or expired" }, 404);
      }
      const { resourceData, mcpAppsCsp, mcpAppsPermissions } = widgetData;
      let htmlContent = "";
      let mimeType;
      const contentsArray = Array.isArray(resourceData?.contents) ? resourceData.contents : [];
      const firstContent = contentsArray[0];
      if (firstContent) {
        mimeType = firstContent.mimeType;
        if (typeof firstContent.text === "string") {
          htmlContent = firstContent.text;
        } else if (typeof firstContent.blob === "string") {
          htmlContent = Buffer.from(firstContent.blob, "base64").toString(
            "utf-8"
          );
        }
      }
      if (!htmlContent) {
        return c.json({ error: "No HTML content in resource" }, 404);
      }
      const mimeTypeValid = mimeType === RESOURCE_MIME_TYPE;
      const mimeTypeWarning = !mimeTypeValid ? mimeType ? `Invalid MIME type "${mimeType}" - SEP-1865 requires "${RESOURCE_MIME_TYPE}"` : `Missing MIME type - SEP-1865 requires "${RESOURCE_MIME_TYPE}"` : null;
      if (mimeTypeWarning) {
        console.warn("[MCP Apps] MIME type validation:", mimeTypeWarning, {
          resourceUri: widgetData.uri
        });
      }
      const cspMode = cspModeParam || "permissive";
      const isPermissive = cspMode === "permissive";
      c.header("Cache-Control", "no-cache, no-store, must-revalidate");
      return c.json({
        html: htmlContent,
        csp: isPermissive ? void 0 : mcpAppsCsp,
        permissions: mcpAppsPermissions,
        permissive: isPermissive,
        cspMode,
        mimeType,
        mimeTypeValid,
        mimeTypeWarning
      });
    } catch (error) {
      console.error("[MCP Apps] Error fetching widget content:", error);
      return c.json(
        { error: error instanceof Error ? error.message : "Unknown error" },
        500
      );
    }
  });
  app2.get("/inspector/api/mcp-apps/sandbox-proxy", (c) => {
    c.header("Content-Type", "text/html; charset=utf-8");
    c.header("Cache-Control", "no-cache, no-store, must-revalidate");
    const additionalFrameAncestors = process.env.FRAME_ANCESTORS || "";
    const frameAncestors = additionalFrameAncestors ? [
      "'self'",
      "http://localhost:*",
      "http://127.0.0.1:*",
      "https://localhost:*",
      "https://127.0.0.1:*",
      additionalFrameAncestors
    ].filter(Boolean).join(" ") : "*";
    c.header("Content-Security-Policy", `frame-ancestors ${frameAncestors}`);
    c.res.headers.delete("X-Frame-Options");
    return c.body(SANDBOX_PROXY_HTML);
  });
}

// src/server/rpc-log-bus.ts
var SimpleEventEmitter = class {
  constructor() {
    __publicField(this, "listeners", /* @__PURE__ */ new Map());
  }
  on(event, listener) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, /* @__PURE__ */ new Set());
    }
    this.listeners.get(event).add(listener);
  }
  off(event, listener) {
    this.listeners.get(event)?.delete(listener);
  }
  emit(event, ...args2) {
    this.listeners.get(event)?.forEach((listener) => {
      try {
        listener(...args2);
      } catch (e) {
        console.error("Error in event listener:", e);
      }
    });
  }
};
var RpcLogBus = class {
  constructor() {
    __publicField(this, "emitter", new SimpleEventEmitter());
    __publicField(this, "bufferByServer", /* @__PURE__ */ new Map());
  }
  publish(event) {
    const buffer = this.bufferByServer.get(event.serverId) ?? [];
    buffer.push(event);
    if (buffer.length > 1e3) {
      buffer.shift();
    }
    this.bufferByServer.set(event.serverId, buffer);
    this.emitter.emit("event", event);
  }
  subscribe(serverIds, listener) {
    const filter = new Set(serverIds);
    const handler = (event) => {
      if (filter.size === 0 || filter.has(event.serverId)) listener(event);
    };
    this.emitter.on("event", handler);
    return () => this.emitter.off("event", handler);
  }
  getBuffer(serverIds, limit) {
    const filter = new Set(serverIds);
    const all = [];
    for (const [serverId, buf] of this.bufferByServer.entries()) {
      if (filter.size > 0 && !filter.has(serverId)) continue;
      all.push(...buf);
    }
    all.sort((a, b) => b.timestamp.localeCompare(a.timestamp));
    if (limit === 0) return [];
    if (!Number.isFinite(limit) || limit < 0) return all;
    return all.slice(0, limit);
  }
  clear(serverIds) {
    if (serverIds && serverIds.length > 0) {
      const filter = new Set(serverIds);
      for (const serverId of filter) {
        this.bufferByServer.delete(serverId);
      }
    } else {
      this.bufferByServer.clear();
    }
  }
};
var rpcLogBus = new RpcLogBus();

// src/server/utils.ts
function isValidUrl(urlString) {
  try {
    const url = new URL(urlString);
    return url.protocol === "http:" || url.protocol === "https:";
  } catch {
    return false;
  }
}
async function findAvailablePort(startPort2 = 8080, maxAttempts = 100) {
  const net = await import("net");
  for (let port = startPort2; port < startPort2 + maxAttempts; port++) {
    try {
      await new Promise((resolve, reject) => {
        const server = net.createServer();
        server.listen(port, () => {
          server.close(() => resolve());
        });
        server.on("error", (err) => reject(err));
      });
      return port;
    } catch {
      continue;
    }
  }
  throw new Error(
    `No available port found after trying ${maxAttempts} ports starting from ${startPort2}`
  );
}
function formatErrorResponse(error, context) {
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  const errorMessage = error instanceof Error ? error.message : "Unknown error";
  const errorStack = error instanceof Error ? error.stack : void 0;
  console.error(`[${timestamp}] Error in ${context}:`, {
    message: errorMessage,
    stack: errorStack
  });
  return {
    error: errorMessage,
    context,
    timestamp,
    // Only include stack in development mode
    ...process.env.NODE_ENV === "development" && errorStack ? { stack: errorStack } : {}
  };
}

// src/server/shared-routes.ts
function getFrameAncestorsFromEnv() {
  const envValue = process.env.MCP_INSPECTOR_FRAME_ANCESTORS;
  if (!envValue) return void 0;
  const trimmed = envValue.trim();
  if (trimmed === "*") return "*";
  return trimmed;
}
function registerInspectorRoutes(app2, config) {
  app2.get("/inspector/health", (c) => {
    return c.json({ status: "ok", timestamp: (/* @__PURE__ */ new Date()).toISOString() });
  });
  mountMcpProxy(app2, {
    path: "/inspector/api/proxy"
  });
  mountOAuthProxy(app2, {
    basePath: "/inspector/api/oauth",
    enableLogging: true
  });
  registerMcpAppsRoutes(app2);
  app2.post("/inspector/api/chat/stream", async (c) => {
    try {
      const requestBody = await c.req.json();
      const { readable, writable } = new globalThis.TransformStream();
      const writer = writable.getWriter();
      const encoder = new TextEncoder();
      (async () => {
        try {
          for await (const chunk of handleChatRequestStream(requestBody)) {
            await writer.write(encoder.encode(chunk));
          }
        } catch (error) {
          const errorMsg = `${JSON.stringify({
            type: "error",
            data: {
              message: error instanceof Error ? error.message : "Unknown error"
            }
          })}
`;
          await writer.write(encoder.encode(errorMsg));
        } finally {
          await writer.close();
        }
      })();
      return new Response(readable, {
        headers: {
          "Content-Type": "text/event-stream",
          "Cache-Control": "no-cache",
          Connection: "keep-alive"
        }
      });
    } catch (error) {
      return c.json(formatErrorResponse(error, "handleChatRequestStream"), 500);
    }
  });
  app2.post("/inspector/api/chat", async (c) => {
    try {
      const requestBody = await c.req.json();
      const result = await handleChatRequest(requestBody);
      return c.json(result);
    } catch (error) {
      return c.json(formatErrorResponse(error, "handleChatRequest"), 500);
    }
  });
  app2.post("/inspector/api/resources/widget/store", async (c) => {
    try {
      const body = await c.req.json();
      const result = storeWidgetData(body);
      if (!result.success) {
        return c.json(result, 400);
      }
      return c.json(result);
    } catch (error) {
      console.error("[Widget Store] Error:", error);
      console.error(
        "[Widget Store] Stack:",
        error instanceof Error ? error.stack : ""
      );
      return c.json(formatErrorResponse(error, "storeWidgetData"), 500);
    }
  });
  app2.get("/inspector/api/resources/widget/:toolId", async (c) => {
    const toolId = c.req.param("toolId");
    const widgetData = getWidgetData(toolId);
    if (!widgetData) {
      return c.html(
        "<html><body>Error: Widget data not found or expired</body></html>",
        404
      );
    }
    return c.html(generateWidgetContainerHtml("/inspector", toolId));
  });
  app2.get("/inspector/api/resources/widget-content/:toolId", async (c) => {
    try {
      const toolId = c.req.param("toolId");
      const widgetData = getWidgetData(toolId);
      if (!widgetData) {
        console.error(
          "[Widget Content] Widget data not found for toolId:",
          toolId
        );
        return c.html(
          "<html><body>Error: Widget data not found or expired</body></html>",
          404
        );
      }
      const result = generateWidgetContentHtml(widgetData);
      if (result.error) {
        return c.html(`<html><body>Error: ${result.error}</body></html>`, 404);
      }
      let serverOrigin;
      if (widgetData.serverId && /^https?:\/\//.test(widgetData.serverId)) {
        try {
          serverOrigin = new URL(
            widgetData.serverId.replace(/\/mcp$/, "")
          ).origin.replace("0.0.0.0", "localhost");
        } catch {
        }
      }
      const headers = getWidgetSecurityHeaders(
        widgetData.widgetCSP,
        serverOrigin,
        getFrameAncestorsFromEnv()
      );
      Object.entries(headers).forEach(([key, value]) => {
        c.header(key, value);
      });
      return c.html(result.html);
    } catch (error) {
      console.error("[Widget Content] Error:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      const errorStack = error instanceof Error ? error.stack : "";
      console.error("[Widget Content] Stack:", errorStack);
      return c.html(`<html><body>Error: ${errorMessage}</body></html>`, 500);
    }
  });
  app2.get("/inspector/config.json", (c) => {
    return c.json({
      autoConnectUrl: config?.autoConnectUrl || null
    });
  });
  const isTelemetryDisabled = () => process.env.MCP_USE_ANONYMIZED_TELEMETRY === "false" || process.env.NODE_ENV === "test";
  app2.post("/inspector/api/tel/posthog", async (c) => {
    if (isTelemetryDisabled()) {
      return c.json({ success: true });
    }
    try {
      const body = await c.req.json();
      const { event, user_id, properties } = body;
      if (!event) {
        return c.json({ success: false, error: "Missing event name" }, 400);
      }
      const { PostHog } = await import("posthog-node");
      const posthog = new PostHog(
        "phc_lyTtbYwvkdSbrcMQNPiKiiRWrrM1seyKIMjycSvItEI",
        {
          host: "https://eu.i.posthog.com"
        }
      );
      const distinctId = user_id || "anonymous";
      posthog.capture({
        distinctId,
        event,
        properties: properties || {}
      });
      await posthog.shutdown();
      return c.json({ success: true });
    } catch (error) {
      console.error("[Telemetry] Error forwarding to PostHog:", error);
      return c.json({ success: false });
    }
  });
  app2.post("/inspector/api/tel/scarf", async (c) => {
    if (isTelemetryDisabled()) {
      return c.json({ success: true });
    }
    try {
      const body = await c.req.json();
      const response = await fetch(
        "https://mcpuse.gateway.scarf.sh/events-inspector",
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(body)
        }
      );
      if (!response.ok) {
        console.error("[Telemetry] Scarf request failed:", response.status);
        return c.json({
          success: false,
          status: response.status,
          error: response.statusText
        });
      }
      return c.json({ success: true });
    } catch (error) {
      console.error("[Telemetry] Error forwarding to Scarf:", error);
      return c.json({ success: false });
    }
  });
  app2.post("/inspector/api/rpc/log", async (c) => {
    try {
      const event = await c.req.json();
      rpcLogBus.publish(event);
      return c.json({ success: true });
    } catch (error) {
      console.error("[RPC Log] Error receiving RPC event:", error);
      return c.json({ success: false });
    }
  });
  app2.delete("/inspector/api/rpc/log", async (c) => {
    try {
      const url = new URL(c.req.url);
      const serverIdsParam = url.searchParams.get("serverIds");
      const serverIds = serverIdsParam ? serverIdsParam.split(",").filter(Boolean) : void 0;
      rpcLogBus.clear(serverIds);
      return c.json({ success: true });
    } catch (error) {
      console.error("[RPC Log] Error clearing RPC log:", error);
      return c.json({ success: false });
    }
  });
  app2.get("/inspector/api/rpc/stream", async (c) => {
    const url = new URL(c.req.url);
    const replay = parseInt(url.searchParams.get("replay") || "3", 10);
    const serverIdsParam = url.searchParams.get("serverIds");
    const serverIds = serverIdsParam ? serverIdsParam.split(",").filter(Boolean) : [];
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      start(controller) {
        const send = (data) => {
          try {
            controller.enqueue(
              encoder.encode(`data: ${JSON.stringify(data)}

`)
            );
          } catch {
          }
        };
        try {
          const recent = rpcLogBus.getBuffer(
            serverIds,
            isNaN(replay) ? 3 : replay
          );
          for (const evt of recent) {
            send({ type: "rpc", ...evt });
          }
        } catch {
        }
        const unsubscribe = rpcLogBus.subscribe(
          serverIds,
          (evt) => {
            send({ type: "rpc", ...evt });
          }
        );
        const keepalive = setInterval(() => {
          try {
            controller.enqueue(encoder.encode(`: keepalive ${Date.now()}

`));
          } catch {
          }
        }, 15e3);
        c.req.raw.signal?.addEventListener("abort", () => {
          try {
            clearInterval(keepalive);
            unsubscribe();
          } catch {
          }
          try {
            controller.close();
          } catch {
          }
        });
      }
    });
    return new Response(stream, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Expose-Headers": "*"
      }
    });
  });
}

// src/server/shared-static.ts
import { existsSync as existsSync2, readFileSync } from "fs";
import { join as join2 } from "path";

// src/server/file-utils.ts
import { existsSync } from "fs";
import { dirname, join } from "path";
import { fileURLToPath } from "url";
function getContentType(filePath) {
  if (filePath.endsWith(".js")) {
    return "application/javascript";
  } else if (filePath.endsWith(".css")) {
    return "text/css";
  } else if (filePath.endsWith(".svg")) {
    return "image/svg+xml";
  } else if (filePath.endsWith(".html")) {
    return "text/html";
  } else if (filePath.endsWith(".json")) {
    return "application/json";
  } else if (filePath.endsWith(".png")) {
    return "image/png";
  } else if (filePath.endsWith(".jpg") || filePath.endsWith(".jpeg")) {
    return "image/jpeg";
  } else if (filePath.endsWith(".ico")) {
    return "image/x-icon";
  } else {
    return "application/octet-stream";
  }
}
function checkClientFiles(clientDistPath) {
  return existsSync(clientDistPath);
}
function getClientDistPath() {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = dirname(__filename);
  if (__dirname.endsWith("dist") || __dirname.endsWith("dist/")) {
    return join(__dirname, "web");
  }
  return join(__dirname, "../web");
}

// src/server/version.ts
var VERSION = "0.22.2";
function getInspectorVersion() {
  return VERSION;
}

// src/server/shared-static.ts
var USE_CDN = process.env.INSPECTOR_USE_CDN === "true";
var INSPECTOR_VERSION = getInspectorVersion();
var CDN_BASE = process.env.INSPECTOR_CDN_BASE ?? "https://inspector-cdn.mcp-use.com";
var CDN_JS_URL = `${CDN_BASE}/inspector@${INSPECTOR_VERSION}.js`;
var CDN_CSS_URL = `${CDN_BASE}/inspector@${INSPECTOR_VERSION}.css`;
function injectRuntimeConfig(html, config) {
  if (!config) return html;
  const scripts = [];
  if (config.devMode) {
    scripts.push(`<script>window.__MCP_DEV_MODE__ = true;</script>`);
  }
  if (config.sandboxOrigin) {
    scripts.push(
      `<script>window.__MCP_SANDBOX_ORIGIN__ = ${JSON.stringify(config.sandboxOrigin)};</script>`
    );
  }
  if (scripts.length === 0) return html;
  const injection = scripts.join("\n    ");
  return html.replace("</head>", `    ${injection}
  </head>`);
}
function generateCdnShellHtml(config) {
  const runtimeScripts = (() => {
    if (!config) return "";
    const scripts = [];
    if (config.devMode) {
      scripts.push(`<script>window.__MCP_DEV_MODE__ = true;</script>`);
    }
    if (config.sandboxOrigin) {
      scripts.push(
        `<script>window.__MCP_SANDBOX_ORIGIN__ = ${JSON.stringify(config.sandboxOrigin)};</script>`
      );
    }
    return scripts.join("\n    ");
  })();
  return `<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link
      rel="icon"
      type="image/svg+xml"
      href="${CDN_BASE}/favicon-black.svg"
    />
    <link
      rel="icon"
      type="image/svg+xml"
      href="${CDN_BASE}/favicon-white.svg"
      media="(prefers-color-scheme: dark)"
    />
    <link
      rel="icon"
      type="image/svg+xml"
      href="${CDN_BASE}/favicon-black.svg"
      media="(prefers-color-scheme: light)"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="${CDN_CSS_URL}" />
    <title>Inspector | mcp-use</title>
    <script>window.__INSPECTOR_VERSION__ = ${JSON.stringify(INSPECTOR_VERSION)};</script>
    ${runtimeScripts}
  </head>
  <body>
    <script>
      if (typeof window !== "undefined" && typeof window.process === "undefined") {
        window.process = {
          env: {},
          platform: "browser",
          browser: true,
          version: "v18.0.0",
          versions: { node: "18.0.0" },
          cwd: () => "/",
          nextTick: (fn, ...args) => queueMicrotask(() => fn(...args)),
        };
      }
    </script>
    <div id="root"></div>
    <script type="module" src="${CDN_JS_URL}"></script>
  </body>
</html>`;
}
function registerStaticRoutes(app2, clientDistPath, runtimeConfig) {
  if (USE_CDN) {
    const serveShell = (c) => c.html(generateCdnShellHtml(runtimeConfig));
    app2.get("/", (c) => {
      const url = new URL(c.req.url);
      return c.redirect(`/inspector${url.search}`);
    });
    app2.get("/inspector", serveShell);
    app2.get("/inspector/*", serveShell);
    app2.post("/inspector/*", serveShell);
    app2.get("*", serveShell);
    return;
  }
  const distPath = clientDistPath || getClientDistPath();
  if (!checkClientFiles(distPath)) {
    console.warn(`\u26A0\uFE0F  MCP Inspector client files not found at ${distPath}`);
    console.warn(
      `   Run 'yarn build' in the inspector package to build the UI`
    );
    app2.get("*", (c) => {
      return c.html(`
      <!DOCTYPE html>
      <html>
        <head>
          <title>MCP Inspector</title>
        </head>
        <body>
          <h1>MCP Inspector</h1>
          <p>Client files not found. Please run 'yarn build' to build the UI.</p>
        </body>
      </html>
    `);
    });
    return;
  }
  app2.get("/inspector/assets/*", (c) => {
    const path = c.req.path.replace("/inspector/assets/", "assets/");
    const fullPath = join2(distPath, path);
    if (existsSync2(fullPath)) {
      const content = readFileSync(fullPath);
      const contentType = getContentType(fullPath);
      c.header("Content-Type", contentType);
      return c.body(content);
    }
    return c.notFound();
  });
  app2.get("/", (c) => {
    const url = new URL(c.req.url);
    const queryString = url.search;
    return c.redirect(`/inspector${queryString}`);
  });
  const serveIndex = (c) => {
    const indexPath = join2(distPath, "index.html");
    if (existsSync2(indexPath)) {
      const content = injectRuntimeConfig(
        readFileSync(indexPath, "utf-8"),
        runtimeConfig
      );
      return c.html(content);
    }
    return c.html(`
      <!DOCTYPE html>
      <html>
        <head>
          <title>MCP Inspector</title>
        </head>
        <body>
          <h1>MCP Inspector</h1>
          <p>Client files not found. Please run 'yarn build' to build the UI.</p>
        </body>
      </html>
    `);
  };
  app2.get("/inspector", serveIndex);
  app2.get("/inspector/*", serveIndex);
  app2.post("/inspector/*", serveIndex);
  app2.get("*", (c) => {
    const indexPath = join2(distPath, "index.html");
    if (existsSync2(indexPath)) {
      const content = injectRuntimeConfig(
        readFileSync(indexPath, "utf-8"),
        runtimeConfig
      );
      return c.html(content);
    }
    return c.html(`
      <!DOCTYPE html>
      <html>
        <head>
          <title>MCP Inspector</title>
        </head>
        <body>
          <h1>MCP Inspector</h1>
          <p>Client files not found. Please run 'yarn build' to build the UI.</p>
        </body>
      </html>
    `);
  });
}

// src/server/cli.ts
var args = process.argv.slice(2);
var mcpUrl;
var startPort = 8080;
for (let i = 0; i < args.length; i++) {
  if (args[i] === "--url" && i + 1 < args.length) {
    const url = args[i + 1];
    if (!isValidUrl(url)) {
      console.error(`Error: Invalid URL format: ${url}`);
      console.error("URL must start with http://, https://, ws://, or wss://");
      process.exit(1);
    }
    mcpUrl = url;
    i++;
  } else if (args[i] === "--port" && i + 1 < args.length) {
    const parsedPort = Number.parseInt(args[i + 1], 10);
    if (Number.isNaN(parsedPort) || parsedPort < 1 || parsedPort > 65535) {
      console.error(
        `Error: Port must be a number between 1 and 65535, got: ${args[i + 1]}`
      );
      process.exit(1);
    }
    startPort = parsedPort;
    i++;
  } else if (args[i] === "--help" || args[i] === "-h") {
    console.log(`
MCP Inspector - Inspect and debug MCP servers

Usage:
  npx @mcp-use/inspector [options]

Options:
  --url <url>    MCP server URL to auto-connect to (e.g., http://localhost:3000/mcp)
  --port <port>  Starting port to try (default: 8080, will find next available)
  --help, -h     Show this help message

Examples:
  # Run inspector with auto-connect
  npx @mcp-use/inspector --url http://localhost:3000/mcp

  # Run starting from custom port
  npx @mcp-use/inspector --url http://localhost:3000/mcp --port 9000

  # Run without auto-connect
  npx @mcp-use/inspector
`);
    process.exit(0);
  }
}
var app = new Hono();
app.use(
  "*",
  cors({
    origin: "*",
    exposeHeaders: ["*"]
    // Expose all headers since this is a proxy
  })
);
app.use("/inspector/api/proxy/*", logger());
registerInspectorRoutes(app, { autoConnectUrl: mcpUrl });
registerStaticRoutes(app);
async function startServer() {
  try {
    const port = await findAvailablePort(startPort);
    serve({
      fetch: app.fetch,
      port
    });
    console.log(`\u{1F680} MCP Inspector running on http://localhost:${port}`);
    if (mcpUrl) {
      console.log(`\u{1F4E1} Auto-connecting to: ${mcpUrl}`);
    }
    try {
      await open(`http://localhost:${port}/inspector`);
      console.log(`\u{1F310} Browser opened`);
    } catch {
      console.log(
        `\u{1F310} Please open http://localhost:${port}/inspector in your browser`
      );
    }
    return { port, fetch: app.fetch };
  } catch (error) {
    console.error("Failed to start server:", error);
    process.exit(1);
  }
}
startServer();
