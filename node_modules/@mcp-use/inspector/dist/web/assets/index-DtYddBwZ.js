import{o as E,s as x,i as P,v as $,p as S,A as b,a as C,e as N,m as O,_ as g,b as A,c as I,d as L,f as J,T as f,g as F,C as R,h as M,j as y,k as B,l as _,n as j,q as Z}from"./index-B9xgKKTO.js";import{B as W,i as q,a as H,b as K,c as V}from"./index-D8-Z6Ssp.js";var z={};j(z,{BaseToolkit:()=>G,DynamicStructuredTool:()=>k,DynamicTool:()=>D,StructuredTool:()=>T,Tool:()=>w,ToolInputParsingException:()=>f,isLangChainTool:()=>V,isRunnableToolLike:()=>K,isStructuredTool:()=>H,isStructuredToolParams:()=>q,tool:()=>Q});var T=class extends W{extras;returnDirect=!1;verboseParsingErrors=!1;get lc_namespace(){return["langchain","tools"]}responseFormat="content";defaultConfig;constructor(t){super(t??{}),this.verboseParsingErrors=t?.verboseParsingErrors??this.verboseParsingErrors,this.responseFormat=t?.responseFormat??this.responseFormat,this.defaultConfig=t?.defaultConfig??this.defaultConfig,this.metadata=t?.metadata??this.metadata,this.extras=t?.extras??this.extras}async invoke(t,e){let a,s=N(O(this.defaultConfig,e));return g(t)?(a=t.args,s={...s,toolCall:t}):a=t,this.call(a,s)}async call(t,e,a){const s=g(t)?t.args:t;let u;if(A(this.schema))try{u=await I(this.schema,s)}catch(c){let o="Received tool input did not match expected schema";throw this.verboseParsingErrors&&(o=`${o}
Details: ${c.message}`),L(c)&&(o=`${o}

${J(c)}`),new f(o,JSON.stringify(t))}else{const c=F(s,this.schema);if(!c.valid){let o="Received tool input did not match expected schema";throw this.verboseParsingErrors&&(o=`${o}
Details: ${c.errors.map(v=>`${v.keywordLocation}: ${v.error}`).join(`
`)}`),new f(o,JSON.stringify(t))}u=s}const n=y(e),h=await R.configure(n.callbacks,this.callbacks,n.tags||a,this.tags,n.metadata,this.metadata,{verbose:this.verbose})?.handleToolStart(this.toJSON(),typeof t=="string"?t:JSON.stringify(t),n.runId,void 0,void 0,void 0,n.runName);delete n.runId;let r;try{r=await this._call(u,h,n)}catch(c){throw await h?.handleToolError(c),c}let m,p;if(this.responseFormat==="content_and_artifact")if(Array.isArray(r)&&r.length===2)[m,p]=r;else throw new Error(`Tool response format is "content_and_artifact" but the output was not a two-tuple.
Result: ${JSON.stringify(r)}`);else m=r;let i;g(t)&&(i=t.id),!i&&M(n)&&(i=n.toolCall.id);const l=U({content:m,artifact:p,toolCallId:i,name:this.name,metadata:this.metadata});return await h?.handleToolEnd(l),l}},w=class extends T{schema=E({input:x().optional()}).transform(t=>t.input);constructor(t){super(t)}call(t,e){const a=typeof t=="string"||t==null?{input:t}:t;return super.call(a,e)}},D=class extends w{static lc_name(){return"DynamicTool"}name;description;func;constructor(t){super(t),this.name=t.name,this.description=t.description,this.func=t.func,this.returnDirect=t.returnDirect??this.returnDirect}async call(t,e){const a=y(e);return a.runName===void 0&&(a.runName=this.name),super.call(t,a)}async _call(t,e,a){return this.func(t,e,a)}},k=class extends T{static lc_name(){return"DynamicStructuredTool"}description;func;schema;constructor(t){super(t),this.name=t.name,this.description=t.description,this.func=t.func,this.returnDirect=t.returnDirect??this.returnDirect,this.schema=t.schema}async call(t,e,a){const s=y(e);return s.runName===void 0&&(s.runName=this.name),super.call(t,s,a)}_call(t,e,a){return this.func(t,e,a)}},G=class{getTools(){return this.tools}};function Q(t,e){const a=P(e.schema),s=$(e.schema);if(!e.schema||a||s)return new D({...e,description:e.description??e.schema?.description??`${e.name} tool`,func:async(d,h,r)=>new Promise((m,p)=>{const i=S(r,{callbacks:h?.getChild()});b.runWithConfig(C(i),async()=>{try{m(t(d,i))}catch(l){p(l)}})})});const u=e.schema,n=e.description??e.schema.description??`${e.name} tool`;return new k({...e,description:n,schema:u,func:async(d,h,r)=>new Promise((m,p)=>{let i;const l=()=>{r?.signal&&i&&r.signal.removeEventListener("abort",i)};r?.signal&&(i=()=>{l(),p(Z(r.signal))},r.signal.addEventListener("abort",i));const c=S(r,{callbacks:h?.getChild()});b.runWithConfig(C(c),async()=>{try{const o=await t(d,c);if(r?.signal?.aborted){l();return}l(),m(o)}catch(o){l(),p(o)}})})})}function U(t){const{content:e,artifact:a,toolCallId:s,metadata:u}=t;return s&&!B(e)?typeof e=="string"||Array.isArray(e)&&e.every(n=>typeof n=="object")?new _({status:"success",content:e,artifact:a,tool_call_id:s,name:t.name,metadata:u}):new _({status:"success",content:X(e),artifact:a,tool_call_id:s,name:t.name,metadata:u}):e}function X(t){try{return JSON.stringify(t)??""}catch{return`${t}`}}export{D,T as S,w as T,k as a,z as b,Q as t};
