// src/server/shared-utils.ts
function toBase64(str) {
  if (typeof window !== "undefined" && typeof window.btoa === "function") {
    return window.btoa(str);
  }
  if (typeof Buffer !== "undefined") {
    return Buffer.from(str).toString("base64");
  }
  throw new Error("No base64 encoding method available");
}
async function* handleChatRequestStream(requestBody) {
  const { mcpServerUrl, llmConfig, authConfig, messages } = requestBody;
  if (!mcpServerUrl || !llmConfig || !messages) {
    throw new Error(
      "Missing required fields: mcpServerUrl, llmConfig, messages"
    );
  }
  const { MCPAgent, MCPClient } = await import("mcp-use");
  let llm;
  if (llmConfig.provider === "openai") {
    const { ChatOpenAI } = await import("@langchain/openai");
    llm = new ChatOpenAI({
      model: llmConfig.model,
      apiKey: llmConfig.apiKey
    });
  } else if (llmConfig.provider === "anthropic") {
    const { ChatAnthropic } = await import("@langchain/anthropic");
    llm = new ChatAnthropic({
      model: llmConfig.model,
      apiKey: llmConfig.apiKey
    });
  } else if (llmConfig.provider === "google") {
    const { ChatGoogleGenerativeAI } = await import("@langchain/google-genai");
    llm = new ChatGoogleGenerativeAI({
      model: llmConfig.model,
      apiKey: llmConfig.apiKey
    });
  } else {
    throw new Error(`Unsupported LLM provider: ${llmConfig.provider}`);
  }
  const client = new MCPClient();
  const serverName = `inspector-${Date.now()}`;
  const serverConfig = {
    url: mcpServerUrl,
    preventAutoAuth: true
    // Prevent auto OAuth popup - tokens are passed via headers
  };
  if (authConfig && authConfig.type !== "none") {
    serverConfig.headers = {};
    if (authConfig.type === "basic" && authConfig.username && authConfig.password) {
      const auth = toBase64(`${authConfig.username}:${authConfig.password}`);
      serverConfig.headers.Authorization = `Basic ${auth}`;
    } else if (authConfig.type === "bearer" && authConfig.token) {
      serverConfig.headers.Authorization = `Bearer ${authConfig.token}`;
    } else if (authConfig.type === "oauth") {
      if (authConfig.oauthTokens?.access_token) {
        const tokenType = authConfig.oauthTokens.token_type ? authConfig.oauthTokens.token_type.charAt(0).toUpperCase() + authConfig.oauthTokens.token_type.slice(1) : "Bearer";
        serverConfig.headers.Authorization = `${tokenType} ${authConfig.oauthTokens.access_token}`;
      }
    }
  }
  try {
    const url = new URL(mcpServerUrl);
    if (url.username && url.password && (!authConfig || authConfig.type === "none")) {
      const auth = toBase64(`${url.username}:${url.password}`);
      serverConfig.headers = serverConfig.headers || {};
      serverConfig.headers.Authorization = `Basic ${auth}`;
      serverConfig.url = `${url.protocol}//${url.host}${url.pathname}${url.search}`;
    }
  } catch (error) {
    console.warn("Failed to parse MCP server URL for auth:", error);
  }
  client.addServer(serverName, serverConfig);
  const agent = new MCPAgent({
    llm,
    client,
    maxSteps: 10,
    memoryEnabled: false,
    // Use externalHistory instead
    exposeResourcesAsTools: false,
    exposePromptsAsTools: false,
    systemPrompt: "You are a helpful assistant with access to MCP tools. Help users interact with the MCP server."
  });
  const { HumanMessage, AIMessage } = await import("@langchain/core/messages");
  const lastUserMessageIndex = messages.map((msg, i) => ({ msg, i })).filter(({ msg }) => msg.role === "user").pop()?.i;
  if (lastUserMessageIndex === void 0) {
    throw new Error("No user message found");
  }
  const lastUserMessage = messages[lastUserMessageIndex];
  const priorMessages = messages.slice(0, lastUserMessageIndex);
  const externalHistory = priorMessages.map((msg) => {
    if (msg.role === "user") {
      if (msg.attachments && msg.attachments.length > 0) {
        const content = [
          { type: "text", text: msg.content || "[no content]" }
        ];
        for (const attachment of msg.attachments) {
          if (attachment.type === "image") {
            content.push({
              type: "image_url",
              image_url: {
                url: `data:${attachment.mimeType};base64,${attachment.data}`
              }
            });
          }
        }
        return new HumanMessage({ content });
      }
      return new HumanMessage(msg.content || "[no content]");
    }
    return new AIMessage(msg.content || "[no content]");
  });
  let messageInput;
  if (lastUserMessage.attachments && lastUserMessage.attachments.length > 0) {
    const content = [
      {
        type: "text",
        text: lastUserMessage.content || "[no content]"
      }
    ];
    for (const attachment of lastUserMessage.attachments) {
      if (attachment.type === "image") {
        content.push({
          type: "image_url",
          image_url: {
            url: `data:${attachment.mimeType};base64,${attachment.data}`
          }
        });
      }
    }
    messageInput = new HumanMessage({ content });
  } else {
    messageInput = lastUserMessage.content;
  }
  try {
    const messageId = `msg-${Date.now()}`;
    yield `data: ${JSON.stringify({ type: "message", id: messageId, role: "assistant" })}

`;
    for await (const event of agent.streamEvents(
      messageInput,
      10,
      true,
      externalHistory
    )) {
      if (event.event === "on_chat_model_stream" && event.data?.chunk?.text) {
        const text = event.data.chunk.text;
        if (typeof text === "string" && text.length > 0) {
          yield `data: ${JSON.stringify({ type: "text", id: messageId, content: text })}

`;
        }
      } else if (event.event === "on_tool_start") {
        const toolCallId = `tool-${event.name}-${Date.now()}`;
        yield `data: ${JSON.stringify({
          type: "tool-call",
          id: messageId,
          toolCallId,
          toolName: event.name,
          args: event.data?.input || {}
        })}

`;
      } else if (event.event === "on_tool_end") {
        const toolCallId = `tool-${event.name}-${Date.now()}`;
        yield `data: ${JSON.stringify({
          type: "tool-result",
          id: messageId,
          toolCallId,
          toolName: event.name,
          result: event.data?.output
        })}

`;
      }
    }
    yield `data: ${JSON.stringify({ type: "done", id: messageId })}

`;
  } finally {
    await client.closeAllSessions();
  }
}
async function handleChatRequest(requestBody) {
  const { mcpServerUrl, llmConfig, authConfig, messages } = requestBody;
  if (!mcpServerUrl || !llmConfig || !messages) {
    throw new Error(
      "Missing required fields: mcpServerUrl, llmConfig, messages"
    );
  }
  const { MCPAgent, MCPClient } = await import("mcp-use");
  let llm;
  if (llmConfig.provider === "openai") {
    const { ChatOpenAI } = await import("@langchain/openai");
    llm = new ChatOpenAI({
      model: llmConfig.model,
      apiKey: llmConfig.apiKey
    });
  } else if (llmConfig.provider === "anthropic") {
    const { ChatAnthropic } = await import("@langchain/anthropic");
    llm = new ChatAnthropic({
      model: llmConfig.model,
      apiKey: llmConfig.apiKey
    });
  } else if (llmConfig.provider === "google") {
    const { ChatGoogleGenerativeAI } = await import("@langchain/google-genai");
    llm = new ChatGoogleGenerativeAI({
      model: llmConfig.model,
      apiKey: llmConfig.apiKey
    });
  } else {
    throw new Error(`Unsupported LLM provider: ${llmConfig.provider}`);
  }
  const client = new MCPClient();
  const serverName = `inspector-${Date.now()}`;
  const serverConfig = {
    url: mcpServerUrl,
    preventAutoAuth: true
    // Prevent auto OAuth popup - tokens are passed via headers
  };
  if (authConfig && authConfig.type !== "none") {
    serverConfig.headers = {};
    if (authConfig.type === "basic" && authConfig.username && authConfig.password) {
      const auth = toBase64(`${authConfig.username}:${authConfig.password}`);
      serverConfig.headers.Authorization = `Basic ${auth}`;
    } else if (authConfig.type === "bearer" && authConfig.token) {
      serverConfig.headers.Authorization = `Bearer ${authConfig.token}`;
    } else if (authConfig.type === "oauth") {
      if (authConfig.oauthTokens?.access_token) {
        const tokenType = authConfig.oauthTokens.token_type ? authConfig.oauthTokens.token_type.charAt(0).toUpperCase() + authConfig.oauthTokens.token_type.slice(1) : "Bearer";
        serverConfig.headers.Authorization = `${tokenType} ${authConfig.oauthTokens.access_token}`;
        console.log("Using OAuth access token for MCP server authentication");
        console.log(
          "Authorization header:",
          `${tokenType} ${authConfig.oauthTokens.access_token.substring(0, 20)}...`
        );
      } else {
        console.warn("OAuth selected but no access token provided");
      }
    }
  }
  try {
    const url = new URL(mcpServerUrl);
    if (url.username && url.password && (!authConfig || authConfig.type === "none")) {
      const auth = toBase64(`${url.username}:${url.password}`);
      serverConfig.headers = serverConfig.headers || {};
      serverConfig.headers.Authorization = `Basic ${auth}`;
      serverConfig.url = `${url.protocol}//${url.host}${url.pathname}${url.search}`;
    }
  } catch (error) {
    console.warn("Failed to parse MCP server URL for auth:", error);
  }
  console.log("Adding server with config:", {
    url: serverConfig.url,
    hasHeaders: !!serverConfig.headers,
    headers: serverConfig.headers
  });
  client.addServer(serverName, serverConfig);
  const agent = new MCPAgent({
    llm,
    client,
    maxSteps: 10,
    memoryEnabled: false,
    // Use externalHistory instead
    exposeResourcesAsTools: false,
    exposePromptsAsTools: false,
    systemPrompt: "You are a helpful assistant with access to MCP tools. Help users interact with the MCP server."
  });
  const { HumanMessage, AIMessage } = await import("@langchain/core/messages");
  const lastUserMessageIndex = messages.map((msg, i) => ({ msg, i })).filter(({ msg }) => msg.role === "user").pop()?.i;
  if (lastUserMessageIndex === void 0) {
    throw new Error("No user message found");
  }
  const lastUserMessage = messages[lastUserMessageIndex];
  const priorMessages = messages.slice(0, lastUserMessageIndex);
  const externalHistory = priorMessages.map((msg) => {
    if (msg.role === "user") {
      if (msg.attachments && msg.attachments.length > 0) {
        const content = [
          { type: "text", text: msg.content || "[no content]" }
        ];
        for (const attachment of msg.attachments) {
          if (attachment.type === "image") {
            content.push({
              type: "image_url",
              image_url: {
                url: `data:${attachment.mimeType};base64,${attachment.data}`
              }
            });
          }
        }
        return new HumanMessage({ content });
      }
      return new HumanMessage(msg.content || "[no content]");
    }
    return new AIMessage(msg.content || "[no content]");
  });
  let messageInput;
  if (lastUserMessage.attachments && lastUserMessage.attachments.length > 0) {
    const content = [
      {
        type: "text",
        text: lastUserMessage.content || "[no content]"
      }
    ];
    for (const attachment of lastUserMessage.attachments) {
      if (attachment.type === "image") {
        content.push({
          type: "image_url",
          image_url: {
            url: `data:${attachment.mimeType};base64,${attachment.data}`
          }
        });
      }
    }
    messageInput = new HumanMessage({ content });
  } else {
    messageInput = lastUserMessage.content;
  }
  const response = await agent.run(messageInput, 10, true, externalHistory);
  await client.closeAllSessions();
  return {
    content: response,
    toolCalls: []
  };
}
var widgetDataStore = /* @__PURE__ */ new Map();
setInterval(
  () => {
    const now = Date.now();
    const ONE_HOUR = 60 * 60 * 1e3;
    for (const [toolId, data] of widgetDataStore.entries()) {
      if (now - data.timestamp > ONE_HOUR) {
        widgetDataStore.delete(toolId);
      }
    }
  },
  5 * 60 * 1e3
).unref();
function storeWidgetData(data) {
  const {
    serverId,
    uri,
    toolInput,
    toolOutput,
    toolResponseMetadata,
    resourceData,
    toolId,
    widgetCSP,
    mcpAppsCsp,
    mcpAppsPermissions,
    devWidgetUrl,
    devServerBaseUrl,
    theme
  } = data;
  const debugWidget = process.env.DEBUG != null && process.env.DEBUG !== "" && process.env.DEBUG !== "0" && process.env.DEBUG.toLowerCase() !== "false";
  if (debugWidget) {
    console.log("[Widget Store] Received request for toolId:", toolId);
    console.log("[Widget Store] Fields:", {
      serverId,
      uri,
      hasResourceData: !!resourceData,
      hasToolInput: !!toolInput,
      hasToolOutput: !!toolOutput,
      hasToolResponseMetadata: !!toolResponseMetadata,
      toolResponseMetadata,
      hasWidgetCSP: !!widgetCSP,
      devWidgetUrl,
      devServerBaseUrl
    });
  }
  if (!serverId || !uri || !toolId || !resourceData) {
    const missingFields = [];
    if (!serverId) missingFields.push("serverId");
    if (!uri) missingFields.push("uri");
    if (!toolId) missingFields.push("toolId");
    if (!resourceData) missingFields.push("resourceData");
    console.error("[Widget Store] Missing required fields:", missingFields);
    return {
      success: false,
      error: `Missing required fields: ${missingFields.join(", ")}`
    };
  }
  widgetDataStore.set(toolId, {
    serverId,
    uri,
    toolInput,
    toolOutput,
    toolResponseMetadata,
    resourceData,
    toolId,
    timestamp: Date.now(),
    widgetCSP,
    mcpAppsCsp,
    mcpAppsPermissions,
    devWidgetUrl,
    devServerBaseUrl,
    theme
  });
  if (debugWidget) {
    console.log("[Widget Store] Data stored successfully for toolId:", toolId);
  }
  return { success: true };
}
function getWidgetData(toolId) {
  return widgetDataStore.get(toolId);
}
function generateWidgetContainerHtml(basePath, toolId) {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <title>Loading Widget...</title>
    </head>
    <body>
      <script>
        (async function() {
          try {
            // Fetch the actual widget HTML using toolId
            const response = await fetch('${basePath}/api/resources/widget-content/${toolId}');
            const html = await response.text();

            // Replace entire document with widget HTML using proper method
            document.open();
            document.write(html);
            document.close();
          } catch (error) {
            console.error('Failed to load widget:', error);
            document.body.innerHTML = '<div style="padding: 20px; color: red;">Failed to load widget: ' + error.message + '</div>';
          }
        })();
      </script>
    </body>
    </html>
  `;
}
function generateWidgetContentHtml(widgetData) {
  const {
    serverId,
    uri,
    toolInput,
    toolOutput,
    toolResponseMetadata,
    resourceData,
    toolId,
    theme,
    playground
  } = widgetData;
  const debugWidget = process.env.DEBUG != null && process.env.DEBUG !== "" && process.env.DEBUG !== "0" && process.env.DEBUG.toLowerCase() !== "false";
  if (debugWidget) {
    console.log("[Widget Content] Using pre-fetched resource for:", {
      serverId,
      uri
    });
  }
  let htmlContent = "";
  const contentsArray = Array.isArray(resourceData?.contents) ? resourceData.contents : [];
  const firstContent = contentsArray[0];
  if (firstContent) {
    if (typeof firstContent.text === "string") {
      htmlContent = firstContent.text;
    } else if (typeof firstContent.blob === "string") {
      htmlContent = firstContent.blob;
    }
  }
  if (!htmlContent && resourceData && typeof resourceData === "object") {
    const recordContent = resourceData;
    if (typeof recordContent.text === "string") {
      htmlContent = recordContent.text;
    } else if (typeof recordContent.blob === "string") {
      htmlContent = recordContent.blob;
    }
  }
  if (!htmlContent) {
    return { html: "", error: "No HTML content found" };
  }
  const widgetStateKey = `openai-widget-state:${toolId}`;
  const safeToolInput = JSON.stringify(toolInput ?? null).replace(/</g, "\\u003c").replace(/>/g, "\\u003e");
  const safeToolOutput = JSON.stringify(toolOutput ?? null).replace(/</g, "\\u003c").replace(/>/g, "\\u003e");
  const safeToolResponseMetadata = JSON.stringify(toolResponseMetadata ?? null).replace(/</g, "\\u003c").replace(/>/g, "\\u003e");
  const safeToolId = JSON.stringify(toolId);
  const safeWidgetStateKey = JSON.stringify(widgetStateKey);
  const safeTheme = JSON.stringify(theme === "dark" ? "dark" : "light");
  const locale = playground?.locale || "en-US";
  const deviceType = playground?.deviceType || "desktop";
  const capabilities = playground?.capabilities || {
    hover: true,
    touch: false
  };
  const safeAreaInsets = playground?.safeAreaInsets || {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  const safeLocale = JSON.stringify(locale);
  const safeUserAgent = JSON.stringify({
    device: { type: deviceType },
    capabilities
  });
  const safeSafeArea = JSON.stringify({ insets: safeAreaInsets });
  const apiScript = `
    <script>
      (function() {
        'use strict';

        // Change URL to "/" for React Router compatibility.
        // Skip when loaded inside the inspector (widget-content endpoint)
        // to prevent Vite HMR reloads from navigating to "/" (inspector SPA).
        if (window.location.pathname !== '/' && !window.location.pathname.includes('/inspector/')) {
          history.replaceState(null, '', '/');
        }

        function emitWidgetRuntimeError(payload) {
          var args = [{
            message: payload && payload.message ? payload.message : "Unknown widget runtime error",
            stack: payload && payload.stack ? payload.stack : undefined,
            source: payload && payload.source ? payload.source : undefined,
            fileName: payload && payload.fileName ? payload.fileName : undefined,
            line: payload && payload.line ? payload.line : undefined,
            column: payload && payload.column ? payload.column : undefined,
            timestamp: payload && payload.timestamp ? payload.timestamp : Date.now(),
          }];
          try {
            window.parent.postMessage(
              {
                type: "iframe-console-log",
                level: "error",
                args: args,
                timestamp: new Date().toISOString(),
                url: window.location.href,
                toolId: ${safeToolId},
              },
              "*"
            );
          } catch (emitErr) {}
        }

        window.addEventListener("error", function(event) {
          var err = event && event.error;
          var message =
            (err && err.message) ||
            (event && event.message) ||
            "Unknown widget runtime error";
          emitWidgetRuntimeError({
            source: "window.error",
            message: String(message),
            stack: err && err.stack ? String(err.stack) : undefined,
            fileName: event && event.filename ? String(event.filename) : undefined,
            line: event && typeof event.lineno === "number" ? event.lineno : undefined,
            column: event && typeof event.colno === "number" ? event.colno : undefined,
            timestamp: Date.now(),
          });
        });

        window.addEventListener("unhandledrejection", function(event) {
          var reason = event ? event.reason : undefined;
          var message = "Unhandled promise rejection";
          var stack = undefined;
          if (reason && typeof reason === "object") {
            message = String(reason.message || message);
            stack = reason.stack ? String(reason.stack) : undefined;
          } else if (typeof reason === "string") {
            message = reason;
          } else if (reason != null) {
            message = String(reason);
          }
          emitWidgetRuntimeError({
            source: "window.unhandledrejection",
            message: message,
            stack: stack,
            timestamp: Date.now(),
          });
        });

        const openaiAPI = {
          toolInput: ${safeToolInput},
          toolOutput: ${safeToolOutput},
          toolResponseMetadata: ${safeToolResponseMetadata},
          displayMode: 'inline',
          maxHeight: 600,
          theme: ${safeTheme},
          locale: ${safeLocale},
          safeArea: ${safeSafeArea},
          userAgent: ${safeUserAgent},
          widgetState: null,

          async setWidgetState(state) {
            this.widgetState = state;
            try {
              localStorage.setItem(${safeWidgetStateKey}, JSON.stringify(state));
            } catch (err) {
              console.error('[OpenAI Widget] Failed to save widget state:', err);
            }
            window.parent.postMessage({
              type: 'openai:setWidgetState',
              toolId: ${safeToolId},
              state
            }, '*');
          },

          async callTool(toolName, params = {}) {
            return new Promise((resolve, reject) => {
              const requestId = \`tool_\${Date.now()}_\${Math.random()}\`;
              const handler = (event) => {
                if (event.data.type === 'openai:callTool:response' &&
                    event.data.requestId === requestId) {
                  window.removeEventListener('message', handler);
                  if (event.data.error) {
                    reject(new Error(event.data.error));
                  } else {
                    resolve(event.data.result);
                  }
                }
              };
              window.addEventListener('message', handler);
              window.parent.postMessage({
                type: 'openai:callTool',
                requestId,
                toolName,
                params
              }, '*');
              setTimeout(() => {
                window.removeEventListener('message', handler);
                reject(new Error('Tool call timeout'));
              }, 30000);
            });
          },

          async sendFollowupTurn(message) {
            const payload = typeof message === 'string'
              ? { prompt: message }
              : message;
            window.parent.postMessage({
              type: 'openai:sendFollowup',
              message: payload.prompt || payload
            }, '*');
          },

          async requestDisplayMode(options = {}) {
            const mode = options.mode || 'inline';
            this.displayMode = mode;
            window.parent.postMessage({
              type: 'openai:requestDisplayMode',
              mode
            }, '*');
            return { mode };
          },

          async sendFollowUpMessage(args) {
            const prompt = typeof args === 'string' ? args : (args?.prompt || '');
            return this.sendFollowupTurn(prompt);
          },

          async notifyIntrinsicHeight(height) {
            console.log('[OpenAI Widget] notifyIntrinsicHeight called with:', height);
            if (typeof height !== 'number' || height < 0) {
              console.error('[OpenAI Widget] Invalid height value:', height);
              throw new Error('Height must be a non-negative number');
            }
            const message = {
              type: 'openai:notifyIntrinsicHeight',
              height
            };
            console.log('[OpenAI Widget] Sending postMessage to parent:', message);
            window.parent.postMessage(message, '*');
          },

          openExternal(payload) {
            const href = typeof payload === 'string' ? payload : payload?.href;
            if (href) {
              window.open(href, '_blank', 'noopener,noreferrer');
            }
          }
        };

        // Report CSP violations to the inspector host
        document.addEventListener('securitypolicyviolation', function(e) {
          window.parent.postMessage({
            type: 'openai:csp-violation',
            toolId: ${safeToolId},
            directive: e.violatedDirective,
            effectiveDirective: e.effectiveDirective,
            blockedUri: e.blockedURI,
            sourceFile: e.sourceFile || null,
            lineNumber: e.lineNumber,
            columnNumber: e.columnNumber,
            originalPolicy: e.originalPolicy,
            disposition: e.disposition,
            timestamp: Date.now(),
          }, '*');
        });

        Object.defineProperty(window, 'openai', {
          value: openaiAPI,
          writable: false,
          configurable: false,
          enumerable: true
        });

        Object.defineProperty(window, 'webplus', {
          value: openaiAPI,
          writable: false,
          configurable: false,
          enumerable: true
        });

        // Do not fire openai:set_globals here \u2014 window.openai is already set synchronously.
        // useSyncExternalStore reads it on first render. Firing the event would cause a
        // redundant second render (double flash at pending/final state).

        // Listen for widget state requests from inspector
        window.addEventListener('message', (event) => {
          if (event.data?.type === 'mcp-inspector:getWidgetState') {
            window.parent.postMessage({
              type: 'mcp-inspector:widgetStateResponse',
              toolId: event.data.toolId,
              state: openaiAPI.widgetState
            }, '*');
            return;
          }
        });

        // Listen for globals changes from parent (for displayMode, theme, etc.)
        window.addEventListener('message', (event) => {
          // Handle new general globalsChanged message
          if (event.data?.type === 'openai:globalsChanged') {
            const updates = event.data.updates || {};
            let hasChanges = false;

            // Update displayMode
            if (updates.displayMode && ['inline', 'pip', 'fullscreen'].includes(updates.displayMode)) {
              openaiAPI.displayMode = updates.displayMode;
              hasChanges = true;
            }

            // Update theme
            if (updates.theme && ['light', 'dark'].includes(updates.theme)) {
              openaiAPI.theme = updates.theme;
              hasChanges = true;
            }

            // Update maxHeight
            if (updates.maxHeight !== undefined && typeof updates.maxHeight === 'number') {
              openaiAPI.maxHeight = updates.maxHeight;
              hasChanges = true;
            }

            // Update locale
            if (updates.locale && typeof updates.locale === 'string') {
              openaiAPI.locale = updates.locale;
              hasChanges = true;
            }

            // Update safeArea
            if (updates.safeArea && typeof updates.safeArea === 'object') {
              openaiAPI.safeArea = updates.safeArea;
              hasChanges = true;
            }

            // Update userAgent
            if (updates.userAgent !== undefined) {
              openaiAPI.userAgent = updates.userAgent;
              hasChanges = true;
            }

            // Dispatch set_globals event to notify React components if any changes occurred
            if (hasChanges) {
              try {
                const globalsEvent = new CustomEvent('openai:set_globals', {
                  detail: {
                    globals: {
                      toolInput: openaiAPI.toolInput,
                      toolOutput: openaiAPI.toolOutput,
                      toolResponseMetadata: openaiAPI.toolResponseMetadata || null,
                      widgetState: openaiAPI.widgetState,
                      displayMode: openaiAPI.displayMode,
                      maxHeight: openaiAPI.maxHeight,
                      theme: openaiAPI.theme,
                      locale: openaiAPI.locale,
                      safeArea: openaiAPI.safeArea,
                      userAgent: openaiAPI.userAgent
                    }
                  }
                });
                window.dispatchEvent(globalsEvent);
              } catch (err) {}
            }
          }
          // Handle legacy displayModeChanged message for backward compatibility
          else if (event.data?.type === 'openai:displayModeChanged') {
            const newMode = event.data.mode;
            if (newMode && ['inline', 'pip', 'fullscreen'].includes(newMode)) {
              openaiAPI.displayMode = newMode;
              // Dispatch set_globals event to notify React components
              try {
                const globalsEvent = new CustomEvent('openai:set_globals', {
                  detail: {
                    globals: {
                      toolInput: openaiAPI.toolInput,
                      toolOutput: openaiAPI.toolOutput,
                      toolResponseMetadata: openaiAPI.toolResponseMetadata || null,
                      widgetState: openaiAPI.widgetState,
                      displayMode: newMode,
                      maxHeight: openaiAPI.maxHeight,
                      theme: openaiAPI.theme,
                      locale: openaiAPI.locale,
                      safeArea: openaiAPI.safeArea,
                      userAgent: openaiAPI.userAgent
                    }
                  }
                });
                window.dispatchEvent(globalsEvent);
              } catch (err) {}
            }
          }
        });

        setTimeout(() => {
          try {
            const stored = localStorage.getItem(${safeWidgetStateKey});
            if (stored && window.openai) {
              window.openai.widgetState = JSON.parse(stored);
            }
          } catch (err) {}
        }, 0);
      })();
    </script>
  `;
  let modifiedHtml;
  if (htmlContent.includes("<html") && htmlContent.includes("<head")) {
    modifiedHtml = htmlContent.replace("<head>", `<head>${apiScript}`);
  } else {
    modifiedHtml = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  ${apiScript}
  <title>Widget</title>
</head>
<body>
  ${htmlContent}
</body>
</html>`;
  }
  if (debugWidget) {
    console.log("[Widget Content] Generated HTML length:", modifiedHtml.length);
  }
  return { html: modifiedHtml };
}
function transformMcpAppsCspToSnakeCase(mcpAppsCsp) {
  if (!mcpAppsCsp) return void 0;
  const result = {};
  if (mcpAppsCsp.connectDomains) {
    result.connect_domains = mcpAppsCsp.connectDomains;
  }
  if (mcpAppsCsp.resourceDomains) {
    result.resource_domains = mcpAppsCsp.resourceDomains;
  }
  if (mcpAppsCsp.frameDomains) {
    result.frame_domains = mcpAppsCsp.frameDomains;
  }
  return Object.keys(result).length > 0 ? result : void 0;
}
function getWidgetSecurityHeaders(widgetCSP, devServerBaseUrl, frameAncestors) {
  const trustedCdns = [
    "https://persistent.oaistatic.com",
    "https://*.oaistatic.com",
    "https://unpkg.com",
    "https://cdn.jsdelivr.net",
    "https://cdnjs.cloudflare.com",
    "https://cdn.skypack.dev",
    "https://*.openai.com"
  ];
  const prodResourceDomains = [...trustedCdns];
  if (widgetCSP?.resource_domains) {
    prodResourceDomains.push(...widgetCSP.resource_domains);
  }
  const prodResourceDomainsStr = prodResourceDomains.join(" ");
  let devServerOrigin = null;
  const allResourceDomains = [...prodResourceDomains];
  if (devServerBaseUrl) {
    try {
      devServerOrigin = new URL(devServerBaseUrl).origin;
      allResourceDomains.push(devServerOrigin);
    } catch (e) {
      console.warn(`[CSP] Invalid devServerBaseUrl: ${devServerBaseUrl}`);
    }
  }
  const resourceDomainsStr = allResourceDomains.join(" ");
  let imgSrc = "'self' data: https: blob:";
  if (devServerOrigin) {
    imgSrc = `'self' data: https: blob: ${devServerOrigin}`;
  }
  let mediaSrc = "'self' data: https: blob:";
  if (devServerOrigin) {
    mediaSrc = `'self' data: https: blob: ${devServerOrigin}`;
  }
  let fontSrc = `'self' data: ${resourceDomainsStr}`;
  if (devServerOrigin) {
    fontSrc = `'self' data: https: http: ${resourceDomainsStr}`;
  }
  let connectSrc = "'self' https: wss: ws:";
  if (widgetCSP?.connect_domains && widgetCSP.connect_domains.length > 0) {
    connectSrc = `'self' ${widgetCSP.connect_domains.join(" ")} https: wss: ws:`;
  }
  let frameSrc = "'self' blob:";
  const frameDomains = widgetCSP?.frame_domains || widgetCSP?.resource_domains;
  if (frameDomains && frameDomains.length > 0) {
    frameSrc = `'self' blob: ${frameDomains.join(" ")}`;
  }
  let frameAncestorsPolicy = "*";
  if (frameAncestors) {
    frameAncestorsPolicy = `'self' ${frameAncestors}`.trim();
  }
  const headers = {
    "Content-Security-Policy": [
      "default-src 'self'",
      `script-src 'self' 'unsafe-inline' 'unsafe-eval' ${resourceDomainsStr}`,
      "worker-src 'self' blob:",
      `child-src 'self' blob: ${frameDomains?.join(" ") || ""}`.trim(),
      `frame-src ${frameSrc}`,
      `style-src 'self' 'unsafe-inline' ${resourceDomainsStr}`,
      `img-src ${imgSrc}`,
      `media-src ${mediaSrc}`,
      `font-src ${fontSrc}`,
      `connect-src ${connectSrc}`,
      `frame-ancestors ${frameAncestorsPolicy}`
    ].join("; "),
    "X-Frame-Options": "SAMEORIGIN",
    "X-Content-Type-Options": "nosniff",
    "Cache-Control": "no-cache, no-store, must-revalidate",
    Pragma: "no-cache",
    Expires: "0"
  };
  if (devServerOrigin) {
    const prodConnectSrc = "'self' https: wss: ws:";
    let prodFrameSrc = "'self' blob:";
    const prodFrameDomains = widgetCSP?.frame_domains || widgetCSP?.resource_domains;
    if (prodFrameDomains && prodFrameDomains.length > 0) {
      prodFrameSrc = `'self' blob: ${prodFrameDomains.join(" ")}`;
    }
    headers["Content-Security-Policy-Report-Only"] = [
      "default-src 'self'",
      `script-src 'self' 'unsafe-inline' 'unsafe-eval' ${prodResourceDomainsStr}`,
      "worker-src 'self' blob:",
      `child-src 'self' blob: ${prodFrameDomains?.join(" ") || ""}`.trim(),
      `frame-src ${prodFrameSrc}`,
      `style-src 'self' 'unsafe-inline' ${prodResourceDomainsStr}`,
      "img-src 'self' data: https: blob:",
      "media-src 'self' data: https: blob:",
      `font-src 'self' data: ${prodResourceDomainsStr}`,
      `connect-src ${prodConnectSrc}`,
      `frame-ancestors ${frameAncestorsPolicy}`
    ].join("; ");
  }
  return headers;
}

export {
  handleChatRequestStream,
  handleChatRequest,
  storeWidgetData,
  getWidgetData,
  generateWidgetContainerHtml,
  generateWidgetContentHtml,
  transformMcpAppsCspToSnakeCase,
  getWidgetSecurityHeaders
};
