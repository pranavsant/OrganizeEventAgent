/**
 * Browser-compatible utilities for MCP Inspector chat functionality
 * Works in both Node.js and browser environments without Node.js-specific APIs
 */
interface LLMConfig {
    provider: "openai" | "anthropic" | "google";
    model: string;
    apiKey: string;
    temperature?: number;
}
interface OAuthTokens {
    access_token: string;
    token_type?: string;
    [key: string]: unknown;
}
interface AuthConfig {
    type?: string;
    clientId?: string;
    redirectUri?: string;
    scope?: string;
    username?: string;
    password?: string;
    token?: string;
    oauthTokens?: OAuthTokens;
    [key: string]: unknown;
}
interface MessageAttachment {
    type: "image" | "file";
    data: string;
    mimeType: string;
    name?: string;
    size?: number;
}
interface ChatMessage {
    role: "system" | "user" | "assistant";
    content: string;
    attachments?: MessageAttachment[];
}
interface ToolCall {
    name: string;
    arguments: Record<string, unknown>;
    result?: unknown;
}
/**
 * Handle chat API request with MCP agent (streaming)
 */
export declare function handleChatRequestStream(requestBody: {
    mcpServerUrl: string;
    llmConfig: LLMConfig;
    authConfig?: AuthConfig;
    messages: ChatMessage[];
}): AsyncGenerator<string, void, void>;
/**
 * Execute a non-streaming chat turn using an MCP agent and the specified LLM configuration.
 *
 * @param requestBody - Request parameters
 * @param requestBody.mcpServerUrl - Base URL of the MCP server to connect to
 * @param requestBody.llmConfig - LLM provider configuration (provider, model, apiKey, etc.)
 * @param requestBody.authConfig - Optional authentication configuration for the MCP server
 * @param requestBody.messages - Array of chat messages; only the last message with role "user" is used as the query
 * @returns An object containing `content` with the agent's response text and `toolCalls` with recorded tool invocations (empty for this non-streaming implementation)
 * @throws If required fields are missing, if the LLM provider is unsupported, or if no user message is found
 */
export declare function handleChatRequest(requestBody: {
    mcpServerUrl: string;
    llmConfig: LLMConfig;
    authConfig?: AuthConfig;
    messages: ChatMessage[];
}): Promise<{
    content: string;
    toolCalls: ToolCall[];
}>;
/**
 * Widget data storage
 */
export interface WidgetData {
    serverId: string;
    uri: string;
    toolInput: Record<string, any>;
    toolOutput: any;
    toolResponseMetadata?: Record<string, any>;
    resourceData: any;
    toolId: string;
    timestamp: number;
    widgetCSP?: {
        connect_domains?: string[];
        resource_domains?: string[];
        frame_domains?: string[];
    };
    devWidgetUrl?: string;
    devServerBaseUrl?: string;
    theme?: "light" | "dark";
    playground?: {
        locale?: string;
        deviceType?: "mobile" | "tablet" | "desktop";
        capabilities?: {
            hover: boolean;
            touch: boolean;
        };
        safeAreaInsets?: {
            top: number;
            right: number;
            bottom: number;
            left: number;
        };
    };
    protocol?: "mcp-apps" | "chatgpt-app";
    toolName?: string;
    mimeType?: string;
    mcpAppsCsp?: {
        connectDomains?: string[];
        resourceDomains?: string[];
        frameDomains?: string[];
        baseUriDomains?: string[];
    };
    mcpAppsPermissions?: {
        camera?: Record<string, never>;
        microphone?: Record<string, never>;
        geolocation?: Record<string, never>;
        clipboardWrite?: Record<string, never>;
    };
}
/**
 * Store widget data for rendering
 */
export declare function storeWidgetData(data: Omit<WidgetData, "timestamp">): {
    success: boolean;
    error?: string;
};
/**
 * Get widget data by toolId
 */
export declare function getWidgetData(toolId: string): WidgetData | undefined;
/**
 * Generate widget container HTML
 */
export declare function generateWidgetContainerHtml(basePath: string, toolId: string): string;
/**
 * Generate widget content HTML with injected OpenAI API
 */
export declare function generateWidgetContentHtml(widgetData: WidgetData): {
    html: string;
    error?: string;
};
/**
 * Transform MCP Apps camelCase CSP to snake_case for existing header builder
 *
 * MCP Apps (SEP-1865) uses camelCase (connectDomains, resourceDomains)
 * ChatGPT Apps SDK uses snake_case (connect_domains, resource_domains)
 *
 * @param mcpAppsCsp - MCP Apps CSP configuration with camelCase keys
 * @returns ChatGPT-compatible CSP configuration with snake_case keys
 */
export declare function transformMcpAppsCspToSnakeCase(mcpAppsCsp?: {
    connectDomains?: string[];
    resourceDomains?: string[];
    frameDomains?: string[];
    baseUriDomains?: string[];
}): {
    connect_domains?: string[];
    resource_domains?: string[];
    frame_domains?: string[];
} | undefined;
/**
 * Get security headers for widget content
 */
export declare function getWidgetSecurityHeaders(widgetCSP?: {
    connect_domains?: string[];
    resource_domains?: string[];
    frame_domains?: string[];
}, devServerBaseUrl?: string, frameAncestors?: string): Record<string, string>;
export {};
//# sourceMappingURL=shared-utils.d.ts.map