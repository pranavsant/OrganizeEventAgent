import {
  generateWidgetContainerHtml,
  generateWidgetContentHtml,
  getWidgetData,
  getWidgetSecurityHeaders,
  handleChatRequest,
  handleChatRequestStream,
  storeWidgetData
} from "./chunk-IZPEEN7F.js";
import {
  formatErrorResponse
} from "./chunk-O7EUTZ5E.js";
import {
  rpcLogBus
} from "./chunk-CVECQ7BJ.js";

// src/server/shared-routes.ts
import { mountMcpProxy, mountOAuthProxy } from "mcp-use/server";

// src/server/routes/mcp-apps.ts
var RESOURCE_MIME_TYPE = "text/html;profile=mcp-app";
var SANDBOX_PROXY_HTML = `<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; img-src * data: blob: 'unsafe-inline'; media-src * blob: data:; font-src * blob: data:; script-src * 'wasm-unsafe-eval' 'unsafe-inline' 'unsafe-eval' blob: data:; style-src * blob: data: 'unsafe-inline'; connect-src * data: blob: about:; frame-src * blob: data: http://localhost:* https://localhost:* http://127.0.0.1:* https://127.0.0.1:*;"
    />
    <title>MCP Apps Sandbox Proxy</title>
    <style>
      html, body { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; }
      * { box-sizing: border-box; }
      iframe { display: block; background-color: transparent; border: 0px none transparent; padding: 0px; width: 100%; height: 100%; }
    </style>
  </head>
  <body>
    <script>
      function sanitizeDomain(domain) {
        if (typeof domain !== "string") return "";
        return domain.replace(/['"<>;]/g, "").trim();
      }

      function buildAllowAttribute(permissions) {
        if (!permissions) return "";
        const allowList = [];
        if (permissions.camera) allowList.push("camera *");
        if (permissions.microphone) allowList.push("microphone *");
        if (permissions.geolocation) allowList.push("geolocation *");
        if (permissions.clipboardWrite) allowList.push("clipboard-write *");
        return allowList.join("; ");
      }

      function buildCSP(csp) {
        if (!csp) {
          return [
            "default-src 'none'",
            "script-src 'unsafe-inline'",
            "style-src 'unsafe-inline'",
            "img-src data:",
            "font-src data:",
            "media-src data:",
            "connect-src 'none'",
            "frame-src 'none'",
            "object-src 'none'",
            "base-uri 'none'",
          ].join("; ");
        }

        const connectDomains = (csp.connectDomains || []).map(sanitizeDomain).filter(Boolean);
        const resourceDomains = (csp.resourceDomains || []).map(sanitizeDomain).filter(Boolean);
        const frameDomains = (csp.frameDomains || []).map(sanitizeDomain).filter(Boolean);
        const baseUriDomains = (csp.baseUriDomains || []).map(sanitizeDomain).filter(Boolean);
        const scriptDirectives = (csp.scriptDirectives || []).filter(function(d) { return typeof d === "string" && d.length > 0; });

        const connectSrc = connectDomains.length > 0 ? connectDomains.join(" ") : "'none'";
        const resourceSrc = resourceDomains.length > 0 ? ["data:", "blob:", ...resourceDomains].join(" ") : "data: blob:";
        const frameSrc = frameDomains.length > 0 ? frameDomains.join(" ") : "'none'";
        const baseUri = baseUriDomains.length > 0 ? baseUriDomains.join(" ") : "'none'";
        const scriptSrcParts = ["'unsafe-inline'", resourceSrc];
        if (scriptDirectives.length > 0) scriptSrcParts.push(scriptDirectives.join(" "));

        return [
          "default-src 'none'",
          "script-src " + scriptSrcParts.join(" "),
          "style-src 'unsafe-inline' " + resourceSrc,
          "img-src " + resourceSrc,
          "font-src " + resourceSrc,
          "media-src " + resourceSrc,
          "connect-src " + connectSrc,
          "frame-src " + frameSrc,
          "object-src 'none'",
          "base-uri " + baseUri,
        ].join("; ");
      }

      function buildViolationListenerScript() {
        return \`<script>
document.addEventListener('securitypolicyviolation', function(e) {
  var violation = {
    type: 'mcp-apps:csp-violation',
    directive: e.violatedDirective,
    blockedUri: e.blockedURI,
    sourceFile: e.sourceFile || null,
    lineNumber: e.lineNumber || null,
    columnNumber: e.columnNumber || null,
    effectiveDirective: e.effectiveDirective,
    originalPolicy: e.originalPolicy,
    disposition: e.disposition,
    timestamp: Date.now()
  };
  console.warn('[MCP Apps CSP Violation]', violation.directive, ':', violation.blockedUri);
  window.parent.postMessage(violation, '*');
});

function serializeConsoleArgs(args) {
  try {
    return Array.from(args || []).map(function(arg) {
      if (arg instanceof Error) {
        return {
          type: 'Error',
          message: arg.message,
          stack: arg.stack,
          name: arg.name,
        };
      }
      if (typeof arg === 'object' && arg !== null) {
        try {
          return JSON.parse(JSON.stringify(arg));
        } catch (e) {
          return String(arg);
        }
      }
      return arg;
    });
  } catch (e) {
    return [String(args)];
  }
}

function sendConsoleToParent(level, args) {
  try {
    window.parent.postMessage({
      type: 'iframe-console-log',
      level: level,
      args: serializeConsoleArgs(args),
      timestamp: new Date().toISOString(),
      url: window.location.href,
    }, '*');
  } catch (e) {}
}

var originalConsoleError = console.error.bind(console);
console.error = function() {
  var args = Array.from(arguments);
  originalConsoleError.apply(console, args);
  sendConsoleToParent('error', args);
};

window.addEventListener('error', function(event) {
  sendConsoleToParent('error', [{
    message: event.message,
    filename: event.filename,
    lineno: event.lineno,
    colno: event.colno,
    error: event.error ? {
      message: event.error.message,
      stack: event.error.stack,
      name: event.error.name,
    } : null,
  }]);
});

window.addEventListener('unhandledrejection', function(event) {
  sendConsoleToParent('error', [{
    message: 'Unhandled Promise Rejection',
    reason: event.reason ? String(event.reason) : 'Unknown',
    error: event.reason instanceof Error ? {
      message: event.reason.message,
      stack: event.reason.stack,
      name: event.reason.name,
    } : null,
  }]);
});
</\` + \`script>\`;
      }

      function injectCSP(html, cspValue) {
        const cspMeta = '<meta http-equiv="Content-Security-Policy" content="' + cspValue + '">';
        const violationListener = buildViolationListenerScript();
        const injection = cspMeta + violationListener;

        if (html.includes("<head>")) {
          return html.replace("<head>", "<head>" + injection);
        } else if (html.includes("<HEAD>")) {
          return html.replace("<HEAD>", "<HEAD>" + injection);
        } else if (html.includes("<html>")) {
          return html.replace("<html>", "<html><head>" + injection + "</head>");
        } else if (html.includes("<HTML>")) {
          return html.replace("<HTML>", "<HTML><head>" + injection + "</head>");
        } else if (html.includes("<!DOCTYPE") || html.includes("<!doctype")) {
          return html.replace(/(<!DOCTYPE[^>]*>|<!doctype[^>]*>)/i, "$1<head>" + injection + "</head>");
        } else {
          return injection + html;
        }
      }

      const inner = document.createElement("iframe");
      inner.style = "width:100%; height:100%; border:none;";
      inner.setAttribute("sandbox", "allow-scripts allow-same-origin allow-forms");
      document.body.appendChild(inner);

      window.addEventListener("message", async (event) => {
        if (event.source === window.parent) {
          if (event.data && event.data.method === "ui/notifications/sandbox-resource-ready") {
            const { html, sandbox, csp, permissions, permissive } = event.data.params || {};
            if (typeof sandbox === "string") {
              inner.setAttribute("sandbox", sandbox);
            }
            const allowAttribute = buildAllowAttribute(permissions);
            if (allowAttribute) {
              inner.setAttribute("allow", allowAttribute);
            }
            if (typeof html === "string") {
              if (permissive) {
                const permissiveCsp = [
                  "default-src * 'unsafe-inline' 'unsafe-eval' data: blob: filesystem: about:",
                  "script-src * 'unsafe-inline' 'unsafe-eval' data: blob:",
                  "style-src * 'unsafe-inline' data: blob:",
                  "img-src * data: blob: https: http:",
                  "media-src * data: blob: https: http:",
                  "font-src * data: blob: https: http:",
                  "connect-src * data: blob: https: http: ws: wss: about:",
                  "frame-src * data: blob: https: http: about:",
                  "object-src * data: blob:",
                  "base-uri *",
                  "form-action *",
                ].join("; ");
                const processedHtml = injectCSP(html, permissiveCsp);
                inner.srcdoc = processedHtml;
              } else {
                const cspValue = buildCSP(csp);
                const processedHtml = injectCSP(html, cspValue);
                inner.srcdoc = processedHtml;
              }
            }
          } else {
            if (inner && inner.contentWindow) {
              inner.contentWindow.postMessage(event.data, "*");
            }
          }
        } else if (event.source === inner.contentWindow) {
          window.parent.postMessage(event.data, "*");
        }
      });

      window.parent.postMessage({
        jsonrpc: "2.0",
        method: "ui/notifications/sandbox-proxy-ready",
        params: {},
      }, "*");
    </script>
  </body>
</html>`;
function registerMcpAppsRoutes(app) {
  app.post("/inspector/api/mcp-apps/widget/store", async (c) => {
    try {
      const body = await c.req.json();
      const result = storeWidgetData({
        ...body,
        protocol: "mcp-apps"
        // Tag as MCP Apps protocol
      });
      if (!result.success) {
        return c.json(result, 400);
      }
      return c.json(result);
    } catch (error) {
      console.error("[MCP Apps] Error storing widget data:", error);
      return c.json(
        {
          success: false,
          error: error instanceof Error ? error.message : "Unknown error"
        },
        500
      );
    }
  });
  app.get("/inspector/api/mcp-apps/widget-content/:toolId", async (c) => {
    try {
      const toolId = c.req.param("toolId");
      const cspModeParam = c.req.query("csp_mode");
      const widgetData = getWidgetData(toolId);
      if (!widgetData) {
        return c.json({ error: "Widget data not found or expired" }, 404);
      }
      const { resourceData, mcpAppsCsp, mcpAppsPermissions } = widgetData;
      let htmlContent = "";
      let mimeType;
      const contentsArray = Array.isArray(resourceData?.contents) ? resourceData.contents : [];
      const firstContent = contentsArray[0];
      if (firstContent) {
        mimeType = firstContent.mimeType;
        if (typeof firstContent.text === "string") {
          htmlContent = firstContent.text;
        } else if (typeof firstContent.blob === "string") {
          htmlContent = Buffer.from(firstContent.blob, "base64").toString(
            "utf-8"
          );
        }
      }
      if (!htmlContent) {
        return c.json({ error: "No HTML content in resource" }, 404);
      }
      const mimeTypeValid = mimeType === RESOURCE_MIME_TYPE;
      const mimeTypeWarning = !mimeTypeValid ? mimeType ? `Invalid MIME type "${mimeType}" - SEP-1865 requires "${RESOURCE_MIME_TYPE}"` : `Missing MIME type - SEP-1865 requires "${RESOURCE_MIME_TYPE}"` : null;
      if (mimeTypeWarning) {
        console.warn("[MCP Apps] MIME type validation:", mimeTypeWarning, {
          resourceUri: widgetData.uri
        });
      }
      const cspMode = cspModeParam || "permissive";
      const isPermissive = cspMode === "permissive";
      c.header("Cache-Control", "no-cache, no-store, must-revalidate");
      return c.json({
        html: htmlContent,
        csp: isPermissive ? void 0 : mcpAppsCsp,
        permissions: mcpAppsPermissions,
        permissive: isPermissive,
        cspMode,
        mimeType,
        mimeTypeValid,
        mimeTypeWarning
      });
    } catch (error) {
      console.error("[MCP Apps] Error fetching widget content:", error);
      return c.json(
        { error: error instanceof Error ? error.message : "Unknown error" },
        500
      );
    }
  });
  app.get("/inspector/api/mcp-apps/sandbox-proxy", (c) => {
    c.header("Content-Type", "text/html; charset=utf-8");
    c.header("Cache-Control", "no-cache, no-store, must-revalidate");
    const additionalFrameAncestors = process.env.FRAME_ANCESTORS || "";
    const frameAncestors = additionalFrameAncestors ? [
      "'self'",
      "http://localhost:*",
      "http://127.0.0.1:*",
      "https://localhost:*",
      "https://127.0.0.1:*",
      additionalFrameAncestors
    ].filter(Boolean).join(" ") : "*";
    c.header("Content-Security-Policy", `frame-ancestors ${frameAncestors}`);
    c.res.headers.delete("X-Frame-Options");
    return c.body(SANDBOX_PROXY_HTML);
  });
}

// src/server/shared-routes.ts
function getFrameAncestorsFromEnv() {
  const envValue = process.env.MCP_INSPECTOR_FRAME_ANCESTORS;
  if (!envValue) return void 0;
  const trimmed = envValue.trim();
  if (trimmed === "*") return "*";
  return trimmed;
}
function registerInspectorRoutes(app, config) {
  app.get("/inspector/health", (c) => {
    return c.json({ status: "ok", timestamp: (/* @__PURE__ */ new Date()).toISOString() });
  });
  mountMcpProxy(app, {
    path: "/inspector/api/proxy"
  });
  mountOAuthProxy(app, {
    basePath: "/inspector/api/oauth",
    enableLogging: true
  });
  registerMcpAppsRoutes(app);
  app.post("/inspector/api/chat/stream", async (c) => {
    try {
      const requestBody = await c.req.json();
      const { readable, writable } = new globalThis.TransformStream();
      const writer = writable.getWriter();
      const encoder = new TextEncoder();
      (async () => {
        try {
          for await (const chunk of handleChatRequestStream(requestBody)) {
            await writer.write(encoder.encode(chunk));
          }
        } catch (error) {
          const errorMsg = `${JSON.stringify({
            type: "error",
            data: {
              message: error instanceof Error ? error.message : "Unknown error"
            }
          })}
`;
          await writer.write(encoder.encode(errorMsg));
        } finally {
          await writer.close();
        }
      })();
      return new Response(readable, {
        headers: {
          "Content-Type": "text/event-stream",
          "Cache-Control": "no-cache",
          Connection: "keep-alive"
        }
      });
    } catch (error) {
      return c.json(formatErrorResponse(error, "handleChatRequestStream"), 500);
    }
  });
  app.post("/inspector/api/chat", async (c) => {
    try {
      const requestBody = await c.req.json();
      const result = await handleChatRequest(requestBody);
      return c.json(result);
    } catch (error) {
      return c.json(formatErrorResponse(error, "handleChatRequest"), 500);
    }
  });
  app.post("/inspector/api/resources/widget/store", async (c) => {
    try {
      const body = await c.req.json();
      const result = storeWidgetData(body);
      if (!result.success) {
        return c.json(result, 400);
      }
      return c.json(result);
    } catch (error) {
      console.error("[Widget Store] Error:", error);
      console.error(
        "[Widget Store] Stack:",
        error instanceof Error ? error.stack : ""
      );
      return c.json(formatErrorResponse(error, "storeWidgetData"), 500);
    }
  });
  app.get("/inspector/api/resources/widget/:toolId", async (c) => {
    const toolId = c.req.param("toolId");
    const widgetData = getWidgetData(toolId);
    if (!widgetData) {
      return c.html(
        "<html><body>Error: Widget data not found or expired</body></html>",
        404
      );
    }
    return c.html(generateWidgetContainerHtml("/inspector", toolId));
  });
  app.get("/inspector/api/resources/widget-content/:toolId", async (c) => {
    try {
      const toolId = c.req.param("toolId");
      const widgetData = getWidgetData(toolId);
      if (!widgetData) {
        console.error(
          "[Widget Content] Widget data not found for toolId:",
          toolId
        );
        return c.html(
          "<html><body>Error: Widget data not found or expired</body></html>",
          404
        );
      }
      const result = generateWidgetContentHtml(widgetData);
      if (result.error) {
        return c.html(`<html><body>Error: ${result.error}</body></html>`, 404);
      }
      let serverOrigin;
      if (widgetData.serverId && /^https?:\/\//.test(widgetData.serverId)) {
        try {
          serverOrigin = new URL(
            widgetData.serverId.replace(/\/mcp$/, "")
          ).origin.replace("0.0.0.0", "localhost");
        } catch {
        }
      }
      const headers = getWidgetSecurityHeaders(
        widgetData.widgetCSP,
        serverOrigin,
        getFrameAncestorsFromEnv()
      );
      Object.entries(headers).forEach(([key, value]) => {
        c.header(key, value);
      });
      return c.html(result.html);
    } catch (error) {
      console.error("[Widget Content] Error:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      const errorStack = error instanceof Error ? error.stack : "";
      console.error("[Widget Content] Stack:", errorStack);
      return c.html(`<html><body>Error: ${errorMessage}</body></html>`, 500);
    }
  });
  app.get("/inspector/config.json", (c) => {
    return c.json({
      autoConnectUrl: config?.autoConnectUrl || null
    });
  });
  const isTelemetryDisabled = () => process.env.MCP_USE_ANONYMIZED_TELEMETRY === "false" || process.env.NODE_ENV === "test";
  app.post("/inspector/api/tel/posthog", async (c) => {
    if (isTelemetryDisabled()) {
      return c.json({ success: true });
    }
    try {
      const body = await c.req.json();
      const { event, user_id, properties } = body;
      if (!event) {
        return c.json({ success: false, error: "Missing event name" }, 400);
      }
      const { PostHog } = await import("posthog-node");
      const posthog = new PostHog(
        "phc_lyTtbYwvkdSbrcMQNPiKiiRWrrM1seyKIMjycSvItEI",
        {
          host: "https://eu.i.posthog.com"
        }
      );
      const distinctId = user_id || "anonymous";
      posthog.capture({
        distinctId,
        event,
        properties: properties || {}
      });
      await posthog.shutdown();
      return c.json({ success: true });
    } catch (error) {
      console.error("[Telemetry] Error forwarding to PostHog:", error);
      return c.json({ success: false });
    }
  });
  app.post("/inspector/api/tel/scarf", async (c) => {
    if (isTelemetryDisabled()) {
      return c.json({ success: true });
    }
    try {
      const body = await c.req.json();
      const response = await fetch(
        "https://mcpuse.gateway.scarf.sh/events-inspector",
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(body)
        }
      );
      if (!response.ok) {
        console.error("[Telemetry] Scarf request failed:", response.status);
        return c.json({
          success: false,
          status: response.status,
          error: response.statusText
        });
      }
      return c.json({ success: true });
    } catch (error) {
      console.error("[Telemetry] Error forwarding to Scarf:", error);
      return c.json({ success: false });
    }
  });
  app.post("/inspector/api/rpc/log", async (c) => {
    try {
      const event = await c.req.json();
      rpcLogBus.publish(event);
      return c.json({ success: true });
    } catch (error) {
      console.error("[RPC Log] Error receiving RPC event:", error);
      return c.json({ success: false });
    }
  });
  app.delete("/inspector/api/rpc/log", async (c) => {
    try {
      const url = new URL(c.req.url);
      const serverIdsParam = url.searchParams.get("serverIds");
      const serverIds = serverIdsParam ? serverIdsParam.split(",").filter(Boolean) : void 0;
      rpcLogBus.clear(serverIds);
      return c.json({ success: true });
    } catch (error) {
      console.error("[RPC Log] Error clearing RPC log:", error);
      return c.json({ success: false });
    }
  });
  app.get("/inspector/api/rpc/stream", async (c) => {
    const url = new URL(c.req.url);
    const replay = parseInt(url.searchParams.get("replay") || "3", 10);
    const serverIdsParam = url.searchParams.get("serverIds");
    const serverIds = serverIdsParam ? serverIdsParam.split(",").filter(Boolean) : [];
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      start(controller) {
        const send = (data) => {
          try {
            controller.enqueue(
              encoder.encode(`data: ${JSON.stringify(data)}

`)
            );
          } catch {
          }
        };
        try {
          const recent = rpcLogBus.getBuffer(
            serverIds,
            isNaN(replay) ? 3 : replay
          );
          for (const evt of recent) {
            send({ type: "rpc", ...evt });
          }
        } catch {
        }
        const unsubscribe = rpcLogBus.subscribe(
          serverIds,
          (evt) => {
            send({ type: "rpc", ...evt });
          }
        );
        const keepalive = setInterval(() => {
          try {
            controller.enqueue(encoder.encode(`: keepalive ${Date.now()}

`));
          } catch {
          }
        }, 15e3);
        c.req.raw.signal?.addEventListener("abort", () => {
          try {
            clearInterval(keepalive);
            unsubscribe();
          } catch {
          }
          try {
            controller.close();
          } catch {
          }
        });
      }
    });
    return new Response(stream, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Expose-Headers": "*"
      }
    });
  });
}

export {
  registerInspectorRoutes
};
