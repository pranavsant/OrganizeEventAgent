#!/usr/bin/env node

// ../../node_modules/.pnpm/tsup@8.5.1_jiti@2.6.1_postcss@8.5.6_tsx@4.21.0_typescript@5.9.3_yaml@2.8.2/node_modules/tsup/assets/esm_shims.js
import path from "path";
import { fileURLToPath } from "url";
var getFilename = () => fileURLToPath(import.meta.url);
var getDirname = () => path.dirname(getFilename());
var __dirname = /* @__PURE__ */ getDirname();

// ../../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/vendor/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// ../../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/vendor/supports-color/index.js
import process2 from "process";
import os from "os";
import tty from "tty";
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : process2.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env } = process2;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== void 0) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (process2.platform === "win32") {
    const osRelease = os.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if (["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((key) => key in env)) {
      return 3;
    }
    if (["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if (env.TERM === "xterm-ghostty") {
    return 3;
  }
  if (env.TERM === "wezterm") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream, options = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
  stderr: createSupportsColor({ isTTY: tty.isatty(2) })
};
var supports_color_default = supportsColor;

// ../../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// ../../node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/index.js
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = /* @__PURE__ */ Symbol("GENERATOR");
var STYLER = /* @__PURE__ */ Symbol("STYLER");
var IS_EMPTY = /* @__PURE__ */ Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles2 = /* @__PURE__ */ Object.create(null);
var applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
var chalkFactory = (options) => {
  const chalk2 = (...strings) => strings.join(" ");
  applyOptions(chalk2, options);
  Object.setPrototypeOf(chalk2, createChalk.prototype);
  return chalk2;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
var createStyler = (open2, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open2;
    closeAll = close;
  } else {
    openAll = parent.openAll + open2;
    closeAll = close + parent.closeAll;
  }
  return {
    open: open2,
    close,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self, string) => {
  if (self.level <= 0 || !string) {
    return self[IS_EMPTY] ? "" : string;
  }
  let styler = self[STYLER];
  if (styler === void 0) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== void 0) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// src/index.ts
import { Command as Command4 } from "commander";
import "dotenv/config";
import { spawn } from "child_process";
import { readFileSync as readFileSync2 } from "fs";
import { access, mkdir as mkdir3, readFile as readFile3, writeFile as writeFile3 } from "fs/promises";
import { createRequire as createRequire2 } from "module";
import path7 from "path";

// ../../node_modules/.pnpm/open@11.0.0/node_modules/open/index.js
import process9 from "process";
import path2 from "path";
import { fileURLToPath as fileURLToPath2 } from "url";
import childProcess3 from "child_process";
import fs6, { constants as fsConstants3 } from "fs/promises";

// ../../node_modules/.pnpm/wsl-utils@0.3.1/node_modules/wsl-utils/index.js
import { promisify as promisify2 } from "util";
import childProcess2 from "child_process";
import fs5, { constants as fsConstants2 } from "fs/promises";

// ../../node_modules/.pnpm/is-wsl@3.1.0/node_modules/is-wsl/index.js
import process3 from "process";
import os2 from "os";
import fs3 from "fs";

// ../../node_modules/.pnpm/is-inside-container@1.0.0/node_modules/is-inside-container/index.js
import fs2 from "fs";

// ../../node_modules/.pnpm/is-docker@3.0.0/node_modules/is-docker/index.js
import fs from "fs";
var isDockerCached;
function hasDockerEnv() {
  try {
    fs.statSync("/.dockerenv");
    return true;
  } catch {
    return false;
  }
}
function hasDockerCGroup() {
  try {
    return fs.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
  } catch {
    return false;
  }
}
function isDocker() {
  if (isDockerCached === void 0) {
    isDockerCached = hasDockerEnv() || hasDockerCGroup();
  }
  return isDockerCached;
}

// ../../node_modules/.pnpm/is-inside-container@1.0.0/node_modules/is-inside-container/index.js
var cachedResult;
var hasContainerEnv = () => {
  try {
    fs2.statSync("/run/.containerenv");
    return true;
  } catch {
    return false;
  }
};
function isInsideContainer() {
  if (cachedResult === void 0) {
    cachedResult = hasContainerEnv() || isDocker();
  }
  return cachedResult;
}

// ../../node_modules/.pnpm/is-wsl@3.1.0/node_modules/is-wsl/index.js
var isWsl = () => {
  if (process3.platform !== "linux") {
    return false;
  }
  if (os2.release().toLowerCase().includes("microsoft")) {
    if (isInsideContainer()) {
      return false;
    }
    return true;
  }
  try {
    return fs3.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isInsideContainer() : false;
  } catch {
    return false;
  }
};
var is_wsl_default = process3.env.__IS_WSL_TEST__ ? isWsl : isWsl();

// ../../node_modules/.pnpm/powershell-utils@0.1.0/node_modules/powershell-utils/index.js
import process4 from "process";
import { Buffer } from "buffer";
import { promisify } from "util";
import childProcess from "child_process";
import fs4, { constants as fsConstants } from "fs/promises";
var execFile = promisify(childProcess.execFile);
var powerShellPath = () => `${process4.env.SYSTEMROOT || process4.env.windir || String.raw`C:\Windows`}\\System32\\WindowsPowerShell\\v1.0\\powershell.exe`;
var executePowerShell = async (command, options = {}) => {
  const {
    powerShellPath: psPath,
    ...execFileOptions
  } = options;
  const encodedCommand = executePowerShell.encodeCommand(command);
  return execFile(
    psPath ?? powerShellPath(),
    [
      ...executePowerShell.argumentsPrefix,
      encodedCommand
    ],
    {
      encoding: "utf8",
      ...execFileOptions
    }
  );
};
executePowerShell.argumentsPrefix = [
  "-NoProfile",
  "-NonInteractive",
  "-ExecutionPolicy",
  "Bypass",
  "-EncodedCommand"
];
executePowerShell.encodeCommand = (command) => Buffer.from(command, "utf16le").toString("base64");
executePowerShell.escapeArgument = (value) => `'${String(value).replaceAll("'", "''")}'`;

// ../../node_modules/.pnpm/wsl-utils@0.3.1/node_modules/wsl-utils/utilities.js
function parseMountPointFromConfig(content) {
  for (const line of content.split("\n")) {
    if (/^\s*#/.test(line)) {
      continue;
    }
    const match = /^\s*root\s*=\s*(?<mountPoint>"[^"]*"|'[^']*'|[^#]*)/.exec(line);
    if (!match) {
      continue;
    }
    return match.groups.mountPoint.trim().replaceAll(/^["']|["']$/g, "");
  }
}

// ../../node_modules/.pnpm/wsl-utils@0.3.1/node_modules/wsl-utils/index.js
var execFile2 = promisify2(childProcess2.execFile);
var wslDrivesMountPoint = /* @__PURE__ */ (() => {
  const defaultMountPoint = "/mnt/";
  let mountPoint;
  return async function() {
    if (mountPoint) {
      return mountPoint;
    }
    const configFilePath = "/etc/wsl.conf";
    let isConfigFileExists = false;
    try {
      await fs5.access(configFilePath, fsConstants2.F_OK);
      isConfigFileExists = true;
    } catch {
    }
    if (!isConfigFileExists) {
      return defaultMountPoint;
    }
    const configContent = await fs5.readFile(configFilePath, { encoding: "utf8" });
    const parsedMountPoint = parseMountPointFromConfig(configContent);
    if (parsedMountPoint === void 0) {
      return defaultMountPoint;
    }
    mountPoint = parsedMountPoint;
    mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
    return mountPoint;
  };
})();
var powerShellPathFromWsl = async () => {
  const mountPoint = await wslDrivesMountPoint();
  return `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe`;
};
var powerShellPath2 = is_wsl_default ? powerShellPathFromWsl : powerShellPath;
var canAccessPowerShellPromise;
var canAccessPowerShell = async () => {
  canAccessPowerShellPromise ??= (async () => {
    try {
      const psPath = await powerShellPath2();
      await fs5.access(psPath, fsConstants2.X_OK);
      return true;
    } catch {
      return false;
    }
  })();
  return canAccessPowerShellPromise;
};
var wslDefaultBrowser = async () => {
  const psPath = await powerShellPath2();
  const command = String.raw`(Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\http\UserChoice").ProgId`;
  const { stdout } = await executePowerShell(command, { powerShellPath: psPath });
  return stdout.trim();
};
var convertWslPathToWindows = async (path8) => {
  if (/^[a-z]+:\/\//i.test(path8)) {
    return path8;
  }
  try {
    const { stdout } = await execFile2("wslpath", ["-aw", path8], { encoding: "utf8" });
    return stdout.trim();
  } catch {
    return path8;
  }
};

// ../../node_modules/.pnpm/define-lazy-prop@3.0.0/node_modules/define-lazy-prop/index.js
function defineLazyProperty(object, propertyName, valueGetter) {
  const define = (value) => Object.defineProperty(object, propertyName, { value, enumerable: true, writable: true });
  Object.defineProperty(object, propertyName, {
    configurable: true,
    enumerable: true,
    get() {
      const result = valueGetter();
      define(result);
      return result;
    },
    set(value) {
      define(value);
    }
  });
  return object;
}

// ../../node_modules/.pnpm/default-browser@5.5.0/node_modules/default-browser/index.js
import { promisify as promisify6 } from "util";
import process7 from "process";
import { execFile as execFile6 } from "child_process";

// ../../node_modules/.pnpm/default-browser-id@5.0.1/node_modules/default-browser-id/index.js
import { promisify as promisify3 } from "util";
import process5 from "process";
import { execFile as execFile3 } from "child_process";
var execFileAsync = promisify3(execFile3);
async function defaultBrowserId() {
  if (process5.platform !== "darwin") {
    throw new Error("macOS only");
  }
  const { stdout } = await execFileAsync("defaults", ["read", "com.apple.LaunchServices/com.apple.launchservices.secure", "LSHandlers"]);
  const match = /LSHandlerRoleAll = "(?!-)(?<id>[^"]+?)";\s+?LSHandlerURLScheme = (?:http|https);/.exec(stdout);
  const browserId = match?.groups.id ?? "com.apple.Safari";
  if (browserId === "com.apple.safari") {
    return "com.apple.Safari";
  }
  return browserId;
}

// ../../node_modules/.pnpm/run-applescript@7.1.0/node_modules/run-applescript/index.js
import process6 from "process";
import { promisify as promisify4 } from "util";
import { execFile as execFile4, execFileSync } from "child_process";
var execFileAsync2 = promisify4(execFile4);
async function runAppleScript(script, { humanReadableOutput = true, signal } = {}) {
  if (process6.platform !== "darwin") {
    throw new Error("macOS only");
  }
  const outputArguments = humanReadableOutput ? [] : ["-ss"];
  const execOptions = {};
  if (signal) {
    execOptions.signal = signal;
  }
  const { stdout } = await execFileAsync2("osascript", ["-e", script, outputArguments], execOptions);
  return stdout.trim();
}

// ../../node_modules/.pnpm/bundle-name@4.1.0/node_modules/bundle-name/index.js
async function bundleName(bundleId) {
  return runAppleScript(`tell application "Finder" to set app_path to application file id "${bundleId}" as string
tell application "System Events" to get value of property list item "CFBundleName" of property list file (app_path & ":Contents:Info.plist")`);
}

// ../../node_modules/.pnpm/default-browser@5.5.0/node_modules/default-browser/windows.js
import { promisify as promisify5 } from "util";
import { execFile as execFile5 } from "child_process";
var execFileAsync3 = promisify5(execFile5);
var windowsBrowserProgIds = {
  MSEdgeHTM: { name: "Edge", id: "com.microsoft.edge" },
  // The missing `L` is correct.
  MSEdgeBHTML: { name: "Edge Beta", id: "com.microsoft.edge.beta" },
  MSEdgeDHTML: { name: "Edge Dev", id: "com.microsoft.edge.dev" },
  AppXq0fevzme2pys62n3e0fbqa7peapykr8v: { name: "Edge", id: "com.microsoft.edge.old" },
  ChromeHTML: { name: "Chrome", id: "com.google.chrome" },
  ChromeBHTML: { name: "Chrome Beta", id: "com.google.chrome.beta" },
  ChromeDHTML: { name: "Chrome Dev", id: "com.google.chrome.dev" },
  ChromiumHTM: { name: "Chromium", id: "org.chromium.Chromium" },
  BraveHTML: { name: "Brave", id: "com.brave.Browser" },
  BraveBHTML: { name: "Brave Beta", id: "com.brave.Browser.beta" },
  BraveDHTML: { name: "Brave Dev", id: "com.brave.Browser.dev" },
  BraveSSHTM: { name: "Brave Nightly", id: "com.brave.Browser.nightly" },
  FirefoxURL: { name: "Firefox", id: "org.mozilla.firefox" },
  OperaStable: { name: "Opera", id: "com.operasoftware.Opera" },
  VivaldiHTM: { name: "Vivaldi", id: "com.vivaldi.Vivaldi" },
  "IE.HTTP": { name: "Internet Explorer", id: "com.microsoft.ie" }
};
var _windowsBrowserProgIdMap = new Map(Object.entries(windowsBrowserProgIds));
var UnknownBrowserError = class extends Error {
};
async function defaultBrowser(_execFileAsync = execFileAsync3) {
  const { stdout } = await _execFileAsync("reg", [
    "QUERY",
    " HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\http\\UserChoice",
    "/v",
    "ProgId"
  ]);
  const match = /ProgId\s*REG_SZ\s*(?<id>\S+)/.exec(stdout);
  if (!match) {
    throw new UnknownBrowserError(`Cannot find Windows browser in stdout: ${JSON.stringify(stdout)}`);
  }
  const { id } = match.groups;
  const dotIndex = id.lastIndexOf(".");
  const hyphenIndex = id.lastIndexOf("-");
  const baseIdByDot = dotIndex === -1 ? void 0 : id.slice(0, dotIndex);
  const baseIdByHyphen = hyphenIndex === -1 ? void 0 : id.slice(0, hyphenIndex);
  return windowsBrowserProgIds[id] ?? windowsBrowserProgIds[baseIdByDot] ?? windowsBrowserProgIds[baseIdByHyphen] ?? { name: id, id };
}

// ../../node_modules/.pnpm/default-browser@5.5.0/node_modules/default-browser/index.js
var execFileAsync4 = promisify6(execFile6);
var titleize = (string) => string.toLowerCase().replaceAll(/(?:^|\s|-)\S/g, (x) => x.toUpperCase());
async function defaultBrowser2() {
  if (process7.platform === "darwin") {
    const id = await defaultBrowserId();
    const name = await bundleName(id);
    return { name, id };
  }
  if (process7.platform === "linux") {
    const { stdout } = await execFileAsync4("xdg-mime", ["query", "default", "x-scheme-handler/http"]);
    const id = stdout.trim();
    const name = titleize(id.replace(/.desktop$/, "").replace("-", " "));
    return { name, id };
  }
  if (process7.platform === "win32") {
    return defaultBrowser();
  }
  throw new Error("Only macOS, Linux, and Windows are supported");
}

// ../../node_modules/.pnpm/is-in-ssh@1.0.0/node_modules/is-in-ssh/index.js
import process8 from "process";
var isInSsh = Boolean(process8.env.SSH_CONNECTION || process8.env.SSH_CLIENT || process8.env.SSH_TTY);
var is_in_ssh_default = isInSsh;

// ../../node_modules/.pnpm/open@11.0.0/node_modules/open/index.js
var fallbackAttemptSymbol = /* @__PURE__ */ Symbol("fallbackAttempt");
var __dirname2 = import.meta.url ? path2.dirname(fileURLToPath2(import.meta.url)) : "";
var localXdgOpenPath = path2.join(__dirname2, "xdg-open");
var { platform, arch } = process9;
var tryEachApp = async (apps2, opener) => {
  if (apps2.length === 0) {
    return;
  }
  const errors = [];
  for (const app of apps2) {
    try {
      return await opener(app);
    } catch (error) {
      errors.push(error);
    }
  }
  throw new AggregateError(errors, "Failed to open in all supported apps");
};
var baseOpen = async (options) => {
  options = {
    wait: false,
    background: false,
    newInstance: false,
    allowNonzeroExitCode: false,
    ...options
  };
  const isFallbackAttempt = options[fallbackAttemptSymbol] === true;
  delete options[fallbackAttemptSymbol];
  if (Array.isArray(options.app)) {
    return tryEachApp(options.app, (singleApp) => baseOpen({
      ...options,
      app: singleApp,
      [fallbackAttemptSymbol]: true
    }));
  }
  let { name: app, arguments: appArguments = [] } = options.app ?? {};
  appArguments = [...appArguments];
  if (Array.isArray(app)) {
    return tryEachApp(app, (appName) => baseOpen({
      ...options,
      app: {
        name: appName,
        arguments: appArguments
      },
      [fallbackAttemptSymbol]: true
    }));
  }
  if (app === "browser" || app === "browserPrivate") {
    const ids = {
      "com.google.chrome": "chrome",
      "google-chrome.desktop": "chrome",
      "com.brave.browser": "brave",
      "org.mozilla.firefox": "firefox",
      "firefox.desktop": "firefox",
      "com.microsoft.msedge": "edge",
      "com.microsoft.edge": "edge",
      "com.microsoft.edgemac": "edge",
      "microsoft-edge.desktop": "edge",
      "com.apple.safari": "safari"
    };
    const flags = {
      chrome: "--incognito",
      brave: "--incognito",
      firefox: "--private-window",
      edge: "--inPrivate"
      // Safari doesn't support private mode via command line
    };
    let browser;
    if (is_wsl_default) {
      const progId = await wslDefaultBrowser();
      const browserInfo = _windowsBrowserProgIdMap.get(progId);
      browser = browserInfo ?? {};
    } else {
      browser = await defaultBrowser2();
    }
    if (browser.id in ids) {
      const browserName = ids[browser.id.toLowerCase()];
      if (app === "browserPrivate") {
        if (browserName === "safari") {
          throw new Error("Safari doesn't support opening in private mode via command line");
        }
        appArguments.push(flags[browserName]);
      }
      return baseOpen({
        ...options,
        app: {
          name: apps[browserName],
          arguments: appArguments
        }
      });
    }
    throw new Error(`${browser.name} is not supported as a default browser`);
  }
  let command;
  const cliArguments = [];
  const childProcessOptions = {};
  let shouldUseWindowsInWsl = false;
  if (is_wsl_default && !isInsideContainer() && !is_in_ssh_default && !app) {
    shouldUseWindowsInWsl = await canAccessPowerShell();
  }
  if (platform === "darwin") {
    command = "open";
    if (options.wait) {
      cliArguments.push("--wait-apps");
    }
    if (options.background) {
      cliArguments.push("--background");
    }
    if (options.newInstance) {
      cliArguments.push("--new");
    }
    if (app) {
      cliArguments.push("-a", app);
    }
  } else if (platform === "win32" || shouldUseWindowsInWsl) {
    command = await powerShellPath2();
    cliArguments.push(...executePowerShell.argumentsPrefix);
    if (!is_wsl_default) {
      childProcessOptions.windowsVerbatimArguments = true;
    }
    if (is_wsl_default && options.target) {
      options.target = await convertWslPathToWindows(options.target);
    }
    const encodedArguments = ["$ProgressPreference = 'SilentlyContinue';", "Start"];
    if (options.wait) {
      encodedArguments.push("-Wait");
    }
    if (app) {
      encodedArguments.push(executePowerShell.escapeArgument(app));
      if (options.target) {
        appArguments.push(options.target);
      }
    } else if (options.target) {
      encodedArguments.push(executePowerShell.escapeArgument(options.target));
    }
    if (appArguments.length > 0) {
      appArguments = appArguments.map((argument) => executePowerShell.escapeArgument(argument));
      encodedArguments.push("-ArgumentList", appArguments.join(","));
    }
    options.target = executePowerShell.encodeCommand(encodedArguments.join(" "));
    if (!options.wait) {
      childProcessOptions.stdio = "ignore";
    }
  } else {
    if (app) {
      command = app;
    } else {
      const isBundled = !__dirname2 || __dirname2 === "/";
      let exeLocalXdgOpen = false;
      try {
        await fs6.access(localXdgOpenPath, fsConstants3.X_OK);
        exeLocalXdgOpen = true;
      } catch {
      }
      const useSystemXdgOpen = process9.versions.electron ?? (platform === "android" || isBundled || !exeLocalXdgOpen);
      command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
    }
    if (appArguments.length > 0) {
      cliArguments.push(...appArguments);
    }
    if (!options.wait) {
      childProcessOptions.stdio = "ignore";
      childProcessOptions.detached = true;
    }
  }
  if (platform === "darwin" && appArguments.length > 0) {
    cliArguments.push("--args", ...appArguments);
  }
  if (options.target) {
    cliArguments.push(options.target);
  }
  const subprocess = childProcess3.spawn(command, cliArguments, childProcessOptions);
  if (options.wait) {
    return new Promise((resolve2, reject) => {
      subprocess.once("error", reject);
      subprocess.once("close", (exitCode) => {
        if (!options.allowNonzeroExitCode && exitCode !== 0) {
          reject(new Error(`Exited with code ${exitCode}`));
          return;
        }
        resolve2(subprocess);
      });
    });
  }
  if (isFallbackAttempt) {
    return new Promise((resolve2, reject) => {
      subprocess.once("error", reject);
      subprocess.once("spawn", () => {
        subprocess.once("close", (exitCode) => {
          subprocess.off("error", reject);
          if (exitCode !== 0) {
            reject(new Error(`Exited with code ${exitCode}`));
            return;
          }
          subprocess.unref();
          resolve2(subprocess);
        });
      });
    });
  }
  subprocess.unref();
  return new Promise((resolve2, reject) => {
    subprocess.once("error", reject);
    subprocess.once("spawn", () => {
      subprocess.off("error", reject);
      resolve2(subprocess);
    });
  });
};
var open = (target, options) => {
  if (typeof target !== "string") {
    throw new TypeError("Expected a `target`");
  }
  return baseOpen({
    ...options,
    target
  });
};
function detectArchBinary(binary) {
  if (typeof binary === "string" || Array.isArray(binary)) {
    return binary;
  }
  const { [arch]: archBinary } = binary;
  if (!archBinary) {
    throw new Error(`${arch} is not supported`);
  }
  return archBinary;
}
function detectPlatformBinary({ [platform]: platformBinary }, { wsl } = {}) {
  if (wsl && is_wsl_default) {
    return detectArchBinary(wsl);
  }
  if (!platformBinary) {
    throw new Error(`${platform} is not supported`);
  }
  return detectArchBinary(platformBinary);
}
var apps = {
  browser: "browser",
  browserPrivate: "browserPrivate"
};
defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
  darwin: "google chrome",
  win32: "chrome",
  // `chromium-browser` is the older deb package name used by Ubuntu/Debian before snap.
  linux: ["google-chrome", "google-chrome-stable", "chromium", "chromium-browser"]
}, {
  wsl: {
    ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
    x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
  }
}));
defineLazyProperty(apps, "brave", () => detectPlatformBinary({
  darwin: "brave browser",
  win32: "brave",
  linux: ["brave-browser", "brave"]
}, {
  wsl: {
    ia32: "/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe",
    x64: ["/mnt/c/Program Files/BraveSoftware/Brave-Browser/Application/brave.exe", "/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe"]
  }
}));
defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
  darwin: "firefox",
  win32: String.raw`C:\Program Files\Mozilla Firefox\firefox.exe`,
  linux: "firefox"
}, {
  wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
}));
defineLazyProperty(apps, "edge", () => detectPlatformBinary({
  darwin: "microsoft edge",
  win32: "msedge",
  linux: ["microsoft-edge", "microsoft-edge-dev"]
}, {
  wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
}));
defineLazyProperty(apps, "safari", () => detectPlatformBinary({
  darwin: "Safari"
}));
var open_default = open;

// src/index.ts
import { viteSingleFile } from "vite-plugin-singlefile";
import { toJSONSchema } from "zod";

// src/commands/auth.ts
import crypto from "crypto";
import {
  createServer
} from "http";

// src/utils/config.ts
import { promises as fs7 } from "fs";
import os3 from "os";
import path3 from "path";
var CONFIG_DIR = path3.join(os3.homedir(), ".mcp-use");
var CONFIG_FILE = path3.join(CONFIG_DIR, "config.json");
var DEFAULT_API_URL = process.env.MCP_API_URL ? process.env.MCP_API_URL.replace(/\/api\/v1$/, "") + "/api/v1" : "https://cloud.mcp-use.com/api/v1";
var DEFAULT_WEB_URL = process.env.MCP_WEB_URL ? process.env.MCP_WEB_URL : "https://manufact.com";
async function ensureConfigDir() {
  try {
    await fs7.mkdir(CONFIG_DIR, { recursive: true });
  } catch (error) {
  }
}
async function readConfig() {
  try {
    const content = await fs7.readFile(CONFIG_FILE, "utf-8");
    return JSON.parse(content);
  } catch (error) {
    return {};
  }
}
async function writeConfig(config) {
  await ensureConfigDir();
  await fs7.writeFile(CONFIG_FILE, JSON.stringify(config, null, 2), "utf-8");
}
async function deleteConfig() {
  try {
    await fs7.unlink(CONFIG_FILE);
  } catch (error) {
  }
}
async function getApiUrl() {
  const config = await readConfig();
  return config.apiUrl || DEFAULT_API_URL;
}
async function getApiKey() {
  const config = await readConfig();
  return config.apiKey || null;
}
async function isLoggedIn() {
  const apiKey = await getApiKey();
  return !!apiKey;
}
async function getWebUrl() {
  return DEFAULT_WEB_URL;
}

// src/utils/api.ts
var McpUseAPI = class _McpUseAPI {
  baseUrl;
  apiKey;
  constructor(baseUrl, apiKey) {
    this.baseUrl = baseUrl || "";
    this.apiKey = apiKey;
  }
  /**
   * Initialize API client with config
   */
  static async create() {
    const baseUrl = await getApiUrl();
    const apiKey = await getApiKey();
    return new _McpUseAPI(baseUrl, apiKey ?? void 0);
  }
  /**
   * Make authenticated request
   */
  async request(endpoint, options = {}) {
    const url = `${this.baseUrl}${endpoint}`;
    const headers = {
      "Content-Type": "application/json",
      ...options.headers || {}
    };
    if (this.apiKey) {
      headers["x-api-key"] = this.apiKey;
    }
    const timeout = options.timeout || 3e4;
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    try {
      const response = await fetch(url, {
        ...options,
        headers,
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        const error = await response.text();
        throw new Error(`API request failed: ${response.status} ${error}`);
      }
      return response.json();
    } catch (error) {
      clearTimeout(timeoutId);
      if (error.name === "AbortError") {
        throw new Error(
          `Request timeout after ${timeout / 1e3}s. Try using --follow flag to stream logs instead.`
        );
      }
      throw error;
    }
  }
  /**
   * Create API key using JWT token
   */
  async createApiKey(jwtToken, name = "CLI") {
    const url = `${this.baseUrl}/api-key`;
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${jwtToken}`
      },
      body: JSON.stringify({ name })
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to create API key: ${response.status} ${error}`);
    }
    return response.json();
  }
  /**
   * Test authentication
   */
  async testAuth() {
    return this.request("/test-auth");
  }
  /**
   * Create deployment
   */
  async createDeployment(request) {
    return this.request("/deployments", {
      method: "POST",
      body: JSON.stringify(request)
    });
  }
  /**
   * Get deployment by ID
   */
  async getDeployment(deploymentId) {
    return this.request(`/deployments/${deploymentId}`);
  }
  /**
   * Stream deployment logs
   */
  async *streamDeploymentLogs(deploymentId) {
    const url = `${this.baseUrl}/deployments/${deploymentId}/logs/stream`;
    const headers = {};
    if (this.apiKey) {
      headers["x-api-key"] = this.apiKey;
    }
    const response = await fetch(url, { headers });
    if (!response.ok) {
      throw new Error(`Failed to stream logs: ${response.status}`);
    }
    if (!response.body) {
      throw new Error("Response body is null");
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          if (line.startsWith("data: ")) {
            const data = line.slice(6);
            try {
              const parsed = JSON.parse(data);
              if (parsed.log) {
                yield parsed.log;
              } else if (parsed.error) {
                throw new Error(parsed.error);
              }
            } catch (e) {
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
  }
  /**
   * Create deployment with source code upload
   */
  async createDeploymentWithUpload(request, filePath) {
    const { readFile: readFile4 } = await import("fs/promises");
    const { basename } = await import("path");
    const { stat } = await import("fs/promises");
    const stats = await stat(filePath);
    const maxSize = 2 * 1024 * 1024;
    if (stats.size > maxSize) {
      throw new Error(
        `File size (${(stats.size / 1024 / 1024).toFixed(2)}MB) exceeds maximum of 2MB`
      );
    }
    const fileBuffer = await readFile4(filePath);
    const filename = basename(filePath);
    const formData = new FormData();
    const blob = new Blob([fileBuffer], { type: "application/gzip" });
    formData.append("source_file", blob, filename);
    formData.append("name", request.name);
    formData.append("source_type", "upload");
    if (request.source.type === "upload") {
      formData.append("runtime", request.source.runtime || "node");
      formData.append("port", String(request.source.port || 3e3));
      if (request.source.startCommand) {
        formData.append("startCommand", request.source.startCommand);
      }
      if (request.source.buildCommand) {
        formData.append("buildCommand", request.source.buildCommand);
      }
      if (request.source.env && Object.keys(request.source.env).length > 0) {
        formData.append("env", JSON.stringify(request.source.env));
      }
    }
    if (request.customDomain) {
      formData.append("customDomain", request.customDomain);
    }
    if (request.healthCheckPath) {
      formData.append("healthCheckPath", request.healthCheckPath);
    }
    const url = `${this.baseUrl}/deployments`;
    const headers = {};
    if (this.apiKey) {
      headers["x-api-key"] = this.apiKey;
    }
    const response = await fetch(url, {
      method: "POST",
      headers,
      body: formData
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Deployment failed: ${error}`);
    }
    return response.json();
  }
  /**
   * List all deployments
   */
  async listDeployments() {
    const response = await this.request("/deployments");
    return response.deployments;
  }
  /**
   * Delete deployment
   */
  async deleteDeployment(deploymentId) {
    await this.request(`/deployments/${deploymentId}`, {
      method: "DELETE"
    });
  }
  /**
   * Update deployment
   */
  async updateDeployment(deploymentId, updates) {
    return this.request(`/deployments/${deploymentId}`, {
      method: "PATCH",
      body: JSON.stringify(updates)
    });
  }
  /**
   * Redeploy deployment
   *
   * @param deploymentId - The deployment ID to redeploy
   * @param configOrFilePath - Either a RedeploymentConfig object with updated settings,
   *                           or a file path string for source code upload
   */
  async redeployDeployment(deploymentId, configOrFilePath) {
    if (typeof configOrFilePath === "string") {
      const filePath = configOrFilePath;
      const { readFile: readFile4 } = await import("fs/promises");
      const { basename } = await import("path");
      const { stat } = await import("fs/promises");
      const stats = await stat(filePath);
      const maxSize = 2 * 1024 * 1024;
      if (stats.size > maxSize) {
        throw new Error(
          `File size (${(stats.size / 1024 / 1024).toFixed(2)}MB) exceeds maximum of 2MB`
        );
      }
      const fileBuffer = await readFile4(filePath);
      const formData = new FormData();
      const blob = new Blob([fileBuffer], { type: "application/gzip" });
      formData.append("source_file", blob, basename(filePath));
      const headers = {};
      if (this.apiKey) headers["x-api-key"] = this.apiKey;
      const response = await fetch(
        `${this.baseUrl}/deployments/${deploymentId}/redeploy`,
        {
          method: "POST",
          headers,
          body: formData
        }
      );
      if (!response.ok) {
        const error = await response.text();
        throw new Error(`Redeploy failed: ${error}`);
      }
      return response.json();
    }
    const config = configOrFilePath;
    return this.request(`/deployments/${deploymentId}/redeploy`, {
      method: "POST",
      body: config ? JSON.stringify(config) : void 0
    });
  }
  /**
   * Get deployment logs
   */
  async getDeploymentLogs(deploymentId) {
    const response = await this.request(
      `/deployments/${deploymentId}/logs`,
      { timeout: 6e4 }
      // 60 second timeout for logs
    );
    return response.data.logs;
  }
  /**
   * Get deployment build logs
   */
  async getDeploymentBuildLogs(deploymentId) {
    const response = await this.request(
      `/deployments/${deploymentId}/logs/build`,
      { timeout: 6e4 }
      // 60 second timeout for logs
    );
    return response.data.logs;
  }
  /**
   * Get GitHub connection status
   */
  async getGitHubConnectionStatus() {
    return this.request("/github/connection");
  }
  /**
   * Get GitHub app name
   */
  async getGitHubAppName() {
    const response = await this.request("/github/appname");
    return response.app_name;
  }
  /**
   * Get accessible GitHub repositories
   */
  async getGitHubRepos(refresh = false) {
    return this.request(
      `/github/repos${refresh ? "?refresh=true" : ""}`
    );
  }
};

// src/commands/auth.ts
var LOGIN_TIMEOUT = 3e5;
async function findAvailablePort(startPort = 8765) {
  for (let port = startPort; port < startPort + 100; port++) {
    try {
      await new Promise((resolve2, reject) => {
        const server = createServer();
        server.once("error", reject);
        server.once("listening", () => {
          server.close();
          resolve2();
        });
        server.listen(port);
      });
      return port;
    } catch {
      continue;
    }
  }
  throw new Error("No available ports found");
}
async function startCallbackServer(port, expectedState) {
  return new Promise((resolve2, reject) => {
    let tokenResolver = null;
    const tokenPromise = new Promise((res) => {
      tokenResolver = res;
    });
    const server = createServer(
      {
        maxHeaderSize: 65536
        // 64KB - handle very long JWT tokens in URL (increased from default 8192)
      },
      (req, res) => {
        if (req.url?.startsWith("/callback")) {
          const url = new URL(req.url, `http://localhost:${port}`);
          const token = url.searchParams.get("token");
          const state = url.searchParams.get("state");
          if (state !== expectedState) {
            res.writeHead(400, { "Content-Type": "text/html" });
            res.end(`
              <!DOCTYPE html>
              <html>
                <head>
                  <title>Security Error</title>
                  <meta name="viewport" content="width=device-width, initial-scale=1.0">
                  <style>
                    body {
                      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                      display: flex;
                      justify-content: center;
                      align-items: center;
                      min-height: 100vh;
                      background: #000;
                      padding: 1rem;
                      margin: 0;
                    }
                    .container {
                      max-width: 28rem;
                      padding: 3rem;
                      text-align: center;
                      background: rgba(255, 255, 255, 0.1);
                      backdrop-filter: blur(40px);
                      border: 1px solid rgba(255, 255, 255, 0.2);
                      border-radius: 1.5rem;
                    }
                    h1 { color: #fff; font-size: 2rem; margin-bottom: 1rem; }
                    p { color: rgba(255, 255, 255, 0.8); font-size: 1rem; }
                  </style>
                </head>
                <body>
                  <div class="container">
                    <h1>Security Error</h1>
                    <p>Invalid state parameter. Please try logging in again.</p>
                  </div>
                </body>
              </html>
            `);
            return;
          }
          if (token && tokenResolver) {
            res.writeHead(200, { "Content-Type": "text/html" });
            res.end(`
              <!DOCTYPE html>
              <html>
                <head>
                  <title>Login Successful</title>
                  <meta name="viewport" content="width=device-width, initial-scale=1.0">
                  <style>
                    * {
                      margin: 0;
                      padding: 0;
                      box-sizing: border-box;
                    }
                    body {
                      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
                      display: flex;
                      justify-content: center;
                      align-items: center;
                      min-height: 100vh;
                      background: #000;
                      padding: 1rem;
                    }
                    .container {
                      width: 100%;
                      max-width: 28rem;
                      padding: 3rem;
                      text-align: center;
                      -webkit-backdrop-filter: blur(40px);
                      border: 1px solid rgba(255, 255, 255, 0.2);
                      border-radius: 1.5rem;
                      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
                    }
                    .icon-container {
                      display: inline-flex;
                      align-items: center;
                      justify-content: center;
                      width: 6rem;
                      height: 6rem;
                      margin-bottom: 2rem;
                      background: rgba(255, 255, 255, 0.1);
                      backdrop-filter: blur(10px);
                      -webkit-backdrop-filter: blur(10px);
                      border-radius: 50%;
                    }
                    .checkmark {
                      font-size: 4rem;
                      color: #fff;
                      line-height: 1;
                      animation: scaleIn 0.5s ease-out;
                    }
                    @keyframes scaleIn {
                      from {
                        transform: scale(0);
                        opacity: 0;
                      }
                      to {
                        transform: scale(1);
                        opacity: 1;
                      }
                    }
                    h1 {
                      color: #fff;
                      margin: 0 0 1rem 0;
                      font-size: 2.5rem;
                      font-weight: 700;
                      letter-spacing: -0.025em;
                    }
                    p {
                      color: rgba(255, 255, 255, 0.8);
                      margin: 0 0 2rem 0;
                      font-size: 1.125rem;
                      line-height: 1.5;
                    }
                    .spinner {
                      display: inline-block;
                      width: 2rem;
                      height: 2rem;
                      border: 3px solid rgba(255, 255, 255, 0.3);
                      border-top-color: #fff;
                      border-radius: 50%;
                      animation: spin 0.8s linear infinite;
                    }
                    @keyframes spin {
                      to { transform: rotate(360deg); }
                    }
                    .footer {
                      margin-top: 2rem;
                      color: rgba(255, 255, 255, 0.6);
                      font-size: 0.875rem;
                    }
                  </style>
                </head>
                <body>
                  <div class="container">
                    <h1>Authentication Successful!</h1>
                    <p>You can now close this window and return to the CLI.</p>
                  </div>
                </body>
              </html>
            `);
            tokenResolver(token);
          } else {
            res.writeHead(400, { "Content-Type": "text/html" });
            res.end(`
              <!DOCTYPE html>
              <html>
                <head>
                  <title>Login Failed</title>
                  <meta name="viewport" content="width=device-width, initial-scale=1.0">
                  <style>
                    * {
                      margin: 0;
                      padding: 0;
                      box-sizing: border-box;
                    }
                    body {
                      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
                      display: flex;
                      justify-content: center;
                      align-items: center;
                      min-height: 100vh;
                      background: #000;
                      padding: 1rem;
                    }
                    .container {
                      width: 100%;
                      max-width: 28rem;
                      padding: 3rem;
                      text-align: center;
                      background: rgba(255, 255, 255, 0.1);
                      backdrop-filter: blur(40px);
                      -webkit-backdrop-filter: blur(40px);
                      border: 1px solid rgba(255, 255, 255, 0.2);
                      border-radius: 1.5rem;
                      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
                    }
                    .icon-container {
                      display: inline-flex;
                      align-items: center;
                      justify-content: center;
                      width: 6rem;
                      height: 6rem;
                      margin-bottom: 2rem;
                      background: rgba(255, 255, 255, 0.1);
                      backdrop-filter: blur(10px);
                      -webkit-backdrop-filter: blur(10px);
                      border-radius: 50%;
                    }
                    .cross {
                      font-size: 4rem;
                      color: #fff;
                      line-height: 1;
                    }
                    h1 {
                      color: #fff;
                      margin: 0 0 1rem 0;
                      font-size: 2.5rem;
                      font-weight: 700;
                      letter-spacing: -0.025em;
                    }
                    p {
                      color: rgba(255, 255, 255, 0.8);
                      margin: 0;
                      font-size: 1.125rem;
                      line-height: 1.5;
                    }
                  </style>
                </head>
                <body>
                  <div class="container">
                    <div class="icon-container">
                      <div class="cross">\u2717</div>
                    </div>
                    <h1>Login Failed</h1>
                    <p>No token received. Please try again.</p>
                  </div>
                </body>
              </html>
            `);
          }
        }
      }
    );
    server.listen(port, () => {
      resolve2({ server, token: tokenPromise });
    });
    server.on("error", reject);
  });
}
async function loginCommand(options) {
  try {
    if (await isLoggedIn()) {
      if (!options?.silent) {
        console.log(
          source_default.yellow(
            "\u26A0\uFE0F  You are already logged in. Run 'npx mcp-use logout' first if you want to login with a different account."
          )
        );
      }
      return;
    }
    console.log(source_default.cyan.bold("\u{1F510} Logging in to Manufact cloud...\n"));
    const state = crypto.randomBytes(32).toString("hex");
    const port = await findAvailablePort();
    const redirectUri = `http://localhost:${port}/callback`;
    console.log(source_default.gray(`Starting local server on port ${port}...`));
    const { server, token } = await startCallbackServer(port, state);
    const webUrl = await getWebUrl();
    const loginUrl = `${webUrl}/auth/cli?redirect_uri=${encodeURIComponent(redirectUri)}&state=${state}`;
    console.log(source_default.gray(`Opening browser to ${webUrl}/auth/cli...
`));
    console.log(
      source_default.white(
        "If the browser doesn't open automatically, please visit:\n" + source_default.cyan(loginUrl)
      )
    );
    await open_default(loginUrl);
    console.log(
      source_default.gray("\nWaiting for authentication... (this may take a moment)")
    );
    const jwtToken = await Promise.race([
      token,
      new Promise(
        (_, reject) => setTimeout(
          () => reject(new Error("Login timeout - please try again")),
          LOGIN_TIMEOUT
        )
      )
    ]);
    server.close();
    console.log(
      source_default.gray("Received authentication token, creating API key...")
    );
    const api = await McpUseAPI.create();
    const apiKeyResponse = await api.createApiKey(jwtToken, "CLI");
    await writeConfig({
      apiKey: apiKeyResponse.api_key
    });
    console.log(source_default.green.bold("\n\u2713 Successfully logged in!"));
    try {
      const api2 = await McpUseAPI.create();
      const authInfo = await api2.testAuth();
      console.log(source_default.cyan.bold("\n\u{1F464} Current user:\n"));
      console.log(source_default.white("Email:   ") + source_default.cyan(authInfo.email));
      console.log(source_default.white("User ID: ") + source_default.gray(authInfo.user_id));
      const apiKey = await getApiKey();
      if (apiKey) {
        const masked = apiKey.substring(0, 6) + "...";
        console.log(source_default.white("API Key: ") + source_default.gray(masked));
      }
    } catch (error) {
      console.log(
        source_default.gray(
          `
Your API key has been saved to ${source_default.white("~/.mcp-use/config.json")}`
        )
      );
    }
    console.log(
      source_default.gray(
        "\nYou can now deploy your MCP servers with " + source_default.white("npx mcp-use deploy")
      )
    );
    console.log(
      source_default.gray("To logout later, run " + source_default.white("npx mcp-use logout"))
    );
  } catch (error) {
    throw new Error(
      `Login failed: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
async function logoutCommand() {
  try {
    if (!await isLoggedIn()) {
      console.log(source_default.yellow("\u26A0\uFE0F  You are not logged in."));
      return;
    }
    console.log(source_default.cyan.bold("\u{1F513} Logging out...\n"));
    await deleteConfig();
    console.log(source_default.green.bold("\u2713 Successfully logged out!"));
    console.log(
      source_default.gray(
        "\nYour local config has been deleted. The API key will remain active until revoked from the web interface."
      )
    );
  } catch (error) {
    console.error(
      source_default.red.bold("\n\u2717 Logout failed:"),
      source_default.red(error instanceof Error ? error.message : "Unknown error")
    );
    process.exit(1);
  }
}
async function whoamiCommand() {
  try {
    if (!await isLoggedIn()) {
      console.log(source_default.yellow("\u26A0\uFE0F  You are not logged in."));
      console.log(
        source_default.gray(
          "Run " + source_default.white("npx mcp-use login") + " to get started."
        )
      );
      return;
    }
    console.log(source_default.cyan.bold("\u{1F464} Current user:\n"));
    const api = await McpUseAPI.create();
    const authInfo = await api.testAuth();
    console.log(source_default.white("Email:   ") + source_default.cyan(authInfo.email));
    console.log(source_default.white("User ID: ") + source_default.gray(authInfo.user_id));
    const apiKey = await getApiKey();
    if (apiKey) {
      const masked = apiKey.substring(0, 6) + "...";
      console.log(source_default.white("API Key: ") + source_default.gray(masked));
    }
  } catch (error) {
    console.error(
      source_default.red.bold("\n\u2717 Failed to get user info:"),
      source_default.red(error instanceof Error ? error.message : "Unknown error")
    );
    process.exit(1);
  }
}

// src/commands/client.ts
import { Command } from "commander";
import { MCPClient } from "mcp-use/client";
import { getPackageVersion } from "mcp-use/server";
import { createInterface } from "readline";

// src/utils/format.ts
function formatTable(data, columns) {
  if (data.length === 0) {
    return source_default.gray("No items found");
  }
  const widths = columns.map((col) => {
    const maxDataWidth = Math.max(
      ...data.map((row) => String(row[col.key] || "").length)
    );
    const headerWidth = col.header.length;
    return col.width || Math.max(maxDataWidth, headerWidth, 10);
  });
  const createRow = (values, bold = false) => {
    const cells = values.map((val, i) => {
      const padded = val.padEnd(widths[i]);
      return bold ? source_default.bold(padded) : padded;
    });
    return `\u2502 ${cells.join(" \u2502 ")} \u2502`;
  };
  const separator = (char) => {
    const parts = widths.map((w) => char.repeat(w + 2));
    if (char === "\u2500") {
      return `\u251C${parts.join("\u253C")}\u2524`;
    }
    return `\u2514${parts.join("\u2534")}\u2518`;
  };
  const lines = [];
  lines.push(`\u250C${widths.map((w) => "\u2500".repeat(w + 2)).join("\u252C")}\u2510`);
  lines.push(
    createRow(
      columns.map((c) => c.header),
      true
    )
  );
  lines.push(separator("\u2500"));
  data.forEach((row) => {
    lines.push(createRow(columns.map((c) => String(row[c.key] || ""))));
  });
  lines.push(separator("\u2500"));
  return lines.join("\n");
}
function formatJson(data, pretty = true) {
  if (pretty) {
    return JSON.stringify(data, null, 2);
  }
  return JSON.stringify(data);
}
function formatToolCall(result) {
  const lines = [];
  if (result.isError) {
    lines.push(source_default.red("\u2717 Tool execution failed"));
    lines.push("");
  } else {
    lines.push(source_default.green("\u2713 Tool executed successfully"));
    lines.push("");
  }
  if (result.content && result.content.length > 0) {
    result.content.forEach((item, index) => {
      if (result.content.length > 1) {
        lines.push(source_default.bold(`Content ${index + 1}:`));
      }
      if (item.type === "text") {
        lines.push(item.text);
      } else if (item.type === "image") {
        lines.push(source_default.cyan(`[Image: ${item.mimeType || "unknown type"}]`));
        if (item.data) {
          lines.push(source_default.gray(`Data: ${item.data.substring(0, 50)}...`));
        }
      } else if (item.type === "resource") {
        lines.push(source_default.cyan(`[Resource]`));
        if (item.resource?.uri) {
          lines.push(source_default.gray(`URI: ${item.resource.uri}`));
        }
        if (item.resource && "text" in item.resource && item.resource.text) {
          lines.push(item.resource.text);
        }
      } else {
        lines.push(source_default.gray(`[Unknown content type: ${item.type}]`));
      }
      if (index < result.content.length - 1) {
        lines.push("");
      }
    });
  }
  return lines.join("\n");
}
function formatResourceContent(content) {
  if (!content || !content.contents) {
    return source_default.gray("No content");
  }
  const lines = [];
  content.contents.forEach((item, index) => {
    if (content.contents.length > 1) {
      lines.push(source_default.bold(`Content ${index + 1}:`));
    }
    if (item.uri) {
      lines.push(source_default.gray(`URI: ${item.uri}`));
    }
    if (item.mimeType) {
      lines.push(source_default.gray(`Type: ${item.mimeType}`));
    }
    if ("text" in item && item.text) {
      lines.push("");
      lines.push(item.text);
    } else if ("blob" in item && item.blob) {
      lines.push("");
      lines.push(source_default.cyan(`[Binary data: ${item.blob.length} bytes]`));
    }
    if (index < content.contents.length - 1) {
      lines.push("");
      lines.push(source_default.gray("\u2500".repeat(50)));
      lines.push("");
    }
  });
  return lines.join("\n");
}
function formatSchema(schema, indent = 0) {
  if (!schema) {
    return source_default.gray("No schema");
  }
  const lines = [];
  const pad = "  ".repeat(indent);
  if (schema.type === "object" && schema.properties) {
    Object.entries(schema.properties).forEach(([key, value]) => {
      const required = schema.required?.includes(key);
      const type = value.type || "any";
      const desc = value.description || "";
      const keyStr = required ? source_default.bold(key) : key;
      const typeStr = source_default.cyan(`(${type})`);
      const requiredStr = required ? source_default.red(" *required") : "";
      lines.push(`${pad}${keyStr} ${typeStr}${requiredStr}`);
      if (desc) {
        lines.push(`${pad}  ${source_default.gray(desc)}`);
      }
      if (value.type === "object" && value.properties) {
        lines.push(formatSchema(value, indent + 1));
      }
      if (value.type === "array" && value.items) {
        lines.push(`${pad}  ${source_default.gray("Items:")}`);
        if (value.items.type === "object") {
          lines.push(formatSchema(value.items, indent + 2));
        } else {
          lines.push(
            `${pad}    ${source_default.cyan(`(${value.items.type || "any"})`)}`
          );
        }
      }
    });
  } else {
    lines.push(`${pad}${source_default.cyan(`Type: ${schema.type || "any"}`)}`);
    if (schema.description) {
      lines.push(`${pad}${source_default.gray(schema.description)}`);
    }
  }
  return lines.join("\n");
}
function formatError(error) {
  const message = typeof error === "string" ? error : error.message;
  return source_default.red(`\u2717 Error: ${message}`);
}
function formatSuccess(message) {
  return source_default.green(`\u2713 ${message}`);
}
function formatInfo(message) {
  return source_default.cyan(message);
}
function formatWarning(message) {
  return source_default.yellow(`\u26A0 ${message}`);
}
function formatHeader(text) {
  return source_default.bold.white(text);
}
function formatKeyValue(pairs) {
  const maxKeyLength = Math.max(...Object.keys(pairs).map((k) => k.length), 0);
  return Object.entries(pairs).map(([key, value]) => {
    const paddedKey = key.padEnd(maxKeyLength);
    return `  ${source_default.gray(paddedKey)}: ${value}`;
  }).join("\n");
}
function formatRelativeTime(dateString) {
  const date = new Date(dateString);
  const now = /* @__PURE__ */ new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffSecs = Math.floor(diffMs / 1e3);
  const diffMins = Math.floor(diffSecs / 60);
  const diffHours = Math.floor(diffMins / 60);
  const diffDays = Math.floor(diffHours / 24);
  const diffWeeks = Math.floor(diffDays / 7);
  const diffMonths = Math.floor(diffDays / 30);
  const diffYears = Math.floor(diffDays / 365);
  if (diffYears > 0) {
    return `${diffYears} year${diffYears > 1 ? "s" : ""} ago`;
  } else if (diffMonths > 0) {
    return `${diffMonths} month${diffMonths > 1 ? "s" : ""} ago`;
  } else if (diffWeeks > 0) {
    return `${diffWeeks} week${diffWeeks > 1 ? "s" : ""} ago`;
  } else if (diffDays > 0) {
    return `${diffDays} day${diffDays > 1 ? "s" : ""} ago`;
  } else if (diffHours > 0) {
    return `${diffHours} hour${diffHours > 1 ? "s" : ""} ago`;
  } else if (diffMins > 0) {
    return `${diffMins} minute${diffMins > 1 ? "s" : ""} ago`;
  } else {
    return "just now";
  }
}
function formatPromptMessages(messages) {
  if (!messages || messages.length === 0) {
    return source_default.gray("No messages");
  }
  const lines = [];
  messages.forEach((msg, index) => {
    const role = msg.role || "unknown";
    const roleStr = role === "user" ? source_default.blue("[User]") : role === "assistant" ? source_default.green("[Assistant]") : source_default.gray(`[${role}]`);
    lines.push(`${roleStr}`);
    if (msg.content) {
      if (typeof msg.content === "string") {
        lines.push(msg.content);
      } else if (msg.content.type === "text") {
        lines.push(msg.content.text);
      } else if (msg.content.type === "image") {
        lines.push(source_default.cyan(`[Image: ${msg.content.mimeType}]`));
      } else if (msg.content.type === "resource") {
        lines.push(source_default.cyan(`[Resource: ${msg.content.resource?.uri}]`));
        if (msg.content.resource?.text) {
          lines.push(msg.content.resource.text);
        }
      }
    }
    if (index < messages.length - 1) {
      lines.push("");
    }
  });
  return lines.join("\n");
}

// src/utils/session-storage.ts
import { homedir } from "os";
import { join } from "path";
import { readFile, writeFile, mkdir } from "fs/promises";
import { existsSync } from "fs";
var SESSION_FILE_PATH = join(homedir(), ".mcp-use", "cli-sessions.json");
async function ensureSessionDir() {
  const dir = join(homedir(), ".mcp-use");
  if (!existsSync(dir)) {
    await mkdir(dir, { recursive: true });
  }
}
async function loadSessions() {
  try {
    await ensureSessionDir();
    if (!existsSync(SESSION_FILE_PATH)) {
      return { activeSession: null, sessions: {} };
    }
    const content = await readFile(SESSION_FILE_PATH, "utf-8");
    return JSON.parse(content);
  } catch (error) {
    return { activeSession: null, sessions: {} };
  }
}
async function saveSessions(storage) {
  await ensureSessionDir();
  await writeFile(SESSION_FILE_PATH, JSON.stringify(storage, null, 2), "utf-8");
}
async function saveSession(name, config) {
  const storage = await loadSessions();
  storage.sessions[name] = {
    ...config,
    lastUsed: (/* @__PURE__ */ new Date()).toISOString()
  };
  if (!storage.activeSession) {
    storage.activeSession = name;
  }
  await saveSessions(storage);
}
async function getActiveSession() {
  const storage = await loadSessions();
  if (!storage.activeSession || !storage.sessions[storage.activeSession]) {
    return null;
  }
  return {
    name: storage.activeSession,
    config: storage.sessions[storage.activeSession]
  };
}
async function getSession(name) {
  const storage = await loadSessions();
  return storage.sessions[name] || null;
}
async function setActiveSession(name) {
  const storage = await loadSessions();
  if (!storage.sessions[name]) {
    throw new Error(`Session '${name}' not found`);
  }
  storage.activeSession = name;
  storage.sessions[name].lastUsed = (/* @__PURE__ */ new Date()).toISOString();
  await saveSessions(storage);
}
async function listAllSessions() {
  const storage = await loadSessions();
  return Object.entries(storage.sessions).map(([name, config]) => ({
    name,
    config,
    isActive: name === storage.activeSession
  }));
}
async function updateSessionInfo(name, serverInfo, capabilities) {
  const storage = await loadSessions();
  if (storage.sessions[name]) {
    storage.sessions[name].serverInfo = serverInfo;
    storage.sessions[name].capabilities = capabilities;
    storage.sessions[name].lastUsed = (/* @__PURE__ */ new Date()).toISOString();
    await saveSessions(storage);
  }
}

// src/commands/client.ts
var activeSessions = /* @__PURE__ */ new Map();
async function getOrRestoreSession(sessionName) {
  if (!sessionName) {
    const active = await getActiveSession();
    if (!active) {
      console.error(
        formatError("No active session. Connect to a server first.")
      );
      console.error(
        formatInfo("Use: npx mcp-use client connect <url> --name <name>")
      );
      return null;
    }
    sessionName = active.name;
  }
  if (activeSessions.has(sessionName)) {
    const { session } = activeSessions.get(sessionName);
    return { name: sessionName, session };
  }
  const config = await getSession(sessionName);
  if (!config) {
    console.error(formatError(`Session '${sessionName}' not found`));
    return null;
  }
  try {
    const client = new MCPClient();
    const cliClientInfo = getCliClientInfo();
    if (config.type === "http") {
      client.addServer(sessionName, {
        url: config.url,
        headers: config.authToken ? { Authorization: `Bearer ${config.authToken}` } : void 0,
        clientInfo: cliClientInfo
      });
    } else if (config.type === "stdio") {
      client.addServer(sessionName, {
        command: config.command,
        args: config.args || [],
        env: config.env,
        clientInfo: cliClientInfo
      });
    } else {
      console.error(formatError(`Unknown session type: ${config.type}`));
      return null;
    }
    const session = await client.createSession(sessionName);
    activeSessions.set(sessionName, { client, session });
    console.error(formatInfo(`Reconnected to session '${sessionName}'`));
    return { name: sessionName, session };
  } catch (error) {
    console.error(formatError(`Failed to restore session: ${error.message}`));
    return null;
  }
}
function getCliClientInfo() {
  return {
    name: "mcp-use CLI",
    title: "mcp-use CLI",
    version: getPackageVersion(),
    description: "mcp-use CLI - Command-line interface for MCP servers",
    icons: [
      {
        src: "https://manufact.com/logo.png"
      }
    ],
    websiteUrl: "https://manufact.com"
  };
}
async function connectCommand(urlOrCommand, options) {
  try {
    const sessionName = options.name || `session-${Date.now()}`;
    const client = new MCPClient();
    let session;
    const cliClientInfo = getCliClientInfo();
    if (options.stdio) {
      const parts = urlOrCommand.split(" ");
      const command = parts[0];
      const args = parts.slice(1);
      console.error(
        formatInfo(`Connecting to stdio server: ${command} ${args.join(" ")}`)
      );
      client.addServer(sessionName, {
        command,
        args,
        clientInfo: cliClientInfo
      });
      session = await client.createSession(sessionName);
      await saveSession(sessionName, {
        type: "stdio",
        command,
        args,
        lastUsed: (/* @__PURE__ */ new Date()).toISOString()
      });
    } else {
      console.error(formatInfo(`Connecting to ${urlOrCommand}...`));
      client.addServer(sessionName, {
        url: urlOrCommand,
        headers: options.auth ? { Authorization: `Bearer ${options.auth}` } : void 0,
        clientInfo: cliClientInfo
      });
      session = await client.createSession(sessionName);
      await saveSession(sessionName, {
        type: "http",
        url: urlOrCommand,
        authToken: options.auth,
        lastUsed: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
    activeSessions.set(sessionName, { client, session });
    const serverInfo = session.serverInfo;
    const capabilities = session.serverCapabilities;
    if (serverInfo) {
      await updateSessionInfo(sessionName, serverInfo, capabilities);
    }
    console.log(formatSuccess(`Connected to ${sessionName}`));
    if (serverInfo) {
      console.log("");
      console.log(formatHeader("Server Information:"));
      console.log(
        formatKeyValue({
          Name: serverInfo.name,
          Version: serverInfo.version || "unknown"
        })
      );
    }
    if (capabilities) {
      console.log("");
      console.log(formatHeader("Capabilities:"));
      const caps = Object.keys(capabilities).join(", ");
      console.log(`  ${caps || "none"}`);
    }
    const tools = session.tools;
    console.log("");
    console.log(
      formatInfo(
        `Available: ${tools.length} tool${tools.length !== 1 ? "s" : ""}`
      )
    );
  } catch (error) {
    console.error(formatError(`Connection failed: ${error.message}`));
    process.exit(1);
  }
}
async function disconnectCommand(sessionName, options) {
  try {
    if (options?.all) {
      for (const [name, { client }] of activeSessions.entries()) {
        await client.closeAllSessions();
        activeSessions.delete(name);
        console.log(formatSuccess(`Disconnected from ${name}`));
      }
      return;
    }
    if (!sessionName) {
      const active = await getActiveSession();
      if (!active) {
        console.error(formatError("No active session to disconnect"));
        return;
      }
      sessionName = active.name;
    }
    const sessionData = activeSessions.get(sessionName);
    if (sessionData) {
      await sessionData.client.closeAllSessions();
      activeSessions.delete(sessionName);
      console.log(formatSuccess(`Disconnected from ${sessionName}`));
    } else {
      console.log(formatInfo(`Session '${sessionName}' is not connected`));
    }
  } catch (error) {
    console.error(formatError(`Failed to disconnect: ${error.message}`));
    process.exit(1);
  }
}
async function listSessionsCommand() {
  try {
    const sessions = await listAllSessions();
    if (sessions.length === 0) {
      console.log(formatInfo("No saved sessions"));
      console.log(
        formatInfo("Connect to a server with: npx mcp-use client connect <url>")
      );
      return;
    }
    console.log(formatHeader("Saved Sessions:"));
    console.log("");
    const tableData = sessions.map((s) => ({
      name: s.isActive ? source_default.green.bold(`${s.name} *`) : s.name,
      type: s.config.type,
      target: s.config.type === "http" ? s.config.url || "" : `${s.config.command} ${(s.config.args || []).join(" ")}`,
      server: s.config.serverInfo?.name || "unknown",
      status: activeSessions.has(s.name) ? source_default.green("connected") : source_default.gray("disconnected")
    }));
    console.log(
      formatTable(tableData, [
        { key: "name", header: "Name" },
        { key: "type", header: "Type" },
        { key: "target", header: "Target", width: 40 },
        { key: "server", header: "Server" },
        { key: "status", header: "Status" }
      ])
    );
    console.log("");
    console.log(source_default.gray("* = active session"));
  } catch (error) {
    console.error(formatError(`Failed to list sessions: ${error.message}`));
    process.exit(1);
  }
}
async function switchSessionCommand(name) {
  try {
    await setActiveSession(name);
    console.log(formatSuccess(`Switched to session '${name}'`));
  } catch (error) {
    console.error(formatError(`Failed to switch session: ${error.message}`));
    process.exit(1);
  }
}
async function listToolsCommand(options) {
  try {
    const result = await getOrRestoreSession(options.session || null);
    if (!result) return;
    const { session } = result;
    const tools = await session.listTools();
    if (options.json) {
      console.log(formatJson(tools));
      return;
    }
    if (tools.length === 0) {
      console.log(formatInfo("No tools available"));
      return;
    }
    console.log(formatHeader(`Available Tools (${tools.length}):`));
    console.log("");
    const tableData = tools.map((tool) => ({
      name: source_default.bold(tool.name),
      description: tool.description || source_default.gray("No description")
    }));
    console.log(
      formatTable(tableData, [
        { key: "name", header: "Tool", width: 25 },
        { key: "description", header: "Description", width: 50 }
      ])
    );
  } catch (error) {
    console.error(formatError(`Failed to list tools: ${error.message}`));
    process.exit(1);
  }
}
async function describeToolCommand(toolName, options) {
  try {
    const result = await getOrRestoreSession(options.session || null);
    if (!result) return;
    const { session } = result;
    const tools = session.tools;
    const tool = tools.find((t) => t.name === toolName);
    if (!tool) {
      console.error(formatError(`Tool '${toolName}' not found`));
      console.log("");
      console.log(formatInfo("Available tools:"));
      tools.forEach((t) => console.log(`  \u2022 ${t.name}`));
      return;
    }
    console.log(formatHeader(`Tool: ${tool.name}`));
    console.log("");
    if (tool.description) {
      console.log(tool.description);
      console.log("");
    }
    if (tool.inputSchema) {
      console.log(formatHeader("Input Schema:"));
      console.log(formatSchema(tool.inputSchema));
    }
  } catch (error) {
    console.error(formatError(`Failed to describe tool: ${error.message}`));
    process.exit(1);
  }
}
async function callToolCommand(toolName, argsJson, options) {
  try {
    const result = await getOrRestoreSession(options?.session || null);
    if (!result) return;
    const { session } = result;
    let args = {};
    if (argsJson) {
      try {
        args = JSON.parse(argsJson);
      } catch (error) {
        console.error(formatError("Invalid JSON arguments"));
        return;
      }
    } else {
      const tools = session.tools;
      const tool = tools.find((t) => t.name === toolName);
      if (tool?.inputSchema?.required && tool.inputSchema.required.length > 0) {
        console.error(
          formatError(
            "This tool requires arguments. Provide them as a JSON string."
          )
        );
        console.log("");
        console.log(formatInfo("Example:"));
        console.log(
          `  npx mcp-use client tools call ${toolName} '{"param": "value"}'`
        );
        console.log("");
        console.log(formatInfo("Tool schema:"));
        console.log(formatSchema(tool.inputSchema));
        return;
      }
    }
    console.error(formatInfo(`Calling tool '${toolName}'...`));
    const callResult = await session.callTool(toolName, args, {
      timeout: options?.timeout
    });
    if (options?.json) {
      console.log(formatJson(callResult));
    } else {
      console.log(formatToolCall(callResult));
    }
  } catch (error) {
    console.error(formatError(`Failed to call tool: ${error.message}`));
    process.exit(1);
  }
}
async function listResourcesCommand(options) {
  try {
    const result = await getOrRestoreSession(options.session || null);
    if (!result) return;
    const { session } = result;
    const resourcesResult = await session.listAllResources();
    const resources = resourcesResult.resources;
    if (options.json) {
      console.log(formatJson(resources));
      return;
    }
    if (resources.length === 0) {
      console.log(formatInfo("No resources available"));
      return;
    }
    console.log(formatHeader(`Available Resources (${resources.length}):`));
    console.log("");
    const tableData = resources.map((resource) => ({
      uri: resource.uri,
      name: resource.name || source_default.gray("(no name)"),
      type: resource.mimeType || source_default.gray("unknown")
    }));
    console.log(
      formatTable(tableData, [
        { key: "uri", header: "URI", width: 40 },
        { key: "name", header: "Name", width: 20 },
        { key: "type", header: "Type", width: 15 }
      ])
    );
  } catch (error) {
    console.error(formatError(`Failed to list resources: ${error.message}`));
    process.exit(1);
  }
}
async function readResourceCommand(uri, options) {
  try {
    const result = await getOrRestoreSession(options.session || null);
    if (!result) return;
    const { session } = result;
    console.error(formatInfo(`Reading resource: ${uri}`));
    const resource = await session.readResource(uri);
    if (options.json) {
      console.log(formatJson(resource));
    } else {
      console.log(formatResourceContent(resource));
    }
  } catch (error) {
    console.error(formatError(`Failed to read resource: ${error.message}`));
    process.exit(1);
  }
}
async function subscribeResourceCommand(uri, options) {
  try {
    const result = await getOrRestoreSession(options.session || null);
    if (!result) return;
    const { session } = result;
    await session.subscribeToResource(uri);
    console.log(formatSuccess(`Subscribed to resource: ${uri}`));
    session.on("notification", async (notification) => {
      if (notification.method === "notifications/resources/updated") {
        console.log("");
        console.log(formatInfo("Resource updated:"));
        console.log(formatJson(notification.params));
      }
    });
    console.log(formatInfo("Listening for updates... (Press Ctrl+C to stop)"));
    await new Promise(() => {
    });
  } catch (error) {
    console.error(
      formatError(`Failed to subscribe to resource: ${error.message}`)
    );
    process.exit(1);
  }
}
async function unsubscribeResourceCommand(uri, options) {
  try {
    const result = await getOrRestoreSession(options.session || null);
    if (!result) return;
    const { session } = result;
    await session.unsubscribeFromResource(uri);
    console.log(formatSuccess(`Unsubscribed from resource: ${uri}`));
  } catch (error) {
    console.error(
      formatError(`Failed to unsubscribe from resource: ${error.message}`)
    );
    process.exit(1);
  }
}
async function listPromptsCommand(options) {
  try {
    const result = await getOrRestoreSession(options.session || null);
    if (!result) return;
    const { session } = result;
    const promptsResult = await session.listPrompts();
    const prompts = promptsResult.prompts;
    if (options.json) {
      console.log(formatJson(prompts));
      return;
    }
    if (prompts.length === 0) {
      console.log(formatInfo("No prompts available"));
      return;
    }
    console.log(formatHeader(`Available Prompts (${prompts.length}):`));
    console.log("");
    const tableData = prompts.map((prompt3) => ({
      name: source_default.bold(prompt3.name),
      description: prompt3.description || source_default.gray("No description")
    }));
    console.log(
      formatTable(tableData, [
        { key: "name", header: "Prompt", width: 25 },
        { key: "description", header: "Description", width: 50 }
      ])
    );
  } catch (error) {
    console.error(formatError(`Failed to list prompts: ${error.message}`));
    process.exit(1);
  }
}
async function getPromptCommand(promptName, argsJson, options) {
  try {
    const result = await getOrRestoreSession(options?.session || null);
    if (!result) return;
    const { session } = result;
    let args = {};
    if (argsJson) {
      try {
        args = JSON.parse(argsJson);
      } catch (error) {
        console.error(formatError("Invalid JSON arguments"));
        return;
      }
    }
    console.error(formatInfo(`Getting prompt '${promptName}'...`));
    const prompt3 = await session.getPrompt(promptName, args);
    if (options?.json) {
      console.log(formatJson(prompt3));
    } else {
      console.log(formatHeader(`Prompt: ${promptName}`));
      console.log("");
      if (prompt3.description) {
        console.log(prompt3.description);
        console.log("");
      }
      if (prompt3.messages) {
        console.log(formatHeader("Messages:"));
        console.log("");
        console.log(formatPromptMessages(prompt3.messages));
      }
    }
  } catch (error) {
    console.error(formatError(`Failed to get prompt: ${error.message}`));
    process.exit(1);
  }
}
async function interactiveCommand(options) {
  try {
    const result = await getOrRestoreSession(options.session || null);
    if (!result) return;
    const { name: sessionName, session } = result;
    console.log(formatHeader("MCP Interactive Mode"));
    console.log("");
    console.log(formatInfo(`Connected to: ${sessionName}`));
    console.log("");
    console.log(source_default.gray("Commands:"));
    console.log(source_default.gray("  tools list              - List available tools"));
    console.log(
      source_default.gray(
        "  tools call <name>       - Call a tool (will prompt for args)"
      )
    );
    console.log(source_default.gray("  tools describe <name>   - Show tool details"));
    console.log(
      source_default.gray("  resources list          - List available resources")
    );
    console.log(source_default.gray("  resources read <uri>    - Read a resource"));
    console.log(
      source_default.gray("  prompts list            - List available prompts")
    );
    console.log(source_default.gray("  prompts get <name>      - Get a prompt"));
    console.log(source_default.gray("  sessions list           - List all sessions"));
    console.log(
      source_default.gray("  sessions switch <name>  - Switch to another session")
    );
    console.log(
      source_default.gray("  exit, quit              - Exit interactive mode")
    );
    console.log("");
    const rl = createInterface({
      input: process.stdin,
      output: process.stdout,
      prompt: source_default.cyan("mcp> ")
    });
    rl.prompt();
    rl.on("line", async (line) => {
      const trimmed = line.trim();
      if (!trimmed) {
        rl.prompt();
        return;
      }
      if (trimmed === "exit" || trimmed === "quit") {
        console.log(formatInfo("Goodbye!"));
        rl.close();
        process.exit(0);
      }
      const parts = trimmed.split(" ");
      const scope = parts[0];
      const command = parts[1];
      const arg = parts[2];
      try {
        if (scope === "tools") {
          if (command === "list") {
            const tools = await session.listTools();
            console.log(
              formatInfo(
                `Available tools: ${tools.map((t) => t.name).join(", ")}`
              )
            );
          } else if (command === "call" && arg) {
            rl.question(
              "Arguments (JSON, or press Enter for none): ",
              async (argsInput) => {
                try {
                  const args = argsInput.trim() ? JSON.parse(argsInput) : {};
                  const result2 = await session.callTool(arg, args);
                  console.log(formatToolCall(result2));
                } catch (error) {
                  console.error(formatError(error.message));
                }
                rl.prompt();
              }
            );
            return;
          } else if (command === "describe" && arg) {
            const tools = session.tools;
            const tool = tools.find((t) => t.name === arg);
            if (tool) {
              console.log(formatHeader(`Tool: ${tool.name}`));
              if (tool.description) console.log(tool.description);
              if (tool.inputSchema) {
                console.log("");
                console.log(formatSchema(tool.inputSchema));
              }
            } else {
              console.error(formatError(`Tool '${arg}' not found`));
            }
          } else {
            console.error(
              formatError(
                "Invalid command. Try: tools list, tools call <name>, tools describe <name>"
              )
            );
          }
        } else if (scope === "resources") {
          if (command === "list") {
            const result2 = await session.listAllResources();
            const resources = result2.resources;
            console.log(
              formatInfo(
                `Available resources: ${resources.map((r) => r.uri).join(", ")}`
              )
            );
          } else if (command === "read" && arg) {
            const resource = await session.readResource(arg);
            console.log(formatResourceContent(resource));
          } else {
            console.error(
              formatError(
                "Invalid command. Try: resources list, resources read <uri>"
              )
            );
          }
        } else if (scope === "prompts") {
          if (command === "list") {
            const result2 = await session.listPrompts();
            const prompts = result2.prompts;
            console.log(
              formatInfo(
                `Available prompts: ${prompts.map((p) => p.name).join(", ")}`
              )
            );
          } else if (command === "get" && arg) {
            rl.question(
              "Arguments (JSON, or press Enter for none): ",
              async (argsInput) => {
                try {
                  const args = argsInput.trim() ? JSON.parse(argsInput) : {};
                  const prompt3 = await session.getPrompt(arg, args);
                  console.log(formatPromptMessages(prompt3.messages));
                } catch (error) {
                  console.error(formatError(error.message));
                }
                rl.prompt();
              }
            );
            return;
          } else {
            console.error(
              formatError(
                "Invalid command. Try: prompts list, prompts get <name>"
              )
            );
          }
        } else if (scope === "sessions") {
          if (command === "list") {
            await listSessionsCommand();
          } else if (command === "switch" && arg) {
            console.log(
              formatWarning(
                "Session switching in interactive mode will be available in a future version"
              )
            );
          } else {
            console.error(formatError("Invalid command. Try: sessions list"));
          }
        } else {
          console.error(
            formatError(
              "Unknown command. Type a valid scope: tools, resources, prompts, sessions"
            )
          );
        }
      } catch (error) {
        console.error(formatError(error.message));
      }
      rl.prompt();
    });
    rl.on("close", () => {
      console.log("");
      console.log(formatInfo("Goodbye!"));
      process.exit(0);
    });
  } catch (error) {
    console.error(
      formatError(`Failed to start interactive mode: ${error.message}`)
    );
    process.exit(1);
  }
}
function createClientCommand() {
  const clientCommand = new Command("client").description(
    "Interactive MCP client for terminal usage"
  );
  clientCommand.command("connect <url>").description("Connect to an MCP server").option("--name <name>", "Session name").option("--stdio", "Use stdio connector instead of HTTP").option("--auth <token>", "Authentication token").action(connectCommand);
  clientCommand.command("disconnect [session]").description("Disconnect from a session").option("--all", "Disconnect all sessions").action(disconnectCommand);
  const sessionsCommand = new Command("sessions").description(
    "Manage CLI sessions"
  );
  sessionsCommand.command("list").description("List all saved sessions").action(listSessionsCommand);
  sessionsCommand.command("switch <name>").description("Switch to a different session").action(switchSessionCommand);
  clientCommand.addCommand(sessionsCommand);
  const toolsCommand = new Command("tools").description(
    "Interact with MCP tools"
  );
  toolsCommand.command("list").description("List available tools").option("--session <name>", "Use specific session").option("--json", "Output as JSON").action(listToolsCommand);
  toolsCommand.command("call <name> [args]").description("Call a tool with arguments (JSON string)").option("--session <name>", "Use specific session").option("--timeout <ms>", "Request timeout in milliseconds", parseInt).option("--json", "Output as JSON").action(callToolCommand);
  toolsCommand.command("describe <name>").description("Show tool details and schema").option("--session <name>", "Use specific session").action(describeToolCommand);
  clientCommand.addCommand(toolsCommand);
  const resourcesCommand = new Command("resources").description(
    "Interact with MCP resources"
  );
  resourcesCommand.command("list").description("List available resources").option("--session <name>", "Use specific session").option("--json", "Output as JSON").action(listResourcesCommand);
  resourcesCommand.command("read <uri>").description("Read a resource by URI").option("--session <name>", "Use specific session").option("--json", "Output as JSON").action(readResourceCommand);
  resourcesCommand.command("subscribe <uri>").description("Subscribe to resource updates").option("--session <name>", "Use specific session").action(subscribeResourceCommand);
  resourcesCommand.command("unsubscribe <uri>").description("Unsubscribe from resource updates").option("--session <name>", "Use specific session").action(unsubscribeResourceCommand);
  clientCommand.addCommand(resourcesCommand);
  const promptsCommand = new Command("prompts").description(
    "Interact with MCP prompts"
  );
  promptsCommand.command("list").description("List available prompts").option("--session <name>", "Use specific session").option("--json", "Output as JSON").action(listPromptsCommand);
  promptsCommand.command("get <name> [args]").description("Get a prompt with arguments (JSON string)").option("--session <name>", "Use specific session").option("--json", "Output as JSON").action(getPromptCommand);
  clientCommand.addCommand(promptsCommand);
  clientCommand.command("interactive").description("Start interactive REPL mode").option("--session <name>", "Use specific session").action(interactiveCommand);
  return clientCommand;
}

// src/commands/deploy.ts
import { promises as fs9 } from "fs";
import path5 from "path";

// src/utils/git.ts
import { exec } from "child_process";
import { promisify as promisify7 } from "util";
var execAsync = promisify7(exec);
async function gitCommand(command, cwd = process.cwd()) {
  try {
    const { stdout } = await execAsync(command, { cwd });
    return stdout.trim();
  } catch (error) {
    return null;
  }
}
async function isGitRepo(cwd = process.cwd()) {
  const result = await gitCommand("git rev-parse --is-inside-work-tree", cwd);
  return result === "true";
}
async function getRemoteUrl(cwd = process.cwd()) {
  return gitCommand("git config --get remote.origin.url", cwd);
}
function parseGitHubUrl(url) {
  const sshMatch = url.match(/git@github\.com:([^/]+)\/(.+?)(?:\.git)?$/);
  const httpsMatch = url.match(
    /https:\/\/github\.com\/([^/]+)\/(.+?)(?:\.git)?$/
  );
  const match = sshMatch || httpsMatch;
  if (!match) return null;
  return {
    owner: match[1],
    repo: match[2]
  };
}
async function getCurrentBranch(cwd = process.cwd()) {
  return gitCommand("git rev-parse --abbrev-ref HEAD", cwd);
}
async function getCommitSha(cwd = process.cwd()) {
  return gitCommand("git rev-parse HEAD", cwd);
}
async function getCommitMessage(cwd = process.cwd()) {
  return gitCommand("git log -1 --pretty=%B", cwd);
}
async function hasUncommittedChanges(cwd = process.cwd()) {
  const result = await gitCommand("git status --porcelain", cwd);
  return result !== null && result.length > 0;
}
async function getGitInfo(cwd = process.cwd()) {
  const isRepo = await isGitRepo(cwd);
  if (!isRepo) {
    return { isGitRepo: false };
  }
  const remoteUrl = await getRemoteUrl(cwd);
  const branch = await getCurrentBranch(cwd);
  const commitSha = await getCommitSha(cwd);
  const commitMessage = await getCommitMessage(cwd);
  const uncommittedChanges = await hasUncommittedChanges(cwd);
  let owner;
  let repo;
  if (remoteUrl) {
    const parsed = parseGitHubUrl(remoteUrl);
    if (parsed) {
      owner = parsed.owner;
      repo = parsed.repo;
    }
  }
  return {
    isGitRepo: true,
    remoteUrl: remoteUrl || void 0,
    owner,
    repo,
    branch: branch || void 0,
    commitSha: commitSha || void 0,
    commitMessage: commitMessage || void 0,
    hasUncommittedChanges: uncommittedChanges
  };
}
function isGitHubUrl(url) {
  try {
    const parsedUrl = new URL(url);
    return parsedUrl.hostname === "github.com" || parsedUrl.hostname === "www.github.com";
  } catch {
    const sshMatch = url.match(/^git@([^:/]+)[:/]/);
    if (sshMatch) {
      const host = sshMatch[1];
      return host === "github.com" || host === "www.github.com";
    }
  }
  return false;
}

// src/utils/project-link.ts
import { promises as fs8 } from "fs";
import path4 from "path";
var MCP_USE_DIR = ".mcp-use";
var MCP_USE_DIR_PROJECT = "project.json";
function getMcpUseDirectory(cwd) {
  return path4.join(cwd, MCP_USE_DIR);
}
async function getProjectLink(cwd) {
  try {
    const linkPath = path4.join(getMcpUseDirectory(cwd), MCP_USE_DIR_PROJECT);
    const content = await fs8.readFile(linkPath, "utf-8");
    return JSON.parse(content);
  } catch (err) {
    if (err.code === "ENOENT") return null;
    throw err;
  }
}
async function saveProjectLink(cwd, link) {
  const mcpUseDir = getMcpUseDirectory(cwd);
  await fs8.mkdir(mcpUseDir, { recursive: true });
  const linkPath = path4.join(mcpUseDir, MCP_USE_DIR_PROJECT);
  await fs8.writeFile(linkPath, JSON.stringify(link, null, 2), "utf-8");
  await addToGitIgnore(cwd);
}
async function addToGitIgnore(cwd) {
  const gitignorePath = path4.join(cwd, ".gitignore");
  try {
    let content = "";
    try {
      content = await fs8.readFile(gitignorePath, "utf-8");
    } catch (err) {
      if (err.code !== "ENOENT") throw err;
    }
    if (!content.includes(MCP_USE_DIR)) {
      const newContent = content + (content.endsWith("\n") ? "" : "\n") + `
# mcp-use deployment
${MCP_USE_DIR}
`;
      await fs8.writeFile(gitignorePath, newContent, "utf-8");
    }
  } catch (err) {
  }
}

// src/commands/deploy.ts
var GATEWAY_DOMAIN = "run.mcp-use.com";
function buildGatewayUrl(slugOrId) {
  return `https://${slugOrId}.${GATEWAY_DOMAIN}/mcp`;
}
async function parseEnvFile(filePath) {
  try {
    const content = await fs9.readFile(filePath, "utf-8");
    const envVars = {};
    const lines = content.split("\n");
    let currentKey = null;
    let currentValue = "";
    for (let line of lines) {
      line = line.trim();
      if (!line || line.startsWith("#")) {
        continue;
      }
      if (currentKey && !line.includes("=")) {
        currentValue += "\n" + line;
        continue;
      }
      if (currentKey) {
        envVars[currentKey] = currentValue.replace(/^["']|["']$/g, "");
        currentKey = null;
        currentValue = "";
      }
      const equalIndex = line.indexOf("=");
      if (equalIndex === -1) {
        continue;
      }
      const key = line.substring(0, equalIndex).trim();
      let value = line.substring(equalIndex + 1).trim();
      if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(key)) {
        console.log(
          source_default.yellow(`\u26A0\uFE0F  Skipping invalid environment variable key: ${key}`)
        );
        continue;
      }
      if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
        value = value.slice(1, -1);
        envVars[key] = value;
      } else if (value.startsWith('"') || value.startsWith("'")) {
        currentKey = key;
        currentValue = value.slice(1);
      } else {
        envVars[key] = value;
      }
    }
    if (currentKey) {
      envVars[currentKey] = currentValue.replace(/^["']|["']$/g, "");
    }
    return envVars;
  } catch (error) {
    if (error.code === "ENOENT") {
      throw new Error(`Environment file not found: ${filePath}`);
    }
    throw new Error(
      `Failed to parse environment file: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}
function parseEnvVar(envStr) {
  const equalIndex = envStr.indexOf("=");
  if (equalIndex === -1) {
    throw new Error(
      `Invalid environment variable format: "${envStr}". Expected KEY=VALUE`
    );
  }
  const key = envStr.substring(0, equalIndex).trim();
  const value = envStr.substring(equalIndex + 1);
  if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(key)) {
    throw new Error(
      `Invalid environment variable key: "${key}". Keys must start with a letter or underscore and contain only letters, numbers, and underscores.`
    );
  }
  return { key, value };
}
async function buildEnvVars(options) {
  const envVars = {};
  if (options.envFile) {
    try {
      const fileEnv = await parseEnvFile(options.envFile);
      Object.assign(envVars, fileEnv);
      console.log(
        source_default.gray(
          `Loaded ${Object.keys(fileEnv).length} variable(s) from ${options.envFile}`
        )
      );
    } catch (error) {
      console.log(
        source_default.red(
          `\u2717 ${error instanceof Error ? error.message : "Failed to load env file"}`
        )
      );
      process.exit(1);
    }
  }
  if (options.env && options.env.length > 0) {
    for (const envStr of options.env) {
      try {
        const { key, value } = parseEnvVar(envStr);
        envVars[key] = value;
      } catch (error) {
        console.log(
          source_default.red(
            `\u2717 ${error instanceof Error ? error.message : "Invalid env variable"}`
          )
        );
        process.exit(1);
      }
    }
  }
  return envVars;
}
async function isMcpProject(cwd = process.cwd()) {
  try {
    const packageJsonPath = path5.join(cwd, "package.json");
    const content = await fs9.readFile(packageJsonPath, "utf-8");
    const packageJson2 = JSON.parse(content);
    const hasMcpDeps = packageJson2.dependencies?.["mcp-use"] || packageJson2.dependencies?.["@modelcontextprotocol/sdk"] || packageJson2.devDependencies?.["mcp-use"] || packageJson2.devDependencies?.["@modelcontextprotocol/sdk"];
    const hasMcpScripts = packageJson2.scripts?.mcp || packageJson2.scripts?.["mcp:dev"];
    return !!(hasMcpDeps || hasMcpScripts);
  } catch {
    return false;
  }
}
async function getProjectName(cwd = process.cwd()) {
  try {
    const packageJsonPath = path5.join(cwd, "package.json");
    const content = await fs9.readFile(packageJsonPath, "utf-8");
    const packageJson2 = JSON.parse(content);
    if (packageJson2.name) {
      return packageJson2.name;
    }
  } catch {
  }
  return path5.basename(cwd);
}
async function detectBuildCommand(cwd = process.cwd()) {
  try {
    const packageJsonPath = path5.join(cwd, "package.json");
    const content = await fs9.readFile(packageJsonPath, "utf-8");
    const packageJson2 = JSON.parse(content);
    if (packageJson2.scripts?.build) {
      return "npm run build";
    }
  } catch {
  }
  return void 0;
}
async function detectStartCommand(cwd = process.cwd()) {
  try {
    const packageJsonPath = path5.join(cwd, "package.json");
    const content = await fs9.readFile(packageJsonPath, "utf-8");
    const packageJson2 = JSON.parse(content);
    if (packageJson2.scripts?.start) {
      return "npm start";
    }
    if (packageJson2.main) {
      return `node ${packageJson2.main}`;
    }
  } catch {
  }
  return void 0;
}
async function detectRuntime(cwd = process.cwd()) {
  try {
    const pythonFiles = ["requirements.txt", "pyproject.toml", "setup.py"];
    for (const file of pythonFiles) {
      try {
        await fs9.access(path5.join(cwd, file));
        return "python";
      } catch {
        continue;
      }
    }
    try {
      await fs9.access(path5.join(cwd, "package.json"));
      return "node";
    } catch {
    }
  } catch {
  }
  return "node";
}
async function prompt(question, defaultValue = "n") {
  const readline = await import("readline");
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  const defaultIndicator = defaultValue === "y" ? "Y/n" : "y/N";
  const questionWithDefault = question.replace(
    /(\(y\/n\):)/,
    `(${defaultIndicator}):`
  );
  return new Promise((resolve2) => {
    rl.question(questionWithDefault, (answer) => {
      rl.close();
      const trimmedAnswer = answer.trim().toLowerCase();
      if (trimmedAnswer === "") {
        resolve2(defaultValue === "y");
      } else {
        resolve2(trimmedAnswer === "y" || trimmedAnswer === "yes");
      }
    });
  });
}
function getMcpServerUrl(deployment) {
  if (deployment.customDomain) {
    return `https://${deployment.customDomain}/mcp`;
  } else if (deployment.serverSlug) {
    return buildGatewayUrl(deployment.serverSlug);
  } else if (deployment.serverId) {
    return buildGatewayUrl(deployment.serverId);
  } else {
    return `https://${deployment.domain}/mcp`;
  }
}
async function displayDeploymentProgress(api, deployment) {
  const frames = ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"];
  let frameIndex = 0;
  let spinnerInterval = null;
  let lastStep = "";
  const startSpinner = (message) => {
    if (spinnerInterval) {
      clearInterval(spinnerInterval);
    }
    process.stdout.write("\r\x1B[K");
    spinnerInterval = setInterval(() => {
      const frame = frames[frameIndex];
      frameIndex = (frameIndex + 1) % frames.length;
      process.stdout.write(
        "\r" + source_default.cyan(frame) + " " + source_default.gray(message)
      );
    }, 80);
  };
  const stopSpinner = () => {
    if (spinnerInterval) {
      clearInterval(spinnerInterval);
      spinnerInterval = null;
      process.stdout.write("\r\x1B[K");
    }
  };
  console.log();
  startSpinner("Deploying...");
  try {
    for await (const log of api.streamDeploymentLogs(deployment.id)) {
      try {
        const logData = JSON.parse(log);
        if (logData.step && logData.step !== lastStep) {
          lastStep = logData.step;
          const stepMessages = {
            clone: "Preparing source code...",
            analyze: "Analyzing project...",
            build: "Building container image...",
            deploy: "Deploying to cloud..."
          };
          const message = stepMessages[logData.step] || "Deploying...";
          startSpinner(message);
        }
        if (logData.line) {
          stopSpinner();
          const levelColor = logData.level === "error" ? source_default.red : logData.level === "warn" ? source_default.yellow : source_default.gray;
          const stepPrefix = logData.step ? source_default.cyan(`[${logData.step}]`) + " " : "";
          console.log(stepPrefix + levelColor(logData.line));
        }
      } catch {
      }
    }
  } catch (error) {
    stopSpinner();
  }
  let checkCount = 0;
  const maxChecks = 60;
  let delay = 3e3;
  const maxDelay = 1e4;
  let lastDisplayedLogLength = 0;
  while (checkCount < maxChecks) {
    const currentDelay = delay;
    await new Promise((resolve2) => setTimeout(resolve2, currentDelay));
    const finalDeployment = await api.getDeployment(deployment.id);
    if (finalDeployment.buildLogs && finalDeployment.buildLogs.length > lastDisplayedLogLength) {
      const newLogs = finalDeployment.buildLogs.substring(
        lastDisplayedLogLength
      );
      const logLines = newLogs.split("\n").filter((l) => l.trim());
      for (const line of logLines) {
        try {
          const logData = JSON.parse(line);
          if (logData.line) {
            stopSpinner();
            const levelColor = logData.level === "error" ? source_default.red : logData.level === "warn" ? source_default.yellow : source_default.gray;
            const stepPrefix = logData.step ? source_default.cyan(`[${logData.step}]`) + " " : "";
            console.log(stepPrefix + levelColor(logData.line));
          }
        } catch {
        }
      }
      lastDisplayedLogLength = finalDeployment.buildLogs.length;
    }
    if (finalDeployment.status === "running") {
      const mcpServerUrl = getMcpServerUrl(finalDeployment);
      let dashboardUrl = null;
      if (finalDeployment.serverSlug) {
        dashboardUrl = `https://manufact.com/cloud/servers/${finalDeployment.serverSlug}`;
      } else if (finalDeployment.serverId) {
        dashboardUrl = `https://manufact.com/cloud/servers/${finalDeployment.serverId}`;
      }
      const inspectorUrl = `https://inspector.manufact.com/inspector?autoConnect=${encodeURIComponent(
        mcpServerUrl
      )}`;
      console.log(source_default.green.bold("\u2713 Deployment successful!\n"));
      console.log(source_default.white("\u{1F310} MCP Server URL:"));
      console.log(source_default.cyan.bold(`   ${mcpServerUrl}
`));
      if (dashboardUrl) {
        console.log(source_default.white("\u{1F4CA} Dashboard:"));
        console.log(source_default.cyan.bold(`   ${dashboardUrl}
`));
      }
      console.log(source_default.white("\u{1F50D} Inspector URL:"));
      console.log(source_default.cyan.bold(`   ${inspectorUrl}
`));
      console.log(
        source_default.gray("Deployment ID: ") + source_default.white(finalDeployment.id)
      );
      return;
    } else if (finalDeployment.status === "failed") {
      stopSpinner();
      console.log(source_default.red.bold("\u2717 Deployment failed\n"));
      if (finalDeployment.error) {
        console.log(source_default.red("Error: ") + finalDeployment.error);
        if (finalDeployment.error.includes("No GitHub installations found")) {
          console.log();
          const retry = await promptGitHubInstallation(api, "not_connected");
          if (retry) {
            console.log(source_default.cyan("\n\u{1F504} Retrying deployment...\n"));
            const newDeployment = await api.redeployDeployment(deployment.id);
            await displayDeploymentProgress(api, newDeployment);
            return;
          }
        } else if (finalDeployment.error.includes("Authenticated git clone failed")) {
          let repoName;
          const repoMatch = finalDeployment.error.match(
            /github\.com\/([^/]+\/[^/\s]+)/
          );
          if (repoMatch) {
            repoName = repoMatch[1].replace(/\.git$/, "");
          } else if (finalDeployment.source.type === "github") {
            repoName = finalDeployment.source.repo;
          }
          console.log();
          const retry = await promptGitHubInstallation(
            api,
            "no_access",
            repoName
          );
          if (retry) {
            console.log(source_default.cyan("\n\u{1F504} Retrying deployment...\n"));
            const newDeployment = await api.redeployDeployment(deployment.id);
            await displayDeploymentProgress(api, newDeployment);
            return;
          }
        }
      }
      if (finalDeployment.buildLogs) {
        console.log(source_default.gray("\nBuild logs:"));
        try {
          const logs = finalDeployment.buildLogs.split("\n").filter((l) => l.trim());
          for (const log of logs) {
            try {
              const logData = JSON.parse(log);
              if (logData.line) {
                console.log(source_default.gray(`  ${logData.line}`));
              }
            } catch {
              console.log(source_default.gray(`  ${log}`));
            }
          }
        } catch {
          console.log(source_default.gray(finalDeployment.buildLogs));
        }
      }
      process.exit(1);
    } else if (finalDeployment.status === "building") {
      startSpinner("Building and deploying...");
      checkCount++;
      delay = Math.min(delay * 1.2, maxDelay);
    } else {
      console.log(
        source_default.yellow("\u26A0\uFE0F  Deployment status: ") + finalDeployment.status
      );
      return;
    }
  }
  stopSpinner();
  console.log(source_default.yellow("\u26A0\uFE0F  Deployment is taking longer than expected."));
  console.log(
    source_default.gray("Check status with: ") + source_default.white(`mcp-use status ${deployment.id}`)
  );
}
async function checkRepoAccess(api, owner, repo) {
  try {
    const reposResponse = await api.getGitHubRepos(true);
    const repoFullName = `${owner}/${repo}`;
    return reposResponse.repos.some((r) => r.full_name === repoFullName);
  } catch (error) {
    console.log(source_default.gray("Could not verify repository access"));
    return false;
  }
}
async function promptGitHubInstallation(api, reason, repoName) {
  console.log();
  if (reason === "not_connected") {
    console.log(source_default.yellow("\u26A0\uFE0F  GitHub account not connected"));
    console.log(
      source_default.white("Deployments require a connected GitHub account.\n")
    );
  } else {
    console.log(
      source_default.yellow("\u26A0\uFE0F  GitHub App doesn't have access to this repository")
    );
    console.log(
      source_default.white(
        `The GitHub App needs permission to access ${source_default.cyan(repoName || "this repository")}.
`
      )
    );
  }
  const shouldInstall = await prompt(
    source_default.white(
      `Would you like to ${reason === "not_connected" ? "connect" : "configure"} GitHub now? (Y/n): `
    ),
    "y"
  );
  if (!shouldInstall) {
    return false;
  }
  try {
    const appName = process.env.MCP_GITHUB_APP_NAME || "mcp-use";
    const installUrl = reason === "not_connected" ? `https://github.com/apps/${appName}/installations/new` : `https://github.com/settings/installations`;
    console.log(
      source_default.cyan(
        `
Opening browser to ${reason === "not_connected" ? "install" : "configure"} GitHub App...`
      )
    );
    console.log(source_default.gray(`URL: ${installUrl}
`));
    if (reason === "no_access") {
      console.log(source_default.white("Please:"));
      console.log(
        source_default.cyan("  1. Find the 'mcp-use' (or similar) GitHub App")
      );
      console.log(source_default.cyan("  2. Click 'Configure'"));
      console.log(
        source_default.cyan(
          `  3. Grant access to ${source_default.bold(repoName || "your repository")}`
        )
      );
      console.log(source_default.cyan("  4. Save your changes"));
      console.log(source_default.cyan("  5. Return here when done\n"));
    } else {
      console.log(source_default.white("Please:"));
      console.log(source_default.cyan("  1. Select the repositories to grant access"));
      if (repoName) {
        console.log(
          source_default.cyan(`  2. Make sure to include ${source_default.bold(repoName)}`)
        );
        console.log(source_default.cyan("  3. Complete the installation"));
      } else {
        console.log(source_default.cyan("  2. Complete the installation"));
      }
      console.log();
    }
    await open_default(installUrl);
    console.log(source_default.gray("Waiting for GitHub configuration..."));
    await prompt(
      source_default.white("Press Enter when you've completed the GitHub setup..."),
      "y"
    );
    console.log(source_default.gray("Verifying GitHub connection..."));
    let verified = false;
    try {
      const status = await api.getGitHubConnectionStatus();
      if (!status.is_connected) {
        console.log(source_default.yellow("\u26A0\uFE0F  GitHub connection not detected."));
      } else if (repoName) {
        const [owner, repo] = repoName.split("/");
        console.log(source_default.gray(`Checking access to ${repoName}...`));
        const hasAccess = await checkRepoAccess(api, owner, repo);
        if (!hasAccess) {
          console.log(
            source_default.yellow(
              `\u26A0\uFE0F  The GitHub App may not have access to ${source_default.cyan(repoName)} yet`
            )
          );
        } else {
          console.log(source_default.green(`\u2713 Repository ${repoName} is accessible!
`));
          verified = true;
        }
      } else {
        console.log(source_default.green("\u2713 GitHub connected successfully!\n"));
        verified = true;
      }
    } catch (error) {
      console.log(
        source_default.yellow("\u26A0\uFE0F  Could not verify GitHub connection (API issue)")
      );
    }
    if (!verified) {
      console.log(
        source_default.gray(
          "\nNote: If you completed the GitHub setup, the deployment may work now.\n"
        )
      );
    }
    return true;
  } catch (error) {
    console.log(
      source_default.yellow("\n\u26A0\uFE0F  Unable to open GitHub installation automatically")
    );
    console.log(
      source_default.white("Please visit: ") + source_default.cyan("https://manufact.com/cloud/settings")
    );
    console.log(
      source_default.gray("Then connect your GitHub account and try again.\n")
    );
    return false;
  }
}
async function deployCommand(options) {
  try {
    const cwd = process.cwd();
    if (!await isLoggedIn()) {
      console.log(source_default.red("\u2717 You are not logged in."));
      const shouldLogin = await prompt(
        source_default.white("Would you like to login now? (Y/n): "),
        "y"
      );
      if (shouldLogin) {
        try {
          await loginCommand({ silent: false });
          if (!await isLoggedIn()) {
            console.log(
              source_default.red("\u2717 Login verification failed. Please try again.")
            );
            process.exit(1);
          }
          console.log(source_default.gray("\nContinuing with deployment...\n"));
        } catch (error) {
          console.error(
            source_default.red.bold("\u2717 Login failed:"),
            source_default.red(error instanceof Error ? error.message : "Unknown error")
          );
          process.exit(1);
        }
      } else {
        console.log(
          source_default.gray(
            "Run " + source_default.white("npx mcp-use login") + " to get started."
          )
        );
        console.log(source_default.gray("Deployment cancelled."));
        process.exit(0);
      }
    }
    console.log(source_default.cyan.bold("\u{1F680} Deploying to Manufact cloud...\n"));
    const isMcp = await isMcpProject(cwd);
    if (!isMcp) {
      console.log(
        source_default.yellow(
          "\u26A0\uFE0F  This doesn't appear to be an MCP server project (no mcp-use or @modelcontextprotocol/sdk dependency found)."
        )
      );
      const shouldContinue = await prompt(
        source_default.white("Continue anyway? (y/n): ")
      );
      if (!shouldContinue) {
        console.log(source_default.gray("Deployment cancelled."));
        process.exit(0);
      }
      console.log();
    }
    const gitInfo = await getGitInfo(cwd);
    if (!gitInfo.isGitRepo) {
      console.log(source_default.red("\u2717 Not a git repository\n"));
      console.log(source_default.white("To deploy, initialize git and push to GitHub:"));
      console.log(source_default.gray("  1. Initialize git:"));
      console.log(source_default.cyan("     git init\n"));
      console.log(source_default.gray("  2. Create a GitHub repository at:"));
      console.log(source_default.cyan("     https://github.com/new\n"));
      console.log(source_default.gray("  3. Add the remote and push:"));
      console.log(source_default.cyan("     git remote add origin <your-github-url>"));
      console.log(source_default.cyan("     git add ."));
      console.log(source_default.cyan("     git commit -m 'Initial commit'"));
      console.log(source_default.cyan("     git push -u origin main\n"));
      process.exit(1);
    }
    if (!gitInfo.remoteUrl) {
      console.log(source_default.red("\u2717 No git remote configured\n"));
      console.log(source_default.white("Add a GitHub remote:"));
      console.log(source_default.cyan("  git remote add origin <your-github-url>\n"));
      process.exit(1);
    }
    if (!isGitHubUrl(gitInfo.remoteUrl)) {
      console.log(source_default.red("\u2717 Remote is not a GitHub repository"));
      console.log(source_default.yellow(`   Current remote: ${gitInfo.remoteUrl}
`));
      console.log(source_default.white("Please add a GitHub remote to deploy."));
      process.exit(1);
    }
    if (!gitInfo.owner || !gitInfo.repo) {
      console.log(source_default.red("\u2717 Could not parse GitHub repository information"));
      process.exit(1);
    }
    if (gitInfo.hasUncommittedChanges) {
      console.log(source_default.yellow("\u26A0\uFE0F  You have uncommitted changes\n"));
      console.log(source_default.white("Deployments use the code pushed to GitHub."));
      console.log(
        source_default.white(
          "Local changes will not be included until you commit and push.\n"
        )
      );
      const shouldContinue = await prompt(
        source_default.white("Continue with deployment from GitHub? (y/n): ")
      );
      if (!shouldContinue) {
        console.log(source_default.gray("Deployment cancelled."));
        process.exit(0);
      }
      console.log();
    }
    console.log(source_default.white("GitHub repository detected:"));
    console.log(
      source_default.gray(`  Repository: `) + source_default.cyan(`${gitInfo.owner}/${gitInfo.repo}`)
    );
    console.log(
      source_default.gray(`  Branch:     `) + source_default.cyan(gitInfo.branch || "main")
    );
    if (gitInfo.commitSha) {
      console.log(
        source_default.gray(`  Commit:     `) + source_default.gray(gitInfo.commitSha.substring(0, 7))
      );
    }
    if (gitInfo.commitMessage) {
      console.log(
        source_default.gray(`  Message:    `) + source_default.gray(gitInfo.commitMessage.split("\n")[0])
      );
    }
    console.log();
    const shouldDeploy = await prompt(
      source_default.white(
        `Deploy from GitHub repository ${gitInfo.owner}/${gitInfo.repo}? (Y/n): `
      ),
      "y"
    );
    if (!shouldDeploy) {
      console.log(source_default.gray("Deployment cancelled."));
      process.exit(0);
    }
    const projectName = options.name || await getProjectName(cwd);
    const runtime = options.runtime || await detectRuntime(cwd);
    const port = options.port || 3e3;
    const buildCommand = await detectBuildCommand(cwd);
    const startCommand = await detectStartCommand(cwd);
    const envVars = await buildEnvVars(options);
    console.log();
    console.log(source_default.white("Deployment configuration:"));
    console.log(source_default.gray(`  Name:          `) + source_default.cyan(projectName));
    console.log(source_default.gray(`  Runtime:       `) + source_default.cyan(runtime));
    console.log(source_default.gray(`  Port:          `) + source_default.cyan(port));
    if (buildCommand) {
      console.log(source_default.gray(`  Build command: `) + source_default.cyan(buildCommand));
    }
    if (startCommand) {
      console.log(source_default.gray(`  Start command: `) + source_default.cyan(startCommand));
    }
    if (envVars && Object.keys(envVars).length > 0) {
      console.log(
        source_default.gray(`  Environment:   `) + source_default.cyan(`${Object.keys(envVars).length} variable(s)`)
      );
      console.log(
        source_default.gray(`                 `) + source_default.gray(Object.keys(envVars).join(", "))
      );
    }
    console.log();
    const api = await McpUseAPI.create();
    let githubVerified = false;
    try {
      console.log(source_default.gray(`[DEBUG] API URL: ${api.baseUrl}`));
      const connectionStatus = await api.getGitHubConnectionStatus();
      if (!connectionStatus.is_connected) {
        const repoFullName = `${gitInfo.owner}/${gitInfo.repo}`;
        const installed = await promptGitHubInstallation(
          api,
          "not_connected",
          repoFullName
        );
        if (!installed) {
          console.log(source_default.gray("Deployment cancelled."));
          process.exit(0);
        }
        const retryStatus = await api.getGitHubConnectionStatus();
        if (!retryStatus.is_connected) {
          console.log(
            source_default.red("\n\u2717 GitHub connection could not be verified.")
          );
          console.log(
            source_default.gray("Please try connecting GitHub from the web UI:")
          );
          console.log(source_default.cyan("  https://manufact.com/cloud/settings\n"));
          process.exit(1);
        }
        githubVerified = true;
      } else if (gitInfo.owner && gitInfo.repo) {
        console.log(source_default.gray("Checking repository access..."));
        const hasAccess = await checkRepoAccess(
          api,
          gitInfo.owner,
          gitInfo.repo
        );
        if (!hasAccess) {
          const repoFullName = `${gitInfo.owner}/${gitInfo.repo}`;
          console.log(
            source_default.yellow(
              `\u26A0\uFE0F  GitHub App doesn't have access to ${source_default.cyan(repoFullName)}`
            )
          );
          const configured = await promptGitHubInstallation(
            api,
            "no_access",
            repoFullName
          );
          if (!configured) {
            console.log(source_default.gray("Deployment cancelled."));
            process.exit(0);
          }
          const hasAccessRetry = await checkRepoAccess(
            api,
            gitInfo.owner,
            gitInfo.repo
          );
          if (!hasAccessRetry) {
            console.log(
              source_default.red(
                `
\u2717 Repository ${source_default.cyan(repoFullName)} is still not accessible.`
              )
            );
            console.log(
              source_default.gray(
                "Please make sure the GitHub App has access to this repository."
              )
            );
            console.log(
              source_default.cyan("  https://github.com/settings/installations\n")
            );
            process.exit(1);
          }
          githubVerified = true;
        } else {
          console.log(source_default.green("\u2713 Repository access confirmed"));
          githubVerified = true;
        }
      }
    } catch (error) {
      console.log(source_default.red("\u2717 Could not verify GitHub connection"));
      console.log(
        source_default.gray(
          "Error: " + (error instanceof Error ? error.message : "Unknown error")
        )
      );
      console.log(source_default.gray("\nPlease ensure:"));
      console.log(
        source_default.cyan(
          "  1. You have connected GitHub at https://manufact.com/cloud/settings"
        )
      );
      console.log(
        source_default.cyan("  2. The GitHub App has access to your repository")
      );
      console.log(source_default.cyan("  3. Your internet connection is stable\n"));
      process.exit(1);
    }
    if (!githubVerified) {
      console.log(
        source_default.red("\n\u2717 GitHub verification required for this deployment")
      );
      process.exit(1);
    }
    const existingLink = !options.new ? await getProjectLink(cwd) : null;
    const serverId = existingLink?.serverId;
    if (existingLink) {
      try {
        const existingDeployment = await api.getDeployment(
          existingLink.deploymentId
        );
        if (existingDeployment && existingDeployment.status !== "failed") {
          console.log(source_default.green(`\u2713 Found linked deployment`));
          console.log(source_default.gray(`  Redeploying to maintain the same URL...`));
          console.log(
            source_default.cyan(`  URL: ${getMcpServerUrl(existingDeployment)}
`)
          );
          const redeploymentConfig = {
            buildCommand,
            startCommand,
            ...options.port !== void 0 ? { port: options.port } : {},
            env: Object.keys(envVars).length > 0 ? envVars : void 0
          };
          const deployment2 = await api.redeployDeployment(
            existingLink.deploymentId,
            redeploymentConfig
          );
          await saveProjectLink(cwd, {
            ...existingLink,
            linkedAt: (/* @__PURE__ */ new Date()).toISOString()
          });
          await displayDeploymentProgress(api, deployment2);
          if (options.open && deployment2.domain) {
            console.log();
            console.log(source_default.gray("Opening deployment in browser..."));
            await open_default(`https://${deployment2.domain}`);
          }
          return;
        } else {
          console.log(
            source_default.yellow(
              `\u26A0\uFE0F  Linked deployment not found or failed, creating new one...`
            )
          );
          if (serverId) {
            console.log(
              source_default.gray(`  Will reuse existing server: ${serverId}`)
            );
          }
        }
      } catch (error) {
        console.log(
          source_default.yellow(`\u26A0\uFE0F  Linked deployment not found, creating new one...`)
        );
        if (serverId) {
          console.log(source_default.gray(`  Will reuse existing server: ${serverId}`));
        }
      }
    }
    const deploymentRequest = {
      name: projectName,
      source: {
        type: "github",
        repo: `${gitInfo.owner}/${gitInfo.repo}`,
        branch: gitInfo.branch || "main",
        runtime,
        port,
        buildCommand,
        startCommand,
        env: Object.keys(envVars).length > 0 ? envVars : void 0
      },
      healthCheckPath: "/healthz",
      serverId
    };
    console.log(source_default.gray("Creating deployment..."));
    const deployment = await api.createDeployment(deploymentRequest);
    console.log(
      source_default.green("\u2713 Deployment created: ") + source_default.gray(deployment.id)
    );
    await saveProjectLink(cwd, {
      deploymentId: deployment.id,
      deploymentName: projectName,
      deploymentUrl: deployment.domain,
      linkedAt: (/* @__PURE__ */ new Date()).toISOString(),
      serverId: deployment.serverId
    });
    console.log(
      source_default.gray(`  Linked to this project (stored in .mcp-use/project.json)`)
    );
    console.log(source_default.gray(`  Future deploys will reuse the same URL
`));
    await displayDeploymentProgress(api, deployment);
    if (options.open && deployment.domain) {
      console.log();
      console.log(source_default.gray("Opening deployment in browser..."));
      await open_default(`https://${deployment.domain}`);
    }
  } catch (error) {
    console.error(
      source_default.red.bold("\n\u2717 Deployment failed:"),
      source_default.red(error instanceof Error ? error.message : "Unknown error")
    );
    process.exit(1);
  }
}

// src/commands/deployments.ts
import { Command as Command2 } from "commander";
async function prompt2(question) {
  const readline = await import("readline");
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  return new Promise((resolve2) => {
    rl.question(question, (answer) => {
      rl.close();
      const trimmedAnswer = answer.trim().toLowerCase();
      resolve2(trimmedAnswer === "y" || trimmedAnswer === "yes");
    });
  });
}
function getStatusColor(status) {
  switch (status) {
    case "running":
      return source_default.green;
    case "building":
    case "pending":
      return source_default.yellow;
    case "failed":
    case "stopped":
      return source_default.red;
    default:
      return source_default.gray;
  }
}
function formatId(id) {
  return id;
}
async function listDeploymentsCommand() {
  try {
    if (!await isLoggedIn()) {
      console.log(source_default.red("\u2717 You are not logged in."));
      console.log(
        source_default.gray(
          "Run " + source_default.white("npx mcp-use login") + " to get started."
        )
      );
      process.exit(1);
    }
    const api = await McpUseAPI.create();
    const deployments = await api.listDeployments();
    const sortedDeployments = [...deployments].sort(
      (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    );
    if (sortedDeployments.length === 0) {
      console.log(source_default.yellow("No deployments found."));
      console.log(
        source_default.gray(
          "\nDeploy your first MCP server with " + source_default.white("mcp-use deploy")
        )
      );
      return;
    }
    console.log(
      source_default.cyan.bold(`
\u{1F4E6} Deployments (${sortedDeployments.length})
`)
    );
    console.log(
      source_default.white.bold(
        `${"ID".padEnd(40)} ${"NAME".padEnd(25)} ${"STATUS".padEnd(12)} ${"DOMAIN".padEnd(35)} ${"CREATED"}`
      )
    );
    console.log(source_default.gray("\u2500".repeat(130)));
    for (const deployment of sortedDeployments) {
      const id = formatId(deployment.id).padEnd(40);
      const name = deployment.name.substring(0, 24).padEnd(25);
      const statusColor = getStatusColor(deployment.status);
      const status = statusColor(deployment.status.padEnd(12));
      const domain = (deployment.domain || "-").substring(0, 34).padEnd(35);
      const created = formatRelativeTime(deployment.createdAt);
      console.log(
        `${source_default.gray(id)} ${name} ${status} ${source_default.cyan(domain)} ${source_default.gray(created)}`
      );
    }
    console.log();
  } catch (error) {
    console.error(
      source_default.red.bold("\n\u2717 Failed to list deployments:"),
      source_default.red(error instanceof Error ? error.message : "Unknown error")
    );
    process.exit(1);
  }
}
async function getDeploymentCommand(deploymentId) {
  try {
    if (!await isLoggedIn()) {
      console.log(source_default.red("\u2717 You are not logged in."));
      console.log(
        source_default.gray(
          "Run " + source_default.white("npx mcp-use login") + " to get started."
        )
      );
      process.exit(1);
    }
    const api = await McpUseAPI.create();
    const deployment = await api.getDeployment(deploymentId);
    console.log(source_default.cyan.bold("\n\u{1F4E6} Deployment Details\n"));
    console.log(source_default.white("ID:            ") + source_default.gray(deployment.id));
    console.log(source_default.white("Name:          ") + source_default.cyan(deployment.name));
    const statusColor = getStatusColor(deployment.status);
    console.log(
      source_default.white("Status:        ") + statusColor(deployment.status)
    );
    if (deployment.domain) {
      console.log(
        source_default.white("Domain:        ") + source_default.cyan(`https://${deployment.domain}`)
      );
    }
    if (deployment.customDomain) {
      console.log(
        source_default.white("Custom Domain: ") + source_default.cyan(`https://${deployment.customDomain}`)
      );
    }
    console.log(
      source_default.white("Source:        ") + source_default.gray(deployment.source.type)
    );
    if (deployment.source.type === "github") {
      console.log(
        source_default.white("Repository:    ") + source_default.gray(deployment.source.repo)
      );
      console.log(
        source_default.white("Branch:        ") + source_default.gray(deployment.source.branch || "main")
      );
    }
    console.log(source_default.white("Port:          ") + source_default.gray(deployment.port));
    console.log(
      source_default.white("Runtime:       ") + source_default.gray(deployment.source.runtime || "node")
    );
    if (deployment.provider) {
      console.log(
        source_default.white("Provider:      ") + source_default.gray(deployment.provider)
      );
    }
    console.log(
      source_default.white("Created:       ") + source_default.gray(formatRelativeTime(deployment.createdAt))
    );
    console.log(
      source_default.white("Updated:       ") + source_default.gray(formatRelativeTime(deployment.updatedAt))
    );
    if (deployment.source.env && Object.keys(deployment.source.env).length > 0) {
      console.log(source_default.white("\nEnvironment Variables:"));
      for (const [key, value] of Object.entries(deployment.source.env)) {
        const displayValue = key.toLowerCase().includes("key") || key.toLowerCase().includes("secret") || key.toLowerCase().includes("password") || key.toLowerCase().includes("token") ? "***" : value;
        console.log(source_default.gray(`  ${key}=`) + source_default.white(displayValue));
      }
    }
    if (deployment.status === "failed" && deployment.error) {
      console.log(source_default.red("\nError:"));
      console.log(source_default.red(`  ${deployment.error}`));
    }
    console.log();
  } catch (error) {
    console.error(
      source_default.red.bold("\n\u2717 Failed to get deployment:"),
      source_default.red(error instanceof Error ? error.message : "Unknown error")
    );
    process.exit(1);
  }
}
async function restartDeploymentCommand(deploymentId, options) {
  try {
    if (!await isLoggedIn()) {
      console.log(source_default.red("\u2717 You are not logged in."));
      console.log(
        source_default.gray(
          "Run " + source_default.white("npx mcp-use login") + " to get started."
        )
      );
      process.exit(1);
    }
    const api = await McpUseAPI.create();
    const deployment = await api.getDeployment(deploymentId);
    console.log(
      source_default.cyan.bold(`
\u{1F504} Restarting deployment: ${deployment.name}
`)
    );
    const redeployedDeployment = await api.redeployDeployment(deploymentId);
    console.log(
      source_default.green("\u2713 Restart initiated: ") + source_default.gray(redeployedDeployment.id)
    );
    if (options.follow) {
      console.log(source_default.gray("\nFollowing deployment logs...\n"));
      try {
        for await (const log of api.streamDeploymentLogs(
          redeployedDeployment.id
        )) {
          try {
            const logData = JSON.parse(log);
            if (logData.line) {
              const levelColor = logData.level === "error" ? source_default.red : logData.level === "warn" ? source_default.yellow : source_default.gray;
              const stepPrefix = logData.step ? source_default.cyan(`[${logData.step}]`) + " " : "";
              console.log(stepPrefix + levelColor(logData.line));
            }
          } catch {
            console.log(source_default.gray(log));
          }
        }
      } catch (error) {
        console.log(
          source_default.gray(
            "\nLog stream ended. Use " + source_default.white(`mcp-use deployments get ${deploymentId}`) + " to check status."
          )
        );
      }
    } else {
      console.log(
        source_default.gray(
          "\nCheck status with: " + source_default.white(`mcp-use deployments get ${deploymentId}`)
        )
      );
    }
    console.log();
  } catch (error) {
    console.error(
      source_default.red.bold("\n\u2717 Failed to restart deployment:"),
      source_default.red(error instanceof Error ? error.message : "Unknown error")
    );
    process.exit(1);
  }
}
async function deleteDeploymentCommand(deploymentId, options) {
  try {
    if (!await isLoggedIn()) {
      console.log(source_default.red("\u2717 You are not logged in."));
      console.log(
        source_default.gray(
          "Run " + source_default.white("npx mcp-use login") + " to get started."
        )
      );
      process.exit(1);
    }
    const api = await McpUseAPI.create();
    const deployment = await api.getDeployment(deploymentId);
    if (!options.yes) {
      console.log(
        source_default.yellow(
          `
\u26A0\uFE0F  You are about to delete deployment: ${source_default.white(deployment.name)}`
        )
      );
      console.log(source_default.gray(`   ID: ${deployment.id}`));
      console.log(source_default.gray(`   Domain: ${deployment.domain || "none"}
`));
      const confirmed = await prompt2(
        source_default.white("Are you sure you want to delete this deployment? (y/N): ")
      );
      if (!confirmed) {
        console.log(source_default.gray("Deletion cancelled."));
        return;
      }
    }
    await api.deleteDeployment(deploymentId);
    console.log(
      source_default.green.bold(`
\u2713 Deployment deleted: ${deployment.name}
`)
    );
  } catch (error) {
    console.error(
      source_default.red.bold("\n\u2717 Failed to delete deployment:"),
      source_default.red(error instanceof Error ? error.message : "Unknown error")
    );
    process.exit(1);
  }
}
async function logsCommand(deploymentId, options) {
  try {
    if (!await isLoggedIn()) {
      console.log(source_default.red("\u2717 You are not logged in."));
      console.log(
        source_default.gray(
          "Run " + source_default.white("npx mcp-use login") + " to get started."
        )
      );
      process.exit(1);
    }
    const api = await McpUseAPI.create();
    if (options.follow) {
      console.log(source_default.gray("Streaming logs...\n"));
      try {
        for await (const log of api.streamDeploymentLogs(deploymentId)) {
          try {
            const logData = JSON.parse(log);
            if (logData.line) {
              const levelColor = logData.level === "error" ? source_default.red : logData.level === "warn" ? source_default.yellow : source_default.gray;
              const stepPrefix = logData.step ? source_default.cyan(`[${logData.step}]`) + " " : "";
              console.log(stepPrefix + levelColor(logData.line));
            }
          } catch {
            console.log(source_default.gray(log));
          }
        }
      } catch (error) {
        console.log(source_default.gray("\nLog stream ended."));
      }
    } else {
      const logs = options.build ? await api.getDeploymentBuildLogs(deploymentId) : await api.getDeploymentLogs(deploymentId);
      if (!logs || logs.trim() === "") {
        console.log(
          source_default.yellow(
            `No ${options.build ? "build " : ""}logs available for this deployment.`
          )
        );
        return;
      }
      const logLines = logs.split("\n").filter((l) => l.trim());
      for (const line of logLines) {
        try {
          const logData = JSON.parse(line);
          if (logData.line) {
            const levelColor = logData.level === "error" ? source_default.red : logData.level === "warn" ? source_default.yellow : source_default.gray;
            const stepPrefix = logData.step ? source_default.cyan(`[${logData.step}]`) + " " : "";
            console.log(stepPrefix + levelColor(logData.line));
          }
        } catch {
          console.log(source_default.gray(line));
        }
      }
    }
    console.log();
  } catch (error) {
    console.error(
      source_default.red.bold("\n\u2717 Failed to get logs:"),
      source_default.red(error instanceof Error ? error.message : "Unknown error")
    );
    process.exit(1);
  }
}
async function listEnvCommand(deploymentId) {
  try {
    if (!await isLoggedIn()) {
      console.log(source_default.red("\u2717 You are not logged in."));
      console.log(
        source_default.gray(
          "Run " + source_default.white("npx mcp-use login") + " to get started."
        )
      );
      process.exit(1);
    }
    const api = await McpUseAPI.create();
    const deployment = await api.getDeployment(deploymentId);
    console.log(
      source_default.cyan.bold(`
\u{1F510} Environment Variables: ${deployment.name}
`)
    );
    if (!deployment.source.env || Object.keys(deployment.source.env).length === 0) {
      console.log(source_default.yellow("No environment variables set."));
      console.log();
      return;
    }
    for (const [key, value] of Object.entries(deployment.source.env)) {
      const displayValue = key.toLowerCase().includes("key") || key.toLowerCase().includes("secret") || key.toLowerCase().includes("password") || key.toLowerCase().includes("token") ? "***" : value;
      console.log(
        source_default.white(key) + source_default.gray("=") + source_default.cyan(displayValue)
      );
    }
    console.log();
  } catch (error) {
    console.error(
      source_default.red.bold("\n\u2717 Failed to list environment variables:"),
      source_default.red(error instanceof Error ? error.message : "Unknown error")
    );
    process.exit(1);
  }
}
async function setEnvCommand(deploymentId, envPairs) {
  try {
    if (!await isLoggedIn()) {
      console.log(source_default.red("\u2717 You are not logged in."));
      console.log(
        source_default.gray(
          "Run " + source_default.white("npx mcp-use login") + " to get started."
        )
      );
      process.exit(1);
    }
    const env2 = {};
    for (const pair of envPairs) {
      const [key, ...valueParts] = pair.split("=");
      if (!key || valueParts.length === 0) {
        console.log(source_default.red(`\u2717 Invalid format: ${pair}. Expected KEY=VALUE`));
        process.exit(1);
      }
      env2[key.trim()] = valueParts.join("=").trim();
    }
    const api = await McpUseAPI.create();
    const deployment = await api.getDeployment(deploymentId);
    const currentEnv = deployment.source.env || {};
    const mergedEnv = { ...currentEnv, ...env2 };
    const updated = await api.updateDeployment(deploymentId, {
      env: mergedEnv
    });
    console.log(
      source_default.green.bold(`
\u2713 Environment variables updated: ${updated.name}
`)
    );
    for (const key of Object.keys(env2)) {
      const displayValue = key.toLowerCase().includes("key") || key.toLowerCase().includes("secret") || key.toLowerCase().includes("password") || key.toLowerCase().includes("token") ? "***" : env2[key];
      console.log(
        source_default.white(key) + source_default.gray("=") + source_default.cyan(displayValue)
      );
    }
    console.log();
  } catch (error) {
    console.error(
      source_default.red.bold("\n\u2717 Failed to set environment variables:"),
      source_default.red(error instanceof Error ? error.message : "Unknown error")
    );
    process.exit(1);
  }
}
async function unsetEnvCommand(deploymentId, keys) {
  try {
    if (!await isLoggedIn()) {
      console.log(source_default.red("\u2717 You are not logged in."));
      console.log(
        source_default.gray(
          "Run " + source_default.white("npx mcp-use login") + " to get started."
        )
      );
      process.exit(1);
    }
    const api = await McpUseAPI.create();
    const deployment = await api.getDeployment(deploymentId);
    const currentEnv = { ...deployment.source.env || {} };
    for (const key of keys) {
      delete currentEnv[key];
    }
    const updated = await api.updateDeployment(deploymentId, {
      env: currentEnv
    });
    console.log(
      source_default.green.bold(`
\u2713 Environment variables removed: ${updated.name}
`)
    );
    for (const key of keys) {
      console.log(source_default.gray(`  ${key}`));
    }
    console.log();
  } catch (error) {
    console.error(
      source_default.red.bold("\n\u2717 Failed to unset environment variables:"),
      source_default.red(error instanceof Error ? error.message : "Unknown error")
    );
    process.exit(1);
  }
}
async function stopDeploymentCommand(deploymentId) {
  try {
    if (!await isLoggedIn()) {
      console.log(source_default.red("\u2717 You are not logged in."));
      console.log(
        source_default.gray(
          "Run " + source_default.white("npx mcp-use login") + " to get started."
        )
      );
      process.exit(1);
    }
    const api = await McpUseAPI.create();
    const updated = await api.updateDeployment(deploymentId, {
      status: "stopped"
    });
    console.log(source_default.green.bold(`
\u2713 Deployment stopped: ${updated.name}
`));
  } catch (error) {
    console.error(
      source_default.red.bold("\n\u2717 Failed to stop deployment:"),
      source_default.red(error instanceof Error ? error.message : "Unknown error")
    );
    process.exit(1);
  }
}
async function startDeploymentCommand(deploymentId) {
  try {
    if (!await isLoggedIn()) {
      console.log(source_default.red("\u2717 You are not logged in."));
      console.log(
        source_default.gray(
          "Run " + source_default.white("npx mcp-use login") + " to get started."
        )
      );
      process.exit(1);
    }
    const api = await McpUseAPI.create();
    const updated = await api.updateDeployment(deploymentId, {
      status: "running"
    });
    console.log(source_default.green.bold(`
\u2713 Deployment started: ${updated.name}
`));
  } catch (error) {
    console.error(
      source_default.red.bold("\n\u2717 Failed to start deployment:"),
      source_default.red(error instanceof Error ? error.message : "Unknown error")
    );
    process.exit(1);
  }
}
function createDeploymentsCommand() {
  const deploymentsCommand = new Command2("deployments").description(
    "Manage cloud deployments"
  );
  deploymentsCommand.command("list").alias("ls").description("List all deployments").action(listDeploymentsCommand);
  deploymentsCommand.command("get").argument("<deployment-id>", "Deployment ID").description("Get deployment details").action(getDeploymentCommand);
  deploymentsCommand.command("restart").argument("<deployment-id>", "Deployment ID").option("-f, --follow", "Follow deployment logs").description("Restart a deployment").action(restartDeploymentCommand);
  deploymentsCommand.command("delete").alias("rm").argument("<deployment-id>", "Deployment ID").option("-y, --yes", "Skip confirmation prompt").description("Delete a deployment").action(deleteDeploymentCommand);
  deploymentsCommand.command("logs").argument("<deployment-id>", "Deployment ID").option("-b, --build", "Show build logs instead of runtime logs").option("-f, --follow", "Stream logs in real-time").description("View deployment logs").action(logsCommand);
  const envCommand = deploymentsCommand.command("env").description("Manage environment variables");
  envCommand.command("list").argument("<deployment-id>", "Deployment ID").description("List environment variables").action(listEnvCommand);
  envCommand.command("set").argument("<deployment-id>", "Deployment ID").argument("<pairs...>", "Environment variables in KEY=VALUE format").description("Set environment variables").action(setEnvCommand);
  envCommand.command("unset").argument("<deployment-id>", "Deployment ID").argument("<keys...>", "Environment variable keys to remove").description("Unset environment variables").action(unsetEnvCommand);
  deploymentsCommand.command("stop").argument("<deployment-id>", "Deployment ID").description("Stop a deployment").action(stopDeploymentCommand);
  deploymentsCommand.command("start").argument("<deployment-id>", "Deployment ID").description("Start a stopped deployment").action(startDeploymentCommand);
  return deploymentsCommand;
}

// src/commands/skills.ts
import { Command as Command3 } from "commander";
import { cpSync, existsSync as existsSync2, mkdtempSync, readdirSync, rmSync } from "fs";
import { tmpdir } from "os";
import { join as join2, resolve } from "path";
import { Readable } from "stream";
import { pipeline } from "stream/promises";
import { extract } from "tar";
var REPO_OWNER = "mcp-use";
var REPO_NAME = "mcp-use";
var REPO_BRANCH = "main";
var TELEMETRY_URL = "https://add-skill.vercel.sh/t";
var SOURCE_REPO = `${REPO_OWNER}/${REPO_NAME}`;
var AGENT_PRESET_FOLDERS = {
  cursor: ".cursor",
  "claude-code": ".claude",
  codex: ".agent"
};
var ALL_PRESETS = ["cursor", "claude-code", "codex"];
function sendInstallTelemetryEvent(agents, skills) {
  const telemetryData = {
    event: "install",
    source: SOURCE_REPO,
    skills,
    agents,
    sourceType: "github"
  };
  try {
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(telemetryData)) {
      if (value !== void 0 && value !== null) {
        params.set(key, String(value));
      }
    }
    fetch(`${TELEMETRY_URL}?${params.toString()}`).catch(() => {
    });
  } catch {
  }
}
async function addSkillsToProject(projectPath) {
  const tarballUrl = `https://codeload.github.com/${REPO_OWNER}/${REPO_NAME}/tar.gz/${REPO_BRANCH}`;
  const tempDir = mkdtempSync(join2(tmpdir(), "mcp-use-skills-"));
  try {
    const response = await fetch(tarballUrl);
    if (!response.ok) {
      throw new Error(`Failed to download tarball: ${response.statusText}`);
    }
    await pipeline(
      Readable.fromWeb(response.body),
      extract({
        cwd: tempDir,
        filter: (path8) => path8.includes("/skills/"),
        strip: 1
      })
    );
    const skillsPath = join2(tempDir, "skills");
    if (!existsSync2(skillsPath)) {
      throw new Error("Skills folder not found in repository");
    }
    for (const preset of ALL_PRESETS) {
      const folderName = AGENT_PRESET_FOLDERS[preset];
      const outputPath = join2(projectPath, folderName, "skills");
      cpSync(skillsPath, outputPath, { recursive: true });
    }
    const skillNames = readdirSync(skillsPath, { withFileTypes: true }).filter((dirent) => dirent.isDirectory()).map((dirent) => dirent.name);
    sendInstallTelemetryEvent(ALL_PRESETS.join(","), skillNames.join(","));
  } finally {
    rmSync(tempDir, { recursive: true, force: true });
  }
}
function createSkillsCommand() {
  const skills = new Command3("skills").description(
    "Manage mcp-use AI agent skills"
  );
  const installAction = async (options) => {
    const projectPath = resolve(options.path);
    if (!existsSync2(projectPath)) {
      console.error(source_default.red(`Directory not found: ${projectPath}`));
      process.exit(1);
    }
    console.log(source_default.cyan("\u{1F4DA} Installing mcp-use skills..."));
    console.log(
      source_default.gray(
        "   Downloading from github.com/mcp-use/mcp-use \u2192 .cursor/skills, .claude/skills, .agent/skills"
      )
    );
    try {
      await addSkillsToProject(projectPath);
      console.log(source_default.green("\u2705 Skills installed successfully!"));
    } catch (error) {
      console.error(source_default.red("\u274C Failed to install skills."));
      console.error(
        source_default.yellow(
          `   Error: ${error instanceof Error ? error.message : String(error)}`
        )
      );
      console.error(
        source_default.yellow(
          "   You can also install manually: npx skills add mcp-use/mcp-use"
        )
      );
      process.exit(1);
    }
  };
  const pathOption = [
    "-p, --path <path>",
    "Path to project directory",
    process.cwd()
  ];
  skills.command("add").description(
    "Install mcp-use skills for AI agents (Cursor, Claude Code, Codex)"
  ).option(...pathOption).action(installAction);
  skills.command("install").description("Install mcp-use skills for AI agents (alias for 'add')").option(...pathOption).action(installAction);
  return skills;
}

// src/utils/update-check.ts
import { readFileSync } from "fs";
import { mkdir as mkdir2, readFile as readFile2, writeFile as writeFile2 } from "fs/promises";
import { createRequire } from "module";
import os4 from "os";
import path6 from "path";
var CACHE_DIR = path6.join(os4.homedir(), ".mcp-use");
var CACHE_FILE = path6.join(CACHE_DIR, "update-check.json");
var CACHE_TTL_MS = 24 * 60 * 60 * 1e3;
var FETCH_TIMEOUT_MS = 3e3;
var PACKAGE_NAME = "mcp-use";
function parseSemver(version) {
  const match = version.match(/^(\d+)\.(\d+)\.(\d+)/);
  if (!match) return null;
  return [
    parseInt(match[1], 10),
    parseInt(match[2], 10),
    parseInt(match[3], 10)
  ];
}
function isNewer(current, candidate) {
  const a = parseSemver(current);
  const b = parseSemver(candidate);
  if (!a || !b) return false;
  for (let i = 0; i < 3; i++) {
    if (b[i] > a[i]) return true;
    if (b[i] < a[i]) return false;
  }
  return false;
}
async function readCache() {
  try {
    const content = await readFile2(CACHE_FILE, "utf-8");
    return JSON.parse(content);
  } catch {
    return null;
  }
}
async function writeCache(latestVersion) {
  try {
    await mkdir2(CACHE_DIR, { recursive: true });
    const cache = {
      lastChecked: (/* @__PURE__ */ new Date()).toISOString(),
      latestVersion
    };
    await writeFile2(CACHE_FILE, JSON.stringify(cache, null, 2), "utf-8");
  } catch {
  }
}
async function fetchLatestVersion() {
  try {
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);
    try {
      const res = await fetch(
        `https://registry.npmjs.org/${PACKAGE_NAME}/latest`,
        {
          signal: controller.signal,
          headers: { Accept: "application/json" }
        }
      );
      if (!res.ok) return null;
      const data = await res.json();
      return data.version ?? null;
    } finally {
      clearTimeout(timer);
    }
  } catch {
    return null;
  }
}
async function getLatestVersion() {
  const cache = await readCache();
  if (cache) {
    const age = Date.now() - new Date(cache.lastChecked).getTime();
    if (age < CACHE_TTL_MS) {
      return cache.latestVersion;
    }
  }
  const latest = await fetchLatestVersion();
  if (latest) {
    await writeCache(latest);
  }
  return latest;
}
function resolveInstalledVersion(projectPath) {
  const attempts = [];
  if (projectPath) {
    attempts.push(() => {
      const projectRequire = createRequire(
        path6.join(projectPath, "package.json")
      );
      return projectRequire.resolve(`${PACKAGE_NAME}/package.json`);
    });
  }
  attempts.push(() => path6.join(__dirname, "../../mcp-use/package.json"));
  for (const attempt of attempts) {
    try {
      const pkgPath = attempt();
      const json = JSON.parse(readFileSync(pkgPath, "utf-8"));
      if (typeof json.version === "string") return json.version;
    } catch {
    }
  }
  return null;
}
async function notifyIfUpdateAvailable(projectPath) {
  try {
    const installed = resolveInstalledVersion(projectPath);
    if (!installed) return;
    const latest = await getLatestVersion();
    if (!latest) return;
    if (isNewer(installed, latest)) {
      console.log(
        source_default.yellow(
          `
A new release of ${source_default.bold(PACKAGE_NAME)} is available: ${source_default.dim(installed)} \u2192 ${source_default.cyan.bold(latest)}`
        )
      );
      console.log(
        source_default.gray(
          `Run ${source_default.white(`npm install ${PACKAGE_NAME}@latest`)} to update
`
        )
      );
    }
  } catch {
  }
}

// src/index.ts
var program = new Command4();
var packageContent = readFileSync2(
  path7.join(__dirname, "../package.json"),
  "utf-8"
);
var packageJson = JSON.parse(packageContent);
var packageVersion = packageJson.version || "unknown";
program.name("mcp-use").description("Create and run MCP servers with ui resources widgets").version(packageVersion);
function displayPackageVersions(projectPath) {
  const packages = [
    { name: "@mcp-use/cli", relativePath: "../package.json" },
    {
      name: "@mcp-use/inspector",
      relativePath: "../../inspector/package.json"
    },
    {
      name: "create-mcp-use-app",
      relativePath: "../../create-mcp-use-app/package.json"
    },
    {
      name: "mcp-use",
      relativePath: "../../mcp-use/package.json",
      highlight: true
    }
  ];
  console.log(source_default.gray("mcp-use packages:"));
  for (const pkg of packages) {
    const paddedName = pkg.name.padEnd(22);
    try {
      let pkgPath;
      if (projectPath) {
        try {
          const projectRequire = createRequire2(
            path7.join(projectPath, "package.json")
          );
          pkgPath = projectRequire.resolve(`${pkg.name}/package.json`);
        } catch (resolveError) {
          pkgPath = path7.join(__dirname, pkg.relativePath);
        }
      } else {
        pkgPath = path7.join(__dirname, pkg.relativePath);
      }
      const pkgContent = readFileSync2(pkgPath, "utf-8");
      const pkgJson = JSON.parse(pkgContent);
      const version = pkgJson.version || "unknown";
      if (pkg.highlight) {
        console.log(
          `  ${source_default.cyan.bold(paddedName)} ${source_default.cyan.bold(`v${version}`)}`
        );
      } else {
        console.log(source_default.gray(`  ${paddedName} v${version}`));
      }
    } catch (error) {
      if (process.env.DEBUG || process.env.VERBOSE) {
        console.log(source_default.dim(`  ${paddedName} (not found)`));
      }
    }
  }
}
async function isPortAvailable(port, host = "localhost") {
  try {
    await fetch(`http://${host}:${port}`);
    return false;
  } catch {
    return true;
  }
}
async function findAvailablePort2(startPort, host = "localhost") {
  for (let port = startPort; port < startPort + 100; port++) {
    if (await isPortAvailable(port, host)) {
      return port;
    }
  }
  throw new Error("No available ports found");
}
async function waitForServer(port, host = "localhost", maxAttempts = 30) {
  for (let i = 0; i < maxAttempts; i++) {
    const controller = new AbortController();
    try {
      const response = await fetch(`http://${host}:${port}/inspector/health`, {
        signal: controller.signal
      });
      if (response.ok) {
        return true;
      }
    } catch {
    } finally {
      controller.abort();
    }
    await new Promise((resolve2) => setTimeout(resolve2, 1e3));
  }
  return false;
}
function normalizeBrowserHost(host) {
  return host === "0.0.0.0" ? "localhost" : host;
}
function runCommand(command, args, cwd, env2, filterStderr = false) {
  const proc = spawn(command, args, {
    cwd,
    stdio: filterStderr ? ["inherit", "inherit", "pipe"] : "inherit",
    shell: process.platform === "win32",
    env: env2 ? { ...process.env, ...env2 } : process.env
  });
  if (filterStderr && proc.stderr) {
    proc.stderr.on("data", (data) => {
      const text = data.toString();
      if (!text.includes("Previous process hasn't exited yet") && !text.includes("Force killing")) {
        process.stderr.write(data);
      }
    });
  }
  const promise = new Promise((resolve2, reject) => {
    proc.on("error", reject);
    proc.on("exit", (code) => {
      if (code === 0 || code === 130 || code === 143) {
        resolve2();
      } else {
        reject(new Error(`Command failed with exit code ${code}`));
      }
    });
  });
  return { promise, process: proc };
}
async function startTunnel(port, subdomain) {
  return new Promise((resolve2, reject) => {
    console.log(source_default.gray(`Starting tunnel for port ${port}...`));
    const tunnelArgs = ["--yes", "@mcp-use/tunnel", String(port)];
    if (subdomain) {
      tunnelArgs.push("--subdomain", subdomain);
    }
    const proc = spawn("npx", tunnelArgs, {
      stdio: ["ignore", "pipe", "pipe"],
      shell: process.platform === "win32"
    });
    let resolved = false;
    let isShuttingDown = false;
    proc.stdout?.on("data", (data) => {
      const text = data.toString();
      const isShutdownMessage = text.includes("Shutting down") || text.includes("\u{1F6D1}");
      if (!isShuttingDown && !isShutdownMessage) {
        process.stdout.write(text);
      }
      const urlMatch = text.match(/https?:\/\/([a-z0-9-]+\.[a-z0-9.-]+)/i);
      if (urlMatch && !resolved) {
        const url = urlMatch[0];
        const fullDomain = urlMatch[1];
        const subdomainMatch = fullDomain.match(/^([a-z0-9-]+)\./i);
        let extractedSubdomain = subdomainMatch ? subdomainMatch[1] : fullDomain.split(".")[0];
        if (!/^[a-z0-9-]+$/i.test(extractedSubdomain)) {
          console.warn(
            source_default.yellow(
              `Warning: Extracted subdomain "${extractedSubdomain}" does not match expected format.`
            )
          );
          extractedSubdomain = "";
        }
        resolved = true;
        clearTimeout(setupTimeout);
        console.log(source_default.green.bold(`\u2713 Tunnel established: ${url}/mcp`));
        resolve2({ url, subdomain: extractedSubdomain, process: proc });
      }
    });
    proc.stderr?.on("data", (data) => {
      const text = data.toString();
      if (!isShuttingDown && !text.includes("INFO") && !text.includes("bore_cli") && !text.includes("Shutting down")) {
        process.stderr.write(data);
      }
    });
    proc.on("error", (error) => {
      if (!resolved) {
        clearTimeout(setupTimeout);
        reject(new Error(`Failed to start tunnel: ${error.message}`));
      }
    });
    proc.on("exit", (code) => {
      if (code !== 0 && !resolved) {
        clearTimeout(setupTimeout);
        reject(new Error(`Tunnel process exited with code ${code}`));
      }
    });
    proc.markShutdown = () => {
      isShuttingDown = true;
    };
    const setupTimeout = setTimeout(() => {
      if (!resolved) {
        proc.kill();
        reject(new Error("Tunnel setup timed out"));
      }
    }, 3e4);
  });
}
async function findServerFile(projectPath) {
  const candidates = ["index.ts", "src/index.ts", "server.ts", "src/server.ts"];
  for (const candidate of candidates) {
    try {
      await access(path7.join(projectPath, candidate));
      return candidate;
    } catch {
      continue;
    }
  }
  throw new Error("No server file found");
}
async function buildWidgets(projectPath, options = {}) {
  const { inline = true } = options;
  const { promises: fs10 } = await import("fs");
  const { build } = await import("vite");
  const resourcesDir = path7.join(projectPath, "resources");
  const mcpUrl = process.env.MCP_URL;
  try {
    await access(resourcesDir);
  } catch {
    console.log(
      source_default.gray("No resources/ directory found - skipping widget build")
    );
    return [];
  }
  const entries = [];
  try {
    const files = await fs10.readdir(resourcesDir, { withFileTypes: true });
    for (const dirent of files) {
      if (dirent.name.startsWith("._") || dirent.name.startsWith(".DS_Store")) {
        continue;
      }
      if (dirent.isFile() && (dirent.name.endsWith(".tsx") || dirent.name.endsWith(".ts"))) {
        entries.push({
          name: dirent.name.replace(/\.tsx?$/, ""),
          path: path7.join(resourcesDir, dirent.name)
        });
      } else if (dirent.isDirectory()) {
        const widgetPath = path7.join(resourcesDir, dirent.name, "widget.tsx");
        try {
          await fs10.access(widgetPath);
          entries.push({
            name: dirent.name,
            path: widgetPath
          });
        } catch {
        }
      }
    }
  } catch (error) {
    console.log(source_default.gray("No widgets found in resources/ directory"));
    return [];
  }
  if (entries.length === 0) {
    console.log(source_default.gray("No widgets found in resources/ directory"));
    return [];
  }
  console.log(
    source_default.gray(
      `Building ${entries.length} widget(s)${inline ? " (inline mode for VS Code compatibility)" : ""}...`
    )
  );
  const react = (await import("@vitejs/plugin-react")).default;
  const tailwindcss = (await import("@tailwindcss/vite")).default;
  const packageJsonPath = path7.join(projectPath, "package.json");
  let favicon = "";
  try {
    const pkgContent = await fs10.readFile(packageJsonPath, "utf-8");
    const pkg = JSON.parse(pkgContent);
    favicon = pkg.mcpUse?.favicon || "";
  } catch {
  }
  const buildSingleWidget = async (entry) => {
    const widgetName = entry.name;
    const entryPath = entry.path.replace(/\\/g, "/");
    console.log(source_default.gray(`  - Building ${widgetName}...`));
    const tempDir = path7.join(projectPath, ".mcp-use", widgetName);
    await fs10.mkdir(tempDir, { recursive: true });
    const relativeResourcesPath = path7.relative(tempDir, resourcesDir).replace(/\\/g, "/");
    const mcpUsePath = path7.join(projectPath, "node_modules", "mcp-use");
    const relativeMcpUsePath = path7.relative(tempDir, mcpUsePath).replace(/\\/g, "/");
    const cssContent = `@import "tailwindcss";

/* Configure Tailwind to scan the resources directory and mcp-use package */
@source "${relativeResourcesPath}";
@source "${relativeMcpUsePath}/**/*.{ts,tsx,js,jsx}";
`;
    await fs10.writeFile(path7.join(tempDir, "styles.css"), cssContent, "utf8");
    const entryContent = `import React from 'react'
import { createRoot } from 'react-dom/client'
import './styles.css'
import Component from '${entryPath}'

const container = document.getElementById('widget-root')
if (container && Component) {
  const root = createRoot(container)
  root.render(<Component />)
}
`;
    const htmlContent = `<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>${widgetName} Widget</title>${favicon ? `
    <link rel="icon" href="/mcp-use/public/${favicon}" />` : ""}
  </head>
  <body>
    <div id="widget-root"></div>
    <script type="module" src="/entry.tsx"></script>
  </body>
</html>`;
    await fs10.writeFile(path7.join(tempDir, "entry.tsx"), entryContent, "utf8");
    await fs10.writeFile(path7.join(tempDir, "index.html"), htmlContent, "utf8");
    const outDir = path7.join(
      projectPath,
      "dist",
      "resources",
      "widgets",
      widgetName
    );
    const baseUrl = mcpUrl ? `${mcpUrl}/${widgetName}/` : `/mcp-use/widgets/${widgetName}/`;
    let widgetMetadata = {};
    try {
      const metadataTempDir = path7.join(
        projectPath,
        ".mcp-use",
        `${widgetName}-metadata`
      );
      await fs10.mkdir(metadataTempDir, { recursive: true });
      const { createServer: createServer2 } = await import("vite");
      const nodeStubsPlugin = {
        name: "node-stubs",
        enforce: "pre",
        resolveId(id) {
          if (id === "posthog-node" || id.startsWith("posthog-node/")) {
            return "\0virtual:posthog-node-stub";
          }
          return null;
        },
        load(id) {
          if (id === "\0virtual:posthog-node-stub") {
            return `
export class PostHog {
  constructor() {}
  capture() {}
  identify() {}
  alias() {}
  flush() { return Promise.resolve(); }
  shutdown() { return Promise.resolve(); }
}
export default PostHog;
`;
          }
          return null;
        }
      };
      const metadataServer = await createServer2({
        root: metadataTempDir,
        cacheDir: path7.join(metadataTempDir, ".vite-cache"),
        plugins: [nodeStubsPlugin, tailwindcss(), react()],
        resolve: {
          alias: {
            "@": resourcesDir
          }
        },
        server: {
          middlewareMode: true
        },
        optimizeDeps: {
          // Exclude Node.js-only packages from browser bundling
          exclude: ["posthog-node"]
        },
        ssr: {
          // Force Vite to transform these packages in SSR instead of using external requires
          noExternal: ["@openai/apps-sdk-ui", "react-router"],
          // Mark Node.js-only packages as external in SSR mode
          external: ["posthog-node"]
        },
        define: {
          // Define process.env for SSR context
          "process.env.NODE_ENV": JSON.stringify(
            process.env.NODE_ENV || "development"
          ),
          "import.meta.env.DEV": true,
          "import.meta.env.PROD": false,
          "import.meta.env.MODE": JSON.stringify("development"),
          "import.meta.env.SSR": true
        },
        clearScreen: false,
        logLevel: "silent",
        customLogger: {
          info: () => {
          },
          warn: () => {
          },
          error: () => {
          },
          clearScreen: () => {
          },
          hasErrorLogged: () => false,
          hasWarned: false,
          warnOnce: () => {
          }
        }
      });
      try {
        const mod = await metadataServer.ssrLoadModule(entryPath);
        if (mod.widgetMetadata) {
          const schemaField = mod.widgetMetadata.props || mod.widgetMetadata.inputs;
          let inputsValue = schemaField || {};
          if (schemaField && typeof schemaField === "object" && "~standard" in schemaField) {
            try {
              inputsValue = toJSONSchema(schemaField);
            } catch (conversionError) {
              console.warn(
                source_default.yellow(
                  `    \u26A0 Could not convert schema for ${widgetName}, using raw schema`
                )
              );
            }
          }
          const {
            props: _rawProps,
            inputs: _rawInputs,
            ...restMetadata
          } = mod.widgetMetadata;
          widgetMetadata = {
            ...restMetadata,
            title: mod.widgetMetadata.title || widgetName,
            description: mod.widgetMetadata.description,
            // Store the converted JSON Schema (props field is used by production mount)
            props: inputsValue,
            inputs: inputsValue
          };
        }
        await new Promise((resolve2) => setTimeout(resolve2, 50));
      } catch (error) {
        console.warn(
          source_default.yellow(`    \u26A0 Could not extract metadata for ${widgetName}`)
        );
      } finally {
        await metadataServer.close();
        try {
          await fs10.rm(metadataTempDir, { recursive: true, force: true });
        } catch {
        }
      }
    } catch (error) {
    }
    try {
      const buildNodeStubsPlugin = {
        name: "node-stubs-build",
        enforce: "pre",
        resolveId(id) {
          if (id === "posthog-node" || id.startsWith("posthog-node/")) {
            return "\0virtual:posthog-node-stub";
          }
          if (id === "path" || id === "node:path") {
            return "\0virtual:path-stub";
          }
          return null;
        },
        load(id) {
          if (id === "\0virtual:posthog-node-stub") {
            return `
export class PostHog {
  constructor() {}
  capture() {}
  identify() {}
  alias() {}
  flush() { return Promise.resolve(); }
  shutdown() { return Promise.resolve(); }
}
export default PostHog;
`;
          }
          if (id === "\0virtual:path-stub") {
            return `
export function join(...paths) {
  return paths.filter(Boolean).join("/").replace(/\\/\\//g, "/").replace(/\\/$/, "");
}
export function resolve(...paths) {
  return join(...paths);
}
export function dirname(filepath) {
  const parts = filepath.split("/");
  parts.pop();
  return parts.join("/") || "/";
}
export function basename(filepath, ext) {
  const parts = filepath.split("/");
  let name = parts[parts.length - 1] || "";
  if (ext && name.endsWith(ext)) {
    name = name.slice(0, -ext.length);
  }
  return name;
}
export function extname(filepath) {
  const name = basename(filepath);
  const index = name.lastIndexOf(".");
  return index > 0 ? name.slice(index) : "";
}
export function normalize(filepath) {
  return filepath.replace(/\\/\\//g, "/");
}
export function isAbsolute(filepath) {
  return filepath.startsWith("/");
}
export const sep = "/";
export const delimiter = ":";
export const posix = {
  join,
  resolve,
  dirname,
  basename,
  extname,
  normalize,
  isAbsolute,
  sep,
  delimiter,
};
export default {
  join,
  resolve,
  dirname,
  basename,
  extname,
  normalize,
  isAbsolute,
  sep,
  delimiter,
  posix,
};
`;
          }
          return null;
        }
      };
      const buildPlugins = inline ? [
        buildNodeStubsPlugin,
        tailwindcss(),
        react(),
        viteSingleFile({ removeViteModuleLoader: true })
      ] : [buildNodeStubsPlugin, tailwindcss(), react()];
      await build({
        root: tempDir,
        base: baseUrl,
        plugins: buildPlugins,
        // Only use renderBuiltUrl for non-inline builds (external assets need runtime URL resolution)
        ...inline ? {} : {
          experimental: {
            renderBuiltUrl: (filename, { hostType }) => {
              if (["js", "css"].includes(hostType)) {
                return {
                  runtime: `window.__getFile(${JSON.stringify(filename)})`
                };
              } else {
                return { relative: true };
              }
            }
          }
        },
        resolve: {
          alias: {
            "@": resourcesDir
          }
        },
        optimizeDeps: {
          // Exclude Node.js-only packages from browser bundling
          exclude: ["posthog-node"]
        },
        build: {
          outDir,
          emptyOutDir: true,
          // Disable source maps to avoid CSP eval violations
          // Source maps can use eval-based mappings which break strict CSP policies
          sourcemap: false,
          // Minify for smaller bundle size
          minify: "esbuild",
          // Widgets bundle React+Zod; suppress expected chunk size warning
          chunkSizeWarningLimit: 1024,
          // For inline builds, disable CSS code splitting and inline all assets
          ...inline ? {
            cssCodeSplit: false,
            assetsInlineLimit: 1e8
            // Inline all assets under 100MB (effectively all)
          } : {},
          rollupOptions: {
            input: path7.join(tempDir, "index.html"),
            external: (id) => {
              return false;
            }
          }
        }
      });
      try {
        const assetsDir = path7.join(outDir, "assets");
        const assetFiles = await fs10.readdir(assetsDir);
        const jsFiles = assetFiles.filter((f) => f.endsWith(".js"));
        for (const jsFile of jsFiles) {
          const jsPath = path7.join(assetsDir, jsFile);
          let content = await fs10.readFile(jsPath, "utf8");
          const zodConfigPatterns = [
            // Non-minified: export const globalConfig = {}
            /export\s+const\s+globalConfig\s*=\s*\{\s*\}/g,
            // Minified pattern: ZodEncodeError"}}const X={};function followed by return X
            // This is the unique signature of Zod's globalConfig
            /ZodEncodeError[^}]*\}\}const\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*\{\s*\}/g
          ];
          let patched = false;
          for (const pattern of zodConfigPatterns) {
            if (pattern.test(content)) {
              pattern.lastIndex = 0;
              content = content.replace(pattern, (match) => {
                return match.replace(/=\s*\{\s*\}/, "={jitless:true}");
              });
              patched = true;
            }
          }
          if (patched) {
            await fs10.writeFile(jsPath, content, "utf8");
            console.log(source_default.gray(`    \u2192 Patched Zod JIT in ${jsFile}`));
          }
        }
      } catch (error) {
        if (error.code !== "ENOENT") {
          console.warn(source_default.yellow(`    \u26A0 Failed to patch Zod JIT: ${error}`));
        }
      }
      const mcpServerUrl = process.env.MCP_SERVER_URL;
      if (mcpServerUrl) {
        try {
          const htmlPath = path7.join(outDir, "index.html");
          let html = await fs10.readFile(htmlPath, "utf8");
          const injectionScript = `<script>window.__getFile = (filename) => { return "${mcpUrl}/${widgetName}/"+filename }; window.__mcpPublicUrl = "${mcpServerUrl}/mcp-use/public"; window.__mcpPublicAssetsUrl = "${mcpUrl}/public";</script>`;
          if (!html.includes("window.__mcpPublicUrl")) {
            html = html.replace(
              /<head[^>]*>/i,
              `<head>
    ${injectionScript}`
            );
          }
          if (/<base\s+[^>]*\/?>/i.test(html)) {
            html = html.replace(
              /<base\s+[^>]*\/?>/i,
              `<base href="${mcpServerUrl}">`
            );
          } else {
            html = html.replace(
              injectionScript,
              `${injectionScript}
    <base href="${mcpServerUrl}">`
            );
          }
          await fs10.writeFile(htmlPath, html, "utf8");
          console.log(
            source_default.gray(`    \u2192 Injected MCP_SERVER_URL into ${widgetName}`)
          );
        } catch (error) {
          console.warn(
            source_default.yellow(
              `    \u26A0 Failed to post-process HTML for ${widgetName}:`,
              error
            )
          );
        }
      }
      console.log(source_default.green(`    \u2713 Built ${widgetName}`));
      return { name: widgetName, metadata: widgetMetadata };
    } catch (error) {
      console.error(source_default.red(`    \u2717 Failed to build ${widgetName}:`), error);
      return null;
    }
  };
  const buildResults = await Promise.all(
    entries.map((entry) => buildSingleWidget(entry))
  );
  const builtWidgets = buildResults.filter(
    (result) => result !== null
  );
  return builtWidgets;
}
program.command("build").description("Build TypeScript and MCP UI widgets").option("-p, --path <path>", "Path to project directory", process.cwd()).option("--with-inspector", "Include inspector in production build").option(
  "--inline",
  "Inline all JS/CSS into HTML (required for VS Code MCP Apps)"
).option("--no-inline", "Keep JS/CSS as separate files (default)").action(async (options) => {
  try {
    const projectPath = path7.resolve(options.path);
    const { promises: fs10 } = await import("fs");
    displayPackageVersions(projectPath);
    const builtWidgets = await buildWidgets(projectPath, {
      inline: options.inline ?? false
    });
    let sourceServerFile;
    try {
      sourceServerFile = await findServerFile(projectPath);
    } catch {
    }
    console.log(source_default.gray("Building TypeScript..."));
    await runCommand(
      "node",
      [
        "--max-old-space-size=4096",
        path7.join(projectPath, "node_modules", "typescript", "bin", "tsc")
      ],
      projectPath
    ).promise;
    console.log(source_default.green("\u2713 TypeScript build complete!"));
    let entryPoint;
    if (sourceServerFile) {
      const baseName = path7.basename(sourceServerFile, ".ts") + ".js";
      const possibleOutputs = [
        `dist/${baseName}`,
        // rootDir set to project root or src
        `dist/src/${baseName}`,
        // no rootDir, source in src/
        `dist/${sourceServerFile.replace(/\.ts$/, ".js")}`
        // exact path preserved
      ];
      for (const candidate of possibleOutputs) {
        try {
          await access(path7.join(projectPath, candidate));
          entryPoint = candidate;
          break;
        } catch {
          continue;
        }
      }
    }
    const publicDir = path7.join(projectPath, "public");
    try {
      await fs10.access(publicDir);
      console.log(source_default.gray("Copying public assets..."));
      await fs10.cp(publicDir, path7.join(projectPath, "dist", "public"), {
        recursive: true
      });
      console.log(source_default.green("\u2713 Public assets copied"));
    } catch {
    }
    const manifestPath = path7.join(projectPath, "dist", "mcp-use.json");
    let existingManifest = {};
    try {
      const existingContent = await fs10.readFile(manifestPath, "utf-8");
      existingManifest = JSON.parse(existingContent);
    } catch {
    }
    const widgetsData = {};
    for (const widget of builtWidgets) {
      widgetsData[widget.name] = widget.metadata;
    }
    const includeInspector = !!options.withInspector;
    const buildTime = (/* @__PURE__ */ new Date()).toISOString();
    const { createHash } = await import("crypto");
    const buildId = createHash("sha256").update(buildTime + Math.random().toString()).digest("hex").substring(0, 16);
    const manifest = {
      ...existingManifest,
      // Preserve existing fields like tunnel
      includeInspector,
      buildTime,
      buildId,
      entryPoint,
      // Server entry point for `mcp-use start`
      widgets: widgetsData
    };
    await fs10.mkdir(path7.dirname(manifestPath), { recursive: true });
    await fs10.writeFile(
      manifestPath,
      JSON.stringify(manifest, null, 2),
      "utf8"
    );
    console.log(source_default.green("\u2713 Build manifest created"));
    console.log(source_default.green.bold(`
\u2713 Build complete!`));
    if (builtWidgets.length > 0) {
      console.log(source_default.gray(`  ${builtWidgets.length} widget(s) built`));
    }
    if (options.withInspector) {
      console.log(source_default.gray("  Inspector included"));
    }
  } catch (error) {
    console.error(source_default.red("Build failed:"), error);
    process.exit(1);
  }
});
program.command("dev").description("Run development server with auto-reload and inspector").option("-p, --path <path>", "Path to project directory", process.cwd()).option("--port <port>", "Server port", "3000").option(
  "--host <host>",
  "Server host (use 0.0.0.0 to listen on all interfaces)",
  "0.0.0.0"
).option("--no-open", "Do not auto-open inspector").option("--no-hmr", "Disable hot module reloading (use tsx watch instead)").option("--tunnel", "Expose server through a tunnel").action(async (options) => {
  try {
    const projectPath = path7.resolve(options.path);
    let port = parseInt(options.port, 10);
    const host = options.host;
    const useHmr = options.hmr !== false;
    displayPackageVersions(projectPath);
    if (!await isPortAvailable(port, host)) {
      console.log(source_default.yellow.bold(`\u26A0\uFE0F  Port ${port} is already in use`));
      const availablePort = await findAvailablePort2(port, host);
      console.log(source_default.green.bold(`\u2713 Using port ${availablePort} instead`));
      port = availablePort;
    }
    const serverFile = await findServerFile(projectPath);
    let tunnelProcess = void 0;
    let tunnelSubdomain = void 0;
    let tunnelUrl = void 0;
    if (options.tunnel) {
      try {
        const manifestPath = path7.join(projectPath, "dist", "mcp-use.json");
        let existingSubdomain;
        try {
          const manifestContent = await readFile3(manifestPath, "utf-8");
          const manifest = JSON.parse(manifestContent);
          existingSubdomain = manifest.tunnel?.subdomain;
          if (existingSubdomain) {
            console.log(
              source_default.gray(`Found existing subdomain: ${existingSubdomain}`)
            );
          }
        } catch {
        }
        const tunnelInfo = await startTunnel(port, existingSubdomain);
        tunnelUrl = tunnelInfo.url;
        tunnelProcess = tunnelInfo.process;
        tunnelSubdomain = tunnelInfo.subdomain;
        try {
          let manifest = {};
          try {
            const manifestContent = await readFile3(manifestPath, "utf-8");
            manifest = JSON.parse(manifestContent);
          } catch {
          }
          if (!manifest.tunnel) {
            manifest.tunnel = {};
          }
          manifest.tunnel.subdomain = tunnelSubdomain;
          await mkdir3(path7.dirname(manifestPath), { recursive: true });
          await writeFile3(
            manifestPath,
            JSON.stringify(manifest, null, 2),
            "utf-8"
          );
        } catch (error) {
          console.warn(
            source_default.yellow(
              `\u26A0\uFE0F  Failed to save subdomain to mcp-use.json: ${error instanceof Error ? error.message : "Unknown error"}`
            )
          );
        }
      } catch (error) {
        console.error(source_default.red("Failed to start tunnel:"), error);
        process.exit(1);
      }
    }
    const mcpUrl = `http://${host}:${port}`;
    process.env.PORT = String(port);
    process.env.HOST = host;
    process.env.NODE_ENV = "development";
    if (tunnelUrl) {
      process.env.MCP_URL = tunnelUrl;
    } else if (!process.env.MCP_URL) {
      process.env.MCP_URL = mcpUrl;
    }
    if (!useHmr) {
      console.log(source_default.gray("HMR disabled, using tsx watch (full restart)"));
      const processes = [];
      const env2 = {
        PORT: String(port),
        HOST: host,
        NODE_ENV: "development",
        // Preserve user-provided MCP_URL (e.g., for reverse proxy setups)
        MCP_URL: process.env.MCP_URL || mcpUrl
      };
      const { createRequire: createRequire4 } = await import("module");
      let cmd;
      let args;
      try {
        const projectRequire = createRequire4(
          path7.join(projectPath, "package.json")
        );
        const tsxPkgPath = projectRequire.resolve("tsx/package.json");
        const tsxPkg = JSON.parse(await readFile3(tsxPkgPath, "utf-8"));
        let binPath;
        if (typeof tsxPkg.bin === "string") {
          binPath = tsxPkg.bin;
        } else if (tsxPkg.bin && typeof tsxPkg.bin === "object") {
          binPath = tsxPkg.bin.tsx || Object.values(tsxPkg.bin)[0];
        } else {
          throw new Error("No bin field found in tsx package.json");
        }
        const tsxBin = path7.resolve(path7.dirname(tsxPkgPath), binPath);
        cmd = "node";
        args = [tsxBin, "watch", serverFile];
      } catch (error) {
        console.log(
          source_default.yellow(
            `Could not resolve local tsx: ${error instanceof Error ? error.message : "unknown error"}`
          )
        );
        cmd = "npx";
        args = ["tsx", "watch", serverFile];
      }
      const serverCommand = runCommand(cmd, args, projectPath, env2, true);
      processes.push(serverCommand.process);
      if (options.open !== false) {
        const startTime = Date.now();
        const browserHost = normalizeBrowserHost(host);
        const ready = await waitForServer(port, browserHost);
        if (ready) {
          const mcpEndpoint = `http://${browserHost}:${port}/mcp`;
          const inspectorUrl = `http://${browserHost}:${port}/inspector?autoConnect=${encodeURIComponent(mcpEndpoint)}`;
          const readyTime = Date.now() - startTime;
          console.log(source_default.green.bold(`\u2713 Ready in ${readyTime}ms`));
          console.log(
            source_default.whiteBright(`Local:    http://${browserHost}:${port}`)
          );
          console.log(source_default.whiteBright(`Network:  http://${host}:${port}`));
          console.log(source_default.whiteBright(`MCP:      ${mcpEndpoint}`));
          if (tunnelUrl) {
            console.log(source_default.whiteBright(`Tunnel:   ${tunnelUrl}/mcp`));
          }
          console.log(source_default.whiteBright(`Inspector: ${inspectorUrl}
`));
          await open_default(inspectorUrl);
        }
      }
      let noHmrCleanupInProgress = false;
      const cleanup2 = async () => {
        if (noHmrCleanupInProgress) return;
        noHmrCleanupInProgress = true;
        console.log(source_default.gray("\n\nShutting down..."));
        if (tunnelProcess && typeof tunnelProcess.markShutdown === "function") {
          tunnelProcess.markShutdown();
        }
        if (tunnelSubdomain) {
          try {
            const apiBase = process.env.MCP_USE_API || "https://local.mcp-use.run";
            await fetch(`${apiBase}/api/tunnels/${tunnelSubdomain}`, {
              method: "DELETE"
            });
          } catch {
          }
        }
        processes.forEach((proc) => {
          if (proc && typeof proc.kill === "function") {
            proc.kill("SIGINT");
          }
        });
        if (tunnelProcess && typeof tunnelProcess.kill === "function") {
          tunnelProcess.kill("SIGINT");
        }
        setTimeout(() => process.exit(0), 2e3);
      };
      process.on("SIGINT", cleanup2);
      process.on("SIGTERM", cleanup2);
      await new Promise(() => {
      });
      return;
    }
    console.log(
      source_default.gray(
        "HMR enabled - changes will hot reload without dropping connections"
      )
    );
    const chokidarModule = await import("chokidar");
    const chokidar = chokidarModule.default || chokidarModule;
    const { pathToFileURL, fileURLToPath: fileURLToPath3 } = await import("url");
    const { createRequire: createRequire3 } = await import("module");
    let tsImport = null;
    try {
      const projectRequire = createRequire3(
        path7.join(projectPath, "package.json")
      );
      const tsxApiPath = projectRequire.resolve("tsx/esm/api");
      const tsxApi = await import(pathToFileURL(tsxApiPath).href);
      tsImport = tsxApi.tsImport;
    } catch {
      console.log(
        source_default.yellow(
          "Warning: tsx not found in project dependencies. TypeScript HMR may not work.\nAdd tsx to your devDependencies: npm install -D tsx"
        )
      );
    }
    const serverFilePath = path7.join(projectPath, serverFile);
    const serverFileUrl = pathToFileURL(serverFilePath).href;
    globalThis.__mcpUseHmrMode = true;
    const importServerModule = async () => {
      const previousServer = globalThis.__mcpUseLastServer;
      globalThis.__mcpUseLastServer = null;
      if (tsImport) {
        await tsImport(`${serverFilePath}?t=${Date.now()}`, {
          parentURL: import.meta.url,
          onImport: (file) => {
            const filePath = file.startsWith("file://") ? fileURLToPath3(file) : file;
            if (!filePath.includes("node_modules") && filePath.startsWith(projectPath)) {
              console.debug(`[HMR] Loaded: ${file}`);
            }
          }
        });
      } else {
        await import(`${serverFileUrl}?t=${Date.now()}`);
      }
      const instance = globalThis.__mcpUseLastServer;
      if (!instance) {
        globalThis.__mcpUseLastServer = previousServer;
        console.warn(
          source_default.yellow(
            "[HMR] Warning: Module re-import did not create a new MCPServer instance. The module may be cached. Check that your server file creates an MCPServer."
          )
        );
        return null;
      }
      if (instance === previousServer) {
        console.warn(
          source_default.yellow(
            "[HMR] Warning: Module re-import returned the same server instance. The module may not have been re-evaluated. " + (!tsImport ? "Install tsx as a devDependency for reliable TypeScript HMR." : "This may be a tsx caching issue.")
          )
        );
        return null;
      }
      return instance;
    };
    console.log(source_default.gray(`Loading server from ${serverFile}...`));
    let runningServer;
    try {
      runningServer = await importServerModule();
      if (!runningServer) {
        console.error(
          source_default.red(
            "Error: Could not find MCPServer instance.\nMake sure your server file creates an MCPServer:\n  const server = new MCPServer({ name: 'my-server', version: '1.0.0' });"
          )
        );
        process.exit(1);
      }
      if (typeof runningServer.listen !== "function") {
        console.error(
          source_default.red("Error: MCPServer instance must have a listen() method")
        );
        process.exit(1);
      }
      const startTime = Date.now();
      globalThis.__mcpUseHmrMode = false;
      await runningServer.listen(port);
      globalThis.__mcpUseHmrMode = true;
      if (options.open !== false) {
        const browserHost = normalizeBrowserHost(host);
        const ready = await waitForServer(port, browserHost);
        if (ready) {
          const mcpEndpoint = `http://${browserHost}:${port}/mcp`;
          const inspectorUrl = `http://${browserHost}:${port}/inspector?autoConnect=${encodeURIComponent(mcpEndpoint)}`;
          const readyTime = Date.now() - startTime;
          console.log(source_default.green.bold(`\u2713 Ready in ${readyTime}ms`));
          console.log(
            source_default.whiteBright(`Local:    http://${browserHost}:${port}`)
          );
          console.log(source_default.whiteBright(`Network:  http://${host}:${port}`));
          console.log(source_default.whiteBright(`MCP:      ${mcpEndpoint}`));
          if (tunnelUrl) {
            console.log(source_default.whiteBright(`Tunnel:   ${tunnelUrl}/mcp`));
          }
          console.log(source_default.whiteBright(`Inspector: ${inspectorUrl}`));
          console.log(source_default.gray(`Watching for changes...
`));
          await open_default(inspectorUrl);
        }
      }
    } catch (error) {
      console.error(
        source_default.red("Failed to start server:"),
        error?.message || error
      );
      if (error?.stack) {
        console.error(source_default.gray(error.stack));
      }
      process.exit(1);
    }
    if (options.open === false) {
      const mcpEndpoint = `http://${host}:${port}/mcp`;
      console.log(source_default.green.bold(`\u2713 Server ready`));
      console.log(source_default.whiteBright(`Local:    http://${host}:${port}`));
      console.log(source_default.whiteBright(`MCP:      ${mcpEndpoint}`));
      if (tunnelUrl) {
        console.log(source_default.whiteBright(`Tunnel:   ${tunnelUrl}/mcp`));
      }
      console.log(source_default.gray(`Watching for changes...
`));
    }
    const watcher = chokidar.watch(".", {
      cwd: projectPath,
      ignored: (path8, stats) => {
        const normalizedPath = path8.replace(/\\/g, "/");
        if (/(^|\/)\.[^/]/.test(normalizedPath)) {
          return true;
        }
        if (normalizedPath.includes("/node_modules/") || normalizedPath.endsWith("/node_modules")) {
          return true;
        }
        if (normalizedPath.includes("/dist/") || normalizedPath.endsWith("/dist")) {
          return true;
        }
        if (normalizedPath.includes("/resources/") || normalizedPath.endsWith("/resources")) {
          return true;
        }
        if (stats?.isFile() && normalizedPath.endsWith(".d.ts")) {
          return true;
        }
        return false;
      },
      persistent: true,
      ignoreInitial: true,
      depth: 3
      // Limit depth to avoid watching too many files
    });
    watcher.on("ready", () => {
      const watched = watcher.getWatched();
      const dirs = Object.keys(watched);
      console.log(
        source_default.gray(`[HMR] Watcher ready, watching ${dirs.length} paths`)
      );
    }).on("error", (error) => {
      console.error(
        source_default.red(
          `[HMR] Watcher error: ${error instanceof Error ? error.message : String(error)}`
        )
      );
    });
    let reloadTimeout = null;
    let isReloading = false;
    watcher.on("change", async (filePath) => {
      if (!filePath.endsWith(".ts") && !filePath.endsWith(".tsx") || filePath.endsWith(".d.ts")) {
        return;
      }
      if (isReloading) return;
      if (reloadTimeout) {
        clearTimeout(reloadTimeout);
      }
      reloadTimeout = setTimeout(async () => {
        isReloading = true;
        console.log(source_default.yellow(`
[HMR] File changed: ${filePath}`));
        try {
          const newServer = await importServerModule();
          if (!newServer) {
            console.warn(
              source_default.yellow(
                "[HMR] Warning: No MCPServer instance found after reload, skipping"
              )
            );
            isReloading = false;
            return;
          }
          if (typeof runningServer.syncRegistrationsFrom !== "function") {
            console.warn(
              source_default.yellow(
                "[HMR] Warning: Server does not support hot reload (missing syncRegistrationsFrom)"
              )
            );
            isReloading = false;
            return;
          }
          const syncResult = runningServer.syncRegistrationsFrom(newServer);
          if (syncResult && syncResult.totalChanges > 0) {
            const parts = [];
            if (syncResult.tools.updated > 0 || syncResult.tools.added > 0 || syncResult.tools.removed > 0) {
              const details = [];
              if (syncResult.tools.updated > 0)
                details.push(`${syncResult.tools.updated} updated`);
              if (syncResult.tools.added > 0)
                details.push(`${syncResult.tools.added} added`);
              if (syncResult.tools.removed > 0)
                details.push(`${syncResult.tools.removed} removed`);
              parts.push(`tools (${details.join(", ")})`);
            }
            if (syncResult.prompts.updated > 0 || syncResult.prompts.added > 0 || syncResult.prompts.removed > 0) {
              const details = [];
              if (syncResult.prompts.updated > 0)
                details.push(`${syncResult.prompts.updated} updated`);
              if (syncResult.prompts.added > 0)
                details.push(`${syncResult.prompts.added} added`);
              if (syncResult.prompts.removed > 0)
                details.push(`${syncResult.prompts.removed} removed`);
              parts.push(`prompts (${details.join(", ")})`);
            }
            if (syncResult.resources.updated > 0 || syncResult.resources.added > 0 || syncResult.resources.removed > 0) {
              const details = [];
              if (syncResult.resources.updated > 0)
                details.push(`${syncResult.resources.updated} updated`);
              if (syncResult.resources.added > 0)
                details.push(`${syncResult.resources.added} added`);
              if (syncResult.resources.removed > 0)
                details.push(`${syncResult.resources.removed} removed`);
              parts.push(`resources (${details.join(", ")})`);
            }
            console.log(source_default.green(`[HMR] \u2713 Reloaded: ${parts.join(", ")}`));
          } else {
            console.log(
              source_default.gray(
                `[HMR] No changes detected (${runningServer.registeredTools?.length || 0} tools, ${runningServer.registeredPrompts?.length || 0} prompts, ${runningServer.registeredResources?.length || 0} resources registered)`
              )
            );
          }
        } catch (error) {
          console.error(source_default.red(`[HMR] Reload failed: ${error.message}`));
        }
        isReloading = false;
      }, 100);
    });
    let hmrCleanupInProgress = false;
    const cleanup = async () => {
      if (hmrCleanupInProgress) return;
      hmrCleanupInProgress = true;
      console.log(source_default.gray("\n\nShutting down..."));
      watcher.close();
      if (tunnelProcess && typeof tunnelProcess.markShutdown === "function") {
        tunnelProcess.markShutdown();
      }
      if (tunnelSubdomain) {
        try {
          const apiBase = process.env.MCP_USE_API || "https://local.mcp-use.run";
          await fetch(`${apiBase}/api/tunnels/${tunnelSubdomain}`, {
            method: "DELETE"
          });
        } catch {
        }
      }
      if (tunnelProcess && typeof tunnelProcess.kill === "function") {
        tunnelProcess.kill("SIGINT");
        setTimeout(() => process.exit(0), 2e3);
      } else {
        process.exit(0);
      }
    };
    process.on("SIGINT", cleanup);
    process.on("SIGTERM", cleanup);
    await new Promise(() => {
    });
  } catch (error) {
    console.error(source_default.red("Dev mode failed:"), error);
    process.exit(1);
  }
});
program.command("start").description("Start production server").option("-p, --path <path>", "Path to project directory", process.cwd()).option("--port <port>", "Server port", "3000").option("--tunnel", "Expose server through a tunnel").action(async (options) => {
  try {
    const projectPath = path7.resolve(options.path);
    const portFlagProvided = process.argv.includes("--port") || process.argv.includes("-p") || process.argv.some((arg) => arg.startsWith("--port=")) || process.argv.some((arg) => arg.startsWith("-p="));
    const port = portFlagProvided ? parseInt(options.port, 10) : parseInt(process.env.PORT || options.port || "3000", 10);
    console.log(
      `\x1B[36m\x1B[1mmcp-use\x1B[0m \x1B[90mVersion: ${packageJson.version}\x1B[0m
`
    );
    let mcpUrl;
    let tunnelProcess = void 0;
    let tunnelSubdomain = void 0;
    if (options.tunnel) {
      try {
        const manifestPath2 = path7.join(projectPath, "dist", "mcp-use.json");
        let existingSubdomain;
        try {
          const manifestContent = await readFile3(manifestPath2, "utf-8");
          const manifest = JSON.parse(manifestContent);
          existingSubdomain = manifest.tunnel?.subdomain;
          if (existingSubdomain) {
            console.log(
              source_default.gray(`Found existing subdomain: ${existingSubdomain}`)
            );
          }
        } catch (error) {
          console.debug(
            source_default.gray(
              `Debug: Failed to read or parse mcp-use.json: ${error instanceof Error ? error.message : String(error)}`
            )
          );
        }
        const tunnelInfo = await startTunnel(port, existingSubdomain);
        mcpUrl = tunnelInfo.url;
        tunnelProcess = tunnelInfo.process;
        const subdomain = tunnelInfo.subdomain;
        tunnelSubdomain = subdomain;
        try {
          let manifest = {};
          try {
            const manifestContent = await readFile3(manifestPath2, "utf-8");
            manifest = JSON.parse(manifestContent);
          } catch {
          }
          if (!manifest.tunnel) {
            manifest.tunnel = {};
          }
          manifest.tunnel.subdomain = subdomain;
          await mkdir3(path7.dirname(manifestPath2), { recursive: true });
          await writeFile3(
            manifestPath2,
            JSON.stringify(manifest, null, 2),
            "utf-8"
          );
        } catch (error) {
          console.warn(
            source_default.yellow(
              `\u26A0\uFE0F  Failed to save subdomain to mcp-use.json: ${error instanceof Error ? error.message : "Unknown error"}`
            )
          );
        }
      } catch (error) {
        console.error(source_default.red("Failed to start tunnel:"), error);
        process.exit(1);
      }
    }
    let serverFile;
    const manifestPath = path7.join(projectPath, "dist", "mcp-use.json");
    try {
      const manifestContent = await readFile3(manifestPath, "utf-8");
      const manifest = JSON.parse(manifestContent);
      if (manifest.entryPoint) {
        await access(path7.join(projectPath, manifest.entryPoint));
        serverFile = manifest.entryPoint;
      }
    } catch {
    }
    if (!serverFile) {
      const serverCandidates = [
        "dist/index.js",
        "dist/server.js",
        "dist/src/index.js",
        "dist/src/server.js"
      ];
      for (const candidate of serverCandidates) {
        try {
          await access(path7.join(projectPath, candidate));
          serverFile = candidate;
          break;
        } catch {
          continue;
        }
      }
    }
    if (!serverFile) {
      console.error(
        source_default.red(
          `No built server file found. Run 'mcp-use build' first.

Looked for:
  - dist/mcp-use.json (manifest with entryPoint)
  - dist/index.js
  - dist/server.js
  - dist/src/index.js
  - dist/src/server.js`
        )
      );
      process.exit(1);
    }
    console.log("Starting production server...");
    const env2 = {
      ...process.env,
      PORT: String(port),
      NODE_ENV: "production"
    };
    if (mcpUrl) {
      env2.MCP_URL = mcpUrl;
      console.log(source_default.whiteBright(`Tunnel:   ${mcpUrl}/mcp`));
    } else if (!env2.MCP_URL) {
      env2.MCP_URL = `http://localhost:${port}`;
    }
    const serverProc = spawn("node", [serverFile], {
      cwd: projectPath,
      stdio: "inherit",
      env: env2
    });
    let cleanupInProgress = false;
    const cleanup = async () => {
      if (cleanupInProgress) {
        return;
      }
      cleanupInProgress = true;
      console.log(source_default.gray("\n\nShutting down..."));
      if (tunnelProcess && typeof tunnelProcess.markShutdown === "function") {
        tunnelProcess.markShutdown();
      }
      if (tunnelSubdomain) {
        try {
          const apiBase = process.env.MCP_USE_API || "https://local.mcp-use.run";
          await fetch(`${apiBase}/api/tunnels/${tunnelSubdomain}`, {
            method: "DELETE"
          });
        } catch (err) {
        }
      }
      const processesToKill = 1 + (tunnelProcess ? 1 : 0);
      let killedCount = 0;
      const checkAndExit = () => {
        killedCount++;
        if (killedCount >= processesToKill) {
          process.exit(0);
        }
      };
      serverProc.on("exit", checkAndExit);
      serverProc.kill("SIGTERM");
      if (tunnelProcess && typeof tunnelProcess.kill === "function") {
        tunnelProcess.on("exit", checkAndExit);
        tunnelProcess.kill("SIGINT");
      } else {
        checkAndExit();
      }
      setTimeout(() => {
        if (serverProc.exitCode === null) {
          serverProc.kill("SIGKILL");
        }
        if (tunnelProcess && tunnelProcess.exitCode === null) {
          tunnelProcess.kill("SIGKILL");
        }
        process.exit(0);
      }, 2e3);
    };
    process.on("SIGINT", cleanup);
    process.on("SIGTERM", cleanup);
    serverProc.on("exit", async (code) => {
      if (!cleanupInProgress) {
        await cleanup();
      }
      process.exit(code || 0);
    });
  } catch (error) {
    console.error("Start failed:", error);
    process.exit(1);
  }
});
program.command("login").description("Login to Manufact cloud").action(async () => {
  try {
    await loginCommand();
    process.exit(0);
  } catch (error) {
    console.error(
      source_default.red.bold("\n\u2717 Login failed:"),
      source_default.red(error instanceof Error ? error.message : "Unknown error")
    );
    process.exit(1);
  }
});
program.command("logout").description("Logout from Manufact cloud").action(async () => {
  await logoutCommand();
});
program.command("whoami").description("Show current user information").action(async () => {
  await whoamiCommand();
});
program.command("deploy").description("Deploy MCP server from GitHub to Manufact cloud").option("--open", "Open deployment in browser after successful deploy").option("--name <name>", "Custom deployment name").option("--port <port>", "Server port", "3000").option("--runtime <runtime>", "Runtime (node or python)").option(
  "--new",
  "Force creation of new deployment instead of reusing linked deployment"
).option(
  "--env <key=value...>",
  "Environment variables (can be used multiple times)"
).option("--env-file <path>", "Path to .env file with environment variables").action(async (options) => {
  await deployCommand({
    open: options.open,
    name: options.name,
    port: options.port ? parseInt(options.port, 10) : void 0,
    runtime: options.runtime,
    new: options.new,
    env: options.env,
    envFile: options.envFile
  });
});
program.addCommand(createClientCommand());
program.addCommand(createDeploymentsCommand());
program.addCommand(createSkillsCommand());
program.command("generate-types").description(
  "Generate TypeScript type definitions for tools (writes .mcp-use/tool-registry.d.ts)"
).option("-p, --path <path>", "Path to project directory", process.cwd()).option("--server <file>", "Server entry file", "index.ts").action(async (options) => {
  const projectPath = path7.resolve(options.path);
  const serverFile = path7.join(projectPath, options.server);
  try {
    if (!await access(serverFile).then(() => true).catch(() => false)) {
      console.error(source_default.red(`Server file not found: ${serverFile}`));
      process.exit(1);
    }
    console.log(source_default.blue("Generating tool registry types..."));
    globalThis.__mcpUseHmrMode = true;
    const { tsImport } = await import("tsx/esm/api");
    await tsImport(serverFile, {
      parentURL: import.meta.url,
      tsconfig: path7.join(projectPath, "tsconfig.json")
    });
    const server = globalThis.__mcpUseLastServer;
    if (!server) {
      console.error(
        source_default.red(
          "No MCPServer instance found. Make sure your server file creates an MCPServer instance."
        )
      );
      process.exit(1);
    }
    const mcpUsePath = path7.join(projectPath, "node_modules", "mcp-use");
    const { generateToolRegistryTypes } = await import(path7.join(mcpUsePath, "dist", "src", "server", "index.js")).then((mod) => mod);
    if (!generateToolRegistryTypes) {
      throw new Error(
        "generateToolRegistryTypes not found in mcp-use package"
      );
    }
    await generateToolRegistryTypes(server.registrations.tools, projectPath);
    console.log(source_default.green("\u2713 Tool registry types generated successfully"));
    process.exit(0);
  } catch (error) {
    console.error(
      source_default.red("Failed to generate types:"),
      error instanceof Error ? error.message : String(error)
    );
    if (error instanceof Error && error.stack) {
      console.error(source_default.gray(error.stack));
    }
    process.exit(1);
  } finally {
    globalThis.__mcpUseHmrMode = false;
  }
});
program.hook("preAction", async (_thisCommand, actionCommand) => {
  const projectPath = actionCommand.opts().path;
  await notifyIfUpdateAvailable(projectPath);
});
program.parse();
//# sourceMappingURL=index.js.map