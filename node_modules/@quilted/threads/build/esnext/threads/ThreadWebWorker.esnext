import { Thread } from '../Thread.esnext';
import { portToMessageTarget } from './ThreadMessagePort.esnext';

class ThreadWebWorker extends Thread {
  worker;
  static from(worker, options) {
    return new ThreadWebWorker(worker, options);
  }
  /**
   * Starts a thread wrapped around a `Worker` object, and returns the imports
   * of the thread.
   *
   * @example
   * ```ts
   * import {ThreadWebWorker} from '@quilted/threads';
   *
   * // On the main thread:
   * const worker = new Worker('worker.js');
   * const {getMessage} = ThreadWebWorker.import(worker);
   * const message = await getMessage(); // 'Hello, world!'
   *
   * // Inside a web worker:
   *
   * import {ThreadWebWorker} from '@quilted/threads';
   *
   * ThreadWebWorker.export(self, {
   *   async getMessage() {
   *     return 'Hello, world!';
   *   },
   * });
   * ```
   */
  static import(worker, options) {
    return new ThreadWebWorker(worker, options).imports;
  }
  /**
   * Starts a thread wrapped around a `Worker` object, providing the second
   * argument as the exports of the thread.
   *
   * @example
   * ```ts
   * import {ThreadWebWorker} from '@quilted/threads';
   *
   * // Inside a web worker:
   * ThreadWebWorker.export(self, {
   *   async getMessage() {
   *     return 'Hello, world!';
   *   },
   * });
   *
   * // On the main thread:
   *
   * import {ThreadWebWorker} from '@quilted/threads';
   *
   * const worker = new Worker('worker.js');
   * const {getMessage} = ThreadWebWorker.import(worker);
   * const message = await getMessage(); // 'Hello, world!'
   * ```
   */
  static export(worker, exports, options) {
    new ThreadWebWorker(worker, { ...options, exports });
  }
  static self = Object.assign(
    (options) => this.from(selfAsWorker(), options),
    {
      import: (options) => this.import(selfAsWorker(), options),
      export: (exports, options) => this.export(selfAsWorker(), exports, options)
    }
  );
  constructor(worker, options) {
    super(portToMessageTarget(worker), options);
    this.worker = worker;
  }
}
function selfAsWorker() {
  if (typeof self === "undefined" || !(self instanceof Worker)) {
    throw new Error("You are not inside a web worker.");
  }
  return self;
}

export { ThreadWebWorker };
