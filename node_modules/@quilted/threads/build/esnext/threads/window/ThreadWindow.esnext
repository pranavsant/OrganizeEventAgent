import { Thread } from '../../Thread.esnext';
import { RESPONSE_MESSAGE, CHECK_MESSAGE } from './shared.esnext';
import { ThreadNestedWindow } from './ThreadNestedWindow.esnext';

class ThreadWindow extends Thread {
  window;
  /**
   * Creates a thread from a `Window` created by this environment.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe
   *
   * @example
   * import {ThreadWindow} from '@quilted/threads';
   *
   * const popup = window.open('https://my-app.com/popup', 'MyAppPopup', 'popup');
   * const thread = ThreadWindow.from(popup);
   * await thread.imports.sendMessage('Hello world!');
   */
  static from(window2, options) {
    return new ThreadWindow(window2, options);
  }
  /**
   * Starts a thread wrapped around a `window` object, and returns the imports
   * of the thread.
   *
   * @example
   * ```ts
   * import {ThreadWindow} from '@quilted/threads';
   *
   * const {getMessage} = ThreadWindow.import(window);
   * const message = await getMessage(); // 'Hello, world!'
   *
   * // In the nested window:
   *
   * import {ThreadNestedWindow} from '@quilted/threads';
   *
   * ThreadNestedWindow.export(window.opener, {
   *   async getMessage() {
   *     return 'Hello, world!';
   *   },
   * });
   * ```
   */
  static import(window2, options) {
    return new ThreadWindow(window2, options).imports;
  }
  /**
   * Starts a thread wrapped around a `window` object, providing the second
   * argument as the exports of the thread.
   *
   * @example
   * ```ts
   * import {ThreadWindow} from '@quilted/threads';
   *
   * ThreadWindow.export(window, {
   *   async getMessage() {
   *     return 'Hello, world!';
   *   },
   * });
   *
   * // In the nested window:
   *
   * import {ThreadNestedWindow} from '@quilted/threads';
   *
   * const {getMessage} = ThreadNestedWindow.import(window.opener);
   * const message = await getMessage(); // 'Hello, world!'
   * ```
   */
  static export(window2, exports, options) {
    new ThreadWindow(window2, { ...options, exports });
  }
  /**
   * Creates a thread from within a window created by a parent document (for example,
   * an `iframe` or popup window).
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/opener
   *
   * @example
   * import {ThreadWindow} from '@quilted/threads';
   *
   * // Inside a document opened as a popup window
   * const thread = ThreadWindow.opener();
   * await thread.imports.sendMessage('Hello world!');
   */
  static opener = Object.assign(
    (options) => ThreadNestedWindow.from(window.opener, options),
    {
      /**
       * Starts a thread wrapped around a nested `window` object, and returns the imports
       * of the thread.
       *
       * @example
       * ```ts
       * import {ThreadWindow} from '@quilted/threads';
       *
       * const {getMessage} = ThreadWindow.opener.import();
       * const message = await getMessage(); // 'Hello, world!'
       *
       * // In the parent window:
       *
       * import {ThreadWindow} from '@quilted/threads';
       *
       * ThreadWindow.export(window, {
       *   async getMessage() {
       *     return 'Hello, world!';
       *   },
       * });
       * ```
       */
      import: (options) => ThreadNestedWindow.import(window.opener, options),
      /**
       * Starts a thread wrapped around a nested `window` object, providing the second
       * argument as the exports of the thread.
       *
       * @example
       * ```ts
       * import {ThreadWindow} from '@quilted/threads';
       *
       * ThreadWindow.opener.export({
       *   async getMessage() {
       *     return 'Hello, world!';
       *   },
       * });
       *
       * // In the parent window:
       *
       * import {ThreadWindow} from '@quilted/threads';
       *
       * const {getMessage} = ThreadWindow.import(window);
       * const message = await getMessage(); // 'Hello, world!'
       * ```
       */
      export: (exports, options) => ThreadNestedWindow.export(window.opener, { ...options, exports })
    }
  );
  constructor(window2, {
    targetOrigin = "*",
    ...options
  } = {}) {
    super(windowToThreadTarget(window2, { targetOrigin }), options);
    this.window = window2;
  }
}
function windowToThreadTarget(window2, { targetOrigin = "*" } = {}) {
  let connected = false;
  const sendMessage = function send(message, transfer) {
    window2.postMessage(message, targetOrigin, transfer);
  };
  const connectedPromise = new Promise((resolve) => {
    const abort = new AbortController();
    globalThis.window.addEventListener(
      "message",
      (event) => {
        if (event.source !== window2) return;
        if (event.data === RESPONSE_MESSAGE) {
          connected = true;
          abort.abort();
          resolve();
        }
      },
      { signal: abort.signal }
    );
    abort.signal.addEventListener("abort", () => resolve(), { once: true });
    sendMessage(CHECK_MESSAGE);
  });
  return {
    send(message, transfer) {
      if (!connected) {
        return connectedPromise.then(() => {
          if (connected) return sendMessage(message, transfer);
        });
      }
      return sendMessage(message, transfer);
    },
    listen(listen, { signal }) {
      self.addEventListener(
        "message",
        (event) => {
          if (event.source !== window2) return;
          if (event.data === RESPONSE_MESSAGE) return;
          listen(event.data);
        },
        { signal }
      );
    }
  };
}

export { ThreadWindow, windowToThreadTarget };
