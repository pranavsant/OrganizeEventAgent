function h(e, t, i) {
  function o(s, u) {
    var l;
    Object.defineProperty(s, "_zod", {
      value: s._zod ?? {},
      enumerable: !1
    }), (l = s._zod).traits ?? (l.traits = /* @__PURE__ */ new Set()), s._zod.traits.add(e), t(s, u);
    for (const d in a.prototype)
      d in s || Object.defineProperty(s, d, { value: a.prototype[d].bind(s) });
    s._zod.constr = a, s._zod.def = u;
  }
  const n = i?.Parent ?? Object;
  class r extends n {
  }
  Object.defineProperty(r, "name", { value: e });
  function a(s) {
    var u;
    const l = i?.Parent ? new r() : this;
    o(l, s), (u = l._zod).deferred ?? (u.deferred = []);
    for (const d of l._zod.deferred)
      d();
    return l;
  }
  return Object.defineProperty(a, "init", { value: o }), Object.defineProperty(a, Symbol.hasInstance, {
    value: (s) => i?.Parent && s instanceof i.Parent ? !0 : s?._zod?.traits?.has(e)
  }), Object.defineProperty(a, "name", { value: e }), a;
}
class it extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
const ha = {};
function Ie(e) {
  return ha;
}
function np(e) {
  const t = Object.values(e).filter((o) => typeof o == "number");
  return Object.entries(e).filter(([o, n]) => t.indexOf(+o) === -1).map(([o, n]) => n);
}
function ip(e, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function bi(e) {
  return {
    get value() {
      {
        const t = e();
        return Object.defineProperty(this, "value", { value: t }), t;
      }
    }
  };
}
function yi(e) {
  return e == null;
}
function ki(e) {
  const t = e.startsWith("^") ? 1 : 0, i = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(t, i);
}
function rp(e, t) {
  const i = (e.toString().split(".")[1] || "").length, o = (t.toString().split(".")[1] || "").length, n = i > o ? i : o, r = Number.parseInt(e.toFixed(n).replace(".", "")), a = Number.parseInt(t.toFixed(n).replace(".", ""));
  return r % a / 10 ** n;
}
function L(e, t, i) {
  Object.defineProperty(e, t, {
    get() {
      {
        const o = i();
        return e[t] = o, o;
      }
    },
    set(o) {
      Object.defineProperty(e, t, {
        value: o
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function cn(e, t, i) {
  Object.defineProperty(e, t, {
    value: i,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function va(e = 10) {
  const t = "abcdefghijklmnopqrstuvwxyz";
  let i = "";
  for (let o = 0; o < e; o++)
    i += t[Math.floor(Math.random() * t.length)];
  return i;
}
function Qe(e) {
  return JSON.stringify(e);
}
const $a = Error.captureStackTrace ? Error.captureStackTrace : (...e) => {
};
function Xt(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
const op = bi(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function ci(e) {
  if (Xt(e) === !1)
    return !1;
  const t = e.constructor;
  if (t === void 0)
    return !0;
  const i = t.prototype;
  return !(Xt(i) === !1 || Object.prototype.hasOwnProperty.call(i, "isPrototypeOf") === !1);
}
const ap = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function ct(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Te(e, t, i) {
  const o = new e._zod.constr(t ?? e._zod.def);
  return (!t || i?.parent) && (o._zod.parent = e), o;
}
function k(e) {
  const t = e;
  if (!t)
    return {};
  if (typeof t == "string")
    return { error: () => t };
  if (t?.message !== void 0) {
    if (t?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return delete t.message, typeof t.error == "string" ? { ...t, error: () => t.error } : t;
}
function sp(e) {
  return Object.keys(e).filter((t) => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional");
}
const up = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function lp(e, t) {
  const i = {}, o = e._zod.def;
  for (const n in t) {
    if (!(n in o.shape))
      throw new Error(`Unrecognized key: "${n}"`);
    t[n] && (i[n] = o.shape[n]);
  }
  return Te(e, {
    ...e._zod.def,
    shape: i,
    checks: []
  });
}
function cp(e, t) {
  const i = { ...e._zod.def.shape }, o = e._zod.def;
  for (const n in t) {
    if (!(n in o.shape))
      throw new Error(`Unrecognized key: "${n}"`);
    t[n] && delete i[n];
  }
  return Te(e, {
    ...e._zod.def,
    shape: i,
    checks: []
  });
}
function dp(e, t) {
  const i = {
    ...e._zod.def,
    get shape() {
      const o = { ...e._zod.def.shape, ...t };
      return cn(this, "shape", o), o;
    },
    checks: []
    // delete existing checks
  };
  return Te(e, i);
}
function mp(e, t) {
  return Te(e, {
    ...e._zod.def,
    get shape() {
      const i = { ...e._zod.def.shape, ...t._zod.def.shape };
      return cn(this, "shape", i), i;
    },
    catchall: t._zod.def.catchall,
    checks: []
    // delete existing checks
  });
}
function pp(e, t, i) {
  const o = t._zod.def.shape, n = { ...o };
  if (i)
    for (const r in i) {
      if (!(r in o))
        throw new Error(`Unrecognized key: "${r}"`);
      i[r] && (n[r] = e ? new e({
        type: "optional",
        innerType: o[r]
      }) : o[r]);
    }
  else
    for (const r in o)
      n[r] = e ? new e({
        type: "optional",
        innerType: o[r]
      }) : o[r];
  return Te(t, {
    ...t._zod.def,
    shape: n,
    checks: []
  });
}
function fp(e, t, i) {
  const o = t._zod.def.shape, n = { ...o };
  if (i)
    for (const r in i) {
      if (!(r in n))
        throw new Error(`Unrecognized key: "${r}"`);
      i[r] && (n[r] = new e({
        type: "nonoptional",
        innerType: o[r]
      }));
    }
  else
    for (const r in o)
      n[r] = new e({
        type: "nonoptional",
        innerType: o[r]
      });
  return Te(t, {
    ...t._zod.def,
    shape: n,
    // optional: [],
    checks: []
  });
}
function nt(e, t = 0) {
  for (let i = t; i < e.issues.length; i++)
    if (e.issues[i].continue !== !0)
      return !0;
  return !1;
}
function Ze(e, t) {
  return t.map((i) => {
    var o;
    return (o = i).path ?? (o.path = []), i.path.unshift(e), i;
  });
}
function Ft(e) {
  return typeof e == "string" ? e : e?.message;
}
function we(e, t, i) {
  const o = { ...e, path: e.path ?? [] };
  if (!e.message) {
    const n = Ft(e.inst?._zod.def?.error?.(e)) ?? Ft(t?.error?.(e)) ?? Ft(i.customError?.(e)) ?? Ft(i.localeError?.(e)) ?? "Invalid input";
    o.message = n;
  }
  return delete o.inst, delete o.continue, t?.reportInput || delete o.input, o;
}
function Ii(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function rt(...e) {
  const [t, i, o] = e;
  return typeof t == "string" ? {
    message: t,
    code: "custom",
    input: i,
    inst: o
  } : { ...t };
}
const _a = (e, t) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", {
    value: e._zod,
    enumerable: !1
  }), Object.defineProperty(e, "issues", {
    value: t,
    enumerable: !1
  }), Object.defineProperty(e, "message", {
    get() {
      return JSON.stringify(t, ip, 2);
    },
    enumerable: !0
    // configurable: false,
  });
}, ba = h("$ZodError", _a), ya = h("$ZodError", _a, { Parent: Error });
function gp(e, t = (i) => i.message) {
  const i = {}, o = [];
  for (const n of e.issues)
    n.path.length > 0 ? (i[n.path[0]] = i[n.path[0]] || [], i[n.path[0]].push(t(n))) : o.push(t(n));
  return { formErrors: o, fieldErrors: i };
}
function hp(e, t) {
  const i = t || function(r) {
    return r.message;
  }, o = { _errors: [] }, n = (r) => {
    for (const a of r.issues)
      if (a.code === "invalid_union" && a.errors.length)
        a.errors.map((s) => n({ issues: s }));
      else if (a.code === "invalid_key")
        n({ issues: a.issues });
      else if (a.code === "invalid_element")
        n({ issues: a.issues });
      else if (a.path.length === 0)
        o._errors.push(i(a));
      else {
        let s = o, u = 0;
        for (; u < a.path.length; ) {
          const l = a.path[u];
          u === a.path.length - 1 ? (s[l] = s[l] || { _errors: [] }, s[l]._errors.push(i(a))) : s[l] = s[l] || { _errors: [] }, s = s[l], u++;
        }
      }
  };
  return n(e), o;
}
const vp = (e) => (t, i, o, n) => {
  const r = o ? Object.assign(o, { async: !1 }) : { async: !1 }, a = t._zod.run({ value: i, issues: [] }, r);
  if (a instanceof Promise)
    throw new it();
  if (a.issues.length) {
    const s = new (n?.Err ?? e)(a.issues.map((u) => we(u, r, Ie())));
    throw $a(s, n?.callee), s;
  }
  return a.value;
}, $p = (e) => async (t, i, o, n) => {
  const r = o ? Object.assign(o, { async: !0 }) : { async: !0 };
  let a = t._zod.run({ value: i, issues: [] }, r);
  if (a instanceof Promise && (a = await a), a.issues.length) {
    const s = new (n?.Err ?? e)(a.issues.map((u) => we(u, r, Ie())));
    throw $a(s, n?.callee), s;
  }
  return a.value;
}, ka = (e) => (t, i, o) => {
  const n = o ? { ...o, async: !1 } : { async: !1 }, r = t._zod.run({ value: i, issues: [] }, n);
  if (r instanceof Promise)
    throw new it();
  return r.issues.length ? {
    success: !1,
    error: new (e ?? ba)(r.issues.map((a) => we(a, n, Ie())))
  } : { success: !0, data: r.value };
}, _p = /* @__PURE__ */ ka(ya), Ia = (e) => async (t, i, o) => {
  const n = o ? Object.assign(o, { async: !0 }) : { async: !0 };
  let r = t._zod.run({ value: i, issues: [] }, n);
  return r instanceof Promise && (r = await r), r.issues.length ? {
    success: !1,
    error: new e(r.issues.map((a) => we(a, n, Ie())))
  } : { success: !0, data: r.value };
}, bp = /* @__PURE__ */ Ia(ya), yp = /^[cC][^\s-]{8,}$/, kp = /^[0-9a-z]+$/, Ip = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, wp = /^[0-9a-vA-V]{20}$/, Sp = /^[A-Za-z0-9]{27}$/, xp = /^[a-zA-Z0-9_-]{21}$/, zp = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, Up = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, No = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/, Op = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, Zp = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function Pp() {
  return new RegExp(Zp, "u");
}
const Ep = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Np = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/, Dp = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, jp = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Tp = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, wa = /^[A-Za-z0-9_-]*$/, Ap = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/, Rp = /^\+(?:[0-9]){6,14}[0-9]$/, Sa = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", Cp = /* @__PURE__ */ new RegExp(`^${Sa}$`);
function xa(e) {
  const t = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof e.precision == "number" ? e.precision === -1 ? `${t}` : e.precision === 0 ? `${t}:[0-5]\\d` : `${t}:[0-5]\\d\\.\\d{${e.precision}}` : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function Mp(e) {
  return new RegExp(`^${xa(e)}$`);
}
function Lp(e) {
  const t = xa({ precision: e.precision }), i = ["Z"];
  e.local && i.push(""), e.offset && i.push("([+-]\\d{2}:\\d{2})");
  const o = `${t}(?:${i.join("|")})`;
  return new RegExp(`^${Sa}T(?:${o})$`);
}
const Fp = (e) => {
  const t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${t}$`);
}, Jp = /^\d+$/, qp = /^-?\d+(?:\.\d+)?/i, Wp = /true|false/i, Kp = /null/i, Vp = /^[^A-Z]*$/, Gp = /^[^a-z]*$/, oe = /* @__PURE__ */ h("$ZodCheck", (e, t) => {
  var i;
  e._zod ?? (e._zod = {}), e._zod.def = t, (i = e._zod).onattach ?? (i.onattach = []);
}), za = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, Ua = /* @__PURE__ */ h("$ZodCheckLessThan", (e, t) => {
  oe.init(e, t);
  const i = za[typeof t.value];
  e._zod.onattach.push((o) => {
    const n = o._zod.bag, r = (t.inclusive ? n.maximum : n.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    t.value < r && (t.inclusive ? n.maximum = t.value : n.exclusiveMaximum = t.value);
  }), e._zod.check = (o) => {
    (t.inclusive ? o.value <= t.value : o.value < t.value) || o.issues.push({
      origin: i,
      code: "too_big",
      maximum: t.value,
      input: o.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), Oa = /* @__PURE__ */ h("$ZodCheckGreaterThan", (e, t) => {
  oe.init(e, t);
  const i = za[typeof t.value];
  e._zod.onattach.push((o) => {
    const n = o._zod.bag, r = (t.inclusive ? n.minimum : n.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    t.value > r && (t.inclusive ? n.minimum = t.value : n.exclusiveMinimum = t.value);
  }), e._zod.check = (o) => {
    (t.inclusive ? o.value >= t.value : o.value > t.value) || o.issues.push({
      origin: i,
      code: "too_small",
      minimum: t.value,
      input: o.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), Bp = /* @__PURE__ */ h("$ZodCheckMultipleOf", (e, t) => {
  oe.init(e, t), e._zod.onattach.push((i) => {
    var o;
    (o = i._zod.bag).multipleOf ?? (o.multipleOf = t.value);
  }), e._zod.check = (i) => {
    if (typeof i.value != typeof t.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof i.value == "bigint" ? i.value % t.value === BigInt(0) : rp(i.value, t.value) === 0) || i.issues.push({
      origin: typeof i.value,
      code: "not_multiple_of",
      divisor: t.value,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Hp = /* @__PURE__ */ h("$ZodCheckNumberFormat", (e, t) => {
  oe.init(e, t), t.format = t.format || "float64";
  const i = t.format?.includes("int"), o = i ? "int" : "number", [n, r] = up[t.format];
  e._zod.onattach.push((a) => {
    const s = a._zod.bag;
    s.format = t.format, s.minimum = n, s.maximum = r, i && (s.pattern = Jp);
  }), e._zod.check = (a) => {
    const s = a.value;
    if (i) {
      if (!Number.isInteger(s)) {
        a.issues.push({
          expected: o,
          format: t.format,
          code: "invalid_type",
          input: s,
          inst: e
        });
        return;
      }
      if (!Number.isSafeInteger(s)) {
        s > 0 ? a.issues.push({
          input: s,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: o,
          continue: !t.abort
        }) : a.issues.push({
          input: s,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: o,
          continue: !t.abort
        });
        return;
      }
    }
    s < n && a.issues.push({
      origin: "number",
      input: s,
      code: "too_small",
      minimum: n,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    }), s > r && a.issues.push({
      origin: "number",
      input: s,
      code: "too_big",
      maximum: r,
      inst: e
    });
  };
}), Xp = /* @__PURE__ */ h("$ZodCheckMaxLength", (e, t) => {
  oe.init(e, t), e._zod.when = (i) => {
    const o = i.value;
    return !yi(o) && o.length !== void 0;
  }, e._zod.onattach.push((i) => {
    const o = i._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < o && (i._zod.bag.maximum = t.maximum);
  }), e._zod.check = (i) => {
    const o = i.value;
    if (o.length <= t.maximum)
      return;
    const r = Ii(o);
    i.issues.push({
      origin: r,
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: o,
      inst: e,
      continue: !t.abort
    });
  };
}), Yp = /* @__PURE__ */ h("$ZodCheckMinLength", (e, t) => {
  oe.init(e, t), e._zod.when = (i) => {
    const o = i.value;
    return !yi(o) && o.length !== void 0;
  }, e._zod.onattach.push((i) => {
    const o = i._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > o && (i._zod.bag.minimum = t.minimum);
  }), e._zod.check = (i) => {
    const o = i.value;
    if (o.length >= t.minimum)
      return;
    const r = Ii(o);
    i.issues.push({
      origin: r,
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: o,
      inst: e,
      continue: !t.abort
    });
  };
}), Qp = /* @__PURE__ */ h("$ZodCheckLengthEquals", (e, t) => {
  oe.init(e, t), e._zod.when = (i) => {
    const o = i.value;
    return !yi(o) && o.length !== void 0;
  }, e._zod.onattach.push((i) => {
    const o = i._zod.bag;
    o.minimum = t.length, o.maximum = t.length, o.length = t.length;
  }), e._zod.check = (i) => {
    const o = i.value, n = o.length;
    if (n === t.length)
      return;
    const r = Ii(o), a = n > t.length;
    i.issues.push({
      origin: r,
      ...a ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length },
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), dn = /* @__PURE__ */ h("$ZodCheckStringFormat", (e, t) => {
  var i;
  oe.init(e, t), e._zod.onattach.push((o) => {
    const n = o._zod.bag;
    n.format = t.format, t.pattern && (n.patterns ?? (n.patterns = /* @__PURE__ */ new Set()), n.patterns.add(t.pattern));
  }), (i = e._zod).check ?? (i.check = (o) => {
    if (!t.pattern)
      throw new Error("Not implemented.");
    t.pattern.lastIndex = 0, !t.pattern.test(o.value) && o.issues.push({
      origin: "string",
      code: "invalid_format",
      format: t.format,
      input: o.value,
      ...t.pattern ? { pattern: t.pattern.toString() } : {},
      inst: e,
      continue: !t.abort
    });
  });
}), ef = /* @__PURE__ */ h("$ZodCheckRegex", (e, t) => {
  dn.init(e, t), e._zod.check = (i) => {
    t.pattern.lastIndex = 0, !t.pattern.test(i.value) && i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: i.value,
      pattern: t.pattern.toString(),
      inst: e,
      continue: !t.abort
    });
  };
}), tf = /* @__PURE__ */ h("$ZodCheckLowerCase", (e, t) => {
  t.pattern ?? (t.pattern = Vp), dn.init(e, t);
}), nf = /* @__PURE__ */ h("$ZodCheckUpperCase", (e, t) => {
  t.pattern ?? (t.pattern = Gp), dn.init(e, t);
}), rf = /* @__PURE__ */ h("$ZodCheckIncludes", (e, t) => {
  oe.init(e, t);
  const i = ct(t.includes), o = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${i}` : i);
  t.pattern = o, e._zod.onattach.push((n) => {
    const r = n._zod.bag;
    r.patterns ?? (r.patterns = /* @__PURE__ */ new Set()), r.patterns.add(o);
  }), e._zod.check = (n) => {
    n.value.includes(t.includes, t.position) || n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: t.includes,
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), of = /* @__PURE__ */ h("$ZodCheckStartsWith", (e, t) => {
  oe.init(e, t);
  const i = new RegExp(`^${ct(t.prefix)}.*`);
  t.pattern ?? (t.pattern = i), e._zod.onattach.push((o) => {
    const n = o._zod.bag;
    n.patterns ?? (n.patterns = /* @__PURE__ */ new Set()), n.patterns.add(i);
  }), e._zod.check = (o) => {
    o.value.startsWith(t.prefix) || o.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: t.prefix,
      input: o.value,
      inst: e,
      continue: !t.abort
    });
  };
}), af = /* @__PURE__ */ h("$ZodCheckEndsWith", (e, t) => {
  oe.init(e, t);
  const i = new RegExp(`.*${ct(t.suffix)}$`);
  t.pattern ?? (t.pattern = i), e._zod.onattach.push((o) => {
    const n = o._zod.bag;
    n.patterns ?? (n.patterns = /* @__PURE__ */ new Set()), n.patterns.add(i);
  }), e._zod.check = (o) => {
    o.value.endsWith(t.suffix) || o.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: t.suffix,
      input: o.value,
      inst: e,
      continue: !t.abort
    });
  };
}), sf = /* @__PURE__ */ h("$ZodCheckOverwrite", (e, t) => {
  oe.init(e, t), e._zod.check = (i) => {
    i.value = t.tx(i.value);
  };
});
class uf {
  constructor(t = []) {
    this.content = [], this.indent = 0, this && (this.args = t);
  }
  indented(t) {
    this.indent += 1, t(this), this.indent -= 1;
  }
  write(t) {
    if (typeof t == "function") {
      t(this, { execution: "sync" }), t(this, { execution: "async" });
      return;
    }
    const o = t.split(`
`).filter((a) => a), n = Math.min(...o.map((a) => a.length - a.trimStart().length)), r = o.map((a) => a.slice(n)).map((a) => " ".repeat(this.indent * 2) + a);
    for (const a of r)
      this.content.push(a);
  }
  compile() {
    const t = Function, i = this?.args, n = [...(this?.content ?? [""]).map((r) => `  ${r}`)];
    return new t(...i, n.join(`
`));
  }
}
const lf = {
  major: 4,
  minor: 0,
  patch: 0
}, C = /* @__PURE__ */ h("$ZodType", (e, t) => {
  var i;
  e ?? (e = {}), L(e._zod, "id", () => t.type + "_" + va(10)), e._zod.def = t, e._zod.bag = e._zod.bag || {}, e._zod.version = lf;
  const o = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && o.unshift(e);
  for (const n of o)
    for (const r of n._zod.onattach)
      r(e);
  if (o.length === 0)
    (i = e._zod).deferred ?? (i.deferred = []), e._zod.deferred?.push(() => {
      e._zod.run = e._zod.parse;
    });
  else {
    const n = (r, a, s) => {
      let u = nt(r), l;
      for (const d of a) {
        if (d._zod.when) {
          if (!d._zod.when(r))
            continue;
        } else if (u)
          continue;
        const p = r.issues.length, g = d._zod.check(r);
        if (g instanceof Promise && s?.async === !1)
          throw new it();
        if (l || g instanceof Promise)
          l = (l ?? Promise.resolve()).then(async () => {
            await g, r.issues.length !== p && (u || (u = nt(r, p)));
          });
        else {
          if (r.issues.length === p)
            continue;
          u || (u = nt(r, p));
        }
      }
      return l ? l.then(() => r) : r;
    };
    e._zod.run = (r, a) => {
      const s = e._zod.parse(r, a);
      if (s instanceof Promise) {
        if (a.async === !1)
          throw new it();
        return s.then((u) => n(u, o, a));
      }
      return n(s, o, a);
    };
  }
  e["~standard"] = {
    validate: (n) => {
      try {
        const r = _p(e, n);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch {
        return bp(e, n).then((a) => a.success ? { value: a.data } : { issues: a.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
}), wi = /* @__PURE__ */ h("$ZodString", (e, t) => {
  C.init(e, t), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? Fp(e._zod.bag), e._zod.parse = (i, o) => {
    if (t.coerce)
      try {
        i.value = String(i.value);
      } catch {
      }
    return typeof i.value == "string" || i.issues.push({
      expected: "string",
      code: "invalid_type",
      input: i.value,
      inst: e
    }), i;
  };
}), F = /* @__PURE__ */ h("$ZodStringFormat", (e, t) => {
  dn.init(e, t), wi.init(e, t);
}), cf = /* @__PURE__ */ h("$ZodGUID", (e, t) => {
  t.pattern ?? (t.pattern = Up), F.init(e, t);
}), df = /* @__PURE__ */ h("$ZodUUID", (e, t) => {
  if (t.version) {
    const o = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[t.version];
    if (o === void 0)
      throw new Error(`Invalid UUID version: "${t.version}"`);
    t.pattern ?? (t.pattern = No(o));
  } else
    t.pattern ?? (t.pattern = No());
  F.init(e, t);
}), mf = /* @__PURE__ */ h("$ZodEmail", (e, t) => {
  t.pattern ?? (t.pattern = Op), F.init(e, t);
}), pf = /* @__PURE__ */ h("$ZodURL", (e, t) => {
  F.init(e, t), e._zod.check = (i) => {
    try {
      const o = new URL(i.value);
      t.hostname && (t.hostname.lastIndex = 0, t.hostname.test(o.hostname) || i.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: Ap.source,
        input: i.value,
        inst: e,
        continue: !t.abort
      })), t.protocol && (t.protocol.lastIndex = 0, t.protocol.test(o.protocol.endsWith(":") ? o.protocol.slice(0, -1) : o.protocol) || i.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: t.protocol.source,
        input: i.value,
        inst: e,
        continue: !t.abort
      }));
      return;
    } catch {
      i.issues.push({
        code: "invalid_format",
        format: "url",
        input: i.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), ff = /* @__PURE__ */ h("$ZodEmoji", (e, t) => {
  t.pattern ?? (t.pattern = Pp()), F.init(e, t);
}), gf = /* @__PURE__ */ h("$ZodNanoID", (e, t) => {
  t.pattern ?? (t.pattern = xp), F.init(e, t);
}), hf = /* @__PURE__ */ h("$ZodCUID", (e, t) => {
  t.pattern ?? (t.pattern = yp), F.init(e, t);
}), vf = /* @__PURE__ */ h("$ZodCUID2", (e, t) => {
  t.pattern ?? (t.pattern = kp), F.init(e, t);
}), $f = /* @__PURE__ */ h("$ZodULID", (e, t) => {
  t.pattern ?? (t.pattern = Ip), F.init(e, t);
}), _f = /* @__PURE__ */ h("$ZodXID", (e, t) => {
  t.pattern ?? (t.pattern = wp), F.init(e, t);
}), bf = /* @__PURE__ */ h("$ZodKSUID", (e, t) => {
  t.pattern ?? (t.pattern = Sp), F.init(e, t);
}), yf = /* @__PURE__ */ h("$ZodISODateTime", (e, t) => {
  t.pattern ?? (t.pattern = Lp(t)), F.init(e, t), e._zod.check;
}), kf = /* @__PURE__ */ h("$ZodISODate", (e, t) => {
  t.pattern ?? (t.pattern = Cp), F.init(e, t);
}), If = /* @__PURE__ */ h("$ZodISOTime", (e, t) => {
  t.pattern ?? (t.pattern = Mp(t)), F.init(e, t), e._zod.check;
}), wf = /* @__PURE__ */ h("$ZodISODuration", (e, t) => {
  t.pattern ?? (t.pattern = zp), F.init(e, t);
}), Sf = /* @__PURE__ */ h("$ZodIPv4", (e, t) => {
  t.pattern ?? (t.pattern = Ep), F.init(e, t), e._zod.onattach.push((i) => {
    const o = i._zod.bag;
    o.format = "ipv4";
  });
}), xf = /* @__PURE__ */ h("$ZodIPv6", (e, t) => {
  t.pattern ?? (t.pattern = Np), F.init(e, t), e._zod.onattach.push((i) => {
    const o = i._zod.bag;
    o.format = "ipv6";
  }), e._zod.check = (i) => {
    try {
      new URL(`http://[${i.value}]`);
    } catch {
      i.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: i.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), zf = /* @__PURE__ */ h("$ZodCIDRv4", (e, t) => {
  t.pattern ?? (t.pattern = Dp), F.init(e, t);
}), Uf = /* @__PURE__ */ h("$ZodCIDRv6", (e, t) => {
  t.pattern ?? (t.pattern = jp), F.init(e, t), e._zod.check = (i) => {
    const [o, n] = i.value.split("/");
    try {
      if (!n)
        throw new Error();
      const r = Number(n);
      if (`${r}` !== n)
        throw new Error();
      if (r < 0 || r > 128)
        throw new Error();
      new URL(`http://[${o}]`);
    } catch {
      i.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: i.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
});
function Za(e) {
  if (e === "")
    return !0;
  if (e.length % 4 !== 0)
    return !1;
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}
const Of = /* @__PURE__ */ h("$ZodBase64", (e, t) => {
  t.pattern ?? (t.pattern = Tp), F.init(e, t), e._zod.onattach.push((i) => {
    i._zod.bag.contentEncoding = "base64";
  }), e._zod.check = (i) => {
    Za(i.value) || i.issues.push({
      code: "invalid_format",
      format: "base64",
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
});
function Zf(e) {
  if (!wa.test(e))
    return !1;
  const t = e.replace(/[-_]/g, (o) => o === "-" ? "+" : "/"), i = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return Za(i);
}
const Pf = /* @__PURE__ */ h("$ZodBase64URL", (e, t) => {
  t.pattern ?? (t.pattern = wa), F.init(e, t), e._zod.onattach.push((i) => {
    i._zod.bag.contentEncoding = "base64url";
  }), e._zod.check = (i) => {
    Zf(i.value) || i.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Ef = /* @__PURE__ */ h("$ZodE164", (e, t) => {
  t.pattern ?? (t.pattern = Rp), F.init(e, t);
});
function Nf(e, t = null) {
  try {
    const i = e.split(".");
    if (i.length !== 3)
      return !1;
    const [o] = i, n = JSON.parse(atob(o));
    return !("typ" in n && n?.typ !== "JWT" || !n.alg || t && (!("alg" in n) || n.alg !== t));
  } catch {
    return !1;
  }
}
const Df = /* @__PURE__ */ h("$ZodJWT", (e, t) => {
  F.init(e, t), e._zod.check = (i) => {
    Nf(i.value, t.alg) || i.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Pa = /* @__PURE__ */ h("$ZodNumber", (e, t) => {
  C.init(e, t), e._zod.pattern = e._zod.bag.pattern ?? qp, e._zod.parse = (i, o) => {
    if (t.coerce)
      try {
        i.value = Number(i.value);
      } catch {
      }
    const n = i.value;
    if (typeof n == "number" && !Number.isNaN(n) && Number.isFinite(n))
      return i;
    const r = typeof n == "number" ? Number.isNaN(n) ? "NaN" : Number.isFinite(n) ? void 0 : "Infinity" : void 0;
    return i.issues.push({
      expected: "number",
      code: "invalid_type",
      input: n,
      inst: e,
      ...r ? { received: r } : {}
    }), i;
  };
}), jf = /* @__PURE__ */ h("$ZodNumber", (e, t) => {
  Hp.init(e, t), Pa.init(e, t);
}), Tf = /* @__PURE__ */ h("$ZodBoolean", (e, t) => {
  C.init(e, t), e._zod.pattern = Wp, e._zod.parse = (i, o) => {
    if (t.coerce)
      try {
        i.value = !!i.value;
      } catch {
      }
    const n = i.value;
    return typeof n == "boolean" || i.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input: n,
      inst: e
    }), i;
  };
}), Af = /* @__PURE__ */ h("$ZodNull", (e, t) => {
  C.init(e, t), e._zod.pattern = Kp, e._zod.values = /* @__PURE__ */ new Set([null]), e._zod.parse = (i, o) => {
    const { value: n } = i;
    return n === null || i.issues.push({
      expected: "null",
      code: "invalid_type",
      input: n,
      inst: e
    }), i;
  };
}), Rf = /* @__PURE__ */ h("$ZodUnknown", (e, t) => {
  C.init(e, t), e._zod.parse = (i) => i;
}), Cf = /* @__PURE__ */ h("$ZodNever", (e, t) => {
  C.init(e, t), e._zod.parse = (i, o) => (i.issues.push({
    expected: "never",
    code: "invalid_type",
    input: i.value,
    inst: e
  }), i);
});
function Do(e, t, i) {
  e.issues.length && t.issues.push(...Ze(i, e.issues)), t.value[i] = e.value;
}
const Mf = /* @__PURE__ */ h("$ZodArray", (e, t) => {
  C.init(e, t), e._zod.parse = (i, o) => {
    const n = i.value;
    if (!Array.isArray(n))
      return i.issues.push({
        expected: "array",
        code: "invalid_type",
        input: n,
        inst: e
      }), i;
    i.value = Array(n.length);
    const r = [];
    for (let a = 0; a < n.length; a++) {
      const s = n[a], u = t.element._zod.run({
        value: s,
        issues: []
      }, o);
      u instanceof Promise ? r.push(u.then((l) => Do(l, i, a))) : Do(u, i, a);
    }
    return r.length ? Promise.all(r).then(() => i) : i;
  };
});
function Jt(e, t, i) {
  e.issues.length && t.issues.push(...Ze(i, e.issues)), t.value[i] = e.value;
}
function jo(e, t, i, o) {
  e.issues.length ? o[i] === void 0 ? i in o ? t.value[i] = void 0 : t.value[i] = e.value : t.issues.push(...Ze(i, e.issues)) : e.value === void 0 ? i in o && (t.value[i] = void 0) : t.value[i] = e.value;
}
const Lf = /* @__PURE__ */ h("$ZodObject", (e, t) => {
  C.init(e, t);
  const i = bi(() => {
    const p = Object.keys(t.shape);
    for (const _ of p)
      if (!(t.shape[_] instanceof C))
        throw new Error(`Invalid element at key "${_}": expected a Zod schema`);
    const g = sp(t.shape);
    return {
      shape: t.shape,
      keys: p,
      keySet: new Set(p),
      numKeys: p.length,
      optionalKeys: new Set(g)
    };
  });
  L(e._zod, "propValues", () => {
    const p = t.shape, g = {};
    for (const _ in p) {
      const x = p[_]._zod;
      if (x.values) {
        g[_] ?? (g[_] = /* @__PURE__ */ new Set());
        for (const B of x.values)
          g[_].add(B);
      }
    }
    return g;
  });
  const o = (p) => {
    const g = new uf(["shape", "payload", "ctx"]), { keys: _, optionalKeys: x } = i.value, B = (D) => {
      const Z = Qe(D);
      return `shape[${Z}]._zod.run({ value: input[${Z}], issues: [] }, ctx)`;
    };
    g.write("const input = payload.value;");
    const $e = /* @__PURE__ */ Object.create(null);
    for (const D of _)
      $e[D] = va(15);
    g.write("const newResult = {}");
    for (const D of _)
      if (x.has(D)) {
        const Z = $e[D];
        g.write(`const ${Z} = ${B(D)};`);
        const N = Qe(D);
        g.write(`
        if (${Z}.issues.length) {
          if (input[${N}] === undefined) {
            if (${N} in input) {
              newResult[${N}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${Z}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${N}, ...iss.path] : [${N}],
              }))
            );
          }
        } else if (${Z}.value === undefined) {
          if (${N} in input) newResult[${N}] = undefined;
        } else {
          newResult[${N}] = ${Z}.value;
        }
        `);
      } else {
        const Z = $e[D];
        g.write(`const ${Z} = ${B(D)};`), g.write(`
          if (${Z}.issues.length) payload.issues = payload.issues.concat(${Z}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${Qe(D)}, ...iss.path] : [${Qe(D)}]
          })));`), g.write(`newResult[${Qe(D)}] = ${Z}.value`);
      }
    g.write("payload.value = newResult;"), g.write("return payload;");
    const Me = g.compile();
    return (D, Z) => Me(p, D, Z);
  };
  let n;
  const r = Xt, a = !ha.jitless, u = a && op.value, { catchall: l } = t;
  let d;
  e._zod.parse = (p, g) => {
    d ?? (d = i.value);
    const _ = p.value;
    if (!r(_))
      return p.issues.push({
        expected: "object",
        code: "invalid_type",
        input: _,
        inst: e
      }), p;
    const x = [];
    if (a && u && g?.async === !1 && g.jitless !== !0)
      n || (n = o(t.shape)), p = n(p, g);
    else {
      p.value = {};
      const Z = d.shape;
      for (const N of d.keys) {
        const Oe = Z[N], Lt = Oe._zod.run({ value: _[N], issues: [] }, g), Po = Oe._zod.optin === "optional" && Oe._zod.optout === "optional";
        Lt instanceof Promise ? x.push(Lt.then((Eo) => Po ? jo(Eo, p, N, _) : Jt(Eo, p, N))) : Po ? jo(Lt, p, N, _) : Jt(Lt, p, N);
      }
    }
    if (!l)
      return x.length ? Promise.all(x).then(() => p) : p;
    const B = [], $e = d.keySet, Me = l._zod, D = Me.def.type;
    for (const Z of Object.keys(_)) {
      if ($e.has(Z))
        continue;
      if (D === "never") {
        B.push(Z);
        continue;
      }
      const N = Me.run({ value: _[Z], issues: [] }, g);
      N instanceof Promise ? x.push(N.then((Oe) => Jt(Oe, p, Z))) : Jt(N, p, Z);
    }
    return B.length && p.issues.push({
      code: "unrecognized_keys",
      keys: B,
      input: _,
      inst: e
    }), x.length ? Promise.all(x).then(() => p) : p;
  };
});
function To(e, t, i, o) {
  for (const n of e)
    if (n.issues.length === 0)
      return t.value = n.value, t;
  return t.issues.push({
    code: "invalid_union",
    input: t.value,
    inst: i,
    errors: e.map((n) => n.issues.map((r) => we(r, o, Ie())))
  }), t;
}
const Ea = /* @__PURE__ */ h("$ZodUnion", (e, t) => {
  C.init(e, t), L(e._zod, "values", () => {
    if (t.options.every((i) => i._zod.values))
      return new Set(t.options.flatMap((i) => Array.from(i._zod.values)));
  }), L(e._zod, "pattern", () => {
    if (t.options.every((i) => i._zod.pattern)) {
      const i = t.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${i.map((o) => ki(o.source)).join("|")})$`);
    }
  }), e._zod.parse = (i, o) => {
    let n = !1;
    const r = [];
    for (const a of t.options) {
      const s = a._zod.run({
        value: i.value,
        issues: []
      }, o);
      if (s instanceof Promise)
        r.push(s), n = !0;
      else {
        if (s.issues.length === 0)
          return s;
        r.push(s);
      }
    }
    return n ? Promise.all(r).then((a) => To(a, i, e, o)) : To(r, i, e, o);
  };
}), Ff = /* @__PURE__ */ h("$ZodDiscriminatedUnion", (e, t) => {
  Ea.init(e, t);
  const i = e._zod.parse;
  L(e._zod, "propValues", () => {
    const n = {};
    for (const r of t.options) {
      const a = r._zod.propValues;
      if (!a || Object.keys(a).length === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(r)}"`);
      for (const [s, u] of Object.entries(a)) {
        n[s] || (n[s] = /* @__PURE__ */ new Set());
        for (const l of u)
          n[s].add(l);
      }
    }
    return n;
  });
  const o = bi(() => {
    const n = t.options, r = /* @__PURE__ */ new Map();
    for (const a of n) {
      const s = a._zod.propValues[t.discriminator];
      if (!s || s.size === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(a)}"`);
      for (const u of s) {
        if (r.has(u))
          throw new Error(`Duplicate discriminator value "${String(u)}"`);
        r.set(u, a);
      }
    }
    return r;
  });
  e._zod.parse = (n, r) => {
    const a = n.value;
    if (!Xt(a))
      return n.issues.push({
        code: "invalid_type",
        expected: "object",
        input: a,
        inst: e
      }), n;
    const s = o.value.get(a?.[t.discriminator]);
    return s ? s._zod.run(n, r) : t.unionFallback ? i(n, r) : (n.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      input: a,
      path: [t.discriminator],
      inst: e
    }), n);
  };
}), Jf = /* @__PURE__ */ h("$ZodIntersection", (e, t) => {
  C.init(e, t), e._zod.parse = (i, o) => {
    const { value: n } = i, r = t.left._zod.run({ value: n, issues: [] }, o), a = t.right._zod.run({ value: n, issues: [] }, o);
    return r instanceof Promise || a instanceof Promise ? Promise.all([r, a]).then(([u, l]) => Ao(i, u, l)) : Ao(i, r, a);
  };
});
function di(e, t) {
  if (e === t)
    return { valid: !0, data: e };
  if (e instanceof Date && t instanceof Date && +e == +t)
    return { valid: !0, data: e };
  if (ci(e) && ci(t)) {
    const i = Object.keys(t), o = Object.keys(e).filter((r) => i.indexOf(r) !== -1), n = { ...e, ...t };
    for (const r of o) {
      const a = di(e[r], t[r]);
      if (!a.valid)
        return {
          valid: !1,
          mergeErrorPath: [r, ...a.mergeErrorPath]
        };
      n[r] = a.data;
    }
    return { valid: !0, data: n };
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length)
      return { valid: !1, mergeErrorPath: [] };
    const i = [];
    for (let o = 0; o < e.length; o++) {
      const n = e[o], r = t[o], a = di(n, r);
      if (!a.valid)
        return {
          valid: !1,
          mergeErrorPath: [o, ...a.mergeErrorPath]
        };
      i.push(a.data);
    }
    return { valid: !0, data: i };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function Ao(e, t, i) {
  if (t.issues.length && e.issues.push(...t.issues), i.issues.length && e.issues.push(...i.issues), nt(e))
    return e;
  const o = di(t.value, i.value);
  if (!o.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(o.mergeErrorPath)}`);
  return e.value = o.data, e;
}
const qf = /* @__PURE__ */ h("$ZodRecord", (e, t) => {
  C.init(e, t), e._zod.parse = (i, o) => {
    const n = i.value;
    if (!ci(n))
      return i.issues.push({
        expected: "record",
        code: "invalid_type",
        input: n,
        inst: e
      }), i;
    const r = [];
    if (t.keyType._zod.values) {
      const a = t.keyType._zod.values;
      i.value = {};
      for (const u of a)
        if (typeof u == "string" || typeof u == "number" || typeof u == "symbol") {
          const l = t.valueType._zod.run({ value: n[u], issues: [] }, o);
          l instanceof Promise ? r.push(l.then((d) => {
            d.issues.length && i.issues.push(...Ze(u, d.issues)), i.value[u] = d.value;
          })) : (l.issues.length && i.issues.push(...Ze(u, l.issues)), i.value[u] = l.value);
        }
      let s;
      for (const u in n)
        a.has(u) || (s = s ?? [], s.push(u));
      s && s.length > 0 && i.issues.push({
        code: "unrecognized_keys",
        input: n,
        inst: e,
        keys: s
      });
    } else {
      i.value = {};
      for (const a of Reflect.ownKeys(n)) {
        if (a === "__proto__")
          continue;
        const s = t.keyType._zod.run({ value: a, issues: [] }, o);
        if (s instanceof Promise)
          throw new Error("Async schemas not supported in object keys currently");
        if (s.issues.length) {
          i.issues.push({
            origin: "record",
            code: "invalid_key",
            issues: s.issues.map((l) => we(l, o, Ie())),
            input: a,
            path: [a],
            inst: e
          }), i.value[s.value] = s.value;
          continue;
        }
        const u = t.valueType._zod.run({ value: n[a], issues: [] }, o);
        u instanceof Promise ? r.push(u.then((l) => {
          l.issues.length && i.issues.push(...Ze(a, l.issues)), i.value[s.value] = l.value;
        })) : (u.issues.length && i.issues.push(...Ze(a, u.issues)), i.value[s.value] = u.value);
      }
    }
    return r.length ? Promise.all(r).then(() => i) : i;
  };
}), Wf = /* @__PURE__ */ h("$ZodEnum", (e, t) => {
  C.init(e, t);
  const i = np(t.entries);
  e._zod.values = new Set(i), e._zod.pattern = new RegExp(`^(${i.filter((o) => ap.has(typeof o)).map((o) => typeof o == "string" ? ct(o) : o.toString()).join("|")})$`), e._zod.parse = (o, n) => {
    const r = o.value;
    return e._zod.values.has(r) || o.issues.push({
      code: "invalid_value",
      values: i,
      input: r,
      inst: e
    }), o;
  };
}), Kf = /* @__PURE__ */ h("$ZodLiteral", (e, t) => {
  C.init(e, t), e._zod.values = new Set(t.values), e._zod.pattern = new RegExp(`^(${t.values.map((i) => typeof i == "string" ? ct(i) : i ? i.toString() : String(i)).join("|")})$`), e._zod.parse = (i, o) => {
    const n = i.value;
    return e._zod.values.has(n) || i.issues.push({
      code: "invalid_value",
      values: t.values,
      input: n,
      inst: e
    }), i;
  };
}), Vf = /* @__PURE__ */ h("$ZodTransform", (e, t) => {
  C.init(e, t), e._zod.parse = (i, o) => {
    const n = t.transform(i.value, i);
    if (o.async)
      return (n instanceof Promise ? n : Promise.resolve(n)).then((a) => (i.value = a, i));
    if (n instanceof Promise)
      throw new it();
    return i.value = n, i;
  };
}), Gf = /* @__PURE__ */ h("$ZodOptional", (e, t) => {
  C.init(e, t), e._zod.optin = "optional", e._zod.optout = "optional", L(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, void 0]) : void 0), L(e._zod, "pattern", () => {
    const i = t.innerType._zod.pattern;
    return i ? new RegExp(`^(${ki(i.source)})?$`) : void 0;
  }), e._zod.parse = (i, o) => i.value === void 0 ? i : t.innerType._zod.run(i, o);
}), Bf = /* @__PURE__ */ h("$ZodNullable", (e, t) => {
  C.init(e, t), L(e._zod, "optin", () => t.innerType._zod.optin), L(e._zod, "optout", () => t.innerType._zod.optout), L(e._zod, "pattern", () => {
    const i = t.innerType._zod.pattern;
    return i ? new RegExp(`^(${ki(i.source)}|null)$`) : void 0;
  }), L(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, null]) : void 0), e._zod.parse = (i, o) => i.value === null ? i : t.innerType._zod.run(i, o);
}), Hf = /* @__PURE__ */ h("$ZodDefault", (e, t) => {
  C.init(e, t), e._zod.optin = "optional", L(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (i, o) => {
    if (i.value === void 0)
      return i.value = t.defaultValue, i;
    const n = t.innerType._zod.run(i, o);
    return n instanceof Promise ? n.then((r) => Ro(r, t)) : Ro(n, t);
  };
});
function Ro(e, t) {
  return e.value === void 0 && (e.value = t.defaultValue), e;
}
const Xf = /* @__PURE__ */ h("$ZodPrefault", (e, t) => {
  C.init(e, t), e._zod.optin = "optional", L(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (i, o) => (i.value === void 0 && (i.value = t.defaultValue), t.innerType._zod.run(i, o));
}), Yf = /* @__PURE__ */ h("$ZodNonOptional", (e, t) => {
  C.init(e, t), L(e._zod, "values", () => {
    const i = t.innerType._zod.values;
    return i ? new Set([...i].filter((o) => o !== void 0)) : void 0;
  }), e._zod.parse = (i, o) => {
    const n = t.innerType._zod.run(i, o);
    return n instanceof Promise ? n.then((r) => Co(r, e)) : Co(n, e);
  };
});
function Co(e, t) {
  return !e.issues.length && e.value === void 0 && e.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: e.value,
    inst: t
  }), e;
}
const Qf = /* @__PURE__ */ h("$ZodCatch", (e, t) => {
  C.init(e, t), L(e._zod, "optin", () => t.innerType._zod.optin), L(e._zod, "optout", () => t.innerType._zod.optout), L(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (i, o) => {
    const n = t.innerType._zod.run(i, o);
    return n instanceof Promise ? n.then((r) => (i.value = r.value, r.issues.length && (i.value = t.catchValue({
      ...i,
      error: {
        issues: r.issues.map((a) => we(a, o, Ie()))
      },
      input: i.value
    }), i.issues = []), i)) : (i.value = n.value, n.issues.length && (i.value = t.catchValue({
      ...i,
      error: {
        issues: n.issues.map((r) => we(r, o, Ie()))
      },
      input: i.value
    }), i.issues = []), i);
  };
}), eg = /* @__PURE__ */ h("$ZodPipe", (e, t) => {
  C.init(e, t), L(e._zod, "values", () => t.in._zod.values), L(e._zod, "optin", () => t.in._zod.optin), L(e._zod, "optout", () => t.out._zod.optout), e._zod.parse = (i, o) => {
    const n = t.in._zod.run(i, o);
    return n instanceof Promise ? n.then((r) => Mo(r, t, o)) : Mo(n, t, o);
  };
});
function Mo(e, t, i) {
  return nt(e) ? e : t.out._zod.run({ value: e.value, issues: e.issues }, i);
}
const tg = /* @__PURE__ */ h("$ZodReadonly", (e, t) => {
  C.init(e, t), L(e._zod, "propValues", () => t.innerType._zod.propValues), L(e._zod, "optin", () => t.innerType._zod.optin), L(e._zod, "optout", () => t.innerType._zod.optout), e._zod.parse = (i, o) => {
    const n = t.innerType._zod.run(i, o);
    return n instanceof Promise ? n.then(Lo) : Lo(n);
  };
});
function Lo(e) {
  return e.value = Object.freeze(e.value), e;
}
const ng = /* @__PURE__ */ h("$ZodCustom", (e, t) => {
  oe.init(e, t), C.init(e, t), e._zod.parse = (i, o) => i, e._zod.check = (i) => {
    const o = i.value, n = t.fn(o);
    if (n instanceof Promise)
      return n.then((r) => Fo(r, i, o, e));
    Fo(n, i, o, e);
  };
});
function Fo(e, t, i, o) {
  if (!e) {
    const n = {
      code: "custom",
      input: i,
      inst: o,
      // incorporates params.error into issue reporting
      path: [...o._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !o._zod.def.abort
      // params: inst._zod.def.params,
    };
    o._zod.def.params && (n.params = o._zod.def.params), t.issues.push(rt(n));
  }
}
class ig {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(t, ...i) {
    const o = i[0];
    if (this._map.set(t, o), o && typeof o == "object" && "id" in o) {
      if (this._idmap.has(o.id))
        throw new Error(`ID ${o.id} already exists in the registry`);
      this._idmap.set(o.id, t);
    }
    return this;
  }
  remove(t) {
    return this._map.delete(t), this;
  }
  get(t) {
    const i = t._zod.parent;
    if (i) {
      const o = { ...this.get(i) ?? {} };
      return delete o.id, { ...o, ...this._map.get(t) };
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
}
function rg() {
  return new ig();
}
const qt = /* @__PURE__ */ rg();
function og(e, t) {
  return new e({
    type: "string",
    ...k(t)
  });
}
function ag(e, t) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...k(t)
  });
}
function Jo(e, t) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...k(t)
  });
}
function sg(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...k(t)
  });
}
function ug(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...k(t)
  });
}
function lg(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...k(t)
  });
}
function cg(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...k(t)
  });
}
function dg(e, t) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...k(t)
  });
}
function mg(e, t) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...k(t)
  });
}
function pg(e, t) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...k(t)
  });
}
function fg(e, t) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...k(t)
  });
}
function gg(e, t) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...k(t)
  });
}
function hg(e, t) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...k(t)
  });
}
function vg(e, t) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...k(t)
  });
}
function $g(e, t) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...k(t)
  });
}
function _g(e, t) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...k(t)
  });
}
function bg(e, t) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...k(t)
  });
}
function yg(e, t) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...k(t)
  });
}
function kg(e, t) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...k(t)
  });
}
function Ig(e, t) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...k(t)
  });
}
function wg(e, t) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...k(t)
  });
}
function Sg(e, t) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...k(t)
  });
}
function xg(e, t) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...k(t)
  });
}
function zg(e, t) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...k(t)
  });
}
function Ug(e, t) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...k(t)
  });
}
function Og(e, t) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...k(t)
  });
}
function Zg(e, t) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...k(t)
  });
}
function Pg(e, t) {
  return new e({
    type: "number",
    checks: [],
    ...k(t)
  });
}
function Eg(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...k(t)
  });
}
function Ng(e, t) {
  return new e({
    type: "boolean",
    ...k(t)
  });
}
function Dg(e, t) {
  return new e({
    type: "null",
    ...k(t)
  });
}
function jg(e) {
  return new e({
    type: "unknown"
  });
}
function Tg(e, t) {
  return new e({
    type: "never",
    ...k(t)
  });
}
function qo(e, t) {
  return new Ua({
    check: "less_than",
    ...k(t),
    value: e,
    inclusive: !1
  });
}
function ui(e, t) {
  return new Ua({
    check: "less_than",
    ...k(t),
    value: e,
    inclusive: !0
  });
}
function Wo(e, t) {
  return new Oa({
    check: "greater_than",
    ...k(t),
    value: e,
    inclusive: !1
  });
}
function li(e, t) {
  return new Oa({
    check: "greater_than",
    ...k(t),
    value: e,
    inclusive: !0
  });
}
function Ko(e, t) {
  return new Bp({
    check: "multiple_of",
    ...k(t),
    value: e
  });
}
function Na(e, t) {
  return new Xp({
    check: "max_length",
    ...k(t),
    maximum: e
  });
}
function Yt(e, t) {
  return new Yp({
    check: "min_length",
    ...k(t),
    minimum: e
  });
}
function Da(e, t) {
  return new Qp({
    check: "length_equals",
    ...k(t),
    length: e
  });
}
function Ag(e, t) {
  return new ef({
    check: "string_format",
    format: "regex",
    ...k(t),
    pattern: e
  });
}
function Rg(e) {
  return new tf({
    check: "string_format",
    format: "lowercase",
    ...k(e)
  });
}
function Cg(e) {
  return new nf({
    check: "string_format",
    format: "uppercase",
    ...k(e)
  });
}
function Mg(e, t) {
  return new rf({
    check: "string_format",
    format: "includes",
    ...k(t),
    includes: e
  });
}
function Lg(e, t) {
  return new of({
    check: "string_format",
    format: "starts_with",
    ...k(t),
    prefix: e
  });
}
function Fg(e, t) {
  return new af({
    check: "string_format",
    format: "ends_with",
    ...k(t),
    suffix: e
  });
}
function dt(e) {
  return new sf({
    check: "overwrite",
    tx: e
  });
}
function Jg(e) {
  return dt((t) => t.normalize(e));
}
function qg() {
  return dt((e) => e.trim());
}
function Wg() {
  return dt((e) => e.toLowerCase());
}
function Kg() {
  return dt((e) => e.toUpperCase());
}
function Vg(e, t, i) {
  return new e({
    type: "array",
    element: t,
    // get element() {
    //   return element;
    // },
    ...k(i)
  });
}
function Gg(e, t, i) {
  const o = k(i);
  return o.abort ?? (o.abort = !0), new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...o
  });
}
function Bg(e, t, i) {
  return new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...k(i)
  });
}
const Hg = /* @__PURE__ */ h("ZodISODateTime", (e, t) => {
  yf.init(e, t), V.init(e, t);
});
function ja(e) {
  return zg(Hg, e);
}
const Xg = /* @__PURE__ */ h("ZodISODate", (e, t) => {
  kf.init(e, t), V.init(e, t);
});
function Yg(e) {
  return Ug(Xg, e);
}
const Qg = /* @__PURE__ */ h("ZodISOTime", (e, t) => {
  If.init(e, t), V.init(e, t);
});
function eh(e) {
  return Og(Qg, e);
}
const th = /* @__PURE__ */ h("ZodISODuration", (e, t) => {
  wf.init(e, t), V.init(e, t);
});
function nh(e) {
  return Zg(th, e);
}
const ih = (e, t) => {
  ba.init(e, t), e.name = "ZodError", Object.defineProperties(e, {
    format: {
      value: (i) => hp(e, i)
      // enumerable: false,
    },
    flatten: {
      value: (i) => gp(e, i)
      // enumerable: false,
    },
    addIssue: {
      value: (i) => e.issues.push(i)
      // enumerable: false,
    },
    addIssues: {
      value: (i) => e.issues.push(...i)
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return e.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, mn = h("ZodError", ih, {
  Parent: Error
}), rh = /* @__PURE__ */ vp(mn), oh = /* @__PURE__ */ $p(mn), ah = /* @__PURE__ */ ka(mn), sh = /* @__PURE__ */ Ia(mn), K = /* @__PURE__ */ h("ZodType", (e, t) => (C.init(e, t), e.def = t, Object.defineProperty(e, "_def", { value: t }), e.check = (...i) => e.clone(
  {
    ...t,
    checks: [
      ...t.checks ?? [],
      ...i.map((o) => typeof o == "function" ? { _zod: { check: o, def: { check: "custom" }, onattach: [] } } : o)
    ]
  }
  // { parent: true }
), e.clone = (i, o) => Te(e, i, o), e.brand = () => e, e.register = (i, o) => (i.add(e, o), e), e.parse = (i, o) => rh(e, i, o, { callee: e.parse }), e.safeParse = (i, o) => ah(e, i, o), e.parseAsync = async (i, o) => oh(e, i, o, { callee: e.parseAsync }), e.safeParseAsync = async (i, o) => sh(e, i, o), e.spa = e.safeParseAsync, e.refine = (i, o) => e.check(Xh(i, o)), e.superRefine = (i) => e.check(Yh(i)), e.overwrite = (i) => e.check(dt(i)), e.optional = () => G(e), e.nullable = () => Bo(e), e.nullish = () => G(Bo(e)), e.nonoptional = (i) => Jh(e, i), e.array = () => E(e), e.or = (i) => M([e, i]), e.and = (i) => Si(e, i), e.transform = (i) => pi(e, Fa(i)), e.default = (i) => Mh(e, i), e.prefault = (i) => Fh(e, i), e.catch = (i) => Wh(e, i), e.pipe = (i) => pi(e, i), e.readonly = () => Gh(e), e.describe = (i) => {
  const o = e.clone();
  return qt.add(o, { description: i }), o;
}, Object.defineProperty(e, "description", {
  get() {
    return qt.get(e)?.description;
  },
  configurable: !0
}), e.meta = (...i) => {
  if (i.length === 0)
    return qt.get(e);
  const o = e.clone();
  return qt.add(o, i[0]), o;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e)), Ta = /* @__PURE__ */ h("_ZodString", (e, t) => {
  wi.init(e, t), K.init(e, t);
  const i = e._zod.bag;
  e.format = i.format ?? null, e.minLength = i.minimum ?? null, e.maxLength = i.maximum ?? null, e.regex = (...o) => e.check(Ag(...o)), e.includes = (...o) => e.check(Mg(...o)), e.startsWith = (...o) => e.check(Lg(...o)), e.endsWith = (...o) => e.check(Fg(...o)), e.min = (...o) => e.check(Yt(...o)), e.max = (...o) => e.check(Na(...o)), e.length = (...o) => e.check(Da(...o)), e.nonempty = (...o) => e.check(Yt(1, ...o)), e.lowercase = (o) => e.check(Rg(o)), e.uppercase = (o) => e.check(Cg(o)), e.trim = () => e.check(qg()), e.normalize = (...o) => e.check(Jg(...o)), e.toLowerCase = () => e.check(Wg()), e.toUpperCase = () => e.check(Kg());
}), uh = /* @__PURE__ */ h("ZodString", (e, t) => {
  wi.init(e, t), Ta.init(e, t), e.email = (i) => e.check(ag(lh, i)), e.url = (i) => e.check(dg(ch, i)), e.jwt = (i) => e.check(xg(Sh, i)), e.emoji = (i) => e.check(mg(dh, i)), e.guid = (i) => e.check(Jo(Vo, i)), e.uuid = (i) => e.check(sg(Wt, i)), e.uuidv4 = (i) => e.check(ug(Wt, i)), e.uuidv6 = (i) => e.check(lg(Wt, i)), e.uuidv7 = (i) => e.check(cg(Wt, i)), e.nanoid = (i) => e.check(pg(mh, i)), e.guid = (i) => e.check(Jo(Vo, i)), e.cuid = (i) => e.check(fg(ph, i)), e.cuid2 = (i) => e.check(gg(fh, i)), e.ulid = (i) => e.check(hg(gh, i)), e.base64 = (i) => e.check(Ig(kh, i)), e.base64url = (i) => e.check(wg(Ih, i)), e.xid = (i) => e.check(vg(hh, i)), e.ksuid = (i) => e.check($g(vh, i)), e.ipv4 = (i) => e.check(_g($h, i)), e.ipv6 = (i) => e.check(bg(_h, i)), e.cidrv4 = (i) => e.check(yg(bh, i)), e.cidrv6 = (i) => e.check(kg(yh, i)), e.e164 = (i) => e.check(Sg(wh, i)), e.datetime = (i) => e.check(ja(i)), e.date = (i) => e.check(Yg(i)), e.time = (i) => e.check(eh(i)), e.duration = (i) => e.check(nh(i));
});
function f(e) {
  return og(uh, e);
}
const V = /* @__PURE__ */ h("ZodStringFormat", (e, t) => {
  F.init(e, t), Ta.init(e, t);
}), lh = /* @__PURE__ */ h("ZodEmail", (e, t) => {
  mf.init(e, t), V.init(e, t);
}), Vo = /* @__PURE__ */ h("ZodGUID", (e, t) => {
  cf.init(e, t), V.init(e, t);
}), Wt = /* @__PURE__ */ h("ZodUUID", (e, t) => {
  df.init(e, t), V.init(e, t);
}), ch = /* @__PURE__ */ h("ZodURL", (e, t) => {
  pf.init(e, t), V.init(e, t);
}), dh = /* @__PURE__ */ h("ZodEmoji", (e, t) => {
  ff.init(e, t), V.init(e, t);
}), mh = /* @__PURE__ */ h("ZodNanoID", (e, t) => {
  gf.init(e, t), V.init(e, t);
}), ph = /* @__PURE__ */ h("ZodCUID", (e, t) => {
  hf.init(e, t), V.init(e, t);
}), fh = /* @__PURE__ */ h("ZodCUID2", (e, t) => {
  vf.init(e, t), V.init(e, t);
}), gh = /* @__PURE__ */ h("ZodULID", (e, t) => {
  $f.init(e, t), V.init(e, t);
}), hh = /* @__PURE__ */ h("ZodXID", (e, t) => {
  _f.init(e, t), V.init(e, t);
}), vh = /* @__PURE__ */ h("ZodKSUID", (e, t) => {
  bf.init(e, t), V.init(e, t);
}), $h = /* @__PURE__ */ h("ZodIPv4", (e, t) => {
  Sf.init(e, t), V.init(e, t);
}), _h = /* @__PURE__ */ h("ZodIPv6", (e, t) => {
  xf.init(e, t), V.init(e, t);
}), bh = /* @__PURE__ */ h("ZodCIDRv4", (e, t) => {
  zf.init(e, t), V.init(e, t);
}), yh = /* @__PURE__ */ h("ZodCIDRv6", (e, t) => {
  Uf.init(e, t), V.init(e, t);
}), kh = /* @__PURE__ */ h("ZodBase64", (e, t) => {
  Of.init(e, t), V.init(e, t);
}), Ih = /* @__PURE__ */ h("ZodBase64URL", (e, t) => {
  Pf.init(e, t), V.init(e, t);
}), wh = /* @__PURE__ */ h("ZodE164", (e, t) => {
  Ef.init(e, t), V.init(e, t);
}), Sh = /* @__PURE__ */ h("ZodJWT", (e, t) => {
  Df.init(e, t), V.init(e, t);
}), Aa = /* @__PURE__ */ h("ZodNumber", (e, t) => {
  Pa.init(e, t), K.init(e, t), e.gt = (o, n) => e.check(Wo(o, n)), e.gte = (o, n) => e.check(li(o, n)), e.min = (o, n) => e.check(li(o, n)), e.lt = (o, n) => e.check(qo(o, n)), e.lte = (o, n) => e.check(ui(o, n)), e.max = (o, n) => e.check(ui(o, n)), e.int = (o) => e.check(Go(o)), e.safe = (o) => e.check(Go(o)), e.positive = (o) => e.check(Wo(0, o)), e.nonnegative = (o) => e.check(li(0, o)), e.negative = (o) => e.check(qo(0, o)), e.nonpositive = (o) => e.check(ui(0, o)), e.multipleOf = (o, n) => e.check(Ko(o, n)), e.step = (o, n) => e.check(Ko(o, n)), e.finite = () => e;
  const i = e._zod.bag;
  e.minValue = Math.max(i.minimum ?? Number.NEGATIVE_INFINITY, i.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(i.maximum ?? Number.POSITIVE_INFINITY, i.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (i.format ?? "").includes("int") || Number.isSafeInteger(i.multipleOf ?? 0.5), e.isFinite = !0, e.format = i.format ?? null;
});
function j(e) {
  return Pg(Aa, e);
}
const xh = /* @__PURE__ */ h("ZodNumberFormat", (e, t) => {
  jf.init(e, t), Aa.init(e, t);
});
function Go(e) {
  return Eg(xh, e);
}
const zh = /* @__PURE__ */ h("ZodBoolean", (e, t) => {
  Tf.init(e, t), K.init(e, t);
});
function H(e) {
  return Ng(zh, e);
}
const Uh = /* @__PURE__ */ h("ZodNull", (e, t) => {
  Af.init(e, t), K.init(e, t);
});
function Ra(e) {
  return Dg(Uh, e);
}
const Oh = /* @__PURE__ */ h("ZodUnknown", (e, t) => {
  Rf.init(e, t), K.init(e, t);
});
function q() {
  return jg(Oh);
}
const Zh = /* @__PURE__ */ h("ZodNever", (e, t) => {
  Cf.init(e, t), K.init(e, t);
});
function Ph(e) {
  return Tg(Zh, e);
}
const Eh = /* @__PURE__ */ h("ZodArray", (e, t) => {
  Mf.init(e, t), K.init(e, t), e.element = t.element, e.min = (i, o) => e.check(Yt(i, o)), e.nonempty = (i) => e.check(Yt(1, i)), e.max = (i, o) => e.check(Na(i, o)), e.length = (i, o) => e.check(Da(i, o)), e.unwrap = () => e.element;
});
function E(e, t) {
  return Vg(Eh, e, t);
}
const Ca = /* @__PURE__ */ h("ZodObject", (e, t) => {
  Lf.init(e, t), K.init(e, t), L(e, "shape", () => t.shape), e.keyof = () => ae(Object.keys(e._zod.def.shape)), e.catchall = (i) => e.clone({ ...e._zod.def, catchall: i }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: q() }), e.loose = () => e.clone({ ...e._zod.def, catchall: q() }), e.strict = () => e.clone({ ...e._zod.def, catchall: Ph() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (i) => dp(e, i), e.merge = (i) => mp(e, i), e.pick = (i) => lp(e, i), e.omit = (i) => cp(e, i), e.partial = (...i) => pp(Ja, e, i[0]), e.required = (...i) => fp(qa, e, i[0]);
});
function y(e, t) {
  const i = {
    type: "object",
    get shape() {
      return cn(this, "shape", { ...e }), this.shape;
    },
    ...k(t)
  };
  return new Ca(i);
}
function re(e, t) {
  return new Ca({
    type: "object",
    get shape() {
      return cn(this, "shape", { ...e }), this.shape;
    },
    catchall: q(),
    ...k(t)
  });
}
const Ma = /* @__PURE__ */ h("ZodUnion", (e, t) => {
  Ea.init(e, t), K.init(e, t), e.options = t.options;
});
function M(e, t) {
  return new Ma({
    type: "union",
    options: e,
    ...k(t)
  });
}
const Nh = /* @__PURE__ */ h("ZodDiscriminatedUnion", (e, t) => {
  Ma.init(e, t), Ff.init(e, t);
});
function La(e, t, i) {
  return new Nh({
    type: "union",
    options: t,
    discriminator: e,
    ...k(i)
  });
}
const Dh = /* @__PURE__ */ h("ZodIntersection", (e, t) => {
  Jf.init(e, t), K.init(e, t);
});
function Si(e, t) {
  return new Dh({
    type: "intersection",
    left: e,
    right: t
  });
}
const jh = /* @__PURE__ */ h("ZodRecord", (e, t) => {
  qf.init(e, t), K.init(e, t), e.keyType = t.keyType, e.valueType = t.valueType;
});
function W(e, t, i) {
  return new jh({
    type: "record",
    keyType: e,
    valueType: t,
    ...k(i)
  });
}
const mi = /* @__PURE__ */ h("ZodEnum", (e, t) => {
  Wf.init(e, t), K.init(e, t), e.enum = t.entries, e.options = Object.values(t.entries);
  const i = new Set(Object.keys(t.entries));
  e.extract = (o, n) => {
    const r = {};
    for (const a of o)
      if (i.has(a))
        r[a] = t.entries[a];
      else
        throw new Error(`Key ${a} not found in enum`);
    return new mi({
      ...t,
      checks: [],
      ...k(n),
      entries: r
    });
  }, e.exclude = (o, n) => {
    const r = { ...t.entries };
    for (const a of o)
      if (i.has(a))
        delete r[a];
      else
        throw new Error(`Key ${a} not found in enum`);
    return new mi({
      ...t,
      checks: [],
      ...k(n),
      entries: r
    });
  };
});
function ae(e, t) {
  const i = Array.isArray(e) ? Object.fromEntries(e.map((o) => [o, o])) : e;
  return new mi({
    type: "enum",
    entries: i,
    ...k(t)
  });
}
const Th = /* @__PURE__ */ h("ZodLiteral", (e, t) => {
  Kf.init(e, t), K.init(e, t), e.values = new Set(t.values), Object.defineProperty(e, "value", {
    get() {
      if (t.values.length > 1)
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return t.values[0];
    }
  });
});
function I(e, t) {
  return new Th({
    type: "literal",
    values: Array.isArray(e) ? e : [e],
    ...k(t)
  });
}
const Ah = /* @__PURE__ */ h("ZodTransform", (e, t) => {
  Vf.init(e, t), K.init(e, t), e._zod.parse = (i, o) => {
    i.addIssue = (r) => {
      if (typeof r == "string")
        i.issues.push(rt(r, i.value, t));
      else {
        const a = r;
        a.fatal && (a.continue = !1), a.code ?? (a.code = "custom"), a.input ?? (a.input = i.value), a.inst ?? (a.inst = e), a.continue ?? (a.continue = !0), i.issues.push(rt(a));
      }
    };
    const n = t.transform(i.value, i);
    return n instanceof Promise ? n.then((r) => (i.value = r, i)) : (i.value = n, i);
  };
});
function Fa(e) {
  return new Ah({
    type: "transform",
    transform: e
  });
}
const Ja = /* @__PURE__ */ h("ZodOptional", (e, t) => {
  Gf.init(e, t), K.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function G(e) {
  return new Ja({
    type: "optional",
    innerType: e
  });
}
const Rh = /* @__PURE__ */ h("ZodNullable", (e, t) => {
  Bf.init(e, t), K.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function Bo(e) {
  return new Rh({
    type: "nullable",
    innerType: e
  });
}
const Ch = /* @__PURE__ */ h("ZodDefault", (e, t) => {
  Hf.init(e, t), K.init(e, t), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function Mh(e, t) {
  return new Ch({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : t;
    }
  });
}
const Lh = /* @__PURE__ */ h("ZodPrefault", (e, t) => {
  Xf.init(e, t), K.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function Fh(e, t) {
  return new Lh({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : t;
    }
  });
}
const qa = /* @__PURE__ */ h("ZodNonOptional", (e, t) => {
  Yf.init(e, t), K.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function Jh(e, t) {
  return new qa({
    type: "nonoptional",
    innerType: e,
    ...k(t)
  });
}
const qh = /* @__PURE__ */ h("ZodCatch", (e, t) => {
  Qf.init(e, t), K.init(e, t), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function Wh(e, t) {
  return new qh({
    type: "catch",
    innerType: e,
    catchValue: typeof t == "function" ? t : () => t
  });
}
const Kh = /* @__PURE__ */ h("ZodPipe", (e, t) => {
  eg.init(e, t), K.init(e, t), e.in = t.in, e.out = t.out;
});
function pi(e, t) {
  return new Kh({
    type: "pipe",
    in: e,
    out: t
    // ...util.normalizeParams(params),
  });
}
const Vh = /* @__PURE__ */ h("ZodReadonly", (e, t) => {
  tg.init(e, t), K.init(e, t);
});
function Gh(e) {
  return new Vh({
    type: "readonly",
    innerType: e
  });
}
const Wa = /* @__PURE__ */ h("ZodCustom", (e, t) => {
  ng.init(e, t), K.init(e, t);
});
function Bh(e, t) {
  const i = new oe({
    check: "custom",
    ...k(t)
  });
  return i._zod.check = e, i;
}
function Hh(e, t) {
  return Gg(Wa, e ?? (() => !0), t);
}
function Xh(e, t = {}) {
  return Bg(Wa, e, t);
}
function Yh(e, t) {
  const i = Bh((o) => (o.addIssue = (n) => {
    if (typeof n == "string")
      o.issues.push(rt(n, o.value, i._zod.def));
    else {
      const r = n;
      r.fatal && (r.continue = !1), r.code ?? (r.code = "custom"), r.input ?? (r.input = o.value), r.inst ?? (r.inst = i), r.continue ?? (r.continue = !i._zod.def.abort), o.issues.push(rt(r));
    }
  }, e(o.value, o)), t);
  return i;
}
function Ka(e, t) {
  return pi(Fa(e), t);
}
const Qh = "io.modelcontextprotocol/related-task", pn = "2.0", X = Hh((e) => e !== null && (typeof e == "object" || typeof e == "function")), Va = M([f(), j().int()]), Ga = f();
re({
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: M([j(), Ra()]).optional(),
  /**
   * Time in milliseconds to wait between task status requests.
   */
  pollInterval: j().optional()
});
const ev = y({
  ttl: j().optional()
}), tv = y({
  taskId: f()
}), xi = re({
  /**
   * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
   */
  progressToken: Va.optional(),
  /**
   * If specified, this request is related to the provided task.
   */
  [Qh]: tv.optional()
}), se = y({
  /**
   * See [General fields: `_meta`](/specification/draft/basic/index#meta) for notes on `_meta` usage.
   */
  _meta: xi.optional()
}), fn = se.extend({
  /**
   * If specified, the caller is requesting task-augmented execution for this request.
   * The request will return a CreateTaskResult immediately, and the actual result can be
   * retrieved later via tasks/result.
   *
   * Task augmentation is subject to capability negotiation - receivers MUST declare support
   * for task augmentation of specific request types in their capabilities.
   */
  task: ev.optional()
}), Y = y({
  method: f(),
  params: se.loose().optional()
}), pe = y({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: xi.optional()
}), fe = y({
  method: f(),
  params: pe.loose().optional()
}), Q = re({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: xi.optional()
}), mt = M([f(), j().int()]), nv = y({
  jsonrpc: I(pn),
  id: mt,
  ...Y.shape
}).strict(), iv = y({
  jsonrpc: I(pn),
  ...fe.shape
}).strict(), Ba = y({
  jsonrpc: I(pn),
  id: mt,
  result: Q
}).strict();
var Ho;
(function(e) {
  e[e.ConnectionClosed = -32e3] = "ConnectionClosed", e[e.RequestTimeout = -32001] = "RequestTimeout", e[e.ParseError = -32700] = "ParseError", e[e.InvalidRequest = -32600] = "InvalidRequest", e[e.MethodNotFound = -32601] = "MethodNotFound", e[e.InvalidParams = -32602] = "InvalidParams", e[e.InternalError = -32603] = "InternalError", e[e.UrlElicitationRequired = -32042] = "UrlElicitationRequired";
})(Ho || (Ho = {}));
const Ha = y({
  jsonrpc: I(pn),
  id: mt.optional(),
  error: y({
    /**
     * The error type that occurred.
     */
    code: j().int(),
    /**
     * A short description of the error. The message SHOULD be limited to a concise single sentence.
     */
    message: f(),
    /**
     * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
     */
    data: q().optional()
  })
}).strict();
M([
  nv,
  iv,
  Ba,
  Ha
]);
M([Ba, Ha]);
const Xa = Q.strict(), rv = pe.extend({
  /**
   * The ID of the request to cancel.
   *
   * This MUST correspond to the ID of a request previously issued in the same direction.
   */
  requestId: mt.optional(),
  /**
   * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
   */
  reason: f().optional()
}), Ya = fe.extend({
  method: I("notifications/cancelled"),
  params: rv
}), ov = y({
  /**
   * URL or data URI for the icon.
   */
  src: f(),
  /**
   * Optional MIME type for the icon.
   */
  mimeType: f().optional(),
  /**
   * Optional array of strings that specify sizes at which the icon can be used.
   * Each string should be in WxH format (e.g., `"48x48"`, `"96x96"`) or `"any"` for scalable formats like SVG.
   *
   * If not provided, the client should assume that the icon can be used at any size.
   */
  sizes: E(f()).optional(),
  /**
   * Optional specifier for the theme this icon is designed for. `light` indicates
   * the icon is designed to be used with a light background, and `dark` indicates
   * the icon is designed to be used with a dark background.
   *
   * If not provided, the client should assume the icon can be used with any theme.
   */
  theme: ae(["light", "dark"]).optional()
}), pt = y({
  /**
   * Optional set of sized icons that the client can display in a user interface.
   *
   * Clients that support rendering icons MUST support at least the following MIME types:
   * - `image/png` - PNG images (safe, universal compatibility)
   * - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
   *
   * Clients that support rendering icons SHOULD also support:
   * - `image/svg+xml` - SVG images (scalable but requires security precautions)
   * - `image/webp` - WebP images (modern, efficient format)
   */
  icons: E(ov).optional()
}), Fe = y({
  /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */
  name: f(),
  /**
   * Intended for UI and end-user contexts  optimized to be human-readable and easily understood,
   * even by those unfamiliar with domain-specific terminology.
   *
   * If not provided, the name should be used for display (except for Tool,
   * where `annotations.title` should be given precedence over using `name`,
   * if present).
   */
  title: f().optional()
}), gn = Fe.extend({
  ...Fe.shape,
  ...pt.shape,
  version: f(),
  /**
   * An optional URL of the website for this implementation.
   */
  websiteUrl: f().optional(),
  /**
   * An optional human-readable description of what this implementation does.
   *
   * This can be used by clients or servers to provide context about their purpose
   * and capabilities. For example, a server might describe the types of resources
   * or tools it provides, while a client might describe its intended use case.
   */
  description: f().optional()
}), av = Si(y({
  applyDefaults: H().optional()
}), W(f(), q())), sv = Ka((e) => e && typeof e == "object" && !Array.isArray(e) && Object.keys(e).length === 0 ? { form: {} } : e, Si(y({
  form: av.optional(),
  url: X.optional()
}), W(f(), q()).optional())), uv = re({
  /**
   * Present if the client supports listing tasks.
   */
  list: X.optional(),
  /**
   * Present if the client supports cancelling tasks.
   */
  cancel: X.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: re({
    /**
     * Task support for sampling requests.
     */
    sampling: re({
      createMessage: X.optional()
    }).optional(),
    /**
     * Task support for elicitation requests.
     */
    elicitation: re({
      create: X.optional()
    }).optional()
  }).optional()
}), lv = re({
  /**
   * Present if the server supports listing tasks.
   */
  list: X.optional(),
  /**
   * Present if the server supports cancelling tasks.
   */
  cancel: X.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: re({
    /**
     * Task support for tool requests.
     */
    tools: re({
      call: X.optional()
    }).optional()
  }).optional()
}), cv = y({
  /**
   * Experimental, non-standard capabilities that the client supports.
   */
  experimental: W(f(), X).optional(),
  /**
   * Present if the client supports sampling from an LLM.
   */
  sampling: y({
    /**
     * Present if the client supports context inclusion via includeContext parameter.
     * If not declared, servers SHOULD only use `includeContext: "none"` (or omit it).
     */
    context: X.optional(),
    /**
     * Present if the client supports tool use via tools and toolChoice parameters.
     */
    tools: X.optional()
  }).optional(),
  /**
   * Present if the client supports eliciting user input.
   */
  elicitation: sv.optional(),
  /**
   * Present if the client supports listing roots.
   */
  roots: y({
    /**
     * Whether the client supports issuing notifications for changes to the roots list.
     */
    listChanged: H().optional()
  }).optional(),
  /**
   * Present if the client supports task creation.
   */
  tasks: uv.optional()
}), dv = se.extend({
  /**
   * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
   */
  protocolVersion: f(),
  capabilities: cv,
  clientInfo: gn
}), mv = Y.extend({
  method: I("initialize"),
  params: dv
}), pv = y({
  /**
   * Experimental, non-standard capabilities that the server supports.
   */
  experimental: W(f(), X).optional(),
  /**
   * Present if the server supports sending log messages to the client.
   */
  logging: X.optional(),
  /**
   * Present if the server supports sending completions to the client.
   */
  completions: X.optional(),
  /**
   * Present if the server offers any prompt templates.
   */
  prompts: y({
    /**
     * Whether this server supports issuing notifications for changes to the prompt list.
     */
    listChanged: H().optional()
  }).optional(),
  /**
   * Present if the server offers any resources to read.
   */
  resources: y({
    /**
     * Whether this server supports clients subscribing to resource updates.
     */
    subscribe: H().optional(),
    /**
     * Whether this server supports issuing notifications for changes to the resource list.
     */
    listChanged: H().optional()
  }).optional(),
  /**
   * Present if the server offers any tools to call.
   */
  tools: y({
    /**
     * Whether this server supports issuing notifications for changes to the tool list.
     */
    listChanged: H().optional()
  }).optional(),
  /**
   * Present if the server supports task creation.
   */
  tasks: lv.optional()
}), fv = Q.extend({
  /**
   * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
   */
  protocolVersion: f(),
  capabilities: pv,
  serverInfo: gn,
  /**
   * Instructions describing how to use the server and its features.
   *
   * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
   */
  instructions: f().optional()
}), gv = fe.extend({
  method: I("notifications/initialized"),
  params: pe.optional()
}), Qa = Y.extend({
  method: I("ping"),
  params: se.optional()
}), hv = y({
  /**
   * The progress thus far. This should increase every time progress is made, even if the total is unknown.
   */
  progress: j(),
  /**
   * Total number of items to process (or total progress required), if known.
   */
  total: G(j()),
  /**
   * An optional message describing the current progress.
   */
  message: G(f())
}), vv = y({
  ...pe.shape,
  ...hv.shape,
  /**
   * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
   */
  progressToken: Va
}), es = fe.extend({
  method: I("notifications/progress"),
  params: vv
}), $v = se.extend({
  /**
   * An opaque token representing the current pagination position.
   * If provided, the server should return results starting after this cursor.
   */
  cursor: Ga.optional()
}), ft = Y.extend({
  params: $v.optional()
}), gt = Q.extend({
  /**
   * An opaque token representing the pagination position after the last returned result.
   * If present, there may be more results available.
   */
  nextCursor: Ga.optional()
}), _v = ae(["working", "input_required", "completed", "failed", "cancelled"]), ht = y({
  taskId: f(),
  status: _v,
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: M([j(), Ra()]),
  /**
   * ISO 8601 timestamp when the task was created.
   */
  createdAt: f(),
  /**
   * ISO 8601 timestamp when the task was last updated.
   */
  lastUpdatedAt: f(),
  pollInterval: G(j()),
  /**
   * Optional diagnostic message for failed tasks or other status information.
   */
  statusMessage: G(f())
}), ts = Q.extend({
  task: ht
}), bv = pe.merge(ht), ns = fe.extend({
  method: I("notifications/tasks/status"),
  params: bv
}), is = Y.extend({
  method: I("tasks/get"),
  params: se.extend({
    taskId: f()
  })
}), rs = Q.merge(ht), os = Y.extend({
  method: I("tasks/result"),
  params: se.extend({
    taskId: f()
  })
});
Q.loose();
const as = ft.extend({
  method: I("tasks/list")
}), ss = gt.extend({
  tasks: E(ht)
}), us = Y.extend({
  method: I("tasks/cancel"),
  params: se.extend({
    taskId: f()
  })
});
Q.merge(ht);
const ls = y({
  /**
   * The URI of this resource.
   */
  uri: f(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: G(f()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: W(f(), q()).optional()
}), cs = ls.extend({
  /**
   * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
   */
  text: f()
}), zi = f().refine((e) => {
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}, { message: "Invalid Base64 string" }), ds = ls.extend({
  /**
   * A base64-encoded string representing the binary data of the item.
   */
  blob: zi
}), vt = ae(["user", "assistant"]), He = y({
  /**
   * Intended audience(s) for the resource.
   */
  audience: E(vt).optional(),
  /**
   * Importance hint for the resource, from 0 (least) to 1 (most).
   */
  priority: j().min(0).max(1).optional(),
  /**
   * ISO 8601 timestamp for the most recent modification.
   */
  lastModified: ja({ offset: !0 }).optional()
}), ms = y({
  ...Fe.shape,
  ...pt.shape,
  /**
   * The URI of this resource.
   */
  uri: f(),
  /**
   * A description of what this resource represents.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: G(f()),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: G(f()),
  /**
   * Optional annotations for the client.
   */
  annotations: He.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: G(re({}))
}), yv = y({
  ...Fe.shape,
  ...pt.shape,
  /**
   * A URI template (according to RFC 6570) that can be used to construct resource URIs.
   */
  uriTemplate: f(),
  /**
   * A description of what this template is for.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: G(f()),
  /**
   * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
   */
  mimeType: G(f()),
  /**
   * Optional annotations for the client.
   */
  annotations: He.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: G(re({}))
}), kv = ft.extend({
  method: I("resources/list")
}), Iv = gt.extend({
  resources: E(ms)
}), wv = ft.extend({
  method: I("resources/templates/list")
}), Sv = gt.extend({
  resourceTemplates: E(yv)
}), Ui = se.extend({
  /**
   * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
   *
   * @format uri
   */
  uri: f()
}), xv = Ui, zv = Y.extend({
  method: I("resources/read"),
  params: xv
}), Uv = Q.extend({
  contents: E(M([cs, ds]))
}), Ov = fe.extend({
  method: I("notifications/resources/list_changed"),
  params: pe.optional()
}), Zv = Ui, Pv = Y.extend({
  method: I("resources/subscribe"),
  params: Zv
}), Ev = Ui, Nv = Y.extend({
  method: I("resources/unsubscribe"),
  params: Ev
}), Dv = pe.extend({
  /**
   * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
   */
  uri: f()
}), jv = fe.extend({
  method: I("notifications/resources/updated"),
  params: Dv
}), Tv = y({
  /**
   * The name of the argument.
   */
  name: f(),
  /**
   * A human-readable description of the argument.
   */
  description: G(f()),
  /**
   * Whether this argument must be provided.
   */
  required: G(H())
}), Av = y({
  ...Fe.shape,
  ...pt.shape,
  /**
   * An optional description of what this prompt provides
   */
  description: G(f()),
  /**
   * A list of arguments to use for templating the prompt.
   */
  arguments: G(E(Tv)),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: G(re({}))
}), Rv = ft.extend({
  method: I("prompts/list")
}), Cv = gt.extend({
  prompts: E(Av)
}), Mv = se.extend({
  /**
   * The name of the prompt or prompt template.
   */
  name: f(),
  /**
   * Arguments to use for templating the prompt.
   */
  arguments: W(f(), f()).optional()
}), Lv = Y.extend({
  method: I("prompts/get"),
  params: Mv
}), Oi = y({
  type: I("text"),
  /**
   * The text content of the message.
   */
  text: f(),
  /**
   * Optional annotations for the client.
   */
  annotations: He.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: W(f(), q()).optional()
}), Zi = y({
  type: I("image"),
  /**
   * The base64-encoded image data.
   */
  data: zi,
  /**
   * The MIME type of the image. Different providers may support different image types.
   */
  mimeType: f(),
  /**
   * Optional annotations for the client.
   */
  annotations: He.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: W(f(), q()).optional()
}), Pi = y({
  type: I("audio"),
  /**
   * The base64-encoded audio data.
   */
  data: zi,
  /**
   * The MIME type of the audio. Different providers may support different audio types.
   */
  mimeType: f(),
  /**
   * Optional annotations for the client.
   */
  annotations: He.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: W(f(), q()).optional()
}), Fv = y({
  type: I("tool_use"),
  /**
   * The name of the tool to invoke.
   * Must match a tool name from the request's tools array.
   */
  name: f(),
  /**
   * Unique identifier for this tool call.
   * Used to correlate with ToolResultContent in subsequent messages.
   */
  id: f(),
  /**
   * Arguments to pass to the tool.
   * Must conform to the tool's inputSchema.
   */
  input: W(f(), q()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: W(f(), q()).optional()
}), Jv = y({
  type: I("resource"),
  resource: M([cs, ds]),
  /**
   * Optional annotations for the client.
   */
  annotations: He.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: W(f(), q()).optional()
}), qv = ms.extend({
  type: I("resource_link")
}), hn = M([
  Oi,
  Zi,
  Pi,
  qv,
  Jv
]), Wv = y({
  role: vt,
  content: hn
}), Kv = Q.extend({
  /**
   * An optional description for the prompt.
   */
  description: f().optional(),
  messages: E(Wv)
}), Vv = fe.extend({
  method: I("notifications/prompts/list_changed"),
  params: pe.optional()
}), Gv = y({
  /**
   * A human-readable title for the tool.
   */
  title: f().optional(),
  /**
   * If true, the tool does not modify its environment.
   *
   * Default: false
   */
  readOnlyHint: H().optional(),
  /**
   * If true, the tool may perform destructive updates to its environment.
   * If false, the tool performs only additive updates.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: true
   */
  destructiveHint: H().optional(),
  /**
   * If true, calling the tool repeatedly with the same arguments
   * will have no additional effect on the its environment.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: false
   */
  idempotentHint: H().optional(),
  /**
   * If true, this tool may interact with an "open world" of external
   * entities. If false, the tool's domain of interaction is closed.
   * For example, the world of a web search tool is open, whereas that
   * of a memory tool is not.
   *
   * Default: true
   */
  openWorldHint: H().optional()
}), Bv = y({
  /**
   * Indicates the tool's preference for task-augmented execution.
   * - "required": Clients MUST invoke the tool as a task
   * - "optional": Clients MAY invoke the tool as a task or normal request
   * - "forbidden": Clients MUST NOT attempt to invoke the tool as a task
   *
   * If not present, defaults to "forbidden".
   */
  taskSupport: ae(["required", "optional", "forbidden"]).optional()
}), Ei = y({
  ...Fe.shape,
  ...pt.shape,
  /**
   * A human-readable description of the tool.
   */
  description: f().optional(),
  /**
   * A JSON Schema 2020-12 object defining the expected parameters for the tool.
   * Must have type: 'object' at the root level per MCP spec.
   */
  inputSchema: y({
    type: I("object"),
    properties: W(f(), X).optional(),
    required: E(f()).optional()
  }).catchall(q()),
  /**
   * An optional JSON Schema 2020-12 object defining the structure of the tool's output
   * returned in the structuredContent field of a CallToolResult.
   * Must have type: 'object' at the root level per MCP spec.
   */
  outputSchema: y({
    type: I("object"),
    properties: W(f(), X).optional(),
    required: E(f()).optional()
  }).catchall(q()).optional(),
  /**
   * Optional additional tool information.
   */
  annotations: Gv.optional(),
  /**
   * Execution-related properties for this tool.
   */
  execution: Bv.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: W(f(), q()).optional()
}), Hv = ft.extend({
  method: I("tools/list")
}), Xv = gt.extend({
  tools: E(Ei)
}), Ni = Q.extend({
  /**
   * A list of content objects that represent the result of the tool call.
   *
   * If the Tool does not define an outputSchema, this field MUST be present in the result.
   * For backwards compatibility, this field is always present, but it may be empty.
   */
  content: E(hn).default([]),
  /**
   * An object containing structured tool output.
   *
   * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
   */
  structuredContent: W(f(), q()).optional(),
  /**
   * Whether the tool call ended in an error.
   *
   * If not set, this is assumed to be false (the call was successful).
   *
   * Any errors that originate from the tool SHOULD be reported inside the result
   * object, with `isError` set to true, _not_ as an MCP protocol-level error
   * response. Otherwise, the LLM would not be able to see that an error occurred
   * and self-correct.
   *
   * However, any errors in _finding_ the tool, an error indicating that the
   * server does not support tool calls, or any other exceptional conditions,
   * should be reported as an MCP error response.
   */
  isError: H().optional()
});
Ni.or(Q.extend({
  toolResult: q()
}));
const Yv = fn.extend({
  /**
   * The name of the tool to call.
   */
  name: f(),
  /**
   * Arguments to pass to the tool.
   */
  arguments: W(f(), q()).optional()
}), Qv = Y.extend({
  method: I("tools/call"),
  params: Yv
}), e$ = fe.extend({
  method: I("notifications/tools/list_changed"),
  params: pe.optional()
});
y({
  /**
   * If true, the list will be refreshed automatically when a list changed notification is received.
   * The callback will be called with the updated list.
   *
   * If false, the callback will be called with null items, allowing manual refresh.
   *
   * @default true
   */
  autoRefresh: H().default(!0),
  /**
   * Debounce time in milliseconds for list changed notification processing.
   *
   * Multiple notifications received within this timeframe will only trigger one refresh.
   * Set to 0 to disable debouncing.
   *
   * @default 300
   */
  debounceMs: j().int().nonnegative().default(300)
});
const ps = ae(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]), t$ = se.extend({
  /**
   * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
   */
  level: ps
}), n$ = Y.extend({
  method: I("logging/setLevel"),
  params: t$
}), i$ = pe.extend({
  /**
   * The severity of this log message.
   */
  level: ps,
  /**
   * An optional name of the logger issuing this message.
   */
  logger: f().optional(),
  /**
   * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
   */
  data: q()
}), r$ = fe.extend({
  method: I("notifications/message"),
  params: i$
}), o$ = y({
  /**
   * A hint for a model name.
   */
  name: f().optional()
}), a$ = y({
  /**
   * Optional hints to use for model selection.
   */
  hints: E(o$).optional(),
  /**
   * How much to prioritize cost when selecting a model.
   */
  costPriority: j().min(0).max(1).optional(),
  /**
   * How much to prioritize sampling speed (latency) when selecting a model.
   */
  speedPriority: j().min(0).max(1).optional(),
  /**
   * How much to prioritize intelligence and capabilities when selecting a model.
   */
  intelligencePriority: j().min(0).max(1).optional()
}), s$ = y({
  /**
   * Controls when tools are used:
   * - "auto": Model decides whether to use tools (default)
   * - "required": Model MUST use at least one tool before completing
   * - "none": Model MUST NOT use any tools
   */
  mode: ae(["auto", "required", "none"]).optional()
}), u$ = y({
  type: I("tool_result"),
  toolUseId: f().describe("The unique identifier for the corresponding tool call."),
  content: E(hn).default([]),
  structuredContent: y({}).loose().optional(),
  isError: H().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: W(f(), q()).optional()
}), l$ = La("type", [Oi, Zi, Pi]), Qt = La("type", [
  Oi,
  Zi,
  Pi,
  Fv,
  u$
]), c$ = y({
  role: vt,
  content: M([Qt, E(Qt)]),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: W(f(), q()).optional()
}), d$ = fn.extend({
  messages: E(c$),
  /**
   * The server's preferences for which model to select. The client MAY modify or omit this request.
   */
  modelPreferences: a$.optional(),
  /**
   * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
   */
  systemPrompt: f().optional(),
  /**
   * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt.
   * The client MAY ignore this request.
   *
   * Default is "none". Values "thisServer" and "allServers" are soft-deprecated. Servers SHOULD only use these values if the client
   * declares ClientCapabilities.sampling.context. These values may be removed in future spec releases.
   */
  includeContext: ae(["none", "thisServer", "allServers"]).optional(),
  temperature: j().optional(),
  /**
   * The requested maximum number of tokens to sample (to prevent runaway completions).
   *
   * The client MAY choose to sample fewer tokens than the requested maximum.
   */
  maxTokens: j().int(),
  stopSequences: E(f()).optional(),
  /**
   * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
   */
  metadata: X.optional(),
  /**
   * Tools that the model may use during generation.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   */
  tools: E(Ei).optional(),
  /**
   * Controls how the model uses tools.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   * Default is `{ mode: "auto" }`.
   */
  toolChoice: s$.optional()
}), m$ = Y.extend({
  method: I("sampling/createMessage"),
  params: d$
}), p$ = Q.extend({
  /**
   * The name of the model that generated the message.
   */
  model: f(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: G(ae(["endTurn", "stopSequence", "maxTokens"]).or(f())),
  role: vt,
  /**
   * Response content. Single content block (text, image, or audio).
   */
  content: l$
}), f$ = Q.extend({
  /**
   * The name of the model that generated the message.
   */
  model: f(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   * - "toolUse": The model wants to use one or more tools
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: G(ae(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(f())),
  role: vt,
  /**
   * Response content. May be a single block or array. May include ToolUseContent if stopReason is "toolUse".
   */
  content: M([Qt, E(Qt)])
}), g$ = y({
  type: I("boolean"),
  title: f().optional(),
  description: f().optional(),
  default: H().optional()
}), h$ = y({
  type: I("string"),
  title: f().optional(),
  description: f().optional(),
  minLength: j().optional(),
  maxLength: j().optional(),
  format: ae(["email", "uri", "date", "date-time"]).optional(),
  default: f().optional()
}), v$ = y({
  type: ae(["number", "integer"]),
  title: f().optional(),
  description: f().optional(),
  minimum: j().optional(),
  maximum: j().optional(),
  default: j().optional()
}), $$ = y({
  type: I("string"),
  title: f().optional(),
  description: f().optional(),
  enum: E(f()),
  default: f().optional()
}), _$ = y({
  type: I("string"),
  title: f().optional(),
  description: f().optional(),
  oneOf: E(y({
    const: f(),
    title: f()
  })),
  default: f().optional()
}), b$ = y({
  type: I("string"),
  title: f().optional(),
  description: f().optional(),
  enum: E(f()),
  enumNames: E(f()).optional(),
  default: f().optional()
}), y$ = M([$$, _$]), k$ = y({
  type: I("array"),
  title: f().optional(),
  description: f().optional(),
  minItems: j().optional(),
  maxItems: j().optional(),
  items: y({
    type: I("string"),
    enum: E(f())
  }),
  default: E(f()).optional()
}), I$ = y({
  type: I("array"),
  title: f().optional(),
  description: f().optional(),
  minItems: j().optional(),
  maxItems: j().optional(),
  items: y({
    anyOf: E(y({
      const: f(),
      title: f()
    }))
  }),
  default: E(f()).optional()
}), w$ = M([k$, I$]), S$ = M([b$, y$, w$]), x$ = M([S$, g$, h$, v$]), z$ = fn.extend({
  /**
   * The elicitation mode.
   *
   * Optional for backward compatibility. Clients MUST treat missing mode as "form".
   */
  mode: I("form").optional(),
  /**
   * The message to present to the user describing what information is being requested.
   */
  message: f(),
  /**
   * A restricted subset of JSON Schema.
   * Only top-level properties are allowed, without nesting.
   */
  requestedSchema: y({
    type: I("object"),
    properties: W(f(), x$),
    required: E(f()).optional()
  })
}), U$ = fn.extend({
  /**
   * The elicitation mode.
   */
  mode: I("url"),
  /**
   * The message to present to the user explaining why the interaction is needed.
   */
  message: f(),
  /**
   * The ID of the elicitation, which must be unique within the context of the server.
   * The client MUST treat this ID as an opaque value.
   */
  elicitationId: f(),
  /**
   * The URL that the user should navigate to.
   */
  url: f().url()
}), O$ = M([z$, U$]), Z$ = Y.extend({
  method: I("elicitation/create"),
  params: O$
}), P$ = pe.extend({
  /**
   * The ID of the elicitation that completed.
   */
  elicitationId: f()
}), E$ = fe.extend({
  method: I("notifications/elicitation/complete"),
  params: P$
}), N$ = Q.extend({
  /**
   * The user action in response to the elicitation.
   * - "accept": User submitted the form/confirmed the action
   * - "decline": User explicitly decline the action
   * - "cancel": User dismissed without making an explicit choice
   */
  action: ae(["accept", "decline", "cancel"]),
  /**
   * The submitted form data, only present when action is "accept".
   * Contains values matching the requested schema.
   * Per MCP spec, content is "typically omitted" for decline/cancel actions.
   * We normalize null to undefined for leniency while maintaining type compatibility.
   */
  content: Ka((e) => e === null ? void 0 : e, W(f(), M([f(), j(), H(), E(f())])).optional())
}), D$ = y({
  type: I("ref/resource"),
  /**
   * The URI or URI template of the resource.
   */
  uri: f()
}), j$ = y({
  type: I("ref/prompt"),
  /**
   * The name of the prompt or prompt template
   */
  name: f()
}), T$ = se.extend({
  ref: M([j$, D$]),
  /**
   * The argument's information
   */
  argument: y({
    /**
     * The name of the argument
     */
    name: f(),
    /**
     * The value of the argument to use for completion matching.
     */
    value: f()
  }),
  context: y({
    /**
     * Previously-resolved variables in a URI template or prompt.
     */
    arguments: W(f(), f()).optional()
  }).optional()
}), A$ = Y.extend({
  method: I("completion/complete"),
  params: T$
}), R$ = Q.extend({
  completion: re({
    /**
     * An array of completion values. Must not exceed 100 items.
     */
    values: E(f()).max(100),
    /**
     * The total number of completion options available. This can exceed the number of values actually sent in the response.
     */
    total: G(j().int()),
    /**
     * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
     */
    hasMore: G(H())
  })
}), C$ = y({
  /**
   * The URI identifying the root. This *must* start with file:// for now.
   */
  uri: f().startsWith("file://"),
  /**
   * An optional name for the root.
   */
  name: f().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: W(f(), q()).optional()
}), M$ = Y.extend({
  method: I("roots/list"),
  params: se.optional()
}), L$ = Q.extend({
  roots: E(C$)
}), F$ = fe.extend({
  method: I("notifications/roots/list_changed"),
  params: pe.optional()
});
M([
  Qa,
  mv,
  A$,
  n$,
  Lv,
  Rv,
  kv,
  wv,
  zv,
  Pv,
  Nv,
  Qv,
  Hv,
  is,
  os,
  as,
  us
]);
M([
  Ya,
  es,
  gv,
  F$,
  ns
]);
M([
  Xa,
  p$,
  f$,
  N$,
  L$,
  rs,
  ss,
  ts
]);
M([
  Qa,
  m$,
  Z$,
  M$,
  is,
  os,
  as,
  us
]);
M([
  Ya,
  es,
  r$,
  jv,
  Ov,
  e$,
  Vv,
  ns,
  E$
]);
M([
  Xa,
  fv,
  R$,
  Kv,
  Cv,
  Iv,
  Sv,
  Uv,
  Ni,
  Xv,
  rs,
  ss,
  ts
]);
new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
var J$ = Object.defineProperty, be = (e, t) => {
  for (var i in t) J$(e, i, { get: t[i], enumerable: !0, configurable: !0, set: (o) => t[i] = () => o });
}, c = {};
be(c, { xor: () => Zm, xid: () => Qd, void: () => wm, uuidv7: () => Wd, uuidv6: () => qd, uuidv4: () => Jd, uuid: () => Fd, util: () => P, url: () => Kd, uppercase: () => Sn, unknown: () => je, union: () => ti, undefined: () => km, ulid: () => Yd, uint64: () => bm, uint32: () => vm, tuple: () => to, trim: () => Pn, treeifyError: () => Us, transform: () => ii, toUpperCase: () => Nn, toLowerCase: () => En, toJSONSchema: () => bd, templateLiteral: () => Jm, symbol: () => ym, superRefine: () => Oo, success: () => Mm, stringbool: () => Hm, stringFormat: () => cm, string: () => sn, strictObject: () => Um, startsWith: () => zn, slugify: () => Dn, size: () => zt, setErrorMap: () => ck, set: () => jm, safeParseAsync: () => Pd, safeParse: () => Zd, safeEncodeAsync: () => Rd, safeEncode: () => Td, safeDecodeAsync: () => Cd, safeDecode: () => Ad, registry: () => or, regexes: () => Re, regex: () => In, refine: () => Uo, record: () => no, readonly: () => ko, property: () => Zr, promise: () => qm, prettifyError: () => Zs, preprocess: () => Ym, prefault: () => go, positive: () => xr, pipe: () => lt, partialRecord: () => Em, parseAsync: () => Od, parse: () => Ud, overwrite: () => ke, optional: () => st, object: () => zm, number: () => Cr, nullish: () => Cm, nullable: () => ut, null: () => qr, normalize: () => Zn, nonpositive: () => Ur, nonoptional: () => ho, nonnegative: () => Or, never: () => Qn, negative: () => zr, nativeEnum: () => Tm, nanoid: () => Bd, nan: () => Lm, multipleOf: () => We, minSize: () => ze, minLength: () => De, mime: () => On, meta: () => Gm, maxSize: () => Xe, maxLength: () => Ut, map: () => Dm, mac: () => nm, lte: () => de, lt: () => Se, lowercase: () => wn, looseRecord: () => Nm, looseObject: () => Om, locales: () => rr, literal: () => Am, length: () => Ot, lazy: () => So, ksuid: () => em, keyof: () => xm, jwt: () => lm, json: () => Xm, iso: () => Nr, ipv6: () => im, ipv4: () => tm, intersection: () => Qr, int64: () => _m, int32: () => hm, int: () => un, instanceof: () => Bm, includes: () => xn, httpUrl: () => Vd, hostname: () => dm, hex: () => mm, hash: () => pm, guid: () => Ld, gte: () => ie, gt: () => xe, globalRegistry: () => ce, getErrorMap: () => dk, function: () => ln, fromJSONSchema: () => gk, formatError: () => Ri, float64: () => gm, float32: () => fm, flattenError: () => Ai, file: () => Rm, exactOptional: () => lo, enum: () => ni, endsWith: () => Un, encodeAsync: () => Dd, encode: () => Ed, emoji: () => Gd, email: () => Md, e164: () => um, discriminatedUnion: () => Pm, describe: () => Vm, decodeAsync: () => jd, decode: () => Nd, date: () => Sm, custom: () => Km, cuid2: () => Xd, cuid: () => Hd, core: () => fs, config: () => te, coerce: () => ep, codec: () => Fm, clone: () => ge, cidrv6: () => om, cidrv4: () => rm, check: () => Wm, catch: () => _o, boolean: () => Mr, bigint: () => $m, base64url: () => sm, base64: () => am, array: () => Tt, any: () => Im, _function: () => ln, _default: () => po, _ZodString: () => jn, ZodXor: () => Hr, ZodXID: () => Fn, ZodVoid: () => Gr, ZodUnknown: () => Kr, ZodUnion: () => Rt, ZodUndefined: () => Fr, ZodUUID: () => ve, ZodURL: () => Et, ZodULID: () => Ln, ZodType: () => U, ZodTuple: () => eo, ZodTransform: () => so, ZodTemplateLiteral: () => Io, ZodSymbol: () => Lr, ZodSuccess: () => vo, ZodStringFormat: () => R, ZodString: () => Pt, ZodSet: () => ro, ZodRecord: () => Ct, ZodRealError: () => le, ZodReadonly: () => yo, ZodPromise: () => xo, ZodPrefault: () => fo, ZodPipe: () => ai, ZodOptional: () => ri, ZodObject: () => At, ZodNumberFormat: () => Ce, ZodNumber: () => Nt, ZodNullable: () => co, ZodNull: () => Jr, ZodNonOptional: () => oi, ZodNever: () => Vr, ZodNanoID: () => Rn, ZodNaN: () => bo, ZodMap: () => io, ZodMAC: () => Rr, ZodLiteral: () => oo, ZodLazy: () => wo, ZodKSUID: () => Jn, ZodJWT: () => Xn, ZodIssueCode: () => lk, ZodIntersection: () => Yr, ZodISOTime: () => Tr, ZodISODuration: () => Ar, ZodISODateTime: () => Dr, ZodISODate: () => jr, ZodIPv6: () => Wn, ZodIPv4: () => qn, ZodGUID: () => at, ZodFunction: () => zo, ZodFirstPartyTypeKind: () => _i, ZodFile: () => ao, ZodExactOptional: () => uo, ZodError: () => uk, ZodEnum: () => Be, ZodEmoji: () => An, ZodEmail: () => Tn, ZodE164: () => Hn, ZodDiscriminatedUnion: () => Xr, ZodDefault: () => mo, ZodDate: () => ei, ZodCustomStringFormat: () => Ye, ZodCustom: () => Mt, ZodCodec: () => si, ZodCatch: () => $o, ZodCUID2: () => Mn, ZodCUID: () => Cn, ZodCIDRv6: () => Vn, ZodCIDRv4: () => Kn, ZodBoolean: () => Dt, ZodBigIntFormat: () => Yn, ZodBigInt: () => jt, ZodBase64URL: () => Bn, ZodBase64: () => Gn, ZodArray: () => Br, ZodAny: () => Wr, TimePrecision: () => Ql, NEVER: () => gs, $output: () => Vl, $input: () => Gl, $brand: () => hs });
var fs = {};
be(fs, { version: () => Zu, util: () => P, treeifyError: () => Us, toJSONSchema: () => bd, toDotPath: () => Os, safeParseAsync: () => Es, safeParse: () => Ps, safeEncodeAsync: () => k_, safeEncode: () => b_, safeDecodeAsync: () => I_, safeDecode: () => y_, registry: () => or, regexes: () => Re, process: () => T, prettifyError: () => Zs, parseAsync: () => hi, parse: () => gi, meta: () => Dc, locales: () => rr, isValidJWT: () => tl, isValidBase64URL: () => Yu, isValidBase64: () => Xi, initializeContext: () => Ke, globalRegistry: () => ce, globalConfig: () => en, formatError: () => Ri, flattenError: () => Ai, finalize: () => Ge, extractDefs: () => Ve, encodeAsync: () => $_, encode: () => h_, describe: () => Nc, decodeAsync: () => __, decode: () => v_, createToJSONSchemaMethod: () => Tc, createStandardJSONSchemaMethod: () => ot, config: () => te, clone: () => ge, _xor: () => Ay, _xid: () => hr, _void: () => Ic, _uuidv7: () => cr, _uuidv6: () => lr, _uuidv4: () => ur, _uuid: () => sr, _url: () => kn, _uppercase: () => Sn, _unknown: () => yc, _union: () => Ty, _undefined: () => $c, _ulid: () => gr, _uint64: () => hc, _uint32: () => cc, _tuple: () => My, _trim: () => Pn, _transform: () => Vy, _toUpperCase: () => Nn, _toLowerCase: () => En, _templateLiteral: () => nk, _symbol: () => vc, _superRefine: () => Pc, _success: () => Yy, _stringbool: () => jc, _stringFormat: () => Zt, _string: () => Hl, _startsWith: () => zn, _slugify: () => Dn, _size: () => zt, _set: () => Jy, _safeParseAsync: () => kt, _safeParse: () => yt, _safeEncodeAsync: () => Wi, _safeEncode: () => Ji, _safeDecodeAsync: () => Ki, _safeDecode: () => qi, _regex: () => In, _refine: () => Zc, _record: () => Ly, _readonly: () => tk, _property: () => Zr, _promise: () => rk, _positive: () => xr, _pipe: () => ek, _parseAsync: () => bt, _parse: () => _t, _overwrite: () => ke, _optional: () => Gy, _number: () => rc, _nullable: () => By, _null: () => _c, _normalize: () => Zn, _nonpositive: () => Ur, _nonoptional: () => Xy, _nonnegative: () => Or, _never: () => kc, _negative: () => zr, _nativeEnum: () => Wy, _nanoid: () => mr, _nan: () => xc, _multipleOf: () => We, _minSize: () => ze, _minLength: () => De, _min: () => ie, _mime: () => On, _maxSize: () => Xe, _maxLength: () => Ut, _max: () => de, _map: () => Fy, _mac: () => Yl, _lte: () => de, _lt: () => Se, _lowercase: () => wn, _literal: () => Ky, _length: () => Ot, _lazy: () => ik, _ksuid: () => vr, _jwt: () => Sr, _isoTime: () => nc, _isoDuration: () => ic, _isoDateTime: () => ec, _isoDate: () => tc, _ipv6: () => _r, _ipv4: () => $r, _intersection: () => Cy, _int64: () => gc, _int32: () => lc, _int: () => ac, _includes: () => xn, _guid: () => an, _gte: () => ie, _gt: () => xe, _float64: () => uc, _float32: () => sc, _file: () => Uc, _enum: () => qy, _endsWith: () => Un, _encodeAsync: () => Li, _encode: () => Ci, _emoji: () => dr, _email: () => ar, _e164: () => wr, _discriminatedUnion: () => Ry, _default: () => Hy, _decodeAsync: () => Fi, _decode: () => Mi, _date: () => wc, _custom: () => Oc, _cuid2: () => fr, _cuid: () => pr, _coercedString: () => Xl, _coercedNumber: () => oc, _coercedDate: () => Sc, _coercedBoolean: () => mc, _coercedBigint: () => fc, _cidrv6: () => yr, _cidrv4: () => br, _check: () => Ec, _catch: () => Qy, _boolean: () => dc, _bigint: () => pc, _base64url: () => Ir, _base64: () => kr, _array: () => zc, _any: () => bc, TimePrecision: () => Ql, NEVER: () => gs, JSONSchemaGenerator: () => ak, JSONSchema: () => sk, Doc: () => Ou, $output: () => Vl, $input: () => Gl, $constructor: () => m, $brand: () => hs, $ZodXor: () => _l, $ZodXID: () => Mu, $ZodVoid: () => ml, $ZodUnknown: () => cl, $ZodUnion: () => yn, $ZodUndefined: () => sl, $ZodUUID: () => Eu, $ZodURL: () => Du, $ZodULID: () => Cu, $ZodType: () => z, $ZodTuple: () => tr, $ZodTransform: () => Ul, $ZodTemplateLiteral: () => Cl, $ZodSymbol: () => al, $ZodSuccess: () => Dl, $ZodStringFormat: () => A, $ZodString: () => xt, $ZodSet: () => wl, $ZodRegistry: () => Bl, $ZodRecord: () => kl, $ZodRealError: () => ue, $ZodReadonly: () => Rl, $ZodPromise: () => Ll, $ZodPrefault: () => El, $ZodPipe: () => Al, $ZodOptional: () => nr, $ZodObjectJIT: () => $l, $ZodObject: () => vl, $ZodNumberFormat: () => rl, $ZodNumber: () => Yi, $ZodNullable: () => Zl, $ZodNull: () => ul, $ZodNonOptional: () => Nl, $ZodNever: () => dl, $ZodNanoID: () => Tu, $ZodNaN: () => Tl, $ZodMap: () => Il, $ZodMAC: () => Gu, $ZodLiteral: () => xl, $ZodLazy: () => Fl, $ZodKSUID: () => Lu, $ZodJWT: () => nl, $ZodIntersection: () => yl, $ZodISOTime: () => qu, $ZodISODuration: () => Wu, $ZodISODateTime: () => Fu, $ZodISODate: () => Ju, $ZodIPv6: () => Vu, $ZodIPv4: () => Ku, $ZodGUID: () => Pu, $ZodFunction: () => Ml, $ZodFile: () => zl, $ZodExactOptional: () => Ol, $ZodError: () => Ti, $ZodEnum: () => Sl, $ZodEncodeError: () => vn, $ZodEmoji: () => ju, $ZodEmail: () => Nu, $ZodE164: () => el, $ZodDiscriminatedUnion: () => bl, $ZodDefault: () => Pl, $ZodDate: () => pl, $ZodCustomStringFormat: () => il, $ZodCustom: () => Jl, $ZodCodec: () => ir, $ZodCheckUpperCase: () => ku, $ZodCheckStringFormat: () => St, $ZodCheckStartsWith: () => wu, $ZodCheckSizeEquals: () => hu, $ZodCheckRegex: () => bu, $ZodCheckProperty: () => xu, $ZodCheckOverwrite: () => Uu, $ZodCheckNumberFormat: () => mu, $ZodCheckMultipleOf: () => du, $ZodCheckMinSize: () => gu, $ZodCheckMinLength: () => $u, $ZodCheckMimeType: () => zu, $ZodCheckMaxSize: () => fu, $ZodCheckMaxLength: () => vu, $ZodCheckLowerCase: () => yu, $ZodCheckLessThan: () => Bi, $ZodCheckLengthEquals: () => _u, $ZodCheckIncludes: () => Iu, $ZodCheckGreaterThan: () => Hi, $ZodCheckEndsWith: () => Su, $ZodCheckBigIntFormat: () => pu, $ZodCheck: () => J, $ZodCatch: () => jl, $ZodCUID2: () => Ru, $ZodCUID: () => Au, $ZodCIDRv6: () => Hu, $ZodCIDRv4: () => Bu, $ZodBoolean: () => Qi, $ZodBigIntFormat: () => ol, $ZodBigInt: () => er, $ZodBase64URL: () => Qu, $ZodBase64: () => Xu, $ZodAsyncError: () => Ee, $ZodArray: () => fl, $ZodAny: () => ll });
var gs = Object.freeze({ status: "aborted" });
function m(e, t, i) {
  function o(s, u) {
    if (s._zod || Object.defineProperty(s, "_zod", { value: { def: u, constr: a, traits: /* @__PURE__ */ new Set() }, enumerable: !1 }), s._zod.traits.has(e)) return;
    s._zod.traits.add(e), t(s, u);
    let l = a.prototype, d = Object.keys(l);
    for (let p = 0; p < d.length; p++) {
      let g = d[p];
      g in s || (s[g] = l[g].bind(s));
    }
  }
  let n = i?.Parent ?? Object;
  class r extends n {
  }
  Object.defineProperty(r, "name", { value: e });
  function a(s) {
    var u;
    let l = i?.Parent ? new r() : this;
    o(l, s), (u = l._zod).deferred ?? (u.deferred = []);
    for (let d of l._zod.deferred) d();
    return l;
  }
  return Object.defineProperty(a, "init", { value: o }), Object.defineProperty(a, Symbol.hasInstance, { value: (s) => i?.Parent && s instanceof i.Parent ? !0 : s?._zod?.traits?.has(e) }), Object.defineProperty(a, "name", { value: e }), a;
}
var hs = Symbol("zod_brand");
class Ee extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
class vn extends Error {
  constructor(t) {
    super(`Encountered unidirectional transform during encode: ${t}`), this.name = "ZodEncodeError";
  }
}
var en = {};
function te(e) {
  return e && Object.assign(en, e), en;
}
var P = {};
be(P, { unwrapMessage: () => tt, uint8ArrayToHex: () => f_, uint8ArrayToBase64url: () => m_, uint8ArrayToBase64: () => xs, stringifyPrimitive: () => w, slugify: () => $s, shallowClone: () => bs, safeExtend: () => a_, required: () => l_, randomString: () => Q$, propertyKeyTypes: () => nn, promiseAllObject: () => Y$, primitiveTypes: () => ys, prefixIssues: () => he, pick: () => i_, partial: () => u_, parsedType: () => S, optionalKeys: () => ks, omit: () => r_, objectClone: () => B$, numKeys: () => e_, nullish: () => Ae, normalizeParams: () => $, mergeDefs: () => ye, merge: () => s_, jsonStringifyReplacer: () => tn, joinValues: () => v, issue: () => rn, isPlainObject: () => Ne, isObject: () => Je, hexToUint8Array: () => p_, getSizableOrigin: () => _n, getParsedType: () => t_, getLengthableOrigin: () => bn, getEnumValues: () => Di, getElementAtPath: () => X$, floatSafeRemainder: () => vs, finalizeIssue: () => me, extend: () => o_, escapeRegex: () => _e, esc: () => fi, defineLazy: () => O, createTransparentProxy: () => n_, cloneDef: () => H$, clone: () => ge, cleanRegex: () => $n, cleanEnum: () => c_, captureStackTrace: () => ji, cached: () => $t, base64urlToUint8Array: () => d_, base64ToUint8Array: () => Ss, assignProp: () => Ue, assertNotEqual: () => W$, assertNever: () => V$, assertIs: () => K$, assertEqual: () => q$, assert: () => G$, allowsEval: () => _s, aborted: () => Pe, NUMBER_FORMAT_RANGES: () => Is, Class: () => g_, BIGINT_FORMAT_RANGES: () => ws });
function q$(e) {
  return e;
}
function W$(e) {
  return e;
}
function K$(e) {
}
function V$(e) {
  throw Error("Unexpected value in exhaustive check");
}
function G$(e) {
}
function Di(e) {
  let t = Object.values(e).filter((i) => typeof i == "number");
  return Object.entries(e).filter(([i, o]) => t.indexOf(+i) === -1).map(([i, o]) => o);
}
function v(e, t = "|") {
  return e.map((i) => w(i)).join(t);
}
function tn(e, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function $t(e) {
  return { get value() {
    {
      let t = e();
      return Object.defineProperty(this, "value", { value: t }), t;
    }
  } };
}
function Ae(e) {
  return e == null;
}
function $n(e) {
  let t = e.startsWith("^") ? 1 : 0, i = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(t, i);
}
function vs(e, t) {
  let i = (e.toString().split(".")[1] || "").length, o = t.toString(), n = (o.split(".")[1] || "").length;
  if (n === 0 && /\d?e-\d?/.test(o)) {
    let u = o.match(/\d?e-(\d?)/);
    u?.[1] && (n = Number.parseInt(u[1]));
  }
  let r = i > n ? i : n, a = Number.parseInt(e.toFixed(r).replace(".", "")), s = Number.parseInt(t.toFixed(r).replace(".", ""));
  return a % s / 10 ** r;
}
var Xo = Symbol("evaluating");
function O(e, t, i) {
  let o;
  Object.defineProperty(e, t, { get() {
    if (o !== Xo)
      return o === void 0 && (o = Xo, o = i()), o;
  }, set(n) {
    Object.defineProperty(e, t, { value: n });
  }, configurable: !0 });
}
function B$(e) {
  return Object.create(Object.getPrototypeOf(e), Object.getOwnPropertyDescriptors(e));
}
function Ue(e, t, i) {
  Object.defineProperty(e, t, { value: i, writable: !0, enumerable: !0, configurable: !0 });
}
function ye(...e) {
  let t = {};
  for (let i of e) {
    let o = Object.getOwnPropertyDescriptors(i);
    Object.assign(t, o);
  }
  return Object.defineProperties({}, t);
}
function H$(e) {
  return ye(e._zod.def);
}
function X$(e, t) {
  return t ? t.reduce((i, o) => i?.[o], e) : e;
}
function Y$(e) {
  let t = Object.keys(e), i = t.map((o) => e[o]);
  return Promise.all(i).then((o) => {
    let n = {};
    for (let r = 0; r < t.length; r++) n[t[r]] = o[r];
    return n;
  });
}
function Q$(e = 10) {
  let t = "";
  for (let i = 0; i < e; i++) t += "abcdefghijklmnopqrstuvwxyz"[Math.floor(Math.random() * 26)];
  return t;
}
function fi(e) {
  return JSON.stringify(e);
}
function $s(e) {
  return e.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var ji = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => {
};
function Je(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
var _s = $t(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare")) return !1;
  try {
    return new Function(""), !0;
  } catch {
    return !1;
  }
});
function Ne(e) {
  if (Je(e) === !1) return !1;
  let t = e.constructor;
  if (t === void 0 || typeof t != "function") return !0;
  let i = t.prototype;
  return !(Je(i) === !1 || Object.prototype.hasOwnProperty.call(i, "isPrototypeOf") === !1);
}
function bs(e) {
  return Ne(e) ? { ...e } : Array.isArray(e) ? [...e] : e;
}
function e_(e) {
  let t = 0;
  for (let i in e) Object.prototype.hasOwnProperty.call(e, i) && t++;
  return t;
}
var t_ = (e) => {
  let t = typeof e;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(e) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      return Array.isArray(e) ? "array" : e === null ? "null" : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? "promise" : typeof Map < "u" && e instanceof Map ? "map" : typeof Set < "u" && e instanceof Set ? "set" : typeof Date < "u" && e instanceof Date ? "date" : typeof File < "u" && e instanceof File ? "file" : "object";
    default:
      throw Error(`Unknown data type: ${t}`);
  }
}, nn = /* @__PURE__ */ new Set(["string", "number", "symbol"]), ys = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function _e(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function ge(e, t, i) {
  let o = new e._zod.constr(t ?? e._zod.def);
  return (!t || i?.parent) && (o._zod.parent = e), o;
}
function $(e) {
  let t = e;
  if (!t) return {};
  if (typeof t == "string") return { error: () => t };
  if (t?.message !== void 0) {
    if (t?.error !== void 0) throw Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return delete t.message, typeof t.error == "string" ? { ...t, error: () => t.error } : t;
}
function n_(e) {
  let t;
  return new Proxy({}, { get(i, o, n) {
    return t ?? (t = e()), Reflect.get(t, o, n);
  }, set(i, o, n, r) {
    return t ?? (t = e()), Reflect.set(t, o, n, r);
  }, has(i, o) {
    return t ?? (t = e()), Reflect.has(t, o);
  }, deleteProperty(i, o) {
    return t ?? (t = e()), Reflect.deleteProperty(t, o);
  }, ownKeys(i) {
    return t ?? (t = e()), Reflect.ownKeys(t);
  }, getOwnPropertyDescriptor(i, o) {
    return t ?? (t = e()), Reflect.getOwnPropertyDescriptor(t, o);
  }, defineProperty(i, o, n) {
    return t ?? (t = e()), Reflect.defineProperty(t, o, n);
  } });
}
function w(e) {
  return typeof e == "bigint" ? e.toString() + "n" : typeof e == "string" ? `"${e}"` : `${e}`;
}
function ks(e) {
  return Object.keys(e).filter((t) => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional");
}
var Is = { safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], int32: [-2147483648, 2147483647], uint32: [0, 4294967295], float32: [-34028234663852886e22, 34028234663852886e22], float64: [-Number.MAX_VALUE, Number.MAX_VALUE] }, ws = { int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")], uint64: [BigInt(0), BigInt("18446744073709551615")] };
function i_(e, t) {
  let i = e._zod.def, o = i.checks;
  if (o && o.length > 0) throw Error(".pick() cannot be used on object schemas containing refinements");
  let n = ye(e._zod.def, { get shape() {
    let r = {};
    for (let a in t) {
      if (!(a in i.shape)) throw Error(`Unrecognized key: "${a}"`);
      t[a] && (r[a] = i.shape[a]);
    }
    return Ue(this, "shape", r), r;
  }, checks: [] });
  return ge(e, n);
}
function r_(e, t) {
  let i = e._zod.def, o = i.checks;
  if (o && o.length > 0) throw Error(".omit() cannot be used on object schemas containing refinements");
  let n = ye(e._zod.def, { get shape() {
    let r = { ...e._zod.def.shape };
    for (let a in t) {
      if (!(a in i.shape)) throw Error(`Unrecognized key: "${a}"`);
      t[a] && delete r[a];
    }
    return Ue(this, "shape", r), r;
  }, checks: [] });
  return ge(e, n);
}
function o_(e, t) {
  if (!Ne(t)) throw Error("Invalid input to extend: expected a plain object");
  let i = e._zod.def.checks;
  if (i && i.length > 0) {
    let n = e._zod.def.shape;
    for (let r in t) if (Object.getOwnPropertyDescriptor(n, r) !== void 0) throw Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
  }
  let o = ye(e._zod.def, { get shape() {
    let n = { ...e._zod.def.shape, ...t };
    return Ue(this, "shape", n), n;
  } });
  return ge(e, o);
}
function a_(e, t) {
  if (!Ne(t)) throw Error("Invalid input to safeExtend: expected a plain object");
  let i = ye(e._zod.def, { get shape() {
    let o = { ...e._zod.def.shape, ...t };
    return Ue(this, "shape", o), o;
  } });
  return ge(e, i);
}
function s_(e, t) {
  let i = ye(e._zod.def, { get shape() {
    let o = { ...e._zod.def.shape, ...t._zod.def.shape };
    return Ue(this, "shape", o), o;
  }, get catchall() {
    return t._zod.def.catchall;
  }, checks: [] });
  return ge(e, i);
}
function u_(e, t, i) {
  let o = t._zod.def.checks;
  if (o && o.length > 0) throw Error(".partial() cannot be used on object schemas containing refinements");
  let n = ye(t._zod.def, { get shape() {
    let r = t._zod.def.shape, a = { ...r };
    if (i) for (let s in i) {
      if (!(s in r)) throw Error(`Unrecognized key: "${s}"`);
      i[s] && (a[s] = e ? new e({ type: "optional", innerType: r[s] }) : r[s]);
    }
    else for (let s in r) a[s] = e ? new e({ type: "optional", innerType: r[s] }) : r[s];
    return Ue(this, "shape", a), a;
  }, checks: [] });
  return ge(t, n);
}
function l_(e, t, i) {
  let o = ye(t._zod.def, { get shape() {
    let n = t._zod.def.shape, r = { ...n };
    if (i) for (let a in i) {
      if (!(a in r)) throw Error(`Unrecognized key: "${a}"`);
      i[a] && (r[a] = new e({ type: "nonoptional", innerType: n[a] }));
    }
    else for (let a in n) r[a] = new e({ type: "nonoptional", innerType: n[a] });
    return Ue(this, "shape", r), r;
  } });
  return ge(t, o);
}
function Pe(e, t = 0) {
  if (e.aborted === !0) return !0;
  for (let i = t; i < e.issues.length; i++) if (e.issues[i]?.continue !== !0) return !0;
  return !1;
}
function he(e, t) {
  return t.map((i) => {
    var o;
    return (o = i).path ?? (o.path = []), i.path.unshift(e), i;
  });
}
function tt(e) {
  return typeof e == "string" ? e : e?.message;
}
function me(e, t, i) {
  let o = { ...e, path: e.path ?? [] };
  if (!e.message) {
    let n = tt(e.inst?._zod.def?.error?.(e)) ?? tt(t?.error?.(e)) ?? tt(i.customError?.(e)) ?? tt(i.localeError?.(e)) ?? "Invalid input";
    o.message = n;
  }
  return delete o.inst, delete o.continue, !t?.reportInput && delete o.input, o;
}
function _n(e) {
  return e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof File ? "file" : "unknown";
}
function bn(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function S(e) {
  let t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "nan" : "number";
    case "object": {
      if (e === null) return "null";
      if (Array.isArray(e)) return "array";
      let i = e;
      if (i && Object.getPrototypeOf(i) !== Object.prototype && "constructor" in i && i.constructor) return i.constructor.name;
    }
  }
  return t;
}
function rn(...e) {
  let [t, i, o] = e;
  return typeof t == "string" ? { message: t, code: "custom", input: i, inst: o } : { ...t };
}
function c_(e) {
  return Object.entries(e).filter(([t, i]) => Number.isNaN(Number.parseInt(t, 10))).map((t) => t[1]);
}
function Ss(e) {
  let t = atob(e), i = new Uint8Array(t.length);
  for (let o = 0; o < t.length; o++) i[o] = t.charCodeAt(o);
  return i;
}
function xs(e) {
  let t = "";
  for (let i = 0; i < e.length; i++) t += String.fromCharCode(e[i]);
  return btoa(t);
}
function d_(e) {
  let t = e.replace(/-/g, "+").replace(/_/g, "/"), i = "=".repeat((4 - t.length % 4) % 4);
  return Ss(t + i);
}
function m_(e) {
  return xs(e).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function p_(e) {
  let t = e.replace(/^0x/, "");
  if (t.length % 2 !== 0) throw Error("Invalid hex string length");
  let i = new Uint8Array(t.length / 2);
  for (let o = 0; o < t.length; o += 2) i[o / 2] = Number.parseInt(t.slice(o, o + 2), 16);
  return i;
}
function f_(e) {
  return Array.from(e).map((t) => t.toString(16).padStart(2, "0")).join("");
}
class g_ {
  constructor(...t) {
  }
}
var zs = (e, t) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", { value: e._zod, enumerable: !1 }), Object.defineProperty(e, "issues", { value: t, enumerable: !1 }), e.message = JSON.stringify(t, tn, 2), Object.defineProperty(e, "toString", { value: () => e.message, enumerable: !1 });
}, Ti = m("$ZodError", zs), ue = m("$ZodError", zs, { Parent: Error });
function Ai(e, t = (i) => i.message) {
  let i = {}, o = [];
  for (let n of e.issues) n.path.length > 0 ? (i[n.path[0]] = i[n.path[0]] || [], i[n.path[0]].push(t(n))) : o.push(t(n));
  return { formErrors: o, fieldErrors: i };
}
function Ri(e, t = (i) => i.message) {
  let i = { _errors: [] }, o = (n) => {
    for (let r of n.issues) if (r.code === "invalid_union" && r.errors.length) r.errors.map((a) => o({ issues: a }));
    else if (r.code === "invalid_key") o({ issues: r.issues });
    else if (r.code === "invalid_element") o({ issues: r.issues });
    else if (r.path.length === 0) i._errors.push(t(r));
    else {
      let a = i, s = 0;
      for (; s < r.path.length; ) {
        let u = r.path[s];
        s !== r.path.length - 1 ? a[u] = a[u] || { _errors: [] } : (a[u] = a[u] || { _errors: [] }, a[u]._errors.push(t(r))), a = a[u], s++;
      }
    }
  };
  return o(e), i;
}
function Us(e, t = (i) => i.message) {
  let i = { errors: [] }, o = (n, r = []) => {
    var a, s;
    for (let u of n.issues) if (u.code === "invalid_union" && u.errors.length) u.errors.map((l) => o({ issues: l }, u.path));
    else if (u.code === "invalid_key") o({ issues: u.issues }, u.path);
    else if (u.code === "invalid_element") o({ issues: u.issues }, u.path);
    else {
      let l = [...r, ...u.path];
      if (l.length === 0) {
        i.errors.push(t(u));
        continue;
      }
      let d = i, p = 0;
      for (; p < l.length; ) {
        let g = l[p], _ = p === l.length - 1;
        typeof g == "string" ? (d.properties ?? (d.properties = {}), (a = d.properties)[g] ?? (a[g] = { errors: [] }), d = d.properties[g]) : (d.items ?? (d.items = []), (s = d.items)[g] ?? (s[g] = { errors: [] }), d = d.items[g]), _ && d.errors.push(t(u)), p++;
      }
    }
  };
  return o(e), i;
}
function Os(e) {
  let t = [], i = e.map((o) => typeof o == "object" ? o.key : o);
  for (let o of i) typeof o == "number" ? t.push(`[${o}]`) : typeof o == "symbol" ? t.push(`[${JSON.stringify(String(o))}]`) : /[^\w$]/.test(o) ? t.push(`[${JSON.stringify(o)}]`) : (t.length && t.push("."), t.push(o));
  return t.join("");
}
function Zs(e) {
  let t = [], i = [...e.issues].sort((o, n) => (o.path ?? []).length - (n.path ?? []).length);
  for (let o of i) t.push(` ${o.message}`), o.path?.length && t.push(`   at ${Os(o.path)}`);
  return t.join(`
`);
}
var _t = (e) => (t, i, o, n) => {
  let r = o ? Object.assign(o, { async: !1 }) : { async: !1 }, a = t._zod.run({ value: i, issues: [] }, r);
  if (a instanceof Promise) throw new Ee();
  if (a.issues.length) {
    let s = new (n?.Err ?? e)(a.issues.map((u) => me(u, r, te())));
    throw ji(s, n?.callee), s;
  }
  return a.value;
}, gi = _t(ue), bt = (e) => async (t, i, o, n) => {
  let r = o ? Object.assign(o, { async: !0 }) : { async: !0 }, a = t._zod.run({ value: i, issues: [] }, r);
  if (a instanceof Promise && (a = await a), a.issues.length) {
    let s = new (n?.Err ?? e)(a.issues.map((u) => me(u, r, te())));
    throw ji(s, n?.callee), s;
  }
  return a.value;
}, hi = bt(ue), yt = (e) => (t, i, o) => {
  let n = o ? { ...o, async: !1 } : { async: !1 }, r = t._zod.run({ value: i, issues: [] }, n);
  if (r instanceof Promise) throw new Ee();
  return r.issues.length ? { success: !1, error: new (e ?? Ti)(r.issues.map((a) => me(a, n, te()))) } : { success: !0, data: r.value };
}, Ps = yt(ue), kt = (e) => async (t, i, o) => {
  let n = o ? Object.assign(o, { async: !0 }) : { async: !0 }, r = t._zod.run({ value: i, issues: [] }, n);
  return r instanceof Promise && (r = await r), r.issues.length ? { success: !1, error: new e(r.issues.map((a) => me(a, n, te()))) } : { success: !0, data: r.value };
}, Es = kt(ue), Ci = (e) => (t, i, o) => {
  let n = o ? Object.assign(o, { direction: "backward" }) : { direction: "backward" };
  return _t(e)(t, i, n);
}, h_ = Ci(ue), Mi = (e) => (t, i, o) => _t(e)(t, i, o), v_ = Mi(ue), Li = (e) => async (t, i, o) => {
  let n = o ? Object.assign(o, { direction: "backward" }) : { direction: "backward" };
  return bt(e)(t, i, n);
}, $_ = Li(ue), Fi = (e) => async (t, i, o) => bt(e)(t, i, o), __ = Fi(ue), Ji = (e) => (t, i, o) => {
  let n = o ? Object.assign(o, { direction: "backward" }) : { direction: "backward" };
  return yt(e)(t, i, n);
}, b_ = Ji(ue), qi = (e) => (t, i, o) => yt(e)(t, i, o), y_ = qi(ue), Wi = (e) => async (t, i, o) => {
  let n = o ? Object.assign(o, { direction: "backward" }) : { direction: "backward" };
  return kt(e)(t, i, n);
}, k_ = Wi(ue), Ki = (e) => async (t, i, o) => kt(e)(t, i, o), I_ = Ki(ue), Re = {};
be(Re, { xid: () => Ts, uuid7: () => z_, uuid6: () => x_, uuid4: () => S_, uuid: () => qe, uppercase: () => lu, unicodeEmail: () => Fs, undefined: () => su, ulid: () => js, time: () => eu, string: () => nu, sha512_hex: () => G_, sha512_base64url: () => H_, sha512_base64: () => B_, sha384_hex: () => W_, sha384_base64url: () => V_, sha384_base64: () => K_, sha256_hex: () => F_, sha256_base64url: () => q_, sha256_base64: () => J_, sha1_hex: () => C_, sha1_base64url: () => L_, sha1_base64: () => M_, rfc5322Email: () => O_, number: () => Gi, null: () => au, nanoid: () => Rs, md5_hex: () => T_, md5_base64url: () => R_, md5_base64: () => A_, mac: () => Ks, lowercase: () => uu, ksuid: () => As, ipv6: () => Ws, ipv4: () => qs, integer: () => ru, idnEmail: () => Z_, html5Email: () => U_, hostname: () => N_, hex: () => j_, guid: () => Ms, extendedDuration: () => w_, emoji: () => Js, email: () => Ls, e164: () => Hs, duration: () => Cs, domain: () => D_, datetime: () => tu, date: () => Ys, cuid2: () => Ds, cuid: () => Ns, cidrv6: () => Gs, cidrv4: () => Vs, browserEmail: () => P_, boolean: () => ou, bigint: () => iu, base64url: () => Vi, base64: () => Bs });
var Ns = /^[cC][^\s-]{8,}$/, Ds = /^[0-9a-z]+$/, js = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, Ts = /^[0-9a-vA-V]{20}$/, As = /^[A-Za-z0-9]{27}$/, Rs = /^[a-zA-Z0-9_-]{21}$/, Cs = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, w_ = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, Ms = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, qe = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, S_ = qe(4), x_ = qe(6), z_ = qe(7), Ls = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, U_ = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, O_ = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, Fs = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u, Z_ = Fs, P_ = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, E_ = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function Js() {
  return new RegExp(E_, "u");
}
var qs = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Ws = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, Ks = (e) => {
  let t = _e(e ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${t}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${t}){5}[0-9a-f]{2}$`);
}, Vs = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, Gs = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Bs = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, Vi = /^[A-Za-z0-9_-]*$/, N_ = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/, D_ = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/, Hs = /^\+[1-9]\d{6,14}$/, Xs = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", Ys = new RegExp(`^${Xs}$`);
function Qs(e) {
  return typeof e.precision == "number" ? e.precision === -1 ? "(?:[01]\\d|2[0-3]):[0-5]\\d" : e.precision === 0 ? "(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d" : `(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d\\.\\d{${e.precision}}` : "(?:[01]\\d|2[0-3]):[0-5]\\d(?::[0-5]\\d(?:\\.\\d+)?)?";
}
function eu(e) {
  return new RegExp(`^${Qs(e)}$`);
}
function tu(e) {
  let t = Qs({ precision: e.precision }), i = ["Z"];
  e.local && i.push(""), e.offset && i.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  let o = `${t}(?:${i.join("|")})`;
  return new RegExp(`^${Xs}T(?:${o})$`);
}
var nu = (e) => {
  let t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${t}$`);
}, iu = /^-?\d+n?$/, ru = /^-?\d+$/, Gi = /^-?\d+(?:\.\d+)?$/, ou = /^(?:true|false)$/i, au = /^null$/i, su = /^undefined$/i, uu = /^[^A-Z]*$/, lu = /^[^a-z]*$/, j_ = /^[0-9a-fA-F]*$/;
function It(e, t) {
  return new RegExp(`^[A-Za-z0-9+/]{${e}}${t}$`);
}
function wt(e) {
  return new RegExp(`^[A-Za-z0-9_-]{${e}}$`);
}
var T_ = /^[0-9a-fA-F]{32}$/, A_ = It(22, "=="), R_ = wt(22), C_ = /^[0-9a-fA-F]{40}$/, M_ = It(27, "="), L_ = wt(27), F_ = /^[0-9a-fA-F]{64}$/, J_ = It(43, "="), q_ = wt(43), W_ = /^[0-9a-fA-F]{96}$/, K_ = It(64, ""), V_ = wt(64), G_ = /^[0-9a-fA-F]{128}$/, B_ = It(86, "=="), H_ = wt(86), J = m("$ZodCheck", (e, t) => {
  var i;
  e._zod ?? (e._zod = {}), e._zod.def = t, (i = e._zod).onattach ?? (i.onattach = []);
}), cu = { number: "number", bigint: "bigint", object: "date" }, Bi = m("$ZodCheckLessThan", (e, t) => {
  J.init(e, t);
  let i = cu[typeof t.value];
  e._zod.onattach.push((o) => {
    let n = o._zod.bag, r = (t.inclusive ? n.maximum : n.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    t.value < r && (t.inclusive ? n.maximum = t.value : n.exclusiveMaximum = t.value);
  }), e._zod.check = (o) => {
    (t.inclusive ? o.value <= t.value : o.value < t.value) || o.issues.push({ origin: i, code: "too_big", maximum: typeof t.value == "object" ? t.value.getTime() : t.value, input: o.value, inclusive: t.inclusive, inst: e, continue: !t.abort });
  };
}), Hi = m("$ZodCheckGreaterThan", (e, t) => {
  J.init(e, t);
  let i = cu[typeof t.value];
  e._zod.onattach.push((o) => {
    let n = o._zod.bag, r = (t.inclusive ? n.minimum : n.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    t.value > r && (t.inclusive ? n.minimum = t.value : n.exclusiveMinimum = t.value);
  }), e._zod.check = (o) => {
    (t.inclusive ? o.value >= t.value : o.value > t.value) || o.issues.push({ origin: i, code: "too_small", minimum: typeof t.value == "object" ? t.value.getTime() : t.value, input: o.value, inclusive: t.inclusive, inst: e, continue: !t.abort });
  };
}), du = m("$ZodCheckMultipleOf", (e, t) => {
  J.init(e, t), e._zod.onattach.push((i) => {
    var o;
    (o = i._zod.bag).multipleOf ?? (o.multipleOf = t.value);
  }), e._zod.check = (i) => {
    if (typeof i.value != typeof t.value) throw Error("Cannot mix number and bigint in multiple_of check.");
    (typeof i.value == "bigint" ? i.value % t.value === BigInt(0) : vs(i.value, t.value) === 0) || i.issues.push({ origin: typeof i.value, code: "not_multiple_of", divisor: t.value, input: i.value, inst: e, continue: !t.abort });
  };
}), mu = m("$ZodCheckNumberFormat", (e, t) => {
  J.init(e, t), t.format = t.format || "float64";
  let i = t.format?.includes("int"), o = i ? "int" : "number", [n, r] = Is[t.format];
  e._zod.onattach.push((a) => {
    let s = a._zod.bag;
    s.format = t.format, s.minimum = n, s.maximum = r, i && (s.pattern = ru);
  }), e._zod.check = (a) => {
    let s = a.value;
    if (i) {
      if (!Number.isInteger(s)) {
        a.issues.push({ expected: o, format: t.format, code: "invalid_type", continue: !1, input: s, inst: e });
        return;
      }
      if (!Number.isSafeInteger(s)) {
        s > 0 ? a.issues.push({ input: s, code: "too_big", maximum: Number.MAX_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: e, origin: o, inclusive: !0, continue: !t.abort }) : a.issues.push({ input: s, code: "too_small", minimum: Number.MIN_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: e, origin: o, inclusive: !0, continue: !t.abort });
        return;
      }
    }
    s < n && a.issues.push({ origin: "number", input: s, code: "too_small", minimum: n, inclusive: !0, inst: e, continue: !t.abort }), s > r && a.issues.push({ origin: "number", input: s, code: "too_big", maximum: r, inclusive: !0, inst: e, continue: !t.abort });
  };
}), pu = m("$ZodCheckBigIntFormat", (e, t) => {
  J.init(e, t);
  let [i, o] = ws[t.format];
  e._zod.onattach.push((n) => {
    let r = n._zod.bag;
    r.format = t.format, r.minimum = i, r.maximum = o;
  }), e._zod.check = (n) => {
    let r = n.value;
    r < i && n.issues.push({ origin: "bigint", input: r, code: "too_small", minimum: i, inclusive: !0, inst: e, continue: !t.abort }), r > o && n.issues.push({ origin: "bigint", input: r, code: "too_big", maximum: o, inclusive: !0, inst: e, continue: !t.abort });
  };
}), fu = m("$ZodCheckMaxSize", (e, t) => {
  var i;
  J.init(e, t), (i = e._zod.def).when ?? (i.when = (o) => {
    let n = o.value;
    return !Ae(n) && n.size !== void 0;
  }), e._zod.onattach.push((o) => {
    let n = o._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < n && (o._zod.bag.maximum = t.maximum);
  }), e._zod.check = (o) => {
    let n = o.value;
    n.size <= t.maximum || o.issues.push({ origin: _n(n), code: "too_big", maximum: t.maximum, inclusive: !0, input: n, inst: e, continue: !t.abort });
  };
}), gu = m("$ZodCheckMinSize", (e, t) => {
  var i;
  J.init(e, t), (i = e._zod.def).when ?? (i.when = (o) => {
    let n = o.value;
    return !Ae(n) && n.size !== void 0;
  }), e._zod.onattach.push((o) => {
    let n = o._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > n && (o._zod.bag.minimum = t.minimum);
  }), e._zod.check = (o) => {
    let n = o.value;
    n.size >= t.minimum || o.issues.push({ origin: _n(n), code: "too_small", minimum: t.minimum, inclusive: !0, input: n, inst: e, continue: !t.abort });
  };
}), hu = m("$ZodCheckSizeEquals", (e, t) => {
  var i;
  J.init(e, t), (i = e._zod.def).when ?? (i.when = (o) => {
    let n = o.value;
    return !Ae(n) && n.size !== void 0;
  }), e._zod.onattach.push((o) => {
    let n = o._zod.bag;
    n.minimum = t.size, n.maximum = t.size, n.size = t.size;
  }), e._zod.check = (o) => {
    let n = o.value, r = n.size;
    if (r === t.size) return;
    let a = r > t.size;
    o.issues.push({ origin: _n(n), ...a ? { code: "too_big", maximum: t.size } : { code: "too_small", minimum: t.size }, inclusive: !0, exact: !0, input: o.value, inst: e, continue: !t.abort });
  };
}), vu = m("$ZodCheckMaxLength", (e, t) => {
  var i;
  J.init(e, t), (i = e._zod.def).when ?? (i.when = (o) => {
    let n = o.value;
    return !Ae(n) && n.length !== void 0;
  }), e._zod.onattach.push((o) => {
    let n = o._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < n && (o._zod.bag.maximum = t.maximum);
  }), e._zod.check = (o) => {
    let n = o.value;
    if (n.length <= t.maximum) return;
    let r = bn(n);
    o.issues.push({ origin: r, code: "too_big", maximum: t.maximum, inclusive: !0, input: n, inst: e, continue: !t.abort });
  };
}), $u = m("$ZodCheckMinLength", (e, t) => {
  var i;
  J.init(e, t), (i = e._zod.def).when ?? (i.when = (o) => {
    let n = o.value;
    return !Ae(n) && n.length !== void 0;
  }), e._zod.onattach.push((o) => {
    let n = o._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > n && (o._zod.bag.minimum = t.minimum);
  }), e._zod.check = (o) => {
    let n = o.value;
    if (n.length >= t.minimum) return;
    let r = bn(n);
    o.issues.push({ origin: r, code: "too_small", minimum: t.minimum, inclusive: !0, input: n, inst: e, continue: !t.abort });
  };
}), _u = m("$ZodCheckLengthEquals", (e, t) => {
  var i;
  J.init(e, t), (i = e._zod.def).when ?? (i.when = (o) => {
    let n = o.value;
    return !Ae(n) && n.length !== void 0;
  }), e._zod.onattach.push((o) => {
    let n = o._zod.bag;
    n.minimum = t.length, n.maximum = t.length, n.length = t.length;
  }), e._zod.check = (o) => {
    let n = o.value, r = n.length;
    if (r === t.length) return;
    let a = bn(n), s = r > t.length;
    o.issues.push({ origin: a, ...s ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length }, inclusive: !0, exact: !0, input: o.value, inst: e, continue: !t.abort });
  };
}), St = m("$ZodCheckStringFormat", (e, t) => {
  var i, o;
  J.init(e, t), e._zod.onattach.push((n) => {
    let r = n._zod.bag;
    r.format = t.format, t.pattern && (r.patterns ?? (r.patterns = /* @__PURE__ */ new Set()), r.patterns.add(t.pattern));
  }), t.pattern ? (i = e._zod).check ?? (i.check = (n) => {
    t.pattern.lastIndex = 0, !t.pattern.test(n.value) && n.issues.push({ origin: "string", code: "invalid_format", format: t.format, input: n.value, ...t.pattern ? { pattern: t.pattern.toString() } : {}, inst: e, continue: !t.abort });
  }) : (o = e._zod).check ?? (o.check = () => {
  });
}), bu = m("$ZodCheckRegex", (e, t) => {
  St.init(e, t), e._zod.check = (i) => {
    t.pattern.lastIndex = 0, !t.pattern.test(i.value) && i.issues.push({ origin: "string", code: "invalid_format", format: "regex", input: i.value, pattern: t.pattern.toString(), inst: e, continue: !t.abort });
  };
}), yu = m("$ZodCheckLowerCase", (e, t) => {
  t.pattern ?? (t.pattern = uu), St.init(e, t);
}), ku = m("$ZodCheckUpperCase", (e, t) => {
  t.pattern ?? (t.pattern = lu), St.init(e, t);
}), Iu = m("$ZodCheckIncludes", (e, t) => {
  J.init(e, t);
  let i = _e(t.includes), o = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${i}` : i);
  t.pattern = o, e._zod.onattach.push((n) => {
    let r = n._zod.bag;
    r.patterns ?? (r.patterns = /* @__PURE__ */ new Set()), r.patterns.add(o);
  }), e._zod.check = (n) => {
    n.value.includes(t.includes, t.position) || n.issues.push({ origin: "string", code: "invalid_format", format: "includes", includes: t.includes, input: n.value, inst: e, continue: !t.abort });
  };
}), wu = m("$ZodCheckStartsWith", (e, t) => {
  J.init(e, t);
  let i = new RegExp(`^${_e(t.prefix)}.*`);
  t.pattern ?? (t.pattern = i), e._zod.onattach.push((o) => {
    let n = o._zod.bag;
    n.patterns ?? (n.patterns = /* @__PURE__ */ new Set()), n.patterns.add(i);
  }), e._zod.check = (o) => {
    o.value.startsWith(t.prefix) || o.issues.push({ origin: "string", code: "invalid_format", format: "starts_with", prefix: t.prefix, input: o.value, inst: e, continue: !t.abort });
  };
}), Su = m("$ZodCheckEndsWith", (e, t) => {
  J.init(e, t);
  let i = new RegExp(`.*${_e(t.suffix)}$`);
  t.pattern ?? (t.pattern = i), e._zod.onattach.push((o) => {
    let n = o._zod.bag;
    n.patterns ?? (n.patterns = /* @__PURE__ */ new Set()), n.patterns.add(i);
  }), e._zod.check = (o) => {
    o.value.endsWith(t.suffix) || o.issues.push({ origin: "string", code: "invalid_format", format: "ends_with", suffix: t.suffix, input: o.value, inst: e, continue: !t.abort });
  };
});
function Yo(e, t, i) {
  e.issues.length && t.issues.push(...he(i, e.issues));
}
var xu = m("$ZodCheckProperty", (e, t) => {
  J.init(e, t), e._zod.check = (i) => {
    let o = t.schema._zod.run({ value: i.value[t.property], issues: [] }, {});
    if (o instanceof Promise) return o.then((n) => Yo(n, i, t.property));
    Yo(o, i, t.property);
  };
}), zu = m("$ZodCheckMimeType", (e, t) => {
  J.init(e, t);
  let i = new Set(t.mime);
  e._zod.onattach.push((o) => {
    o._zod.bag.mime = t.mime;
  }), e._zod.check = (o) => {
    i.has(o.value.type) || o.issues.push({ code: "invalid_value", values: t.mime, input: o.value.type, inst: e, continue: !t.abort });
  };
}), Uu = m("$ZodCheckOverwrite", (e, t) => {
  J.init(e, t), e._zod.check = (i) => {
    i.value = t.tx(i.value);
  };
});
class Ou {
  constructor(t = []) {
    this.content = [], this.indent = 0, this && (this.args = t);
  }
  indented(t) {
    this.indent += 1, t(this), this.indent -= 1;
  }
  write(t) {
    if (typeof t == "function") {
      t(this, { execution: "sync" }), t(this, { execution: "async" });
      return;
    }
    let i = t.split(`
`).filter((r) => r), o = Math.min(...i.map((r) => r.length - r.trimStart().length)), n = i.map((r) => r.slice(o)).map((r) => " ".repeat(this.indent * 2) + r);
    for (let r of n) this.content.push(r);
  }
  compile() {
    let t = Function, i = this?.args, o = [...(this?.content ?? [""]).map((n) => `  ${n}`)];
    return new t(...i, o.join(`
`));
  }
}
var Zu = { major: 4, minor: 3, patch: 5 }, z = m("$ZodType", (e, t) => {
  var i;
  e ?? (e = {}), e._zod.def = t, e._zod.bag = e._zod.bag || {}, e._zod.version = Zu;
  let o = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && o.unshift(e);
  for (let n of o) for (let r of n._zod.onattach) r(e);
  if (o.length === 0) (i = e._zod).deferred ?? (i.deferred = []), e._zod.deferred?.push(() => {
    e._zod.run = e._zod.parse;
  });
  else {
    let n = (a, s, u) => {
      let l = Pe(a), d;
      for (let p of s) {
        if (p._zod.def.when) {
          if (!p._zod.def.when(a)) continue;
        } else if (l) continue;
        let g = a.issues.length, _ = p._zod.check(a);
        if (_ instanceof Promise && u?.async === !1) throw new Ee();
        if (d || _ instanceof Promise) d = (d ?? Promise.resolve()).then(async () => {
          await _, a.issues.length !== g && (l || (l = Pe(a, g)));
        });
        else {
          if (a.issues.length === g) continue;
          l || (l = Pe(a, g));
        }
      }
      return d ? d.then(() => a) : a;
    }, r = (a, s, u) => {
      if (Pe(a)) return a.aborted = !0, a;
      let l = n(s, o, u);
      if (l instanceof Promise) {
        if (u.async === !1) throw new Ee();
        return l.then((d) => e._zod.parse(d, u));
      }
      return e._zod.parse(l, u);
    };
    e._zod.run = (a, s) => {
      if (s.skipChecks) return e._zod.parse(a, s);
      if (s.direction === "backward") {
        let l = e._zod.parse({ value: a.value, issues: [] }, { ...s, skipChecks: !0 });
        return l instanceof Promise ? l.then((d) => r(d, a, s)) : r(l, a, s);
      }
      let u = e._zod.parse(a, s);
      if (u instanceof Promise) {
        if (s.async === !1) throw new Ee();
        return u.then((l) => n(l, o, s));
      }
      return n(u, o, s);
    };
  }
  O(e, "~standard", () => ({ validate: (n) => {
    try {
      let r = Ps(e, n);
      return r.success ? { value: r.data } : { issues: r.error?.issues };
    } catch {
      return Es(e, n).then((a) => a.success ? { value: a.data } : { issues: a.error?.issues });
    }
  }, vendor: "zod", version: 1 }));
}), xt = m("$ZodString", (e, t) => {
  z.init(e, t), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? nu(e._zod.bag), e._zod.parse = (i, o) => {
    if (t.coerce) try {
      i.value = String(i.value);
    } catch {
    }
    return typeof i.value == "string" || i.issues.push({ expected: "string", code: "invalid_type", input: i.value, inst: e }), i;
  };
}), A = m("$ZodStringFormat", (e, t) => {
  St.init(e, t), xt.init(e, t);
}), Pu = m("$ZodGUID", (e, t) => {
  t.pattern ?? (t.pattern = Ms), A.init(e, t);
}), Eu = m("$ZodUUID", (e, t) => {
  if (t.version) {
    let i = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[t.version];
    if (i === void 0) throw Error(`Invalid UUID version: "${t.version}"`);
    t.pattern ?? (t.pattern = qe(i));
  } else t.pattern ?? (t.pattern = qe());
  A.init(e, t);
}), Nu = m("$ZodEmail", (e, t) => {
  t.pattern ?? (t.pattern = Ls), A.init(e, t);
}), Du = m("$ZodURL", (e, t) => {
  A.init(e, t), e._zod.check = (i) => {
    try {
      let o = i.value.trim(), n = new URL(o);
      t.hostname && (t.hostname.lastIndex = 0, !t.hostname.test(n.hostname) && i.issues.push({ code: "invalid_format", format: "url", note: "Invalid hostname", pattern: t.hostname.source, input: i.value, inst: e, continue: !t.abort })), t.protocol && (t.protocol.lastIndex = 0, !t.protocol.test(n.protocol.endsWith(":") ? n.protocol.slice(0, -1) : n.protocol) && i.issues.push({ code: "invalid_format", format: "url", note: "Invalid protocol", pattern: t.protocol.source, input: i.value, inst: e, continue: !t.abort })), t.normalize ? i.value = n.href : i.value = o;
      return;
    } catch {
      i.issues.push({ code: "invalid_format", format: "url", input: i.value, inst: e, continue: !t.abort });
    }
  };
}), ju = m("$ZodEmoji", (e, t) => {
  t.pattern ?? (t.pattern = Js()), A.init(e, t);
}), Tu = m("$ZodNanoID", (e, t) => {
  t.pattern ?? (t.pattern = Rs), A.init(e, t);
}), Au = m("$ZodCUID", (e, t) => {
  t.pattern ?? (t.pattern = Ns), A.init(e, t);
}), Ru = m("$ZodCUID2", (e, t) => {
  t.pattern ?? (t.pattern = Ds), A.init(e, t);
}), Cu = m("$ZodULID", (e, t) => {
  t.pattern ?? (t.pattern = js), A.init(e, t);
}), Mu = m("$ZodXID", (e, t) => {
  t.pattern ?? (t.pattern = Ts), A.init(e, t);
}), Lu = m("$ZodKSUID", (e, t) => {
  t.pattern ?? (t.pattern = As), A.init(e, t);
}), Fu = m("$ZodISODateTime", (e, t) => {
  t.pattern ?? (t.pattern = tu(t)), A.init(e, t);
}), Ju = m("$ZodISODate", (e, t) => {
  t.pattern ?? (t.pattern = Ys), A.init(e, t);
}), qu = m("$ZodISOTime", (e, t) => {
  t.pattern ?? (t.pattern = eu(t)), A.init(e, t);
}), Wu = m("$ZodISODuration", (e, t) => {
  t.pattern ?? (t.pattern = Cs), A.init(e, t);
}), Ku = m("$ZodIPv4", (e, t) => {
  t.pattern ?? (t.pattern = qs), A.init(e, t), e._zod.bag.format = "ipv4";
}), Vu = m("$ZodIPv6", (e, t) => {
  t.pattern ?? (t.pattern = Ws), A.init(e, t), e._zod.bag.format = "ipv6", e._zod.check = (i) => {
    try {
      new URL(`http://[${i.value}]`);
    } catch {
      i.issues.push({ code: "invalid_format", format: "ipv6", input: i.value, inst: e, continue: !t.abort });
    }
  };
}), Gu = m("$ZodMAC", (e, t) => {
  t.pattern ?? (t.pattern = Ks(t.delimiter)), A.init(e, t), e._zod.bag.format = "mac";
}), Bu = m("$ZodCIDRv4", (e, t) => {
  t.pattern ?? (t.pattern = Vs), A.init(e, t);
}), Hu = m("$ZodCIDRv6", (e, t) => {
  t.pattern ?? (t.pattern = Gs), A.init(e, t), e._zod.check = (i) => {
    let o = i.value.split("/");
    try {
      if (o.length !== 2) throw Error();
      let [n, r] = o;
      if (!r) throw Error();
      let a = Number(r);
      if (`${a}` !== r || a < 0 || a > 128) throw Error();
      new URL(`http://[${n}]`);
    } catch {
      i.issues.push({ code: "invalid_format", format: "cidrv6", input: i.value, inst: e, continue: !t.abort });
    }
  };
});
function Xi(e) {
  if (e === "") return !0;
  if (e.length % 4 !== 0) return !1;
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}
var Xu = m("$ZodBase64", (e, t) => {
  t.pattern ?? (t.pattern = Bs), A.init(e, t), e._zod.bag.contentEncoding = "base64", e._zod.check = (i) => {
    Xi(i.value) || i.issues.push({ code: "invalid_format", format: "base64", input: i.value, inst: e, continue: !t.abort });
  };
});
function Yu(e) {
  if (!Vi.test(e)) return !1;
  let t = e.replace(/[-_]/g, (o) => o === "-" ? "+" : "/"), i = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return Xi(i);
}
var Qu = m("$ZodBase64URL", (e, t) => {
  t.pattern ?? (t.pattern = Vi), A.init(e, t), e._zod.bag.contentEncoding = "base64url", e._zod.check = (i) => {
    Yu(i.value) || i.issues.push({ code: "invalid_format", format: "base64url", input: i.value, inst: e, continue: !t.abort });
  };
}), el = m("$ZodE164", (e, t) => {
  t.pattern ?? (t.pattern = Hs), A.init(e, t);
});
function tl(e, t = null) {
  try {
    let i = e.split(".");
    if (i.length !== 3) return !1;
    let [o] = i;
    if (!o) return !1;
    let n = JSON.parse(atob(o));
    return !("typ" in n && n?.typ !== "JWT" || !n.alg || t && (!("alg" in n) || n.alg !== t));
  } catch {
    return !1;
  }
}
var nl = m("$ZodJWT", (e, t) => {
  A.init(e, t), e._zod.check = (i) => {
    tl(i.value, t.alg) || i.issues.push({ code: "invalid_format", format: "jwt", input: i.value, inst: e, continue: !t.abort });
  };
}), il = m("$ZodCustomStringFormat", (e, t) => {
  A.init(e, t), e._zod.check = (i) => {
    t.fn(i.value) || i.issues.push({ code: "invalid_format", format: t.format, input: i.value, inst: e, continue: !t.abort });
  };
}), Yi = m("$ZodNumber", (e, t) => {
  z.init(e, t), e._zod.pattern = e._zod.bag.pattern ?? Gi, e._zod.parse = (i, o) => {
    if (t.coerce) try {
      i.value = Number(i.value);
    } catch {
    }
    let n = i.value;
    if (typeof n == "number" && !Number.isNaN(n) && Number.isFinite(n)) return i;
    let r = typeof n == "number" ? Number.isNaN(n) ? "NaN" : Number.isFinite(n) ? void 0 : "Infinity" : void 0;
    return i.issues.push({ expected: "number", code: "invalid_type", input: n, inst: e, ...r ? { received: r } : {} }), i;
  };
}), rl = m("$ZodNumberFormat", (e, t) => {
  mu.init(e, t), Yi.init(e, t);
}), Qi = m("$ZodBoolean", (e, t) => {
  z.init(e, t), e._zod.pattern = ou, e._zod.parse = (i, o) => {
    if (t.coerce) try {
      i.value = !!i.value;
    } catch {
    }
    let n = i.value;
    return typeof n == "boolean" || i.issues.push({ expected: "boolean", code: "invalid_type", input: n, inst: e }), i;
  };
}), er = m("$ZodBigInt", (e, t) => {
  z.init(e, t), e._zod.pattern = iu, e._zod.parse = (i, o) => {
    if (t.coerce) try {
      i.value = BigInt(i.value);
    } catch {
    }
    return typeof i.value == "bigint" || i.issues.push({ expected: "bigint", code: "invalid_type", input: i.value, inst: e }), i;
  };
}), ol = m("$ZodBigIntFormat", (e, t) => {
  pu.init(e, t), er.init(e, t);
}), al = m("$ZodSymbol", (e, t) => {
  z.init(e, t), e._zod.parse = (i, o) => {
    let n = i.value;
    return typeof n == "symbol" || i.issues.push({ expected: "symbol", code: "invalid_type", input: n, inst: e }), i;
  };
}), sl = m("$ZodUndefined", (e, t) => {
  z.init(e, t), e._zod.pattern = su, e._zod.values = /* @__PURE__ */ new Set([void 0]), e._zod.optin = "optional", e._zod.optout = "optional", e._zod.parse = (i, o) => {
    let n = i.value;
    return typeof n > "u" || i.issues.push({ expected: "undefined", code: "invalid_type", input: n, inst: e }), i;
  };
}), ul = m("$ZodNull", (e, t) => {
  z.init(e, t), e._zod.pattern = au, e._zod.values = /* @__PURE__ */ new Set([null]), e._zod.parse = (i, o) => {
    let n = i.value;
    return n === null || i.issues.push({ expected: "null", code: "invalid_type", input: n, inst: e }), i;
  };
}), ll = m("$ZodAny", (e, t) => {
  z.init(e, t), e._zod.parse = (i) => i;
}), cl = m("$ZodUnknown", (e, t) => {
  z.init(e, t), e._zod.parse = (i) => i;
}), dl = m("$ZodNever", (e, t) => {
  z.init(e, t), e._zod.parse = (i, o) => (i.issues.push({ expected: "never", code: "invalid_type", input: i.value, inst: e }), i);
}), ml = m("$ZodVoid", (e, t) => {
  z.init(e, t), e._zod.parse = (i, o) => {
    let n = i.value;
    return typeof n > "u" || i.issues.push({ expected: "void", code: "invalid_type", input: n, inst: e }), i;
  };
}), pl = m("$ZodDate", (e, t) => {
  z.init(e, t), e._zod.parse = (i, o) => {
    if (t.coerce) try {
      i.value = new Date(i.value);
    } catch {
    }
    let n = i.value, r = n instanceof Date;
    return r && !Number.isNaN(n.getTime()) || i.issues.push({ expected: "date", code: "invalid_type", input: n, ...r ? { received: "Invalid Date" } : {}, inst: e }), i;
  };
});
function Qo(e, t, i) {
  e.issues.length && t.issues.push(...he(i, e.issues)), t.value[i] = e.value;
}
var fl = m("$ZodArray", (e, t) => {
  z.init(e, t), e._zod.parse = (i, o) => {
    let n = i.value;
    if (!Array.isArray(n)) return i.issues.push({ expected: "array", code: "invalid_type", input: n, inst: e }), i;
    i.value = Array(n.length);
    let r = [];
    for (let a = 0; a < n.length; a++) {
      let s = n[a], u = t.element._zod.run({ value: s, issues: [] }, o);
      u instanceof Promise ? r.push(u.then((l) => Qo(l, i, a))) : Qo(u, i, a);
    }
    return r.length ? Promise.all(r).then(() => i) : i;
  };
});
function on(e, t, i, o, n) {
  if (e.issues.length) {
    if (n && !(i in o)) return;
    t.issues.push(...he(i, e.issues));
  }
  e.value === void 0 ? i in o && (t.value[i] = void 0) : t.value[i] = e.value;
}
function gl(e) {
  let t = Object.keys(e.shape);
  for (let o of t) if (!e.shape?.[o]?._zod?.traits?.has("$ZodType")) throw Error(`Invalid element at key "${o}": expected a Zod schema`);
  let i = ks(e.shape);
  return { ...e, keys: t, keySet: new Set(t), numKeys: t.length, optionalKeys: new Set(i) };
}
function hl(e, t, i, o, n, r) {
  let a = [], s = n.keySet, u = n.catchall._zod, l = u.def.type, d = u.optout === "optional";
  for (let p in t) {
    if (s.has(p)) continue;
    if (l === "never") {
      a.push(p);
      continue;
    }
    let g = u.run({ value: t[p], issues: [] }, o);
    g instanceof Promise ? e.push(g.then((_) => on(_, i, p, t, d))) : on(g, i, p, t, d);
  }
  return a.length && i.issues.push({ code: "unrecognized_keys", keys: a, input: t, inst: r }), e.length ? Promise.all(e).then(() => i) : i;
}
var vl = m("$ZodObject", (e, t) => {
  if (z.init(e, t), !Object.getOwnPropertyDescriptor(t, "shape")?.get) {
    let a = t.shape;
    Object.defineProperty(t, "shape", { get: () => {
      let s = { ...a };
      return Object.defineProperty(t, "shape", { value: s }), s;
    } });
  }
  let i = $t(() => gl(t));
  O(e._zod, "propValues", () => {
    let a = t.shape, s = {};
    for (let u in a) {
      let l = a[u]._zod;
      if (l.values) {
        s[u] ?? (s[u] = /* @__PURE__ */ new Set());
        for (let d of l.values) s[u].add(d);
      }
    }
    return s;
  });
  let o = Je, n = t.catchall, r;
  e._zod.parse = (a, s) => {
    r ?? (r = i.value);
    let u = a.value;
    if (!o(u)) return a.issues.push({ expected: "object", code: "invalid_type", input: u, inst: e }), a;
    a.value = {};
    let l = [], d = r.shape;
    for (let p of r.keys) {
      let g = d[p], _ = g._zod.optout === "optional", x = g._zod.run({ value: u[p], issues: [] }, s);
      x instanceof Promise ? l.push(x.then((B) => on(B, a, p, u, _))) : on(x, a, p, u, _);
    }
    return n ? hl(l, u, a, s, i.value, e) : l.length ? Promise.all(l).then(() => a) : a;
  };
}), $l = m("$ZodObjectJIT", (e, t) => {
  vl.init(e, t);
  let i = e._zod.parse, o = $t(() => gl(t)), n = (p) => {
    let g = new Ou(["shape", "payload", "ctx"]), _ = o.value, x = (D) => {
      let Z = fi(D);
      return `shape[${Z}]._zod.run({ value: input[${Z}], issues: [] }, ctx)`;
    };
    g.write("const input = payload.value;");
    let B = /* @__PURE__ */ Object.create(null), $e = 0;
    for (let D of _.keys) B[D] = `key_${$e++}`;
    g.write("const newResult = {};");
    for (let D of _.keys) {
      let Z = B[D], N = fi(D), Oe = p[D]?._zod?.optout === "optional";
      g.write(`const ${Z} = ${x(D)};`), Oe ? g.write(`
        if (${Z}.issues.length) {
          if (${N} in input) {
            payload.issues = payload.issues.concat(${Z}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${N}, ...iss.path] : [${N}]
            })));
          }
        }
        
        if (${Z}.value === undefined) {
          if (${N} in input) {
            newResult[${N}] = undefined;
          }
        } else {
          newResult[${N}] = ${Z}.value;
        }
        
      `) : g.write(`
        if (${Z}.issues.length) {
          payload.issues = payload.issues.concat(${Z}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${N}, ...iss.path] : [${N}]
          })));
        }
        
        if (${Z}.value === undefined) {
          if (${N} in input) {
            newResult[${N}] = undefined;
          }
        } else {
          newResult[${N}] = ${Z}.value;
        }
        
      `);
    }
    g.write("payload.value = newResult;"), g.write("return payload;");
    let Me = g.compile();
    return (D, Z) => Me(p, D, Z);
  }, r, a = Je, s = !en.jitless, u = s && _s.value, l = t.catchall, d;
  e._zod.parse = (p, g) => {
    d ?? (d = o.value);
    let _ = p.value;
    return a(_) ? s && u && g?.async === !1 && g.jitless !== !0 ? (r || (r = n(t.shape)), p = r(p, g), l ? hl([], _, p, g, d, e) : p) : i(p, g) : (p.issues.push({ expected: "object", code: "invalid_type", input: _, inst: e }), p);
  };
});
function ea(e, t, i, o) {
  for (let r of e) if (r.issues.length === 0) return t.value = r.value, t;
  let n = e.filter((r) => !Pe(r));
  return n.length === 1 ? (t.value = n[0].value, n[0]) : (t.issues.push({ code: "invalid_union", input: t.value, inst: i, errors: e.map((r) => r.issues.map((a) => me(a, o, te()))) }), t);
}
var yn = m("$ZodUnion", (e, t) => {
  z.init(e, t), O(e._zod, "optin", () => t.options.some((n) => n._zod.optin === "optional") ? "optional" : void 0), O(e._zod, "optout", () => t.options.some((n) => n._zod.optout === "optional") ? "optional" : void 0), O(e._zod, "values", () => {
    if (t.options.every((n) => n._zod.values)) return new Set(t.options.flatMap((n) => Array.from(n._zod.values)));
  }), O(e._zod, "pattern", () => {
    if (t.options.every((n) => n._zod.pattern)) {
      let n = t.options.map((r) => r._zod.pattern);
      return new RegExp(`^(${n.map((r) => $n(r.source)).join("|")})$`);
    }
  });
  let i = t.options.length === 1, o = t.options[0]._zod.run;
  e._zod.parse = (n, r) => {
    if (i) return o(n, r);
    let a = !1, s = [];
    for (let u of t.options) {
      let l = u._zod.run({ value: n.value, issues: [] }, r);
      if (l instanceof Promise) s.push(l), a = !0;
      else {
        if (l.issues.length === 0) return l;
        s.push(l);
      }
    }
    return a ? Promise.all(s).then((u) => ea(u, n, e, r)) : ea(s, n, e, r);
  };
});
function ta(e, t, i, o) {
  let n = e.filter((r) => r.issues.length === 0);
  return n.length === 1 ? (t.value = n[0].value, t) : (n.length === 0 ? t.issues.push({ code: "invalid_union", input: t.value, inst: i, errors: e.map((r) => r.issues.map((a) => me(a, o, te()))) }) : t.issues.push({ code: "invalid_union", input: t.value, inst: i, errors: [], inclusive: !1 }), t);
}
var _l = m("$ZodXor", (e, t) => {
  yn.init(e, t), t.inclusive = !1;
  let i = t.options.length === 1, o = t.options[0]._zod.run;
  e._zod.parse = (n, r) => {
    if (i) return o(n, r);
    let a = !1, s = [];
    for (let u of t.options) {
      let l = u._zod.run({ value: n.value, issues: [] }, r);
      l instanceof Promise ? (s.push(l), a = !0) : s.push(l);
    }
    return a ? Promise.all(s).then((u) => ta(u, n, e, r)) : ta(s, n, e, r);
  };
}), bl = m("$ZodDiscriminatedUnion", (e, t) => {
  t.inclusive = !1, yn.init(e, t);
  let i = e._zod.parse;
  O(e._zod, "propValues", () => {
    let n = {};
    for (let r of t.options) {
      let a = r._zod.propValues;
      if (!a || Object.keys(a).length === 0) throw Error(`Invalid discriminated union option at index "${t.options.indexOf(r)}"`);
      for (let [s, u] of Object.entries(a)) {
        n[s] || (n[s] = /* @__PURE__ */ new Set());
        for (let l of u) n[s].add(l);
      }
    }
    return n;
  });
  let o = $t(() => {
    let n = t.options, r = /* @__PURE__ */ new Map();
    for (let a of n) {
      let s = a._zod.propValues?.[t.discriminator];
      if (!s || s.size === 0) throw Error(`Invalid discriminated union option at index "${t.options.indexOf(a)}"`);
      for (let u of s) {
        if (r.has(u)) throw Error(`Duplicate discriminator value "${String(u)}"`);
        r.set(u, a);
      }
    }
    return r;
  });
  e._zod.parse = (n, r) => {
    let a = n.value;
    if (!Je(a)) return n.issues.push({ code: "invalid_type", expected: "object", input: a, inst: e }), n;
    let s = o.value.get(a?.[t.discriminator]);
    return s ? s._zod.run(n, r) : t.unionFallback ? i(n, r) : (n.issues.push({ code: "invalid_union", errors: [], note: "No matching discriminator", discriminator: t.discriminator, input: a, path: [t.discriminator], inst: e }), n);
  };
}), yl = m("$ZodIntersection", (e, t) => {
  z.init(e, t), e._zod.parse = (i, o) => {
    let n = i.value, r = t.left._zod.run({ value: n, issues: [] }, o), a = t.right._zod.run({ value: n, issues: [] }, o);
    return r instanceof Promise || a instanceof Promise ? Promise.all([r, a]).then(([s, u]) => na(i, s, u)) : na(i, r, a);
  };
});
function vi(e, t) {
  if (e === t) return { valid: !0, data: e };
  if (e instanceof Date && t instanceof Date && +e == +t) return { valid: !0, data: e };
  if (Ne(e) && Ne(t)) {
    let i = Object.keys(t), o = Object.keys(e).filter((r) => i.indexOf(r) !== -1), n = { ...e, ...t };
    for (let r of o) {
      let a = vi(e[r], t[r]);
      if (!a.valid) return { valid: !1, mergeErrorPath: [r, ...a.mergeErrorPath] };
      n[r] = a.data;
    }
    return { valid: !0, data: n };
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length) return { valid: !1, mergeErrorPath: [] };
    let i = [];
    for (let o = 0; o < e.length; o++) {
      let n = e[o], r = t[o], a = vi(n, r);
      if (!a.valid) return { valid: !1, mergeErrorPath: [o, ...a.mergeErrorPath] };
      i.push(a.data);
    }
    return { valid: !0, data: i };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function na(e, t, i) {
  let o = /* @__PURE__ */ new Map(), n;
  for (let s of t.issues) if (s.code === "unrecognized_keys") {
    n ?? (n = s);
    for (let u of s.keys)
      o.has(u) || o.set(u, {}), o.get(u).l = !0;
  } else e.issues.push(s);
  for (let s of i.issues) if (s.code === "unrecognized_keys") for (let u of s.keys)
    o.has(u) || o.set(u, {}), o.get(u).r = !0;
  else e.issues.push(s);
  let r = [...o].filter(([, s]) => s.l && s.r).map(([s]) => s);
  if (r.length && n && e.issues.push({ ...n, keys: r }), Pe(e)) return e;
  let a = vi(t.value, i.value);
  if (!a.valid) throw Error(`Unmergable intersection. Error path: ${JSON.stringify(a.mergeErrorPath)}`);
  return e.value = a.data, e;
}
var tr = m("$ZodTuple", (e, t) => {
  z.init(e, t);
  let i = t.items;
  e._zod.parse = (o, n) => {
    let r = o.value;
    if (!Array.isArray(r)) return o.issues.push({ input: r, inst: e, expected: "tuple", code: "invalid_type" }), o;
    o.value = [];
    let a = [], s = [...i].reverse().findIndex((d) => d._zod.optin !== "optional"), u = s === -1 ? 0 : i.length - s;
    if (!t.rest) {
      let d = r.length > i.length, p = r.length < u - 1;
      if (d || p) return o.issues.push({ ...d ? { code: "too_big", maximum: i.length, inclusive: !0 } : { code: "too_small", minimum: i.length }, input: r, inst: e, origin: "array" }), o;
    }
    let l = -1;
    for (let d of i) {
      if (l++, l >= r.length && l >= u)
        continue;
      let p = d._zod.run({ value: r[l], issues: [] }, n);
      p instanceof Promise ? a.push(p.then((g) => Kt(g, o, l))) : Kt(p, o, l);
    }
    if (t.rest) {
      let d = r.slice(i.length);
      for (let p of d) {
        l++;
        let g = t.rest._zod.run({ value: p, issues: [] }, n);
        g instanceof Promise ? a.push(g.then((_) => Kt(_, o, l))) : Kt(g, o, l);
      }
    }
    return a.length ? Promise.all(a).then(() => o) : o;
  };
});
function Kt(e, t, i) {
  e.issues.length && t.issues.push(...he(i, e.issues)), t.value[i] = e.value;
}
var kl = m("$ZodRecord", (e, t) => {
  z.init(e, t), e._zod.parse = (i, o) => {
    let n = i.value;
    if (!Ne(n)) return i.issues.push({ expected: "record", code: "invalid_type", input: n, inst: e }), i;
    let r = [], a = t.keyType._zod.values;
    if (a) {
      i.value = {};
      let s = /* @__PURE__ */ new Set();
      for (let l of a) if (typeof l == "string" || typeof l == "number" || typeof l == "symbol") {
        s.add(typeof l == "number" ? l.toString() : l);
        let d = t.valueType._zod.run({ value: n[l], issues: [] }, o);
        d instanceof Promise ? r.push(d.then((p) => {
          p.issues.length && i.issues.push(...he(l, p.issues)), i.value[l] = p.value;
        })) : (d.issues.length && i.issues.push(...he(l, d.issues)), i.value[l] = d.value);
      }
      let u;
      for (let l in n) s.has(l) || (u = u ?? [], u.push(l));
      u && u.length > 0 && i.issues.push({ code: "unrecognized_keys", input: n, inst: e, keys: u });
    } else {
      i.value = {};
      for (let s of Reflect.ownKeys(n)) {
        if (s === "__proto__") continue;
        let u = t.keyType._zod.run({ value: s, issues: [] }, o);
        if (u instanceof Promise) throw Error("Async schemas not supported in object keys currently");
        if (typeof s == "string" && Gi.test(s) && u.issues.length && u.issues.some((d) => d.code === "invalid_type" && d.expected === "number")) {
          let d = t.keyType._zod.run({ value: Number(s), issues: [] }, o);
          if (d instanceof Promise) throw Error("Async schemas not supported in object keys currently");
          d.issues.length === 0 && (u = d);
        }
        if (u.issues.length) {
          t.mode === "loose" ? i.value[s] = n[s] : i.issues.push({ code: "invalid_key", origin: "record", issues: u.issues.map((d) => me(d, o, te())), input: s, path: [s], inst: e });
          continue;
        }
        let l = t.valueType._zod.run({ value: n[s], issues: [] }, o);
        l instanceof Promise ? r.push(l.then((d) => {
          d.issues.length && i.issues.push(...he(s, d.issues)), i.value[u.value] = d.value;
        })) : (l.issues.length && i.issues.push(...he(s, l.issues)), i.value[u.value] = l.value);
      }
    }
    return r.length ? Promise.all(r).then(() => i) : i;
  };
}), Il = m("$ZodMap", (e, t) => {
  z.init(e, t), e._zod.parse = (i, o) => {
    let n = i.value;
    if (!(n instanceof Map)) return i.issues.push({ expected: "map", code: "invalid_type", input: n, inst: e }), i;
    let r = [];
    i.value = /* @__PURE__ */ new Map();
    for (let [a, s] of n) {
      let u = t.keyType._zod.run({ value: a, issues: [] }, o), l = t.valueType._zod.run({ value: s, issues: [] }, o);
      u instanceof Promise || l instanceof Promise ? r.push(Promise.all([u, l]).then(([d, p]) => {
        ia(d, p, i, a, n, e, o);
      })) : ia(u, l, i, a, n, e, o);
    }
    return r.length ? Promise.all(r).then(() => i) : i;
  };
});
function ia(e, t, i, o, n, r, a) {
  e.issues.length && (nn.has(typeof o) ? i.issues.push(...he(o, e.issues)) : i.issues.push({ code: "invalid_key", origin: "map", input: n, inst: r, issues: e.issues.map((s) => me(s, a, te())) })), t.issues.length && (nn.has(typeof o) ? i.issues.push(...he(o, t.issues)) : i.issues.push({ origin: "map", code: "invalid_element", input: n, inst: r, key: o, issues: t.issues.map((s) => me(s, a, te())) })), i.value.set(e.value, t.value);
}
var wl = m("$ZodSet", (e, t) => {
  z.init(e, t), e._zod.parse = (i, o) => {
    let n = i.value;
    if (!(n instanceof Set)) return i.issues.push({ input: n, inst: e, expected: "set", code: "invalid_type" }), i;
    let r = [];
    i.value = /* @__PURE__ */ new Set();
    for (let a of n) {
      let s = t.valueType._zod.run({ value: a, issues: [] }, o);
      s instanceof Promise ? r.push(s.then((u) => ra(u, i))) : ra(s, i);
    }
    return r.length ? Promise.all(r).then(() => i) : i;
  };
});
function ra(e, t) {
  e.issues.length && t.issues.push(...e.issues), t.value.add(e.value);
}
var Sl = m("$ZodEnum", (e, t) => {
  z.init(e, t);
  let i = Di(t.entries), o = new Set(i);
  e._zod.values = o, e._zod.pattern = new RegExp(`^(${i.filter((n) => nn.has(typeof n)).map((n) => typeof n == "string" ? _e(n) : n.toString()).join("|")})$`), e._zod.parse = (n, r) => {
    let a = n.value;
    return o.has(a) || n.issues.push({ code: "invalid_value", values: i, input: a, inst: e }), n;
  };
}), xl = m("$ZodLiteral", (e, t) => {
  if (z.init(e, t), t.values.length === 0) throw Error("Cannot create literal schema with no valid values");
  let i = new Set(t.values);
  e._zod.values = i, e._zod.pattern = new RegExp(`^(${t.values.map((o) => typeof o == "string" ? _e(o) : o ? _e(o.toString()) : String(o)).join("|")})$`), e._zod.parse = (o, n) => {
    let r = o.value;
    return i.has(r) || o.issues.push({ code: "invalid_value", values: t.values, input: r, inst: e }), o;
  };
}), zl = m("$ZodFile", (e, t) => {
  z.init(e, t), e._zod.parse = (i, o) => {
    let n = i.value;
    return n instanceof File || i.issues.push({ expected: "file", code: "invalid_type", input: n, inst: e }), i;
  };
}), Ul = m("$ZodTransform", (e, t) => {
  z.init(e, t), e._zod.parse = (i, o) => {
    if (o.direction === "backward") throw new vn(e.constructor.name);
    let n = t.transform(i.value, i);
    if (o.async) return (n instanceof Promise ? n : Promise.resolve(n)).then((r) => (i.value = r, i));
    if (n instanceof Promise) throw new Ee();
    return i.value = n, i;
  };
});
function oa(e, t) {
  return e.issues.length && t === void 0 ? { issues: [], value: void 0 } : e;
}
var nr = m("$ZodOptional", (e, t) => {
  z.init(e, t), e._zod.optin = "optional", e._zod.optout = "optional", O(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, void 0]) : void 0), O(e._zod, "pattern", () => {
    let i = t.innerType._zod.pattern;
    return i ? new RegExp(`^(${$n(i.source)})?$`) : void 0;
  }), e._zod.parse = (i, o) => {
    if (t.innerType._zod.optin === "optional") {
      let n = t.innerType._zod.run(i, o);
      return n instanceof Promise ? n.then((r) => oa(r, i.value)) : oa(n, i.value);
    }
    return i.value === void 0 ? i : t.innerType._zod.run(i, o);
  };
}), Ol = m("$ZodExactOptional", (e, t) => {
  nr.init(e, t), O(e._zod, "values", () => t.innerType._zod.values), O(e._zod, "pattern", () => t.innerType._zod.pattern), e._zod.parse = (i, o) => t.innerType._zod.run(i, o);
}), Zl = m("$ZodNullable", (e, t) => {
  z.init(e, t), O(e._zod, "optin", () => t.innerType._zod.optin), O(e._zod, "optout", () => t.innerType._zod.optout), O(e._zod, "pattern", () => {
    let i = t.innerType._zod.pattern;
    return i ? new RegExp(`^(${$n(i.source)}|null)$`) : void 0;
  }), O(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, null]) : void 0), e._zod.parse = (i, o) => i.value === null ? i : t.innerType._zod.run(i, o);
}), Pl = m("$ZodDefault", (e, t) => {
  z.init(e, t), e._zod.optin = "optional", O(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (i, o) => {
    if (o.direction === "backward") return t.innerType._zod.run(i, o);
    if (i.value === void 0) return i.value = t.defaultValue, i;
    let n = t.innerType._zod.run(i, o);
    return n instanceof Promise ? n.then((r) => aa(r, t)) : aa(n, t);
  };
});
function aa(e, t) {
  return e.value === void 0 && (e.value = t.defaultValue), e;
}
var El = m("$ZodPrefault", (e, t) => {
  z.init(e, t), e._zod.optin = "optional", O(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (i, o) => (o.direction === "backward" || i.value === void 0 && (i.value = t.defaultValue), t.innerType._zod.run(i, o));
}), Nl = m("$ZodNonOptional", (e, t) => {
  z.init(e, t), O(e._zod, "values", () => {
    let i = t.innerType._zod.values;
    return i ? new Set([...i].filter((o) => o !== void 0)) : void 0;
  }), e._zod.parse = (i, o) => {
    let n = t.innerType._zod.run(i, o);
    return n instanceof Promise ? n.then((r) => sa(r, e)) : sa(n, e);
  };
});
function sa(e, t) {
  return !e.issues.length && e.value === void 0 && e.issues.push({ code: "invalid_type", expected: "nonoptional", input: e.value, inst: t }), e;
}
var Dl = m("$ZodSuccess", (e, t) => {
  z.init(e, t), e._zod.parse = (i, o) => {
    if (o.direction === "backward") throw new vn("ZodSuccess");
    let n = t.innerType._zod.run(i, o);
    return n instanceof Promise ? n.then((r) => (i.value = r.issues.length === 0, i)) : (i.value = n.issues.length === 0, i);
  };
}), jl = m("$ZodCatch", (e, t) => {
  z.init(e, t), O(e._zod, "optin", () => t.innerType._zod.optin), O(e._zod, "optout", () => t.innerType._zod.optout), O(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (i, o) => {
    if (o.direction === "backward") return t.innerType._zod.run(i, o);
    let n = t.innerType._zod.run(i, o);
    return n instanceof Promise ? n.then((r) => (i.value = r.value, r.issues.length && (i.value = t.catchValue({ ...i, error: { issues: r.issues.map((a) => me(a, o, te())) }, input: i.value }), i.issues = []), i)) : (i.value = n.value, n.issues.length && (i.value = t.catchValue({ ...i, error: { issues: n.issues.map((r) => me(r, o, te())) }, input: i.value }), i.issues = []), i);
  };
}), Tl = m("$ZodNaN", (e, t) => {
  z.init(e, t), e._zod.parse = (i, o) => ((typeof i.value != "number" || !Number.isNaN(i.value)) && i.issues.push({ input: i.value, inst: e, expected: "nan", code: "invalid_type" }), i);
}), Al = m("$ZodPipe", (e, t) => {
  z.init(e, t), O(e._zod, "values", () => t.in._zod.values), O(e._zod, "optin", () => t.in._zod.optin), O(e._zod, "optout", () => t.out._zod.optout), O(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (i, o) => {
    if (o.direction === "backward") {
      let r = t.out._zod.run(i, o);
      return r instanceof Promise ? r.then((a) => Vt(a, t.in, o)) : Vt(r, t.in, o);
    }
    let n = t.in._zod.run(i, o);
    return n instanceof Promise ? n.then((r) => Vt(r, t.out, o)) : Vt(n, t.out, o);
  };
});
function Vt(e, t, i) {
  return e.issues.length ? (e.aborted = !0, e) : t._zod.run({ value: e.value, issues: e.issues }, i);
}
var ir = m("$ZodCodec", (e, t) => {
  z.init(e, t), O(e._zod, "values", () => t.in._zod.values), O(e._zod, "optin", () => t.in._zod.optin), O(e._zod, "optout", () => t.out._zod.optout), O(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (i, o) => {
    if ((o.direction || "forward") === "forward") {
      let n = t.in._zod.run(i, o);
      return n instanceof Promise ? n.then((r) => Gt(r, t, o)) : Gt(n, t, o);
    } else {
      let n = t.out._zod.run(i, o);
      return n instanceof Promise ? n.then((r) => Gt(r, t, o)) : Gt(n, t, o);
    }
  };
});
function Gt(e, t, i) {
  if (e.issues.length) return e.aborted = !0, e;
  if ((i.direction || "forward") === "forward") {
    let o = t.transform(e.value, e);
    return o instanceof Promise ? o.then((n) => Bt(e, n, t.out, i)) : Bt(e, o, t.out, i);
  } else {
    let o = t.reverseTransform(e.value, e);
    return o instanceof Promise ? o.then((n) => Bt(e, n, t.in, i)) : Bt(e, o, t.in, i);
  }
}
function Bt(e, t, i, o) {
  return e.issues.length ? (e.aborted = !0, e) : i._zod.run({ value: t, issues: e.issues }, o);
}
var Rl = m("$ZodReadonly", (e, t) => {
  z.init(e, t), O(e._zod, "propValues", () => t.innerType._zod.propValues), O(e._zod, "values", () => t.innerType._zod.values), O(e._zod, "optin", () => t.innerType?._zod?.optin), O(e._zod, "optout", () => t.innerType?._zod?.optout), e._zod.parse = (i, o) => {
    if (o.direction === "backward") return t.innerType._zod.run(i, o);
    let n = t.innerType._zod.run(i, o);
    return n instanceof Promise ? n.then(ua) : ua(n);
  };
});
function ua(e) {
  return e.value = Object.freeze(e.value), e;
}
var Cl = m("$ZodTemplateLiteral", (e, t) => {
  z.init(e, t);
  let i = [];
  for (let o of t.parts) if (typeof o == "object" && o !== null) {
    if (!o._zod.pattern) throw Error(`Invalid template literal part, no pattern found: ${[...o._zod.traits].shift()}`);
    let n = o._zod.pattern instanceof RegExp ? o._zod.pattern.source : o._zod.pattern;
    if (!n) throw Error(`Invalid template literal part: ${o._zod.traits}`);
    let r = n.startsWith("^") ? 1 : 0, a = n.endsWith("$") ? n.length - 1 : n.length;
    i.push(n.slice(r, a));
  } else if (o === null || ys.has(typeof o)) i.push(_e(`${o}`));
  else throw Error(`Invalid template literal part: ${o}`);
  e._zod.pattern = new RegExp(`^${i.join("")}$`), e._zod.parse = (o, n) => typeof o.value != "string" ? (o.issues.push({ input: o.value, inst: e, expected: "string", code: "invalid_type" }), o) : (e._zod.pattern.lastIndex = 0, e._zod.pattern.test(o.value) || o.issues.push({ input: o.value, inst: e, code: "invalid_format", format: t.format ?? "template_literal", pattern: e._zod.pattern.source }), o);
}), Ml = m("$ZodFunction", (e, t) => (z.init(e, t), e._def = t, e._zod.def = t, e.implement = (i) => {
  if (typeof i != "function") throw Error("implement() must be called with a function");
  return function(...o) {
    let n = e._def.input ? gi(e._def.input, o) : o, r = Reflect.apply(i, this, n);
    return e._def.output ? gi(e._def.output, r) : r;
  };
}, e.implementAsync = (i) => {
  if (typeof i != "function") throw Error("implementAsync() must be called with a function");
  return async function(...o) {
    let n = e._def.input ? await hi(e._def.input, o) : o, r = await Reflect.apply(i, this, n);
    return e._def.output ? await hi(e._def.output, r) : r;
  };
}, e._zod.parse = (i, o) => typeof i.value != "function" ? (i.issues.push({ code: "invalid_type", expected: "function", input: i.value, inst: e }), i) : (e._def.output && e._def.output._zod.def.type === "promise" ? i.value = e.implementAsync(i.value) : i.value = e.implement(i.value), i), e.input = (...i) => {
  let o = e.constructor;
  return Array.isArray(i[0]) ? new o({ type: "function", input: new tr({ type: "tuple", items: i[0], rest: i[1] }), output: e._def.output }) : new o({ type: "function", input: i[0], output: e._def.output });
}, e.output = (i) => new e.constructor({ type: "function", input: e._def.input, output: i }), e)), Ll = m("$ZodPromise", (e, t) => {
  z.init(e, t), e._zod.parse = (i, o) => Promise.resolve(i.value).then((n) => t.innerType._zod.run({ value: n, issues: [] }, o));
}), Fl = m("$ZodLazy", (e, t) => {
  z.init(e, t), O(e._zod, "innerType", () => t.getter()), O(e._zod, "pattern", () => e._zod.innerType?._zod?.pattern), O(e._zod, "propValues", () => e._zod.innerType?._zod?.propValues), O(e._zod, "optin", () => e._zod.innerType?._zod?.optin ?? void 0), O(e._zod, "optout", () => e._zod.innerType?._zod?.optout ?? void 0), e._zod.parse = (i, o) => e._zod.innerType._zod.run(i, o);
}), Jl = m("$ZodCustom", (e, t) => {
  J.init(e, t), z.init(e, t), e._zod.parse = (i, o) => i, e._zod.check = (i) => {
    let o = i.value, n = t.fn(o);
    if (n instanceof Promise) return n.then((r) => la(r, i, o, e));
    la(n, i, o, e);
  };
});
function la(e, t, i, o) {
  if (!e) {
    let n = { code: "custom", input: i, inst: o, path: [...o._zod.def.path ?? []], continue: !o._zod.def.abort };
    o._zod.def.params && (n.params = o._zod.def.params), t.issues.push(rn(n));
  }
}
var rr = {};
be(rr, { zhTW: () => Ny, zhCN: () => Py, yo: () => jy, vi: () => Oy, uz: () => zy, ur: () => Sy, uk: () => Kl, ua: () => Iy, tr: () => yy, th: () => _y, ta: () => vy, sv: () => gy, sl: () => py, ru: () => dy, pt: () => ly, ps: () => oy, pl: () => sy, ota: () => iy, no: () => ty, nl: () => Qb, ms: () => Xb, mk: () => Bb, lt: () => Vb, ko: () => Wb, km: () => Wl, kh: () => Jb, ka: () => Lb, ja: () => Cb, it: () => Ab, is: () => jb, id: () => Nb, hy: () => Pb, hu: () => Ob, he: () => zb, frCA: () => Sb, fr: () => Ib, fi: () => yb, fa: () => _b, es: () => vb, eo: () => gb, en: () => ql, de: () => mb, da: () => cb, cs: () => ub, ca: () => ab, bg: () => rb, be: () => nb, az: () => eb, ar: () => Y_ });
var X_ = () => {
  let e = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "", email: " ", url: "", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ISO", date: "  ISO", time: "  ISO", duration: "  ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: "   IPv4", cidrv6: "   IPv6", base64: "  base64-encoded", base64url: "  base64url-encoded", json_string: "   JSON", e164: "   E.164", jwt: "JWT", template_literal: "" }, o = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `  :   instanceof ${n.expected}    ${s}` : `  :   ${r}    ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `  :   ${w(n.values[0])}` : `  :     : ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `   :    ${n.origin ?? ""} ${r} ${n.maximum.toString()} ${a.unit ?? ""}` : `  :    ${n.origin ?? ""} ${r} ${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `  :   ${n.origin}   ${r} ${n.minimum.toString()} ${a.unit}` : `  :   ${n.origin}   ${r} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `  :     "${n.prefix}"` : r.format === "ends_with" ? `  :     "${r.suffix}"` : r.format === "includes" ? `  :    "${r.includes}"` : r.format === "regex" ? `  :     ${r.pattern}` : `${i[r.format] ?? n.format}  `;
      }
      case "not_multiple_of":
        return `  :      ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "" : ""} ${n.keys.length > 1 ? "" : ""}: ${v(n.keys, " ")}`;
      case "invalid_key":
        return `    ${n.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `    ${n.origin}`;
      default:
        return "  ";
    }
  };
};
function Y_() {
  return { localeError: X_() };
}
var Q_ = () => {
  let e = { string: { unit: "simvol", verb: "olmaldr" }, file: { unit: "bayt", verb: "olmaldr" }, array: { unit: "element", verb: "olmaldr" }, set: { unit: "element", verb: "olmaldr" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" }, o = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Yanl dyr: gzlniln instanceof ${n.expected}, daxil olan ${s}` : `Yanl dyr: gzlniln ${r}, daxil olan ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Yanl dyr: gzlniln ${w(n.values[0])}` : `Yanl seim: aadaklardan biri olmaldr: ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `ox byk: gzlniln ${n.origin ?? "dyr"} ${r}${n.maximum.toString()} ${a.unit ?? "element"}` : `ox byk: gzlniln ${n.origin ?? "dyr"} ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `ox kiik: gzlniln ${n.origin} ${r}${n.minimum.toString()} ${a.unit}` : `ox kiik: gzlniln ${n.origin} ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Yanl mtn: "${r.prefix}" il balamaldr` : r.format === "ends_with" ? `Yanl mtn: "${r.suffix}" il bitmlidir` : r.format === "includes" ? `Yanl mtn: "${r.includes}" daxil olmaldr` : r.format === "regex" ? `Yanl mtn: ${r.pattern} ablonuna uyun olmaldr` : `Yanl ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Yanl dd: ${n.divisor} il bln biln olmaldr`;
      case "unrecognized_keys":
        return `Tannmayan aar${n.keys.length > 1 ? "lar" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} daxilind yanl aar`;
      case "invalid_union":
        return "Yanl dyr";
      case "invalid_element":
        return `${n.origin} daxilind yanl dyr`;
      default:
        return "Yanl dyr";
    }
  };
};
function eb() {
  return { localeError: Q_() };
}
function ca(e, t, i, o) {
  let n = Math.abs(e), r = n % 10, a = n % 100;
  return a >= 11 && a <= 19 ? o : r === 1 ? t : r >= 2 && r <= 4 ? i : o;
}
var tb = () => {
  let e = { string: { unit: { one: "", few: "", many: "" }, verb: "" }, array: { unit: { one: "", few: "", many: "" }, verb: "" }, set: { unit: { one: "", few: "", many: "" }, verb: "" }, file: { unit: { one: "", few: "", many: "" }, verb: "" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "", email: "email ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "   base64", base64url: "   base64url", json_string: "JSON ", e164: " E.164", jwt: "JWT", template_literal: "" }, o = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? ` :  instanceof ${n.expected},  ${s}` : ` :  ${r},  ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? ` :  ${w(n.values[0])}` : ` :    ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        if (a) {
          let s = Number(n.maximum), u = ca(s, a.unit.one, a.unit.few, a.unit.many);
          return ` : ,  ${n.origin ?? ""}  ${a.verb} ${r}${n.maximum.toString()} ${u}`;
        }
        return ` : ,  ${n.origin ?? ""}   ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        if (a) {
          let s = Number(n.minimum), u = ca(s, a.unit.one, a.unit.few, a.unit.many);
          return ` : ,  ${n.origin}  ${a.verb} ${r}${n.minimum.toString()} ${u}`;
        }
        return ` : ,  ${n.origin}   ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? ` :    "${r.prefix}"` : r.format === "ends_with" ? ` :    "${r.suffix}"` : r.format === "includes" ? ` :   "${r.includes}"` : r.format === "regex" ? ` :    ${r.pattern}` : ` ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` :    ${n.divisor}`;
      case "unrecognized_keys":
        return ` ${n.keys.length > 1 ? "" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${n.origin}`;
      default:
        return " ";
    }
  };
};
function nb() {
  return { localeError: tb() };
}
var ib = () => {
  let e = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "", email: " ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64- ", base64url: "base64url- ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, o = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? ` :  instanceof ${n.expected},  ${s}` : ` :  ${r},  ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? ` :  ${w(n.values[0])}` : ` :    ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? ` :   ${n.origin ?? ""}   ${r}${n.maximum.toString()} ${a.unit ?? ""}` : ` :   ${n.origin ?? ""}   ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? ` :   ${n.origin}   ${r}${n.minimum.toString()} ${a.unit}` : ` :   ${n.origin}   ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        if (r.format === "starts_with") return ` :     "${r.prefix}"`;
        if (r.format === "ends_with") return ` :     "${r.suffix}"`;
        if (r.format === "includes") return ` :    "${r.includes}"`;
        if (r.format === "regex") return ` :     ${r.pattern}`;
        let a = "";
        return r.format === "emoji" && (a = ""), r.format === "datetime" && (a = ""), r.format === "date" && (a = ""), r.format === "time" && (a = ""), r.format === "duration" && (a = ""), `${a} ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` :      ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "" : ""} ${n.keys.length > 1 ? "" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${n.origin}`;
      default:
        return " ";
    }
  };
};
function rb() {
  return { localeError: ib() };
}
var ob = () => {
  let e = { string: { unit: "carcters", verb: "contenir" }, file: { unit: "bytes", verb: "contenir" }, array: { unit: "elements", verb: "contenir" }, set: { unit: "elements", verb: "contenir" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "entrada", email: "adrea electrnica", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i hora ISO", date: "data ISO", time: "hora ISO", duration: "durada ISO", ipv4: "adrea IPv4", ipv6: "adrea IPv6", cidrv4: "rang IPv4", cidrv6: "rang IPv6", base64: "cadena codificada en base64", base64url: "cadena codificada en base64url", json_string: "cadena JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" }, o = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Tipus invlid: s'esperava instanceof ${n.expected}, s'ha rebut ${s}` : `Tipus invlid: s'esperava ${r}, s'ha rebut ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Valor invlid: s'esperava ${w(n.values[0])}` : `Opci invlida: s'esperava una de ${v(n.values, " o ")}`;
      case "too_big": {
        let r = n.inclusive ? "com a mxim" : "menys de", a = t(n.origin);
        return a ? `Massa gran: s'esperava que ${n.origin ?? "el valor"} contingus ${r} ${n.maximum.toString()} ${a.unit ?? "elements"}` : `Massa gran: s'esperava que ${n.origin ?? "el valor"} fos ${r} ${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? "com a mnim" : "ms de", a = t(n.origin);
        return a ? `Massa petit: s'esperava que ${n.origin} contingus ${r} ${n.minimum.toString()} ${a.unit}` : `Massa petit: s'esperava que ${n.origin} fos ${r} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Format invlid: ha de comenar amb "${r.prefix}"` : r.format === "ends_with" ? `Format invlid: ha d'acabar amb "${r.suffix}"` : r.format === "includes" ? `Format invlid: ha d'incloure "${r.includes}"` : r.format === "regex" ? `Format invlid: ha de coincidir amb el patr ${r.pattern}` : `Format invlid per a ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlid: ha de ser mltiple de ${n.divisor}`;
      case "unrecognized_keys":
        return `Clau${n.keys.length > 1 ? "s" : ""} no reconeguda${n.keys.length > 1 ? "s" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Clau invlida a ${n.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Element invlid a ${n.origin}`;
      default:
        return "Entrada invlida";
    }
  };
};
function ab() {
  return { localeError: ob() };
}
var sb = () => {
  let e = { string: { unit: "znak", verb: "mt" }, file: { unit: "bajt", verb: "mt" }, array: { unit: "prvk", verb: "mt" }, set: { unit: "prvk", verb: "mt" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "regulrn vraz", email: "e-mailov adresa", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "datum a as ve formtu ISO", date: "datum ve formtu ISO", time: "as ve formtu ISO", duration: "doba trvn ISO", ipv4: "IPv4 adresa", ipv6: "IPv6 adresa", cidrv4: "rozsah IPv4", cidrv6: "rozsah IPv6", base64: "etzec zakdovan ve formtu base64", base64url: "etzec zakdovan ve formtu base64url", json_string: "etzec ve formtu JSON", e164: "slo E.164", jwt: "JWT", template_literal: "vstup" }, o = { nan: "NaN", number: "slo", string: "etzec", function: "funkce", array: "pole" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Neplatn vstup: oekvno instanceof ${n.expected}, obdreno ${s}` : `Neplatn vstup: oekvno ${r}, obdreno ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Neplatn vstup: oekvno ${w(n.values[0])}` : `Neplatn monost: oekvna jedna z hodnot ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Hodnota je pli velk: ${n.origin ?? "hodnota"} mus mt ${r}${n.maximum.toString()} ${a.unit ?? "prvk"}` : `Hodnota je pli velk: ${n.origin ?? "hodnota"} mus bt ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Hodnota je pli mal: ${n.origin ?? "hodnota"} mus mt ${r}${n.minimum.toString()} ${a.unit ?? "prvk"}` : `Hodnota je pli mal: ${n.origin ?? "hodnota"} mus bt ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Neplatn etzec: mus zanat na "${r.prefix}"` : r.format === "ends_with" ? `Neplatn etzec: mus konit na "${r.suffix}"` : r.format === "includes" ? `Neplatn etzec: mus obsahovat "${r.includes}"` : r.format === "regex" ? `Neplatn etzec: mus odpovdat vzoru ${r.pattern}` : `Neplatn formt ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Neplatn slo: mus bt nsobkem ${n.divisor}`;
      case "unrecognized_keys":
        return `Neznm kle: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn kl v ${n.origin}`;
      case "invalid_union":
        return "Neplatn vstup";
      case "invalid_element":
        return `Neplatn hodnota v ${n.origin}`;
      default:
        return "Neplatn vstup";
    }
  };
};
function ub() {
  return { localeError: sb() };
}
var lb = () => {
  let e = { string: { unit: "tegn", verb: "havde" }, file: { unit: "bytes", verb: "havde" }, array: { unit: "elementer", verb: "indeholdt" }, set: { unit: "elementer", verb: "indeholdt" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "input", email: "e-mailadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslt", date: "ISO-dato", time: "ISO-klokkeslt", duration: "ISO-varighed", ipv4: "IPv4-omrde", ipv6: "IPv6-omrde", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodet streng", base64url: "base64url-kodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" }, o = { nan: "NaN", string: "streng", number: "tal", boolean: "boolean", array: "liste", object: "objekt", set: "st", file: "fil" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Ugyldigt input: forventede instanceof ${n.expected}, fik ${s}` : `Ugyldigt input: forventede ${r}, fik ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Ugyldig vrdi: forventede ${w(n.values[0])}` : `Ugyldigt valg: forventede en af flgende ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin), s = o[n.origin] ?? n.origin;
        return a ? `For stor: forventede ${s ?? "value"} ${a.verb} ${r} ${n.maximum.toString()} ${a.unit ?? "elementer"}` : `For stor: forventede ${s ?? "value"} havde ${r} ${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin), s = o[n.origin] ?? n.origin;
        return a ? `For lille: forventede ${s} ${a.verb} ${r} ${n.minimum.toString()} ${a.unit}` : `For lille: forventede ${s} havde ${r} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Ugyldig streng: skal starte med "${r.prefix}"` : r.format === "ends_with" ? `Ugyldig streng: skal ende med "${r.suffix}"` : r.format === "includes" ? `Ugyldig streng: skal indeholde "${r.includes}"` : r.format === "regex" ? `Ugyldig streng: skal matche mnsteret ${r.pattern}` : `Ugyldig ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal vre deleligt med ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Ukendte ngler" : "Ukendt ngle"}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig ngle i ${n.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig vrdi i ${n.origin}`;
      default:
        return "Ugyldigt input";
    }
  };
};
function cb() {
  return { localeError: lb() };
}
var db = () => {
  let e = { string: { unit: "Zeichen", verb: "zu haben" }, file: { unit: "Bytes", verb: "zu haben" }, array: { unit: "Elemente", verb: "zu haben" }, set: { unit: "Elemente", verb: "zu haben" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "Eingabe", email: "E-Mail-Adresse", url: "URL", emoji: "Emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-Datum und -Uhrzeit", date: "ISO-Datum", time: "ISO-Uhrzeit", duration: "ISO-Dauer", ipv4: "IPv4-Adresse", ipv6: "IPv6-Adresse", cidrv4: "IPv4-Bereich", cidrv6: "IPv6-Bereich", base64: "Base64-codierter String", base64url: "Base64-URL-codierter String", json_string: "JSON-String", e164: "E.164-Nummer", jwt: "JWT", template_literal: "Eingabe" }, o = { nan: "NaN", number: "Zahl", array: "Array" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Ungltige Eingabe: erwartet instanceof ${n.expected}, erhalten ${s}` : `Ungltige Eingabe: erwartet ${r}, erhalten ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Ungltige Eingabe: erwartet ${w(n.values[0])}` : `Ungltige Option: erwartet eine von ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Zu gro: erwartet, dass ${n.origin ?? "Wert"} ${r}${n.maximum.toString()} ${a.unit ?? "Elemente"} hat` : `Zu gro: erwartet, dass ${n.origin ?? "Wert"} ${r}${n.maximum.toString()} ist`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Zu klein: erwartet, dass ${n.origin} ${r}${n.minimum.toString()} ${a.unit} hat` : `Zu klein: erwartet, dass ${n.origin} ${r}${n.minimum.toString()} ist`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Ungltiger String: muss mit "${r.prefix}" beginnen` : r.format === "ends_with" ? `Ungltiger String: muss mit "${r.suffix}" enden` : r.format === "includes" ? `Ungltiger String: muss "${r.includes}" enthalten` : r.format === "regex" ? `Ungltiger String: muss dem Muster ${r.pattern} entsprechen` : `Ungltig: ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ungltige Zahl: muss ein Vielfaches von ${n.divisor} sein`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Ungltiger Schlssel in ${n.origin}`;
      case "invalid_union":
        return "Ungltige Eingabe";
      case "invalid_element":
        return `Ungltiger Wert in ${n.origin}`;
      default:
        return "Ungltige Eingabe";
    }
  };
};
function mb() {
  return { localeError: db() };
}
var pb = () => {
  let e = { string: { unit: "characters", verb: "to have" }, file: { unit: "bytes", verb: "to have" }, array: { unit: "items", verb: "to have" }, set: { unit: "items", verb: "to have" }, map: { unit: "entries", verb: "to have" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", mac: "MAC address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" }, o = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return `Invalid input: expected ${r}, received ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Invalid input: expected ${w(n.values[0])}` : `Invalid option: expected one of ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Too big: expected ${n.origin ?? "value"} to have ${r}${n.maximum.toString()} ${a.unit ?? "elements"}` : `Too big: expected ${n.origin ?? "value"} to be ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Too small: expected ${n.origin} to have ${r}${n.minimum.toString()} ${a.unit}` : `Too small: expected ${n.origin} to be ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Invalid string: must start with "${r.prefix}"` : r.format === "ends_with" ? `Invalid string: must end with "${r.suffix}"` : r.format === "includes" ? `Invalid string: must include "${r.includes}"` : r.format === "regex" ? `Invalid string: must match pattern ${r.pattern}` : `Invalid ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${n.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${n.keys.length > 1 ? "s" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${n.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${n.origin}`;
      default:
        return "Invalid input";
    }
  };
};
function ql() {
  return { localeError: pb() };
}
var fb = () => {
  let e = { string: { unit: "karaktrojn", verb: "havi" }, file: { unit: "bajtojn", verb: "havi" }, array: { unit: "elementojn", verb: "havi" }, set: { unit: "elementojn", verb: "havi" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "enigo", email: "retadreso", url: "URL", emoji: "emoio", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datotempo", date: "ISO-dato", time: "ISO-tempo", duration: "ISO-daro", ipv4: "IPv4-adreso", ipv6: "IPv6-adreso", cidrv4: "IPv4-rango", cidrv6: "IPv6-rango", base64: "64-ume kodita karaktraro", base64url: "URL-64-ume kodita karaktraro", json_string: "JSON-karaktraro", e164: "E.164-nombro", jwt: "JWT", template_literal: "enigo" }, o = { nan: "NaN", number: "nombro", array: "tabelo", null: "senvalora" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Nevalida enigo: atendiis instanceof ${n.expected}, riceviis ${s}` : `Nevalida enigo: atendiis ${r}, riceviis ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Nevalida enigo: atendiis ${w(n.values[0])}` : `Nevalida opcio: atendiis unu el ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Tro granda: atendiis ke ${n.origin ?? "valoro"} havu ${r}${n.maximum.toString()} ${a.unit ?? "elementojn"}` : `Tro granda: atendiis ke ${n.origin ?? "valoro"} havu ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Tro malgranda: atendiis ke ${n.origin} havu ${r}${n.minimum.toString()} ${a.unit}` : `Tro malgranda: atendiis ke ${n.origin} estu ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Nevalida karaktraro: devas komencii per "${r.prefix}"` : r.format === "ends_with" ? `Nevalida karaktraro: devas finii per "${r.suffix}"` : r.format === "includes" ? `Nevalida karaktraro: devas inkluzivi "${r.includes}"` : r.format === "regex" ? `Nevalida karaktraro: devas kongrui kun la modelo ${r.pattern}` : `Nevalida ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${n.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${n.keys.length > 1 ? "j" : ""} losilo${n.keys.length > 1 ? "j" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida losilo en ${n.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${n.origin}`;
      default:
        return "Nevalida enigo";
    }
  };
};
function gb() {
  return { localeError: fb() };
}
var hb = () => {
  let e = { string: { unit: "caracteres", verb: "tener" }, file: { unit: "bytes", verb: "tener" }, array: { unit: "elementos", verb: "tener" }, set: { unit: "elementos", verb: "tener" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "entrada", email: "direccin de correo electrnico", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "fecha y hora ISO", date: "fecha ISO", time: "hora ISO", duration: "duracin ISO", ipv4: "direccin IPv4", ipv6: "direccin IPv6", cidrv4: "rango IPv4", cidrv6: "rango IPv6", base64: "cadena codificada en base64", base64url: "URL codificada en base64", json_string: "cadena JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" }, o = { nan: "NaN", string: "texto", number: "nmero", boolean: "booleano", array: "arreglo", object: "objeto", set: "conjunto", file: "archivo", date: "fecha", bigint: "nmero grande", symbol: "smbolo", undefined: "indefinido", null: "nulo", function: "funcin", map: "mapa", record: "registro", tuple: "tupla", enum: "enumeracin", union: "unin", literal: "literal", promise: "promesa", void: "vaco", never: "nunca", unknown: "desconocido", any: "cualquiera" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Entrada invlida: se esperaba instanceof ${n.expected}, recibido ${s}` : `Entrada invlida: se esperaba ${r}, recibido ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Entrada invlida: se esperaba ${w(n.values[0])}` : `Opcin invlida: se esperaba una de ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin), s = o[n.origin] ?? n.origin;
        return a ? `Demasiado grande: se esperaba que ${s ?? "valor"} tuviera ${r}${n.maximum.toString()} ${a.unit ?? "elementos"}` : `Demasiado grande: se esperaba que ${s ?? "valor"} fuera ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin), s = o[n.origin] ?? n.origin;
        return a ? `Demasiado pequeo: se esperaba que ${s} tuviera ${r}${n.minimum.toString()} ${a.unit}` : `Demasiado pequeo: se esperaba que ${s} fuera ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Cadena invlida: debe comenzar con "${r.prefix}"` : r.format === "ends_with" ? `Cadena invlida: debe terminar en "${r.suffix}"` : r.format === "includes" ? `Cadena invlida: debe incluir "${r.includes}"` : r.format === "regex" ? `Cadena invlida: debe coincidir con el patrn ${r.pattern}` : `Invlido ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlido: debe ser mltiplo de ${n.divisor}`;
      case "unrecognized_keys":
        return `Llave${n.keys.length > 1 ? "s" : ""} desconocida${n.keys.length > 1 ? "s" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Llave invlida en ${o[n.origin] ?? n.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido en ${o[n.origin] ?? n.origin}`;
      default:
        return "Entrada invlida";
    }
  };
};
function vb() {
  return { localeError: hb() };
}
var $b = () => {
  let e = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "", email: " ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ", date: " ", time: " ", duration: "  ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, o = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? ` :  instanceof ${n.expected}  ${s}  ` : ` :  ${r}  ${s}  `;
      }
      case "invalid_value":
        return n.values.length === 1 ? ` :  ${w(n.values[0])} ` : ` :    ${v(n.values, "|")} `;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? ` : ${n.origin ?? ""}  ${r}${n.maximum.toString()} ${a.unit ?? ""} ` : ` : ${n.origin ?? ""}  ${r}${n.maximum.toString()} `;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? ` : ${n.origin}  ${r}${n.minimum.toString()} ${a.unit} ` : ` : ${n.origin}  ${r}${n.minimum.toString()} `;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? ` :   "${r.prefix}"  ` : r.format === "ends_with" ? ` :   "${r.suffix}"  ` : r.format === "includes" ? ` :   "${r.includes}" ` : r.format === "regex" ? ` :    ${r.pattern}   ` : `${i[r.format] ?? n.format} `;
      }
      case "not_multiple_of":
        return ` :   ${n.divisor} `;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "" : ""} : ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${n.origin}`;
      default:
        return " ";
    }
  };
};
function _b() {
  return { localeError: $b() };
}
var bb = () => {
  let e = { string: { unit: "merkki", subject: "merkkijonon" }, file: { unit: "tavua", subject: "tiedoston" }, array: { unit: "alkiota", subject: "listan" }, set: { unit: "alkiota", subject: "joukon" }, number: { unit: "", subject: "luvun" }, bigint: { unit: "", subject: "suuren kokonaisluvun" }, int: { unit: "", subject: "kokonaisluvun" }, date: { unit: "", subject: "pivmrn" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "snnllinen lauseke", email: "shkpostiosoite", url: "URL-osoite", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-aikaleima", date: "ISO-pivmr", time: "ISO-aika", duration: "ISO-kesto", ipv4: "IPv4-osoite", ipv6: "IPv6-osoite", cidrv4: "IPv4-alue", cidrv6: "IPv6-alue", base64: "base64-koodattu merkkijono", base64url: "base64url-koodattu merkkijono", json_string: "JSON-merkkijono", e164: "E.164-luku", jwt: "JWT", template_literal: "templaattimerkkijono" }, o = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Virheellinen tyyppi: odotettiin instanceof ${n.expected}, oli ${s}` : `Virheellinen tyyppi: odotettiin ${r}, oli ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Virheellinen syte: tytyy olla ${w(n.values[0])}` : `Virheellinen valinta: tytyy olla yksi seuraavista: ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Liian suuri: ${a.subject} tytyy olla ${r}${n.maximum.toString()} ${a.unit}`.trim() : `Liian suuri: arvon tytyy olla ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Liian pieni: ${a.subject} tytyy olla ${r}${n.minimum.toString()} ${a.unit}`.trim() : `Liian pieni: arvon tytyy olla ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Virheellinen syte: tytyy alkaa "${r.prefix}"` : r.format === "ends_with" ? `Virheellinen syte: tytyy loppua "${r.suffix}"` : r.format === "includes" ? `Virheellinen syte: tytyy sislt "${r.includes}"` : r.format === "regex" ? `Virheellinen syte: tytyy vastata snnllist lauseketta ${r.pattern}` : `Virheellinen ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: tytyy olla luvun ${n.divisor} monikerta`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return "Virheellinen syte";
    }
  };
};
function yb() {
  return { localeError: bb() };
}
var kb = () => {
  let e = { string: { unit: "caractres", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "lments", verb: "avoir" }, set: { unit: "lments", verb: "avoir" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "entre", email: "adresse e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date et heure ISO", date: "date ISO", time: "heure ISO", duration: "dure ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chane encode en base64", base64url: "chane encode en base64url", json_string: "chane JSON", e164: "numro E.164", jwt: "JWT", template_literal: "entre" }, o = { nan: "NaN", number: "nombre", array: "tableau" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Entre invalide : instanceof ${n.expected} attendu, ${s} reu` : `Entre invalide : ${r} attendu, ${s} reu`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Entre invalide : ${w(n.values[0])} attendu` : `Option invalide : une valeur parmi ${v(n.values, "|")} attendue`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Trop grand : ${n.origin ?? "valeur"} doit ${a.verb} ${r}${n.maximum.toString()} ${a.unit ?? "lment(s)"}` : `Trop grand : ${n.origin ?? "valeur"} doit tre ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Trop petit : ${n.origin} doit ${a.verb} ${r}${n.minimum.toString()} ${a.unit}` : `Trop petit : ${n.origin} doit tre ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Chane invalide : doit commencer par "${r.prefix}"` : r.format === "ends_with" ? `Chane invalide : doit se terminer par "${r.suffix}"` : r.format === "includes" ? `Chane invalide : doit inclure "${r.includes}"` : r.format === "regex" ? `Chane invalide : doit correspondre au modle ${r.pattern}` : `${i[r.format] ?? n.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${n.divisor}`;
      case "unrecognized_keys":
        return `Cl${n.keys.length > 1 ? "s" : ""} non reconnue${n.keys.length > 1 ? "s" : ""} : ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${n.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${n.origin}`;
      default:
        return "Entre invalide";
    }
  };
};
function Ib() {
  return { localeError: kb() };
}
var wb = () => {
  let e = { string: { unit: "caractres", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "lments", verb: "avoir" }, set: { unit: "lments", verb: "avoir" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "entre", email: "adresse courriel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date-heure ISO", date: "date ISO", time: "heure ISO", duration: "dure ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chane encode en base64", base64url: "chane encode en base64url", json_string: "chane JSON", e164: "numro E.164", jwt: "JWT", template_literal: "entre" }, o = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Entre invalide : attendu instanceof ${n.expected}, reu ${s}` : `Entre invalide : attendu ${r}, reu ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Entre invalide : attendu ${w(n.values[0])}` : `Option invalide : attendu l'une des valeurs suivantes ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "" : "<", a = t(n.origin);
        return a ? `Trop grand : attendu que ${n.origin ?? "la valeur"} ait ${r}${n.maximum.toString()} ${a.unit}` : `Trop grand : attendu que ${n.origin ?? "la valeur"} soit ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? "" : ">", a = t(n.origin);
        return a ? `Trop petit : attendu que ${n.origin} ait ${r}${n.minimum.toString()} ${a.unit}` : `Trop petit : attendu que ${n.origin} soit ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Chane invalide : doit commencer par "${r.prefix}"` : r.format === "ends_with" ? `Chane invalide : doit se terminer par "${r.suffix}"` : r.format === "includes" ? `Chane invalide : doit inclure "${r.includes}"` : r.format === "regex" ? `Chane invalide : doit correspondre au motif ${r.pattern}` : `${i[r.format] ?? n.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${n.divisor}`;
      case "unrecognized_keys":
        return `Cl${n.keys.length > 1 ? "s" : ""} non reconnue${n.keys.length > 1 ? "s" : ""} : ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${n.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${n.origin}`;
      default:
        return "Entre invalide";
    }
  };
};
function Sb() {
  return { localeError: wb() };
}
var xb = () => {
  let e = { string: { label: "", gender: "f" }, number: { label: "", gender: "m" }, boolean: { label: " ", gender: "m" }, bigint: { label: "BigInt", gender: "m" }, date: { label: "", gender: "m" }, array: { label: "", gender: "m" }, object: { label: "", gender: "m" }, null: { label: "  (null)", gender: "m" }, undefined: { label: "   (undefined)", gender: "m" }, symbol: { label: " (Symbol)", gender: "m" }, function: { label: "", gender: "f" }, map: { label: " (Map)", gender: "f" }, set: { label: " (Set)", gender: "f" }, file: { label: "", gender: "m" }, promise: { label: "Promise", gender: "m" }, NaN: { label: "NaN", gender: "m" }, unknown: { label: "  ", gender: "m" }, value: { label: "", gender: "m" } }, t = { string: { unit: "", shortLabel: "", longLabel: "" }, file: { unit: "", shortLabel: "", longLabel: "" }, array: { unit: "", shortLabel: "", longLabel: "" }, set: { unit: "", shortLabel: "", longLabel: "" }, number: { unit: "", shortLabel: "", longLabel: "" } }, i = (l) => l ? e[l] : void 0, o = (l) => {
    let d = i(l);
    return d ? d.label : l ?? e.unknown.label;
  }, n = (l) => `${o(l)}`, r = (l) => (i(l)?.gender ?? "m") === "f" ? " " : " ", a = (l) => l ? t[l] ?? null : null, s = { regex: { label: "", gender: "m" }, email: { label: " ", gender: "f" }, url: { label: " ", gender: "f" }, emoji: { label: "'", gender: "m" }, uuid: { label: "UUID", gender: "m" }, nanoid: { label: "nanoid", gender: "m" }, guid: { label: "GUID", gender: "m" }, cuid: { label: "cuid", gender: "m" }, cuid2: { label: "cuid2", gender: "m" }, ulid: { label: "ULID", gender: "m" }, xid: { label: "XID", gender: "m" }, ksuid: { label: "KSUID", gender: "m" }, datetime: { label: "  ISO", gender: "m" }, date: { label: " ISO", gender: "m" }, time: { label: " ISO", gender: "m" }, duration: { label: "  ISO", gender: "m" }, ipv4: { label: " IPv4", gender: "f" }, ipv6: { label: " IPv6", gender: "f" }, cidrv4: { label: " IPv4", gender: "m" }, cidrv6: { label: " IPv6", gender: "m" }, base64: { label: "  64", gender: "f" }, base64url: { label: "  64  ", gender: "f" }, json_string: { label: " JSON", gender: "f" }, e164: { label: " E.164", gender: "m" }, jwt: { label: "JWT", gender: "m" }, ends_with: { label: "", gender: "m" }, includes: { label: "", gender: "m" }, lowercase: { label: "", gender: "m" }, starts_with: { label: "", gender: "m" }, uppercase: { label: "", gender: "m" } }, u = { nan: "NaN" };
  return (l) => {
    switch (l.code) {
      case "invalid_type": {
        let d = l.expected, p = u[d ?? ""] ?? o(d), g = S(l.input), _ = u[g] ?? e[g]?.label ?? g;
        return /^[A-Z]/.test(l.expected) ? `  :   instanceof ${l.expected},  ${_}` : `  :   ${p},  ${_}`;
      }
      case "invalid_value": {
        if (l.values.length === 1) return `  :    ${w(l.values[0])}`;
        let d = l.values.map((g) => w(g));
        if (l.values.length === 2) return `  :    ${d[0]}  ${d[1]}`;
        let p = d[d.length - 1];
        return `  :    ${d.slice(0, -1).join(", ")}  ${p}`;
      }
      case "too_big": {
        let d = a(l.origin), p = n(l.origin ?? "value");
        if (l.origin === "string") return `${d?.longLabel ?? ""} : ${p}   ${l.maximum.toString()} ${d?.unit ?? ""} ${l.inclusive ? " " : " "}`.trim();
        if (l.origin === "number") {
          let x = l.inclusive ? `   -${l.maximum}` : ` -${l.maximum}`;
          return ` : ${p}   ${x}`;
        }
        if (l.origin === "array" || l.origin === "set") {
          let x = l.origin === "set" ? "" : "", B = l.inclusive ? `${l.maximum} ${d?.unit ?? ""}  ` : ` -${l.maximum} ${d?.unit ?? ""}`;
          return ` : ${p} ${x}  ${B}`.trim();
        }
        let g = l.inclusive ? "<=" : "<", _ = r(l.origin ?? "value");
        return d?.unit ? `${d.longLabel} : ${p} ${_} ${g}${l.maximum.toString()} ${d.unit}` : `${d?.longLabel ?? ""} : ${p} ${_} ${g}${l.maximum.toString()}`;
      }
      case "too_small": {
        let d = a(l.origin), p = n(l.origin ?? "value");
        if (l.origin === "string") return `${d?.shortLabel ?? ""} : ${p}   ${l.minimum.toString()} ${d?.unit ?? ""} ${l.inclusive ? " " : ""}`.trim();
        if (l.origin === "number") {
          let x = l.inclusive ? `   -${l.minimum}` : ` -${l.minimum}`;
          return ` : ${p}   ${x}`;
        }
        if (l.origin === "array" || l.origin === "set") {
          let x = l.origin === "set" ? "" : "";
          if (l.minimum === 1 && l.inclusive) {
            let $e = (l.origin === "set", "  ");
            return ` : ${p} ${x}  ${$e}`;
          }
          let B = l.inclusive ? `${l.minimum} ${d?.unit ?? ""}  ` : ` -${l.minimum} ${d?.unit ?? ""}`;
          return ` : ${p} ${x}  ${B}`.trim();
        }
        let g = l.inclusive ? ">=" : ">", _ = r(l.origin ?? "value");
        return d?.unit ? `${d.shortLabel} : ${p} ${_} ${g}${l.minimum.toString()} ${d.unit}` : `${d?.shortLabel ?? ""} : ${p} ${_} ${g}${l.minimum.toString()}`;
      }
      case "invalid_format": {
        let d = l;
        if (d.format === "starts_with") return `    "${d.prefix}"`;
        if (d.format === "ends_with") return `    "${d.suffix}"`;
        if (d.format === "includes") return `   "${d.includes}"`;
        if (d.format === "regex") return `    ${d.pattern}`;
        let p = s[d.format], g = p?.label ?? d.format, _ = (p?.gender ?? "m") === "f" ? "" : "";
        return `${g}  ${_}`;
      }
      case "not_multiple_of":
        return `  :     ${l.divisor}`;
      case "unrecognized_keys":
        return `${l.keys.length > 1 ? "" : ""}  ${l.keys.length > 1 ? "" : ""}: ${v(l.keys, ", ")}`;
      case "invalid_key":
        return "   ";
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${n(l.origin ?? "array")}`;
      default:
        return "  ";
    }
  };
};
function zb() {
  return { localeError: xb() };
}
var Ub = () => {
  let e = { string: { unit: "karakter", verb: "legyen" }, file: { unit: "byte", verb: "legyen" }, array: { unit: "elem", verb: "legyen" }, set: { unit: "elem", verb: "legyen" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "bemenet", email: "email cm", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO idblyeg", date: "ISO dtum", time: "ISO id", duration: "ISO idintervallum", ipv4: "IPv4 cm", ipv6: "IPv6 cm", cidrv4: "IPv4 tartomny", cidrv6: "IPv6 tartomny", base64: "base64-kdolt string", base64url: "base64url-kdolt string", json_string: "JSON string", e164: "E.164 szm", jwt: "JWT", template_literal: "bemenet" }, o = { nan: "NaN", number: "szm", array: "tmb" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `rvnytelen bemenet: a vrt rtk instanceof ${n.expected}, a kapott rtk ${s}` : `rvnytelen bemenet: a vrt rtk ${r}, a kapott rtk ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `rvnytelen bemenet: a vrt rtk ${w(n.values[0])}` : `rvnytelen opci: valamelyik rtk vrt ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Tl nagy: ${n.origin ?? "rtk"} mrete tl nagy ${r}${n.maximum.toString()} ${a.unit ?? "elem"}` : `Tl nagy: a bemeneti rtk ${n.origin ?? "rtk"} tl nagy: ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Tl kicsi: a bemeneti rtk ${n.origin} mrete tl kicsi ${r}${n.minimum.toString()} ${a.unit}` : `Tl kicsi: a bemeneti rtk ${n.origin} tl kicsi ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `rvnytelen string: "${r.prefix}" rtkkel kell kezddnie` : r.format === "ends_with" ? `rvnytelen string: "${r.suffix}" rtkkel kell vgzdnie` : r.format === "includes" ? `rvnytelen string: "${r.includes}" rtket kell tartalmaznia` : r.format === "regex" ? `rvnytelen string: ${r.pattern} mintnak kell megfelelnie` : `rvnytelen ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `rvnytelen szm: ${n.divisor} tbbszrsnek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${n.keys.length > 1 ? "s" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `rvnytelen kulcs ${n.origin}`;
      case "invalid_union":
        return "rvnytelen bemenet";
      case "invalid_element":
        return `rvnytelen rtk: ${n.origin}`;
      default:
        return "rvnytelen bemenet";
    }
  };
};
function Ob() {
  return { localeError: Ub() };
}
function da(e, t, i) {
  return Math.abs(e) === 1 ? t : i;
}
function Le(e) {
  if (!e) return "";
  let t = ["", "", "", "", "", "", ""], i = e[e.length - 1];
  return e + (t.includes(i) ? "" : "");
}
var Zb = () => {
  let e = { string: { unit: { one: "", many: "" }, verb: "" }, file: { unit: { one: "", many: "" }, verb: "" }, array: { unit: { one: "", many: "" }, verb: "" }, set: { unit: { one: "", many: "" }, verb: "" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "", email: ". ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64  ", base64url: "base64url  ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, o = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `    instanceof ${n.expected},   ${s}` : `    ${r},   ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `    ${w(n.values[1])}` : `      ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        if (a) {
          let s = Number(n.maximum), u = da(s, a.unit.one, a.unit.many);
          return `    ,  ${Le(n.origin ?? "")}  ${r}${n.maximum.toString()} ${u}`;
        }
        return `    ,  ${Le(n.origin ?? "")}  ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        if (a) {
          let s = Number(n.minimum), u = da(s, a.unit.one, a.unit.many);
          return `    ,  ${Le(n.origin)}  ${r}${n.minimum.toString()} ${u}`;
        }
        return `    ,  ${Le(n.origin)}  ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `     "${r.prefix}"-` : r.format === "ends_with" ? `     "${r.suffix}"-` : r.format === "includes" ? `     "${r.includes}"` : r.format === "regex" ? `     ${r.pattern} ` : ` ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `      ${n.divisor}-`;
      case "unrecognized_keys":
        return ` ${n.keys.length > 1 ? "" : ""}. ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `  ${Le(n.origin)}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${Le(n.origin)}-`;
      default:
        return " ";
    }
  };
};
function Pb() {
  return { localeError: Zb() };
}
var Eb = () => {
  let e = { string: { unit: "karakter", verb: "memiliki" }, file: { unit: "byte", verb: "memiliki" }, array: { unit: "item", verb: "memiliki" }, set: { unit: "item", verb: "memiliki" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "input", email: "alamat email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tanggal dan waktu format ISO", date: "tanggal format ISO", time: "jam format ISO", duration: "durasi format ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "rentang alamat IPv4", cidrv6: "rentang alamat IPv6", base64: "string dengan enkode base64", base64url: "string dengan enkode base64url", json_string: "string JSON", e164: "angka E.164", jwt: "JWT", template_literal: "input" }, o = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Input tidak valid: diharapkan instanceof ${n.expected}, diterima ${s}` : `Input tidak valid: diharapkan ${r}, diterima ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Input tidak valid: diharapkan ${w(n.values[0])}` : `Pilihan tidak valid: diharapkan salah satu dari ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Terlalu besar: diharapkan ${n.origin ?? "value"} memiliki ${r}${n.maximum.toString()} ${a.unit ?? "elemen"}` : `Terlalu besar: diharapkan ${n.origin ?? "value"} menjadi ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Terlalu kecil: diharapkan ${n.origin} memiliki ${r}${n.minimum.toString()} ${a.unit}` : `Terlalu kecil: diharapkan ${n.origin} menjadi ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `String tidak valid: harus dimulai dengan "${r.prefix}"` : r.format === "ends_with" ? `String tidak valid: harus berakhir dengan "${r.suffix}"` : r.format === "includes" ? `String tidak valid: harus menyertakan "${r.includes}"` : r.format === "regex" ? `String tidak valid: harus sesuai pola ${r.pattern}` : `${i[r.format] ?? n.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${n.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${n.keys.length > 1 ? "s" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${n.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${n.origin}`;
      default:
        return "Input tidak valid";
    }
  };
};
function Nb() {
  return { localeError: Eb() };
}
var Db = () => {
  let e = { string: { unit: "stafi", verb: "a hafa" }, file: { unit: "bti", verb: "a hafa" }, array: { unit: "hluti", verb: "a hafa" }, set: { unit: "hluti", verb: "a hafa" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "gildi", email: "netfang", url: "vefsl", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dagsetning og tmi", date: "ISO dagsetning", time: "ISO tmi", duration: "ISO tmalengd", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded strengur", base64url: "base64url-encoded strengur", json_string: "JSON strengur", e164: "E.164 tlugildi", jwt: "JWT", template_literal: "gildi" }, o = { nan: "NaN", number: "nmer", array: "fylki" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Rangt gildi:  slst inn ${s} ar sem  a vera instanceof ${n.expected}` : `Rangt gildi:  slst inn ${s} ar sem  a vera ${r}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Rangt gildi: gert r fyrir ${w(n.values[0])}` : `gilt val: m vera eitt af eftirfarandi ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Of strt: gert er r fyrir a ${n.origin ?? "gildi"} hafi ${r}${n.maximum.toString()} ${a.unit ?? "hluti"}` : `Of strt: gert er r fyrir a ${n.origin ?? "gildi"} s ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Of lti: gert er r fyrir a ${n.origin} hafi ${r}${n.minimum.toString()} ${a.unit}` : `Of lti: gert er r fyrir a ${n.origin} s ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `gildur strengur: verur a byrja  "${r.prefix}"` : r.format === "ends_with" ? `gildur strengur: verur a enda  "${r.suffix}"` : r.format === "includes" ? `gildur strengur: verur a innihalda "${r.includes}"` : r.format === "regex" ? `gildur strengur: verur a fylgja mynstri ${r.pattern}` : `Rangt ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Rng tala: verur a vera margfeldi af ${n.divisor}`;
      case "unrecognized_keys":
        return `ekkt ${n.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill  ${n.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi  ${n.origin}`;
      default:
        return "Rangt gildi";
    }
  };
};
function jb() {
  return { localeError: Db() };
}
var Tb = () => {
  let e = { string: { unit: "caratteri", verb: "avere" }, file: { unit: "byte", verb: "avere" }, array: { unit: "elementi", verb: "avere" }, set: { unit: "elementi", verb: "avere" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "input", email: "indirizzo email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e ora ISO", date: "data ISO", time: "ora ISO", duration: "durata ISO", ipv4: "indirizzo IPv4", ipv6: "indirizzo IPv6", cidrv4: "intervallo IPv4", cidrv6: "intervallo IPv6", base64: "stringa codificata in base64", base64url: "URL codificata in base64", json_string: "stringa JSON", e164: "numero E.164", jwt: "JWT", template_literal: "input" }, o = { nan: "NaN", number: "numero", array: "vettore" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Input non valido: atteso instanceof ${n.expected}, ricevuto ${s}` : `Input non valido: atteso ${r}, ricevuto ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Input non valido: atteso ${w(n.values[0])}` : `Opzione non valida: atteso uno tra ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Troppo grande: ${n.origin ?? "valore"} deve avere ${r}${n.maximum.toString()} ${a.unit ?? "elementi"}` : `Troppo grande: ${n.origin ?? "valore"} deve essere ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Troppo piccolo: ${n.origin} deve avere ${r}${n.minimum.toString()} ${a.unit}` : `Troppo piccolo: ${n.origin} deve essere ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Stringa non valida: deve iniziare con "${r.prefix}"` : r.format === "ends_with" ? `Stringa non valida: deve terminare con "${r.suffix}"` : r.format === "includes" ? `Stringa non valida: deve includere "${r.includes}"` : r.format === "regex" ? `Stringa non valida: deve corrispondere al pattern ${r.pattern}` : `Invalid ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${n.divisor}`;
      case "unrecognized_keys":
        return `Chiav${n.keys.length > 1 ? "i" : "e"} non riconosciut${n.keys.length > 1 ? "e" : "a"}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${n.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${n.origin}`;
      default:
        return "Input non valido";
    }
  };
};
function Ab() {
  return { localeError: Tb() };
}
var Rb = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO", date: "ISO", time: "ISO", duration: "ISO", ipv4: "IPv4", ipv6: "IPv6", cidrv4: "IPv4", cidrv6: "IPv6", base64: "base64", base64url: "base64url", json_string: "JSON", e164: "E.164", jwt: "JWT", template_literal: "" }, o = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `: instanceof ${n.expected}${s}` : `: ${r}${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `: ${w(n.values[0])}` : `: ${v(n.values, "")}`;
      case "too_big": {
        let r = n.inclusive ? "" : "", a = t(n.origin);
        return a ? `: ${n.origin ?? ""}${n.maximum.toString()}${a.unit ?? ""}${r}` : `: ${n.origin ?? ""}${n.maximum.toString()}${r}`;
      }
      case "too_small": {
        let r = n.inclusive ? "" : "", a = t(n.origin);
        return a ? `: ${n.origin}${n.minimum.toString()}${a.unit}${r}` : `: ${n.origin}${n.minimum.toString()}${r}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `: "${r.prefix}"` : r.format === "ends_with" ? `: "${r.suffix}"` : r.format === "includes" ? `: "${r.includes}"` : r.format === "regex" ? `: ${r.pattern}` : `${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `: ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "" : ""}: ${v(n.keys, "")}`;
      case "invalid_key":
        return `${n.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${n.origin}`;
      default:
        return "";
    }
  };
};
function Cb() {
  return { localeError: Rb() };
}
var Mb = () => {
  let e = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "", email: "- ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "-", date: "", time: "", duration: "", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64- ", base64url: "base64url- ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, o = { nan: "NaN", number: "", string: "", boolean: "", function: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? ` :  instanceof ${n.expected},  ${s}` : ` :  ${r},  ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? ` :  ${w(n.values[0])}` : ` :  - ${v(n.values, "|")}-`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? ` :  ${n.origin ?? ""} ${a.verb} ${r}${n.maximum.toString()} ${a.unit}` : ` :  ${n.origin ?? ""}  ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? ` :  ${n.origin} ${a.verb} ${r}${n.minimum.toString()} ${a.unit}` : ` :  ${n.origin}  ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? ` :   "${r.prefix}"-` : r.format === "ends_with" ? ` :   "${r.suffix}"-` : r.format === "includes" ? ` :   "${r.includes}"-` : r.format === "regex" ? ` :    ${r.pattern}` : ` ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` :   ${n.divisor}- `;
      case "unrecognized_keys":
        return ` ${n.keys.length > 1 ? "" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `  ${n.origin}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${n.origin}-`;
      default:
        return " ";
    }
  };
};
function Lb() {
  return { localeError: Mb() };
}
var Fb = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "  ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IPv4", cidrv6: " IPv6", base64: " base64", base64url: " base64url", json_string: " JSON", e164: " E.164", jwt: "JWT", template_literal: "" }, o = { nan: "NaN", number: "", array: " (Array)", null: " (null)" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `  instanceof ${n.expected}  ${s}` : `  ${r}  ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `  ${w(n.values[0])}` : `  ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `  ${n.origin ?? ""} ${r} ${n.maximum.toString()} ${a.unit ?? ""}` : `  ${n.origin ?? ""} ${r} ${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `  ${n.origin} ${r} ${n.minimum.toString()} ${a.unit}` : `  ${n.origin} ${r} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `  "${r.prefix}"` : r.format === "ends_with" ? `  "${r.suffix}"` : r.format === "includes" ? `  "${r.includes}"` : r.format === "regex" ? `  ${r.pattern}` : ` ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `  ${n.divisor}`;
      case "unrecognized_keys":
        return ` ${v(n.keys, ", ")}`;
      case "invalid_key":
        return ` ${n.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return ` ${n.origin}`;
      default:
        return "";
    }
  };
};
function Wl() {
  return { localeError: Fb() };
}
function Jb() {
  return Wl();
}
var qb = () => {
  let e = { string: { unit: "", verb: "to have" }, file: { unit: "", verb: "to have" }, array: { unit: "", verb: "to have" }, set: { unit: "", verb: "to have" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "", email: " ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64  ", base64url: "base64url  ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, o = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? ` :   instanceof ${n.expected},   ${s}` : ` :   ${r},   ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? ` :  ${w(n.values[0])}  ` : ` : ${v(n.values, " ")}   `;
      case "too_big": {
        let r = n.inclusive ? "" : "", a = r === "" ? " " : " ", s = t(n.origin), u = s?.unit ?? "";
        return s ? `${n.origin ?? ""}  : ${n.maximum.toString()}${u} ${r}${a}` : `${n.origin ?? ""}  : ${n.maximum.toString()} ${r}${a}`;
      }
      case "too_small": {
        let r = n.inclusive ? "" : "", a = r === "" ? " " : " ", s = t(n.origin), u = s?.unit ?? "";
        return s ? `${n.origin ?? ""}  : ${n.minimum.toString()}${u} ${r}${a}` : `${n.origin ?? ""}  : ${n.minimum.toString()} ${r}${a}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? ` : "${r.prefix}"()  ` : r.format === "ends_with" ? ` : "${r.suffix}"()  ` : r.format === "includes" ? ` : "${r.includes}"()  ` : r.format === "regex" ? ` :  ${r.pattern}   ` : ` ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` : ${n.divisor}  `;
      case "unrecognized_keys":
        return `   : ${v(n.keys, ", ")}`;
      case "invalid_key":
        return ` : ${n.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return ` : ${n.origin}`;
      default:
        return " ";
    }
  };
};
function Wb() {
  return { localeError: qb() };
}
var et = (e) => e.charAt(0).toUpperCase() + e.slice(1);
function ma(e) {
  let t = Math.abs(e), i = t % 10, o = t % 100;
  return o >= 11 && o <= 19 || i === 0 ? "many" : i === 1 ? "one" : "few";
}
var Kb = () => {
  let e = { string: { unit: { one: "simbolis", few: "simboliai", many: "simboli" }, verb: { smaller: { inclusive: "turi bti ne ilgesn kaip", notInclusive: "turi bti trumpesn kaip" }, bigger: { inclusive: "turi bti ne trumpesn kaip", notInclusive: "turi bti ilgesn kaip" } } }, file: { unit: { one: "baitas", few: "baitai", many: "bait" }, verb: { smaller: { inclusive: "turi bti ne didesnis kaip", notInclusive: "turi bti maesnis kaip" }, bigger: { inclusive: "turi bti ne maesnis kaip", notInclusive: "turi bti didesnis kaip" } } }, array: { unit: { one: "element", few: "elementus", many: "element" }, verb: { smaller: { inclusive: "turi turti ne daugiau kaip", notInclusive: "turi turti maiau kaip" }, bigger: { inclusive: "turi turti ne maiau kaip", notInclusive: "turi turti daugiau kaip" } } }, set: { unit: { one: "element", few: "elementus", many: "element" }, verb: { smaller: { inclusive: "turi turti ne daugiau kaip", notInclusive: "turi turti maiau kaip" }, bigger: { inclusive: "turi turti ne maiau kaip", notInclusive: "turi turti daugiau kaip" } } } };
  function t(n, r, a, s) {
    let u = e[n] ?? null;
    return u === null ? u : { unit: u.unit[r], verb: u.verb[s][a ? "inclusive" : "notInclusive"] };
  }
  let i = { regex: "vestis", email: "el. pato adresas", url: "URL", emoji: "jaustukas", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO data ir laikas", date: "ISO data", time: "ISO laikas", duration: "ISO trukm", ipv4: "IPv4 adresas", ipv6: "IPv6 adresas", cidrv4: "IPv4 tinklo prefiksas (CIDR)", cidrv6: "IPv6 tinklo prefiksas (CIDR)", base64: "base64 ukoduota eilut", base64url: "base64url ukoduota eilut", json_string: "JSON eilut", e164: "E.164 numeris", jwt: "JWT", template_literal: "vestis" }, o = { nan: "NaN", number: "skaiius", bigint: "sveikasis skaiius", string: "eilut", boolean: "login reikm", undefined: "neapibrta reikm", function: "funkcija", symbol: "simbolis", array: "masyvas", object: "objektas", null: "nulin reikm" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Gautas tipas ${s}, o tiktasi - instanceof ${n.expected}` : `Gautas tipas ${s}, o tiktasi - ${r}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Privalo bti ${w(n.values[0])}` : `Privalo bti vienas i ${v(n.values, "|")} pasirinkim`;
      case "too_big": {
        let r = o[n.origin] ?? n.origin, a = t(n.origin, ma(Number(n.maximum)), n.inclusive ?? !1, "smaller");
        if (a?.verb) return `${et(r ?? n.origin ?? "reikm")} ${a.verb} ${n.maximum.toString()} ${a.unit ?? "element"}`;
        let s = n.inclusive ? "ne didesnis kaip" : "maesnis kaip";
        return `${et(r ?? n.origin ?? "reikm")} turi bti ${s} ${n.maximum.toString()} ${a?.unit}`;
      }
      case "too_small": {
        let r = o[n.origin] ?? n.origin, a = t(n.origin, ma(Number(n.minimum)), n.inclusive ?? !1, "bigger");
        if (a?.verb) return `${et(r ?? n.origin ?? "reikm")} ${a.verb} ${n.minimum.toString()} ${a.unit ?? "element"}`;
        let s = n.inclusive ? "ne maesnis kaip" : "didesnis kaip";
        return `${et(r ?? n.origin ?? "reikm")} turi bti ${s} ${n.minimum.toString()} ${a?.unit}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Eilut privalo prasidti "${r.prefix}"` : r.format === "ends_with" ? `Eilut privalo pasibaigti "${r.suffix}"` : r.format === "includes" ? `Eilut privalo traukti "${r.includes}"` : r.format === "regex" ? `Eilut privalo atitikti ${r.pattern}` : `Neteisingas ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Skaiius privalo bti ${n.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpaint${n.keys.length > 1 ? "i" : "as"} rakt${n.keys.length > 1 ? "ai" : "as"}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga vestis";
      case "invalid_element": {
        let r = o[n.origin] ?? n.origin;
        return `${et(r ?? n.origin ?? "reikm")} turi klaiding vest`;
      }
      default:
        return "Klaidinga vestis";
    }
  };
};
function Vb() {
  return { localeError: Kb() };
}
var Gb = () => {
  let e = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "", email: "  -", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64- ", base64url: "base64url- ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, o = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? ` :   instanceof ${n.expected},  ${s}` : ` :   ${r},  ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Invalid input: expected ${w(n.values[0])}` : ` :    ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? ` :   ${n.origin ?? ""}   ${r}${n.maximum.toString()} ${a.unit ?? ""}` : ` :   ${n.origin ?? ""}   ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? ` :   ${n.origin}   ${r}${n.minimum.toString()} ${a.unit}` : ` :   ${n.origin}   ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? ` :     "${r.prefix}"` : r.format === "ends_with" ? ` :     "${r.suffix}"` : r.format === "includes" ? ` :    "${r.includes}"` : r.format === "regex" ? ` :      ${r.pattern}` : `Invalid ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` :      ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? " " : " "}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${n.origin}`;
      default:
        return " ";
    }
  };
};
function Bb() {
  return { localeError: Gb() };
}
var Hb = () => {
  let e = { string: { unit: "aksara", verb: "mempunyai" }, file: { unit: "bait", verb: "mempunyai" }, array: { unit: "elemen", verb: "mempunyai" }, set: { unit: "elemen", verb: "mempunyai" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "input", email: "alamat e-mel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tarikh masa ISO", date: "tarikh ISO", time: "masa ISO", duration: "tempoh ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "julat IPv4", cidrv6: "julat IPv6", base64: "string dikodkan base64", base64url: "string dikodkan base64url", json_string: "string JSON", e164: "nombor E.164", jwt: "JWT", template_literal: "input" }, o = { nan: "NaN", number: "nombor" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Input tidak sah: dijangka instanceof ${n.expected}, diterima ${s}` : `Input tidak sah: dijangka ${r}, diterima ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Input tidak sah: dijangka ${w(n.values[0])}` : `Pilihan tidak sah: dijangka salah satu daripada ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Terlalu besar: dijangka ${n.origin ?? "nilai"} ${a.verb} ${r}${n.maximum.toString()} ${a.unit ?? "elemen"}` : `Terlalu besar: dijangka ${n.origin ?? "nilai"} adalah ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Terlalu kecil: dijangka ${n.origin} ${a.verb} ${r}${n.minimum.toString()} ${a.unit}` : `Terlalu kecil: dijangka ${n.origin} adalah ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `String tidak sah: mesti bermula dengan "${r.prefix}"` : r.format === "ends_with" ? `String tidak sah: mesti berakhir dengan "${r.suffix}"` : r.format === "includes" ? `String tidak sah: mesti mengandungi "${r.includes}"` : r.format === "regex" ? `String tidak sah: mesti sepadan dengan corak ${r.pattern}` : `${i[r.format] ?? n.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${n.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${n.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${n.origin}`;
      default:
        return "Input tidak sah";
    }
  };
};
function Xb() {
  return { localeError: Hb() };
}
var Yb = () => {
  let e = { string: { unit: "tekens", verb: "heeft" }, file: { unit: "bytes", verb: "heeft" }, array: { unit: "elementen", verb: "heeft" }, set: { unit: "elementen", verb: "heeft" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "invoer", email: "emailadres", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum en tijd", date: "ISO datum", time: "ISO tijd", duration: "ISO duur", ipv4: "IPv4-adres", ipv6: "IPv6-adres", cidrv4: "IPv4-bereik", cidrv6: "IPv6-bereik", base64: "base64-gecodeerde tekst", base64url: "base64 URL-gecodeerde tekst", json_string: "JSON string", e164: "E.164-nummer", jwt: "JWT", template_literal: "invoer" }, o = { nan: "NaN", number: "getal" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Ongeldige invoer: verwacht instanceof ${n.expected}, ontving ${s}` : `Ongeldige invoer: verwacht ${r}, ontving ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Ongeldige invoer: verwacht ${w(n.values[0])}` : `Ongeldige optie: verwacht n van ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin), s = n.origin === "date" ? "laat" : n.origin === "string" ? "lang" : "groot";
        return a ? `Te ${s}: verwacht dat ${n.origin ?? "waarde"} ${r}${n.maximum.toString()} ${a.unit ?? "elementen"} ${a.verb}` : `Te ${s}: verwacht dat ${n.origin ?? "waarde"} ${r}${n.maximum.toString()} is`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin), s = n.origin === "date" ? "vroeg" : n.origin === "string" ? "kort" : "klein";
        return a ? `Te ${s}: verwacht dat ${n.origin} ${r}${n.minimum.toString()} ${a.unit} ${a.verb}` : `Te ${s}: verwacht dat ${n.origin} ${r}${n.minimum.toString()} is`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Ongeldige tekst: moet met "${r.prefix}" beginnen` : r.format === "ends_with" ? `Ongeldige tekst: moet op "${r.suffix}" eindigen` : r.format === "includes" ? `Ongeldige tekst: moet "${r.includes}" bevatten` : r.format === "regex" ? `Ongeldige tekst: moet overeenkomen met patroon ${r.pattern}` : `Ongeldig: ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${n.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${n.keys.length > 1 ? "s" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${n.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${n.origin}`;
      default:
        return "Ongeldige invoer";
    }
  };
};
function Qb() {
  return { localeError: Yb() };
}
var ey = () => {
  let e = { string: { unit: "tegn", verb: " ha" }, file: { unit: "bytes", verb: " ha" }, array: { unit: "elementer", verb: " inneholde" }, set: { unit: "elementer", verb: " inneholde" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "input", email: "e-postadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslett", date: "ISO-dato", time: "ISO-klokkeslett", duration: "ISO-varighet", ipv4: "IPv4-omrde", ipv6: "IPv6-omrde", cidrv4: "IPv4-spekter", cidrv6: "IPv6-spekter", base64: "base64-enkodet streng", base64url: "base64url-enkodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" }, o = { nan: "NaN", number: "tall", array: "liste" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Ugyldig input: forventet instanceof ${n.expected}, fikk ${s}` : `Ugyldig input: forventet ${r}, fikk ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Ugyldig verdi: forventet ${w(n.values[0])}` : `Ugyldig valg: forventet en av ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `For stor(t): forventet ${n.origin ?? "value"} til  ha ${r}${n.maximum.toString()} ${a.unit ?? "elementer"}` : `For stor(t): forventet ${n.origin ?? "value"} til  ha ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `For lite(n): forventet ${n.origin} til  ha ${r}${n.minimum.toString()} ${a.unit}` : `For lite(n): forventet ${n.origin} til  ha ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Ugyldig streng: m starte med "${r.prefix}"` : r.format === "ends_with" ? `Ugyldig streng: m ende med "${r.suffix}"` : r.format === "includes" ? `Ugyldig streng: m inneholde "${r.includes}"` : r.format === "regex" ? `Ugyldig streng: m matche mnsteret ${r.pattern}` : `Ugyldig ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m vre et multiplum av ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nkkel i ${n.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${n.origin}`;
      default:
        return "Ugyldig input";
    }
  };
};
function ty() {
  return { localeError: ey() };
}
var ny = () => {
  let e = { string: { unit: "harf", verb: "olmaldr" }, file: { unit: "bayt", verb: "olmaldr" }, array: { unit: "unsur", verb: "olmaldr" }, set: { unit: "unsur", verb: "olmaldr" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "giren", email: "epostagh", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO hengm", date: "ISO tarihi", time: "ISO zaman", duration: "ISO mddeti", ipv4: "IPv4 nin", ipv6: "IPv6 nin", cidrv4: "IPv4 menzili", cidrv6: "IPv6 menzili", base64: "base64-ifreli metin", base64url: "base64url-ifreli metin", json_string: "JSON metin", e164: "E.164 says", jwt: "JWT", template_literal: "giren" }, o = { nan: "NaN", number: "numara", array: "saf", null: "gayb" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Fsit giren: umulan instanceof ${n.expected}, alnan ${s}` : `Fsit giren: umulan ${r}, alnan ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Fsit giren: umulan ${w(n.values[0])}` : `Fsit tercih: mteberler ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Fazla byk: ${n.origin ?? "value"}, ${r}${n.maximum.toString()} ${a.unit ?? "elements"} sahip olmalyd.` : `Fazla byk: ${n.origin ?? "value"}, ${r}${n.maximum.toString()} olmalyd.`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Fazla kk: ${n.origin}, ${r}${n.minimum.toString()} ${a.unit} sahip olmalyd.` : `Fazla kk: ${n.origin}, ${r}${n.minimum.toString()} olmalyd.`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Fsit metin: "${r.prefix}" ile balamal.` : r.format === "ends_with" ? `Fsit metin: "${r.suffix}" ile bitmeli.` : r.format === "includes" ? `Fsit metin: "${r.includes}" ihtiv etmeli.` : r.format === "regex" ? `Fsit metin: ${r.pattern} nakna uymal.` : `Fsit ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Fsit say: ${n.divisor} kat olmalyd.`;
      case "unrecognized_keys":
        return `Tannmayan anahtar ${n.keys.length > 1 ? "s" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} iin tannmayan anahtar var.`;
      case "invalid_union":
        return "Giren tannamad.";
      case "invalid_element":
        return `${n.origin} iin tannmayan kymet var.`;
      default:
        return "Kymet tannamad.";
    }
  };
};
function iy() {
  return { localeError: ny() };
}
var ry = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "", email: "", url: "  ", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "  ", date: "", time: "", duration: "", ipv4: " IPv4 ", ipv6: " IPv6 ", cidrv4: " IPv4 ", cidrv6: " IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: " E.164 ", jwt: "JWT", template_literal: "" }, o = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? ` :  instanceof ${n.expected} ,  ${s}  ` : ` :  ${r} ,  ${s}  `;
      }
      case "invalid_value":
        return n.values.length === 1 ? ` :  ${w(n.values[0])} ` : ` :    ${v(n.values, "|")}  `;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? ` : ${n.origin ?? ""}  ${r}${n.maximum.toString()} ${a.unit ?? ""} ` : ` : ${n.origin ?? ""}  ${r}${n.maximum.toString()} `;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? ` : ${n.origin}  ${r}${n.minimum.toString()} ${a.unit} ` : ` : ${n.origin}  ${r}${n.minimum.toString()} `;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? ` :   "${r.prefix}"   ` : r.format === "ends_with" ? ` :   "${r.suffix}"    ` : r.format === "includes" ? ` :  "${r.includes}" ` : r.format === "regex" ? ` :   ${r.pattern}   ` : `${i[r.format] ?? n.format}  `;
      }
      case "not_multiple_of":
        return ` :   ${n.divisor}  `;
      case "unrecognized_keys":
        return ` ${n.keys.length > 1 ? "" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin} `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${n.origin} `;
      default:
        return " ";
    }
  };
};
function oy() {
  return { localeError: ry() };
}
var ay = () => {
  let e = { string: { unit: "znakw", verb: "mie" }, file: { unit: "bajtw", verb: "mie" }, array: { unit: "elementw", verb: "mie" }, set: { unit: "elementw", verb: "mie" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "wyraenie", email: "adres email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i godzina w formacie ISO", date: "data w formacie ISO", time: "godzina w formacie ISO", duration: "czas trwania ISO", ipv4: "adres IPv4", ipv6: "adres IPv6", cidrv4: "zakres IPv4", cidrv6: "zakres IPv6", base64: "cig znakw zakodowany w formacie base64", base64url: "cig znakw zakodowany w formacie base64url", json_string: "cig znakw w formacie JSON", e164: "liczba E.164", jwt: "JWT", template_literal: "wejcie" }, o = { nan: "NaN", number: "liczba", array: "tablica" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Nieprawidowe dane wejciowe: oczekiwano instanceof ${n.expected}, otrzymano ${s}` : `Nieprawidowe dane wejciowe: oczekiwano ${r}, otrzymano ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Nieprawidowe dane wejciowe: oczekiwano ${w(n.values[0])}` : `Nieprawidowa opcja: oczekiwano jednej z wartoci ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Za dua warto: oczekiwano, e ${n.origin ?? "warto"} bdzie mie ${r}${n.maximum.toString()} ${a.unit ?? "elementw"}` : `Zbyt du(y/a/e): oczekiwano, e ${n.origin ?? "warto"} bdzie wynosi ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Za maa warto: oczekiwano, e ${n.origin ?? "warto"} bdzie mie ${r}${n.minimum.toString()} ${a.unit ?? "elementw"}` : `Zbyt ma(y/a/e): oczekiwano, e ${n.origin ?? "warto"} bdzie wynosi ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Nieprawidowy cig znakw: musi zaczyna si od "${r.prefix}"` : r.format === "ends_with" ? `Nieprawidowy cig znakw: musi koczy si na "${r.suffix}"` : r.format === "includes" ? `Nieprawidowy cig znakw: musi zawiera "${r.includes}"` : r.format === "regex" ? `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${r.pattern}` : `Nieprawidow(y/a/e) ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidowa liczba: musi by wielokrotnoci ${n.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${n.keys.length > 1 ? "s" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidowy klucz w ${n.origin}`;
      case "invalid_union":
        return "Nieprawidowe dane wejciowe";
      case "invalid_element":
        return `Nieprawidowa warto w ${n.origin}`;
      default:
        return "Nieprawidowe dane wejciowe";
    }
  };
};
function sy() {
  return { localeError: ay() };
}
var uy = () => {
  let e = { string: { unit: "caracteres", verb: "ter" }, file: { unit: "bytes", verb: "ter" }, array: { unit: "itens", verb: "ter" }, set: { unit: "itens", verb: "ter" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "padro", email: "endereo de e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e hora ISO", date: "data ISO", time: "hora ISO", duration: "durao ISO", ipv4: "endereo IPv4", ipv6: "endereo IPv6", cidrv4: "faixa de IPv4", cidrv6: "faixa de IPv6", base64: "texto codificado em base64", base64url: "URL codificada em base64", json_string: "texto JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" }, o = { nan: "NaN", number: "nmero", null: "nulo" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Tipo invlido: esperado instanceof ${n.expected}, recebido ${s}` : `Tipo invlido: esperado ${r}, recebido ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Entrada invlida: esperado ${w(n.values[0])}` : `Opo invlida: esperada uma das ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Muito grande: esperado que ${n.origin ?? "valor"} tivesse ${r}${n.maximum.toString()} ${a.unit ?? "elementos"}` : `Muito grande: esperado que ${n.origin ?? "valor"} fosse ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Muito pequeno: esperado que ${n.origin} tivesse ${r}${n.minimum.toString()} ${a.unit}` : `Muito pequeno: esperado que ${n.origin} fosse ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Texto invlido: deve comear com "${r.prefix}"` : r.format === "ends_with" ? `Texto invlido: deve terminar com "${r.suffix}"` : r.format === "includes" ? `Texto invlido: deve incluir "${r.includes}"` : r.format === "regex" ? `Texto invlido: deve corresponder ao padro ${r.pattern}` : `${i[r.format] ?? n.format} invlido`;
      }
      case "not_multiple_of":
        return `Nmero invlido: deve ser mltiplo de ${n.divisor}`;
      case "unrecognized_keys":
        return `Chave${n.keys.length > 1 ? "s" : ""} desconhecida${n.keys.length > 1 ? "s" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Chave invlida em ${n.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido em ${n.origin}`;
      default:
        return "Campo invlido";
    }
  };
};
function ly() {
  return { localeError: uy() };
}
function pa(e, t, i, o) {
  let n = Math.abs(e), r = n % 10, a = n % 100;
  return a >= 11 && a <= 19 ? o : r === 1 ? t : r >= 2 && r <= 4 ? i : o;
}
var cy = () => {
  let e = { string: { unit: { one: "", few: "", many: "" }, verb: "" }, file: { unit: { one: "", few: "", many: "" }, verb: "" }, array: { unit: { one: "", few: "", many: "" }, verb: "" }, set: { unit: { one: "", few: "", many: "" }, verb: "" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "", email: "email ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "   base64", base64url: "   base64url", json_string: "JSON ", e164: " E.164", jwt: "JWT", template_literal: "" }, o = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? ` :  instanceof ${n.expected},  ${s}` : ` :  ${r},  ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? ` :  ${w(n.values[0])}` : ` :    ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        if (a) {
          let s = Number(n.maximum), u = pa(s, a.unit.one, a.unit.few, a.unit.many);
          return `  : ,  ${n.origin ?? ""}   ${r}${n.maximum.toString()} ${u}`;
        }
        return `  : ,  ${n.origin ?? ""}  ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        if (a) {
          let s = Number(n.minimum), u = pa(s, a.unit.one, a.unit.few, a.unit.many);
          return `  : ,  ${n.origin}   ${r}${n.minimum.toString()} ${u}`;
        }
        return `  : ,  ${n.origin}  ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? ` :    "${r.prefix}"` : r.format === "ends_with" ? ` :    "${r.suffix}"` : r.format === "includes" ? ` :   "${r.includes}"` : r.format === "regex" ? ` :    ${r.pattern}` : ` ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` :    ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "" : ""} ${n.keys.length > 1 ? "" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${n.origin}`;
      default:
        return "  ";
    }
  };
};
function dy() {
  return { localeError: cy() };
}
var my = () => {
  let e = { string: { unit: "znakov", verb: "imeti" }, file: { unit: "bajtov", verb: "imeti" }, array: { unit: "elementov", verb: "imeti" }, set: { unit: "elementov", verb: "imeti" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "vnos", email: "e-potni naslov", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum in as", date: "ISO datum", time: "ISO as", duration: "ISO trajanje", ipv4: "IPv4 naslov", ipv6: "IPv6 naslov", cidrv4: "obseg IPv4", cidrv6: "obseg IPv6", base64: "base64 kodiran niz", base64url: "base64url kodiran niz", json_string: "JSON niz", e164: "E.164 tevilka", jwt: "JWT", template_literal: "vnos" }, o = { nan: "NaN", number: "tevilo", array: "tabela" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Neveljaven vnos: priakovano instanceof ${n.expected}, prejeto ${s}` : `Neveljaven vnos: priakovano ${r}, prejeto ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Neveljaven vnos: priakovano ${w(n.values[0])}` : `Neveljavna monost: priakovano eno izmed ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Preveliko: priakovano, da bo ${n.origin ?? "vrednost"} imelo ${r}${n.maximum.toString()} ${a.unit ?? "elementov"}` : `Preveliko: priakovano, da bo ${n.origin ?? "vrednost"} ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Premajhno: priakovano, da bo ${n.origin} imelo ${r}${n.minimum.toString()} ${a.unit}` : `Premajhno: priakovano, da bo ${n.origin} ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Neveljaven niz: mora se zaeti z "${r.prefix}"` : r.format === "ends_with" ? `Neveljaven niz: mora se konati z "${r.suffix}"` : r.format === "includes" ? `Neveljaven niz: mora vsebovati "${r.includes}"` : r.format === "regex" ? `Neveljaven niz: mora ustrezati vzorcu ${r.pattern}` : `Neveljaven ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno tevilo: mora biti vekratnik ${n.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${n.keys.length > 1 ? "i kljui" : " klju"}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju v ${n.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${n.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function py() {
  return { localeError: my() };
}
var fy = () => {
  let e = { string: { unit: "tecken", verb: "att ha" }, file: { unit: "bytes", verb: "att ha" }, array: { unit: "objekt", verb: "att innehlla" }, set: { unit: "objekt", verb: "att innehlla" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "reguljrt uttryck", email: "e-postadress", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datum och tid", date: "ISO-datum", time: "ISO-tid", duration: "ISO-varaktighet", ipv4: "IPv4-intervall", ipv6: "IPv6-intervall", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodad strng", base64url: "base64url-kodad strng", json_string: "JSON-strng", e164: "E.164-nummer", jwt: "JWT", template_literal: "mall-literal" }, o = { nan: "NaN", number: "antal", array: "lista" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Ogiltig inmatning: frvntat instanceof ${n.expected}, fick ${s}` : `Ogiltig inmatning: frvntat ${r}, fick ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Ogiltig inmatning: frvntat ${w(n.values[0])}` : `Ogiltigt val: frvntade en av ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Fr stor(t): frvntade ${n.origin ?? "vrdet"} att ha ${r}${n.maximum.toString()} ${a.unit ?? "element"}` : `Fr stor(t): frvntat ${n.origin ?? "vrdet"} att ha ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Fr lite(t): frvntade ${n.origin ?? "vrdet"} att ha ${r}${n.minimum.toString()} ${a.unit}` : `Fr lite(t): frvntade ${n.origin ?? "vrdet"} att ha ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Ogiltig strng: mste brja med "${r.prefix}"` : r.format === "ends_with" ? `Ogiltig strng: mste sluta med "${r.suffix}"` : r.format === "includes" ? `Ogiltig strng: mste innehlla "${r.includes}"` : r.format === "regex" ? `Ogiltig strng: mste matcha mnstret "${r.pattern}"` : `Ogiltig(t) ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: mste vara en multipel av ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${n.origin ?? "vrdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt vrde i ${n.origin ?? "vrdet"}`;
      default:
        return "Ogiltig input";
    }
  };
};
function gy() {
  return { localeError: fy() };
}
var hy = () => {
  let e = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "", email: " ", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO  ", date: "ISO ", time: "ISO ", duration: "ISO  ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "input" }, o = { nan: "NaN", number: "", array: "", null: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? ` :  instanceof ${n.expected},  ${s}` : ` :  ${r},  ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? ` :  ${w(n.values[0])}` : ` :  ${v(n.values, "|")}  `;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? ` :  ${n.origin ?? ""} ${r}${n.maximum.toString()} ${a.unit ?? ""}   ` : ` :  ${n.origin ?? ""} ${r}${n.maximum.toString()}   `;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? ` :  ${n.origin} ${r}${n.minimum.toString()} ${a.unit}   ` : ` :  ${n.origin} ${r}${n.minimum.toString()}   `;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? ` : "${r.prefix}"   ` : r.format === "ends_with" ? ` : "${r.suffix}"   ` : r.format === "includes" ? ` : "${r.includes}"   ` : r.format === "regex" ? ` : ${r.pattern}   ` : ` ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` : ${n.divisor}    `;
      case "unrecognized_keys":
        return `  ${n.keys.length > 1 ? "" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin}   `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `${n.origin}   `;
      default:
        return " ";
    }
  };
};
function vy() {
  return { localeError: hy() };
}
var $y = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: " ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IP  IPv4", cidrv6: " IP  IPv6", base64: " Base64", base64url: " Base64  URL", json_string: " JSON", e164: " (E.164)", jwt: " JWT", template_literal: "" }, o = { nan: "NaN", number: "", array: " (Array)", null: " (null)" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `:  instanceof ${n.expected}  ${s}` : `:  ${r}  ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `:  ${w(n.values[0])}` : `:  ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "" : "", a = t(n.origin);
        return a ? `: ${n.origin ?? ""} ${r} ${n.maximum.toString()} ${a.unit ?? ""}` : `: ${n.origin ?? ""} ${r} ${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? "" : "", a = t(n.origin);
        return a ? `: ${n.origin} ${r} ${n.minimum.toString()} ${a.unit}` : `: ${n.origin} ${r} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `:  "${r.prefix}"` : r.format === "ends_with" ? `:  "${r.suffix}"` : r.format === "includes" ? `:  "${r.includes}" ` : r.format === "regex" ? `:  ${r.pattern}` : `: ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `:  ${n.divisor} `;
      case "unrecognized_keys":
        return `: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return ` ${n.origin}`;
      case "invalid_union":
        return ": ";
      case "invalid_element":
        return ` ${n.origin}`;
      default:
        return "";
    }
  };
};
function _y() {
  return { localeError: $y() };
}
var by = () => {
  let e = { string: { unit: "karakter", verb: "olmal" }, file: { unit: "bayt", verb: "olmal" }, array: { unit: "e", verb: "olmal" }, set: { unit: "e", verb: "olmal" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "girdi", email: "e-posta adresi", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO tarih ve saat", date: "ISO tarih", time: "ISO saat", duration: "ISO sre", ipv4: "IPv4 adresi", ipv6: "IPv6 adresi", cidrv4: "IPv4 aral", cidrv6: "IPv6 aral", base64: "base64 ile ifrelenmi metin", base64url: "base64url ile ifrelenmi metin", json_string: "JSON dizesi", e164: "E.164 says", jwt: "JWT", template_literal: "ablon dizesi" }, o = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Geersiz deer: beklenen instanceof ${n.expected}, alnan ${s}` : `Geersiz deer: beklenen ${r}, alnan ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Geersiz deer: beklenen ${w(n.values[0])}` : `Geersiz seenek: aadakilerden biri olmal: ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `ok byk: beklenen ${n.origin ?? "deer"} ${r}${n.maximum.toString()} ${a.unit ?? "e"}` : `ok byk: beklenen ${n.origin ?? "deer"} ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `ok kk: beklenen ${n.origin} ${r}${n.minimum.toString()} ${a.unit}` : `ok kk: beklenen ${n.origin} ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Geersiz metin: "${r.prefix}" ile balamal` : r.format === "ends_with" ? `Geersiz metin: "${r.suffix}" ile bitmeli` : r.format === "includes" ? `Geersiz metin: "${r.includes}" iermeli` : r.format === "regex" ? `Geersiz metin: ${r.pattern} desenine uymal` : `Geersiz ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Geersiz say: ${n.divisor} ile tam blnebilmeli`;
      case "unrecognized_keys":
        return `Tannmayan anahtar${n.keys.length > 1 ? "lar" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} iinde geersiz anahtar`;
      case "invalid_union":
        return "Geersiz deer";
      case "invalid_element":
        return `${n.origin} iinde geersiz deer`;
      default:
        return "Geersiz deer";
    }
  };
};
function yy() {
  return { localeError: by() };
}
var ky = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: " ", email: "  ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IPv4", cidrv6: " IPv6", base64: "   base64", base64url: "   base64url", json_string: " JSON", e164: " E.164", jwt: "JWT", template_literal: " " }, o = { nan: "NaN", number: "", array: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `  :  instanceof ${n.expected},  ${s}` : `  :  ${r},  ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `  :  ${w(n.values[0])}` : ` :    ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? ` : ,  ${n.origin ?? ""} ${a.verb} ${r}${n.maximum.toString()} ${a.unit ?? ""}` : ` : ,  ${n.origin ?? ""}  ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? ` : ,  ${n.origin} ${a.verb} ${r}${n.minimum.toString()} ${a.unit}` : ` : ,  ${n.origin}  ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? ` :    "${r.prefix}"` : r.format === "ends_with" ? ` :    "${r.suffix}"` : r.format === "includes" ? ` :   "${r.includes}"` : r.format === "regex" ? ` :    ${r.pattern}` : ` ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` :    ${n.divisor}`;
      case "unrecognized_keys":
        return ` ${n.keys.length > 1 ? "" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `   ${n.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${n.origin}`;
      default:
        return "  ";
    }
  };
};
function Kl() {
  return { localeError: ky() };
}
function Iy() {
  return Kl();
}
var wy = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: " ", email: "  ", url: "  ", emoji: "", uuid: "   ", uuidv4: "     4", uuidv6: "     6", nanoid: "  ", guid: "   ", cuid: "   ", cuid2: "    2", ulid: "   ", xid: "  ", ksuid: "    ", datetime: "    ", date: "   ", time: "   ", duration: "   ", ipv4: "   4 ", ipv6: "   6 ", cidrv4: "   4 ", cidrv6: "   6 ", base64: " 64   ", base64url: " 64      ", json_string: "    ", e164: " 164 ", jwt: "  ", template_literal: " " }, o = { nan: "NaN", number: "", array: "", null: "" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `  : instanceof ${n.expected}   ${s}  ` : `  : ${r}   ${s}  `;
      }
      case "invalid_value":
        return n.values.length === 1 ? `  : ${w(n.values[0])}  ` : ` : ${v(n.values, "|")}     `;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? ` : ${n.origin ?? ""}  ${r}${n.maximum.toString()} ${a.unit ?? ""}   ` : ` : ${n.origin ?? ""}  ${r}${n.maximum.toString()}   `;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? ` : ${n.origin}  ${r}${n.minimum.toString()} ${a.unit}   ` : ` : ${n.origin}  ${r}${n.minimum.toString()}   `;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? ` : "${r.prefix}"    ` : r.format === "ends_with" ? ` : "${r.suffix}"    ` : r.format === "includes" ? ` : "${r.includes}"   ` : r.format === "regex" ? ` :  ${r.pattern}    ` : ` ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` : ${n.divisor}    `;
      case "unrecognized_keys":
        return `   ${n.keys.length > 1 ? "" : ""}: ${v(n.keys, " ")}`;
      case "invalid_key":
        return `${n.origin}   `;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `${n.origin}   `;
      default:
        return "  ";
    }
  };
};
function Sy() {
  return { localeError: wy() };
}
var xy = () => {
  let e = { string: { unit: "belgi", verb: "bolishi kerak" }, file: { unit: "bayt", verb: "bolishi kerak" }, array: { unit: "element", verb: "bolishi kerak" }, set: { unit: "element", verb: "bolishi kerak" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "kirish", email: "elektron pochta manzili", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO sana va vaqti", date: "ISO sana", time: "ISO vaqt", duration: "ISO davomiylik", ipv4: "IPv4 manzil", ipv6: "IPv6 manzil", mac: "MAC manzil", cidrv4: "IPv4 diapazon", cidrv6: "IPv6 diapazon", base64: "base64 kodlangan satr", base64url: "base64url kodlangan satr", json_string: "JSON satr", e164: "E.164 raqam", jwt: "JWT", template_literal: "kirish" }, o = { nan: "NaN", number: "raqam", array: "massiv" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `Notogri kirish: kutilgan instanceof ${n.expected}, qabul qilingan ${s}` : `Notogri kirish: kutilgan ${r}, qabul qilingan ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `Notogri kirish: kutilgan ${w(n.values[0])}` : `Notogri variant: quyidagilardan biri kutilgan ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Juda katta: kutilgan ${n.origin ?? "qiymat"} ${r}${n.maximum.toString()} ${a.unit} ${a.verb}` : `Juda katta: kutilgan ${n.origin ?? "qiymat"} ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Juda kichik: kutilgan ${n.origin} ${r}${n.minimum.toString()} ${a.unit} ${a.verb}` : `Juda kichik: kutilgan ${n.origin} ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Notogri satr: "${r.prefix}" bilan boshlanishi kerak` : r.format === "ends_with" ? `Notogri satr: "${r.suffix}" bilan tugashi kerak` : r.format === "includes" ? `Notogri satr: "${r.includes}" ni oz ichiga olishi kerak` : r.format === "regex" ? `Notogri satr: ${r.pattern} shabloniga mos kelishi kerak` : `Notogri ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Notogri raqam: ${n.divisor} ning karralisi bolishi kerak`;
      case "unrecognized_keys":
        return `Nomalum kalit${n.keys.length > 1 ? "lar" : ""}: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} dagi kalit notogri`;
      case "invalid_union":
        return "Notogri kirish";
      case "invalid_element":
        return `${n.origin} da notogri qiymat`;
      default:
        return "Notogri kirish";
    }
  };
};
function zy() {
  return { localeError: xy() };
}
var Uy = () => {
  let e = { string: { unit: "k t", verb: "c" }, file: { unit: "byte", verb: "c" }, array: { unit: "phn t", verb: "c" }, set: { unit: "phn t", verb: "c" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "u vo", email: "a ch email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ngy gi ISO", date: "ngy ISO", time: "gi ISO", duration: "khong thi gian ISO", ipv4: "a ch IPv4", ipv6: "a ch IPv6", cidrv4: "di IPv4", cidrv6: "di IPv6", base64: "chui m ha base64", base64url: "chui m ha base64url", json_string: "chui JSON", e164: "s E.164", jwt: "JWT", template_literal: "u vo" }, o = { nan: "NaN", number: "s", array: "mng" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `u vo khng hp l: mong i instanceof ${n.expected}, nhn c ${s}` : `u vo khng hp l: mong i ${r}, nhn c ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `u vo khng hp l: mong i ${w(n.values[0])}` : `Ty chn khng hp l: mong i mt trong cc gi tr ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Qu ln: mong i ${n.origin ?? "gi tr"} ${a.verb} ${r}${n.maximum.toString()} ${a.unit ?? "phn t"}` : `Qu ln: mong i ${n.origin ?? "gi tr"} ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Qu nh: mong i ${n.origin} ${a.verb} ${r}${n.minimum.toString()} ${a.unit}` : `Qu nh: mong i ${n.origin} ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `Chui khng hp l: phi bt u bng "${r.prefix}"` : r.format === "ends_with" ? `Chui khng hp l: phi kt thc bng "${r.suffix}"` : r.format === "includes" ? `Chui khng hp l: phi bao gm "${r.includes}"` : r.format === "regex" ? `Chui khng hp l: phi khp vi mu ${r.pattern}` : `${i[r.format] ?? n.format} khng hp l`;
      }
      case "not_multiple_of":
        return `S khng hp l: phi l bi s ca ${n.divisor}`;
      case "unrecognized_keys":
        return `Kha khng c nhn dng: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Kha khng hp l trong ${n.origin}`;
      case "invalid_union":
        return "u vo khng hp l";
      case "invalid_element":
        return `Gi tr khng hp l trong ${n.origin}`;
      default:
        return "u vo khng hp l";
    }
  };
};
function Oy() {
  return { localeError: Uy() };
}
var Zy = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO", date: "ISO", time: "ISO", duration: "ISO", ipv4: "IPv4", ipv6: "IPv6", cidrv4: "IPv4", cidrv6: "IPv6", base64: "base64", base64url: "base64url", json_string: "JSON", e164: "E.164", jwt: "JWT", template_literal: "" }, o = { nan: "NaN", number: "", array: "", null: "(null)" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? ` instanceof ${n.expected} ${s}` : ` ${r} ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? ` ${w(n.values[0])}` : ` ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? ` ${n.origin ?? ""} ${r}${n.maximum.toString()} ${a.unit ?? ""}` : ` ${n.origin ?? ""} ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? ` ${n.origin} ${r}${n.minimum.toString()} ${a.unit}` : ` ${n.origin} ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? ` "${r.prefix}" ` : r.format === "ends_with" ? ` "${r.suffix}" ` : r.format === "includes" ? ` "${r.includes}"` : r.format === "regex" ? ` ${r.pattern}` : `${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` ${n.divisor} `;
      case "unrecognized_keys":
        return `(key): ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} (key)`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${n.origin} (value)`;
      default:
        return "";
    }
  };
};
function Py() {
  return { localeError: Zy() };
}
var Ey = () => {
  let e = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "", email: "", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64 ", base64url: "base64url ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" }, o = { nan: "NaN" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? ` instanceof ${n.expected} ${s}` : ` ${r} ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? ` ${w(n.values[0])}` : ` ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? ` ${n.origin ?? ""}  ${r}${n.maximum.toString()} ${a.unit ?? ""}` : ` ${n.origin ?? ""}  ${r}${n.maximum.toString()}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? ` ${n.origin}  ${r}${n.minimum.toString()} ${a.unit}` : ` ${n.origin}  ${r}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? ` "${r.prefix}" ` : r.format === "ends_with" ? ` "${r.suffix}" ` : r.format === "includes" ? ` "${r.includes}"` : r.format === "regex" ? ` ${r.pattern}` : ` ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return ` ${n.divisor} `;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "" : ""}${v(n.keys, "")}`;
      case "invalid_key":
        return `${n.origin} `;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${n.origin} `;
      default:
        return "";
    }
  };
};
function Ny() {
  return { localeError: Ey() };
}
var Dy = () => {
  let e = { string: { unit: "mi", verb: "n" }, file: { unit: "bytes", verb: "n" }, array: { unit: "nkan", verb: "n" }, set: { unit: "nkan", verb: "n" } };
  function t(n) {
    return e[n] ?? null;
  }
  let i = { regex: "r bwl", email: "drs ml", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "kk ISO", date: "j ISO", time: "kk ISO", duration: "kk t p ISO", ipv4: "drs IPv4", ipv6: "drs IPv6", cidrv4: "gbgb IPv4", cidrv6: "gbgb IPv6", base64: "r t a k n base64", base64url: "r base64url", json_string: "r JSON", e164: "nmb E.164", jwt: "JWT", template_literal: "r bwl" }, o = { nan: "NaN", number: "nmb", array: "akop" };
  return (n) => {
    switch (n.code) {
      case "invalid_type": {
        let r = o[n.expected] ?? n.expected, a = S(n.input), s = o[a] ?? a;
        return /^[A-Z]/.test(n.expected) ? `bwl ae: a n lti fi instanceof ${n.expected}, m a r ${s}` : `bwl ae: a n lti fi ${r}, m a r ${s}`;
      }
      case "invalid_value":
        return n.values.length === 1 ? `bwl ae: a n lti fi ${w(n.values[0])}` : `yn ae: yan kan lra ${v(n.values, "|")}`;
      case "too_big": {
        let r = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `T p j: a n lti j p ${n.origin ?? "iye"} ${a.verb} ${r}${n.maximum} ${a.unit}` : `T p j: a n lti j ${r}${n.maximum}`;
      }
      case "too_small": {
        let r = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Kr ju: a n lti j p ${n.origin} ${a.verb} ${r}${n.minimum} ${a.unit}` : `Kr ju: a n lti j ${r}${n.minimum}`;
      }
      case "invalid_format": {
        let r = n;
        return r.format === "starts_with" ? `r ae: gbd br pl "${r.prefix}"` : r.format === "ends_with" ? `r ae: gbd par pl "${r.suffix}"` : r.format === "includes" ? `r ae: gbd n "${r.includes}"` : r.format === "regex" ? `r ae: gbd b pr mu ${r.pattern}` : `Ae: ${i[r.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Nmb ae: gbd j y ppn ti ${n.divisor}`;
      case "unrecognized_keys":
        return `Btn m: ${v(n.keys, ", ")}`;
      case "invalid_key":
        return `Btn ae nn ${n.origin}`;
      case "invalid_union":
        return "bwl ae";
      case "invalid_element":
        return `Iye ae nn ${n.origin}`;
      default:
        return "bwl ae";
    }
  };
};
function jy() {
  return { localeError: Dy() };
}
var fa, Vl = Symbol("ZodOutput"), Gl = Symbol("ZodInput");
class Bl {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(t, ...i) {
    let o = i[0];
    return this._map.set(t, o), o && typeof o == "object" && "id" in o && this._idmap.set(o.id, t), this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(t) {
    let i = this._map.get(t);
    return i && typeof i == "object" && "id" in i && this._idmap.delete(i.id), this._map.delete(t), this;
  }
  get(t) {
    let i = t._zod.parent;
    if (i) {
      let o = { ...this.get(i) ?? {} };
      delete o.id;
      let n = { ...o, ...this._map.get(t) };
      return Object.keys(n).length ? n : void 0;
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
}
function or() {
  return new Bl();
}
(fa = globalThis).__zod_globalRegistry ?? (fa.__zod_globalRegistry = or());
var ce = globalThis.__zod_globalRegistry;
function Hl(e, t) {
  return new e({ type: "string", ...$(t) });
}
function Xl(e, t) {
  return new e({ type: "string", coerce: !0, ...$(t) });
}
function ar(e, t) {
  return new e({ type: "string", format: "email", check: "string_format", abort: !1, ...$(t) });
}
function an(e, t) {
  return new e({ type: "string", format: "guid", check: "string_format", abort: !1, ...$(t) });
}
function sr(e, t) {
  return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, ...$(t) });
}
function ur(e, t) {
  return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, version: "v4", ...$(t) });
}
function lr(e, t) {
  return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, version: "v6", ...$(t) });
}
function cr(e, t) {
  return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, version: "v7", ...$(t) });
}
function kn(e, t) {
  return new e({ type: "string", format: "url", check: "string_format", abort: !1, ...$(t) });
}
function dr(e, t) {
  return new e({ type: "string", format: "emoji", check: "string_format", abort: !1, ...$(t) });
}
function mr(e, t) {
  return new e({ type: "string", format: "nanoid", check: "string_format", abort: !1, ...$(t) });
}
function pr(e, t) {
  return new e({ type: "string", format: "cuid", check: "string_format", abort: !1, ...$(t) });
}
function fr(e, t) {
  return new e({ type: "string", format: "cuid2", check: "string_format", abort: !1, ...$(t) });
}
function gr(e, t) {
  return new e({ type: "string", format: "ulid", check: "string_format", abort: !1, ...$(t) });
}
function hr(e, t) {
  return new e({ type: "string", format: "xid", check: "string_format", abort: !1, ...$(t) });
}
function vr(e, t) {
  return new e({ type: "string", format: "ksuid", check: "string_format", abort: !1, ...$(t) });
}
function $r(e, t) {
  return new e({ type: "string", format: "ipv4", check: "string_format", abort: !1, ...$(t) });
}
function _r(e, t) {
  return new e({ type: "string", format: "ipv6", check: "string_format", abort: !1, ...$(t) });
}
function Yl(e, t) {
  return new e({ type: "string", format: "mac", check: "string_format", abort: !1, ...$(t) });
}
function br(e, t) {
  return new e({ type: "string", format: "cidrv4", check: "string_format", abort: !1, ...$(t) });
}
function yr(e, t) {
  return new e({ type: "string", format: "cidrv6", check: "string_format", abort: !1, ...$(t) });
}
function kr(e, t) {
  return new e({ type: "string", format: "base64", check: "string_format", abort: !1, ...$(t) });
}
function Ir(e, t) {
  return new e({ type: "string", format: "base64url", check: "string_format", abort: !1, ...$(t) });
}
function wr(e, t) {
  return new e({ type: "string", format: "e164", check: "string_format", abort: !1, ...$(t) });
}
function Sr(e, t) {
  return new e({ type: "string", format: "jwt", check: "string_format", abort: !1, ...$(t) });
}
var Ql = { Any: null, Minute: -1, Second: 0, Millisecond: 3, Microsecond: 6 };
function ec(e, t) {
  return new e({ type: "string", format: "datetime", check: "string_format", offset: !1, local: !1, precision: null, ...$(t) });
}
function tc(e, t) {
  return new e({ type: "string", format: "date", check: "string_format", ...$(t) });
}
function nc(e, t) {
  return new e({ type: "string", format: "time", check: "string_format", precision: null, ...$(t) });
}
function ic(e, t) {
  return new e({ type: "string", format: "duration", check: "string_format", ...$(t) });
}
function rc(e, t) {
  return new e({ type: "number", checks: [], ...$(t) });
}
function oc(e, t) {
  return new e({ type: "number", coerce: !0, checks: [], ...$(t) });
}
function ac(e, t) {
  return new e({ type: "number", check: "number_format", abort: !1, format: "safeint", ...$(t) });
}
function sc(e, t) {
  return new e({ type: "number", check: "number_format", abort: !1, format: "float32", ...$(t) });
}
function uc(e, t) {
  return new e({ type: "number", check: "number_format", abort: !1, format: "float64", ...$(t) });
}
function lc(e, t) {
  return new e({ type: "number", check: "number_format", abort: !1, format: "int32", ...$(t) });
}
function cc(e, t) {
  return new e({ type: "number", check: "number_format", abort: !1, format: "uint32", ...$(t) });
}
function dc(e, t) {
  return new e({ type: "boolean", ...$(t) });
}
function mc(e, t) {
  return new e({ type: "boolean", coerce: !0, ...$(t) });
}
function pc(e, t) {
  return new e({ type: "bigint", ...$(t) });
}
function fc(e, t) {
  return new e({ type: "bigint", coerce: !0, ...$(t) });
}
function gc(e, t) {
  return new e({ type: "bigint", check: "bigint_format", abort: !1, format: "int64", ...$(t) });
}
function hc(e, t) {
  return new e({ type: "bigint", check: "bigint_format", abort: !1, format: "uint64", ...$(t) });
}
function vc(e, t) {
  return new e({ type: "symbol", ...$(t) });
}
function $c(e, t) {
  return new e({ type: "undefined", ...$(t) });
}
function _c(e, t) {
  return new e({ type: "null", ...$(t) });
}
function bc(e) {
  return new e({ type: "any" });
}
function yc(e) {
  return new e({ type: "unknown" });
}
function kc(e, t) {
  return new e({ type: "never", ...$(t) });
}
function Ic(e, t) {
  return new e({ type: "void", ...$(t) });
}
function wc(e, t) {
  return new e({ type: "date", ...$(t) });
}
function Sc(e, t) {
  return new e({ type: "date", coerce: !0, ...$(t) });
}
function xc(e, t) {
  return new e({ type: "nan", ...$(t) });
}
function Se(e, t) {
  return new Bi({ check: "less_than", ...$(t), value: e, inclusive: !1 });
}
function de(e, t) {
  return new Bi({ check: "less_than", ...$(t), value: e, inclusive: !0 });
}
function xe(e, t) {
  return new Hi({ check: "greater_than", ...$(t), value: e, inclusive: !1 });
}
function ie(e, t) {
  return new Hi({ check: "greater_than", ...$(t), value: e, inclusive: !0 });
}
function xr(e) {
  return xe(0, e);
}
function zr(e) {
  return Se(0, e);
}
function Ur(e) {
  return de(0, e);
}
function Or(e) {
  return ie(0, e);
}
function We(e, t) {
  return new du({ check: "multiple_of", ...$(t), value: e });
}
function Xe(e, t) {
  return new fu({ check: "max_size", ...$(t), maximum: e });
}
function ze(e, t) {
  return new gu({ check: "min_size", ...$(t), minimum: e });
}
function zt(e, t) {
  return new hu({ check: "size_equals", ...$(t), size: e });
}
function Ut(e, t) {
  return new vu({ check: "max_length", ...$(t), maximum: e });
}
function De(e, t) {
  return new $u({ check: "min_length", ...$(t), minimum: e });
}
function Ot(e, t) {
  return new _u({ check: "length_equals", ...$(t), length: e });
}
function In(e, t) {
  return new bu({ check: "string_format", format: "regex", ...$(t), pattern: e });
}
function wn(e) {
  return new yu({ check: "string_format", format: "lowercase", ...$(e) });
}
function Sn(e) {
  return new ku({ check: "string_format", format: "uppercase", ...$(e) });
}
function xn(e, t) {
  return new Iu({ check: "string_format", format: "includes", ...$(t), includes: e });
}
function zn(e, t) {
  return new wu({ check: "string_format", format: "starts_with", ...$(t), prefix: e });
}
function Un(e, t) {
  return new Su({ check: "string_format", format: "ends_with", ...$(t), suffix: e });
}
function Zr(e, t, i) {
  return new xu({ check: "property", property: e, schema: t, ...$(i) });
}
function On(e, t) {
  return new zu({ check: "mime_type", mime: e, ...$(t) });
}
function ke(e) {
  return new Uu({ check: "overwrite", tx: e });
}
function Zn(e) {
  return ke((t) => t.normalize(e));
}
function Pn() {
  return ke((e) => e.trim());
}
function En() {
  return ke((e) => e.toLowerCase());
}
function Nn() {
  return ke((e) => e.toUpperCase());
}
function Dn() {
  return ke((e) => $s(e));
}
function zc(e, t, i) {
  return new e({ type: "array", element: t, ...$(i) });
}
function Ty(e, t, i) {
  return new e({ type: "union", options: t, ...$(i) });
}
function Ay(e, t, i) {
  return new e({ type: "union", options: t, inclusive: !1, ...$(i) });
}
function Ry(e, t, i, o) {
  return new e({ type: "union", options: i, discriminator: t, ...$(o) });
}
function Cy(e, t, i) {
  return new e({ type: "intersection", left: t, right: i });
}
function My(e, t, i, o) {
  let n = i instanceof z;
  return new e({ type: "tuple", items: t, rest: n ? i : null, ...$(n ? o : i) });
}
function Ly(e, t, i, o) {
  return new e({ type: "record", keyType: t, valueType: i, ...$(o) });
}
function Fy(e, t, i, o) {
  return new e({ type: "map", keyType: t, valueType: i, ...$(o) });
}
function Jy(e, t, i) {
  return new e({ type: "set", valueType: t, ...$(i) });
}
function qy(e, t, i) {
  let o = Array.isArray(t) ? Object.fromEntries(t.map((n) => [n, n])) : t;
  return new e({ type: "enum", entries: o, ...$(i) });
}
function Wy(e, t, i) {
  return new e({ type: "enum", entries: t, ...$(i) });
}
function Ky(e, t, i) {
  return new e({ type: "literal", values: Array.isArray(t) ? t : [t], ...$(i) });
}
function Uc(e, t) {
  return new e({ type: "file", ...$(t) });
}
function Vy(e, t) {
  return new e({ type: "transform", transform: t });
}
function Gy(e, t) {
  return new e({ type: "optional", innerType: t });
}
function By(e, t) {
  return new e({ type: "nullable", innerType: t });
}
function Hy(e, t, i) {
  return new e({ type: "default", innerType: t, get defaultValue() {
    return typeof i == "function" ? i() : bs(i);
  } });
}
function Xy(e, t, i) {
  return new e({ type: "nonoptional", innerType: t, ...$(i) });
}
function Yy(e, t) {
  return new e({ type: "success", innerType: t });
}
function Qy(e, t, i) {
  return new e({ type: "catch", innerType: t, catchValue: typeof i == "function" ? i : () => i });
}
function ek(e, t, i) {
  return new e({ type: "pipe", in: t, out: i });
}
function tk(e, t) {
  return new e({ type: "readonly", innerType: t });
}
function nk(e, t, i) {
  return new e({ type: "template_literal", parts: t, ...$(i) });
}
function ik(e, t) {
  return new e({ type: "lazy", getter: t });
}
function rk(e, t) {
  return new e({ type: "promise", innerType: t });
}
function Oc(e, t, i) {
  let o = $(i);
  return o.abort ?? (o.abort = !0), new e({ type: "custom", check: "custom", fn: t, ...o });
}
function Zc(e, t, i) {
  return new e({ type: "custom", check: "custom", fn: t, ...$(i) });
}
function Pc(e) {
  let t = Ec((i) => (i.addIssue = (o) => {
    if (typeof o == "string") i.issues.push(rn(o, i.value, t._zod.def));
    else {
      let n = o;
      n.fatal && (n.continue = !1), n.code ?? (n.code = "custom"), n.input ?? (n.input = i.value), n.inst ?? (n.inst = t), n.continue ?? (n.continue = !t._zod.def.abort), i.issues.push(rn(n));
    }
  }, e(i.value, i)));
  return t;
}
function Ec(e, t) {
  let i = new J({ check: "custom", ...$(t) });
  return i._zod.check = e, i;
}
function Nc(e) {
  let t = new J({ check: "describe" });
  return t._zod.onattach = [(i) => {
    let o = ce.get(i) ?? {};
    ce.add(i, { ...o, description: e });
  }], t._zod.check = () => {
  }, t;
}
function Dc(e) {
  let t = new J({ check: "meta" });
  return t._zod.onattach = [(i) => {
    let o = ce.get(i) ?? {};
    ce.add(i, { ...o, ...e });
  }], t._zod.check = () => {
  }, t;
}
function jc(e, t) {
  let i = $(t), o = i.truthy ?? ["true", "1", "yes", "on", "y", "enabled"], n = i.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  i.case !== "sensitive" && (o = o.map((g) => typeof g == "string" ? g.toLowerCase() : g), n = n.map((g) => typeof g == "string" ? g.toLowerCase() : g));
  let r = new Set(o), a = new Set(n), s = e.Codec ?? ir, u = e.Boolean ?? Qi, l = new (e.String ?? xt)({ type: "string", error: i.error }), d = new u({ type: "boolean", error: i.error }), p = new s({ type: "pipe", in: l, out: d, transform: (g, _) => {
    let x = g;
    return i.case !== "sensitive" && (x = x.toLowerCase()), r.has(x) ? !0 : a.has(x) ? !1 : (_.issues.push({ code: "invalid_value", expected: "stringbool", values: [...r, ...a], input: _.value, inst: p, continue: !1 }), {});
  }, reverseTransform: (g, _) => g === !0 ? o[0] || "true" : n[0] || "false", error: i.error });
  return p;
}
function Zt(e, t, i, o = {}) {
  let n = $(o), r = { ...$(o), check: "string_format", type: "string", format: t, fn: typeof i == "function" ? i : (a) => i.test(a), ...n };
  return i instanceof RegExp && (r.pattern = i), new e(r);
}
function Ke(e) {
  let t = e?.target ?? "draft-2020-12";
  return t === "draft-4" && (t = "draft-04"), t === "draft-7" && (t = "draft-07"), { processors: e.processors ?? {}, metadataRegistry: e?.metadata ?? ce, target: t, unrepresentable: e?.unrepresentable ?? "throw", override: e?.override ?? (() => {
  }), io: e?.io ?? "output", counter: 0, seen: /* @__PURE__ */ new Map(), cycles: e?.cycles ?? "ref", reused: e?.reused ?? "inline", external: e?.external ?? void 0 };
}
function T(e, t, i = { path: [], schemaPath: [] }) {
  var o;
  let n = e._zod.def, r = t.seen.get(e);
  if (r)
    return r.count++, i.schemaPath.includes(e) && (r.cycle = i.path), r.schema;
  let a = { schema: {}, count: 1, cycle: void 0, path: i.path };
  t.seen.set(e, a);
  let s = e._zod.toJSONSchema?.();
  if (s) a.schema = s;
  else {
    let l = { ...i, schemaPath: [...i.schemaPath, e], path: i.path };
    if (e._zod.processJSONSchema) e._zod.processJSONSchema(t, a.schema, l);
    else {
      let p = a.schema, g = t.processors[n.type];
      if (!g) throw Error(`[toJSONSchema]: Non-representable type encountered: ${n.type}`);
      g(e, t, p, l);
    }
    let d = e._zod.parent;
    d && (a.ref || (a.ref = d), T(d, t, l), t.seen.get(d).isParent = !0);
  }
  let u = t.metadataRegistry.get(e);
  return u && Object.assign(a.schema, u), t.io === "input" && ne(e) && (delete a.schema.examples, delete a.schema.default), t.io === "input" && a.schema._prefault && ((o = a.schema).default ?? (o.default = a.schema._prefault)), delete a.schema._prefault, t.seen.get(e).schema;
}
function Ve(e, t) {
  let i = e.seen.get(t);
  if (!i) throw Error("Unprocessed schema. This is a bug in Zod.");
  let o = /* @__PURE__ */ new Map();
  for (let a of e.seen.entries()) {
    let s = e.metadataRegistry.get(a[0])?.id;
    if (s) {
      let u = o.get(s);
      if (u && u !== a[0]) throw Error(`Duplicate schema id "${s}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      o.set(s, a[0]);
    }
  }
  let n = (a) => {
    let s = e.target === "draft-2020-12" ? "$defs" : "definitions";
    if (e.external) {
      let d = e.external.registry.get(a[0])?.id, p = e.external.uri ?? ((_) => _);
      if (d) return { ref: p(d) };
      let g = a[1].defId ?? a[1].schema.id ?? `schema${e.counter++}`;
      return a[1].defId = g, { defId: g, ref: `${p("__shared")}#/${s}/${g}` };
    }
    if (a[1] === i) return { ref: "#" };
    let u = `#/${s}/`, l = a[1].schema.id ?? `__schema${e.counter++}`;
    return { defId: l, ref: u + l };
  }, r = (a) => {
    if (a[1].schema.$ref) return;
    let s = a[1], { ref: u, defId: l } = n(a);
    s.def = { ...s.schema }, l && (s.defId = l);
    let d = s.schema;
    for (let p in d) delete d[p];
    d.$ref = u;
  };
  if (e.cycles === "throw") for (let a of e.seen.entries()) {
    let s = a[1];
    if (s.cycle) throw Error(`Cycle detected: #/${s.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
  }
  for (let a of e.seen.entries()) {
    let s = a[1];
    if (t === a[0]) {
      r(a);
      continue;
    }
    if (e.external) {
      let u = e.external.registry.get(a[0])?.id;
      if (t !== a[0] && u) {
        r(a);
        continue;
      }
    }
    if (e.metadataRegistry.get(a[0])?.id) {
      r(a);
      continue;
    }
    if (s.cycle) {
      r(a);
      continue;
    }
    if (s.count > 1 && e.reused === "ref") {
      r(a);
      continue;
    }
  }
}
function Ge(e, t) {
  let i = e.seen.get(t);
  if (!i) throw Error("Unprocessed schema. This is a bug in Zod.");
  let o = (a) => {
    let s = e.seen.get(a);
    if (s.ref === null) return;
    let u = s.def ?? s.schema, l = { ...u }, d = s.ref;
    if (s.ref = null, d) {
      o(d);
      let g = e.seen.get(d), _ = g.schema;
      if (_.$ref && (e.target === "draft-07" || e.target === "draft-04" || e.target === "openapi-3.0") ? (u.allOf = u.allOf ?? [], u.allOf.push(_)) : Object.assign(u, _), Object.assign(u, l), a._zod.parent === d) for (let x in u)
        x === "$ref" || x === "allOf" || x in l || delete u[x];
      if (_.$ref) for (let x in u)
        x === "$ref" || x === "allOf" || x in g.def && JSON.stringify(u[x]) === JSON.stringify(g.def[x]) && delete u[x];
    }
    let p = a._zod.parent;
    if (p && p !== d) {
      o(p);
      let g = e.seen.get(p);
      if (g?.schema.$ref && (u.$ref = g.schema.$ref, g.def))
        for (let _ in u)
          _ === "$ref" || _ === "allOf" || _ in g.def && JSON.stringify(u[_]) === JSON.stringify(g.def[_]) && delete u[_];
    }
    e.override({ zodSchema: a, jsonSchema: u, path: s.path ?? [] });
  };
  for (let a of [...e.seen.entries()].reverse()) o(a[0]);
  let n = {};
  if (e.target === "draft-2020-12" ? n.$schema = "https://json-schema.org/draft/2020-12/schema" : e.target === "draft-07" ? n.$schema = "http://json-schema.org/draft-07/schema#" : e.target === "draft-04" ? n.$schema = "http://json-schema.org/draft-04/schema#" : e.target, e.external?.uri) {
    let a = e.external.registry.get(t)?.id;
    if (!a) throw Error("Schema is missing an `id` property");
    n.$id = e.external.uri(a);
  }
  Object.assign(n, i.def ?? i.schema);
  let r = e.external?.defs ?? {};
  for (let a of e.seen.entries()) {
    let s = a[1];
    s.def && s.defId && (r[s.defId] = s.def);
  }
  e.external || Object.keys(r).length > 0 && (e.target === "draft-2020-12" ? n.$defs = r : n.definitions = r);
  try {
    let a = JSON.parse(JSON.stringify(n));
    return Object.defineProperty(a, "~standard", { value: { ...t["~standard"], jsonSchema: { input: ot(t, "input", e.processors), output: ot(t, "output", e.processors) } }, enumerable: !1, writable: !1 }), a;
  } catch {
    throw Error("Error converting schema to JSON.");
  }
}
function ne(e, t) {
  let i = t ?? { seen: /* @__PURE__ */ new Set() };
  if (i.seen.has(e)) return !1;
  i.seen.add(e);
  let o = e._zod.def;
  if (o.type === "transform") return !0;
  if (o.type === "array") return ne(o.element, i);
  if (o.type === "set") return ne(o.valueType, i);
  if (o.type === "lazy") return ne(o.getter(), i);
  if (o.type === "promise" || o.type === "optional" || o.type === "nonoptional" || o.type === "nullable" || o.type === "readonly" || o.type === "default" || o.type === "prefault") return ne(o.innerType, i);
  if (o.type === "intersection") return ne(o.left, i) || ne(o.right, i);
  if (o.type === "record" || o.type === "map") return ne(o.keyType, i) || ne(o.valueType, i);
  if (o.type === "pipe") return ne(o.in, i) || ne(o.out, i);
  if (o.type === "object") {
    for (let n in o.shape) if (ne(o.shape[n], i)) return !0;
    return !1;
  }
  if (o.type === "union") {
    for (let n of o.options) if (ne(n, i)) return !0;
    return !1;
  }
  if (o.type === "tuple") {
    for (let n of o.items) if (ne(n, i)) return !0;
    return !!(o.rest && ne(o.rest, i));
  }
  return !1;
}
var Tc = (e, t = {}) => (i) => {
  let o = Ke({ ...i, processors: t });
  return T(e, o), Ve(o, e), Ge(o, e);
}, ot = (e, t, i = {}) => (o) => {
  let { libraryOptions: n, target: r } = o ?? {}, a = Ke({ ...n ?? {}, target: r, io: t, processors: i });
  return T(e, a), Ve(a, e), Ge(a, e);
}, ok = { guid: "uuid", url: "uri", datetime: "date-time", json_string: "json-string", regex: "" }, Ac = (e, t, i, o) => {
  let n = i;
  n.type = "string";
  let { minimum: r, maximum: a, format: s, patterns: u, contentEncoding: l } = e._zod.bag;
  if (typeof r == "number" && (n.minLength = r), typeof a == "number" && (n.maxLength = a), s && (n.format = ok[s] ?? s, n.format === "" && delete n.format, s === "time" && delete n.format), l && (n.contentEncoding = l), u && u.size > 0) {
    let d = [...u];
    d.length === 1 ? n.pattern = d[0].source : d.length > 1 && (n.allOf = [...d.map((p) => ({ ...t.target === "draft-07" || t.target === "draft-04" || t.target === "openapi-3.0" ? { type: "string" } : {}, pattern: p.source }))]);
  }
}, Rc = (e, t, i, o) => {
  let n = i, { minimum: r, maximum: a, format: s, multipleOf: u, exclusiveMaximum: l, exclusiveMinimum: d } = e._zod.bag;
  typeof s == "string" && s.includes("int") ? n.type = "integer" : n.type = "number", typeof d == "number" && (t.target === "draft-04" || t.target === "openapi-3.0" ? (n.minimum = d, n.exclusiveMinimum = !0) : n.exclusiveMinimum = d), typeof r == "number" && (n.minimum = r, typeof d == "number" && t.target !== "draft-04" && (d >= r ? delete n.minimum : delete n.exclusiveMinimum)), typeof l == "number" && (t.target === "draft-04" || t.target === "openapi-3.0" ? (n.maximum = l, n.exclusiveMaximum = !0) : n.exclusiveMaximum = l), typeof a == "number" && (n.maximum = a, typeof l == "number" && t.target !== "draft-04" && (l <= a ? delete n.maximum : delete n.exclusiveMaximum)), typeof u == "number" && (n.multipleOf = u);
}, Cc = (e, t, i, o) => {
  i.type = "boolean";
}, Mc = (e, t, i, o) => {
  if (t.unrepresentable === "throw") throw Error("BigInt cannot be represented in JSON Schema");
}, Lc = (e, t, i, o) => {
  if (t.unrepresentable === "throw") throw Error("Symbols cannot be represented in JSON Schema");
}, Fc = (e, t, i, o) => {
  t.target === "openapi-3.0" ? (i.type = "string", i.nullable = !0, i.enum = [null]) : i.type = "null";
}, Jc = (e, t, i, o) => {
  if (t.unrepresentable === "throw") throw Error("Undefined cannot be represented in JSON Schema");
}, qc = (e, t, i, o) => {
  if (t.unrepresentable === "throw") throw Error("Void cannot be represented in JSON Schema");
}, Wc = (e, t, i, o) => {
  i.not = {};
}, Kc = (e, t, i, o) => {
}, Vc = (e, t, i, o) => {
}, Gc = (e, t, i, o) => {
  if (t.unrepresentable === "throw") throw Error("Date cannot be represented in JSON Schema");
}, Bc = (e, t, i, o) => {
  let n = e._zod.def, r = Di(n.entries);
  r.every((a) => typeof a == "number") && (i.type = "number"), r.every((a) => typeof a == "string") && (i.type = "string"), i.enum = r;
}, Hc = (e, t, i, o) => {
  let n = e._zod.def, r = [];
  for (let a of n.values) if (a === void 0) {
    if (t.unrepresentable === "throw") throw Error("Literal `undefined` cannot be represented in JSON Schema");
  } else if (typeof a == "bigint") {
    if (t.unrepresentable === "throw") throw Error("BigInt literals cannot be represented in JSON Schema");
    r.push(Number(a));
  } else r.push(a);
  if (r.length !== 0) if (r.length === 1) {
    let a = r[0];
    i.type = a === null ? "null" : typeof a, t.target === "draft-04" || t.target === "openapi-3.0" ? i.enum = [a] : i.const = a;
  } else
    r.every((a) => typeof a == "number") && (i.type = "number"), r.every((a) => typeof a == "string") && (i.type = "string"), r.every((a) => typeof a == "boolean") && (i.type = "boolean"), r.every((a) => a === null) && (i.type = "null"), i.enum = r;
}, Xc = (e, t, i, o) => {
  if (t.unrepresentable === "throw") throw Error("NaN cannot be represented in JSON Schema");
}, Yc = (e, t, i, o) => {
  let n = i, r = e._zod.pattern;
  if (!r) throw Error("Pattern not found in template literal");
  n.type = "string", n.pattern = r.source;
}, Qc = (e, t, i, o) => {
  let n = i, r = { type: "string", format: "binary", contentEncoding: "binary" }, { minimum: a, maximum: s, mime: u } = e._zod.bag;
  a !== void 0 && (r.minLength = a), s !== void 0 && (r.maxLength = s), u ? u.length === 1 ? (r.contentMediaType = u[0], Object.assign(n, r)) : (Object.assign(n, r), n.anyOf = u.map((l) => ({ contentMediaType: l }))) : Object.assign(n, r);
}, ed = (e, t, i, o) => {
  i.type = "boolean";
}, td = (e, t, i, o) => {
  if (t.unrepresentable === "throw") throw Error("Custom types cannot be represented in JSON Schema");
}, nd = (e, t, i, o) => {
  if (t.unrepresentable === "throw") throw Error("Function types cannot be represented in JSON Schema");
}, id = (e, t, i, o) => {
  if (t.unrepresentable === "throw") throw Error("Transforms cannot be represented in JSON Schema");
}, rd = (e, t, i, o) => {
  if (t.unrepresentable === "throw") throw Error("Map cannot be represented in JSON Schema");
}, od = (e, t, i, o) => {
  if (t.unrepresentable === "throw") throw Error("Set cannot be represented in JSON Schema");
}, ad = (e, t, i, o) => {
  let n = i, r = e._zod.def, { minimum: a, maximum: s } = e._zod.bag;
  typeof a == "number" && (n.minItems = a), typeof s == "number" && (n.maxItems = s), n.type = "array", n.items = T(r.element, t, { ...o, path: [...o.path, "items"] });
}, sd = (e, t, i, o) => {
  let n = i, r = e._zod.def;
  n.type = "object", n.properties = {};
  let a = r.shape;
  for (let l in a) n.properties[l] = T(a[l], t, { ...o, path: [...o.path, "properties", l] });
  let s = new Set(Object.keys(a)), u = new Set([...s].filter((l) => {
    let d = r.shape[l]._zod;
    return t.io === "input" ? d.optin === void 0 : d.optout === void 0;
  }));
  u.size > 0 && (n.required = Array.from(u)), r.catchall?._zod.def.type === "never" ? n.additionalProperties = !1 : r.catchall ? r.catchall && (n.additionalProperties = T(r.catchall, t, { ...o, path: [...o.path, "additionalProperties"] })) : t.io === "output" && (n.additionalProperties = !1);
}, Pr = (e, t, i, o) => {
  let n = e._zod.def, r = n.inclusive === !1, a = n.options.map((s, u) => T(s, t, { ...o, path: [...o.path, r ? "oneOf" : "anyOf", u] }));
  r ? i.oneOf = a : i.anyOf = a;
}, ud = (e, t, i, o) => {
  let n = e._zod.def, r = T(n.left, t, { ...o, path: [...o.path, "allOf", 0] }), a = T(n.right, t, { ...o, path: [...o.path, "allOf", 1] }), s = (l) => "allOf" in l && Object.keys(l).length === 1, u = [...s(r) ? r.allOf : [r], ...s(a) ? a.allOf : [a]];
  i.allOf = u;
}, ld = (e, t, i, o) => {
  let n = i, r = e._zod.def;
  n.type = "array";
  let a = t.target === "draft-2020-12" ? "prefixItems" : "items", s = t.target === "draft-2020-12" || t.target === "openapi-3.0" ? "items" : "additionalItems", u = r.items.map((g, _) => T(g, t, { ...o, path: [...o.path, a, _] })), l = r.rest ? T(r.rest, t, { ...o, path: [...o.path, s, ...t.target === "openapi-3.0" ? [r.items.length] : []] }) : null;
  t.target === "draft-2020-12" ? (n.prefixItems = u, l && (n.items = l)) : t.target === "openapi-3.0" ? (n.items = { anyOf: u }, l && n.items.anyOf.push(l), n.minItems = u.length, !l && (n.maxItems = u.length)) : (n.items = u, l && (n.additionalItems = l));
  let { minimum: d, maximum: p } = e._zod.bag;
  typeof d == "number" && (n.minItems = d), typeof p == "number" && (n.maxItems = p);
}, cd = (e, t, i, o) => {
  let n = i, r = e._zod.def;
  n.type = "object";
  let a = r.keyType, s = a._zod.bag?.patterns;
  if (r.mode === "loose" && s && s.size > 0) {
    let l = T(r.valueType, t, { ...o, path: [...o.path, "patternProperties", "*"] });
    n.patternProperties = {};
    for (let d of s) n.patternProperties[d.source] = l;
  } else
    (t.target === "draft-07" || t.target === "draft-2020-12") && (n.propertyNames = T(r.keyType, t, { ...o, path: [...o.path, "propertyNames"] })), n.additionalProperties = T(r.valueType, t, { ...o, path: [...o.path, "additionalProperties"] });
  let u = a._zod.values;
  if (u) {
    let l = [...u].filter((d) => typeof d == "string" || typeof d == "number");
    l.length > 0 && (n.required = l);
  }
}, dd = (e, t, i, o) => {
  let n = e._zod.def, r = T(n.innerType, t, o), a = t.seen.get(e);
  t.target === "openapi-3.0" ? (a.ref = n.innerType, i.nullable = !0) : i.anyOf = [r, { type: "null" }];
}, md = (e, t, i, o) => {
  let n = e._zod.def;
  T(n.innerType, t, o);
  let r = t.seen.get(e);
  r.ref = n.innerType;
}, pd = (e, t, i, o) => {
  let n = e._zod.def;
  T(n.innerType, t, o);
  let r = t.seen.get(e);
  r.ref = n.innerType, i.default = JSON.parse(JSON.stringify(n.defaultValue));
}, fd = (e, t, i, o) => {
  let n = e._zod.def;
  T(n.innerType, t, o);
  let r = t.seen.get(e);
  r.ref = n.innerType, t.io === "input" && (i._prefault = JSON.parse(JSON.stringify(n.defaultValue)));
}, gd = (e, t, i, o) => {
  let n = e._zod.def;
  T(n.innerType, t, o);
  let r = t.seen.get(e);
  r.ref = n.innerType;
  let a;
  try {
    a = n.catchValue(void 0);
  } catch {
    throw Error("Dynamic catch values are not supported in JSON Schema");
  }
  i.default = a;
}, hd = (e, t, i, o) => {
  let n = e._zod.def, r = t.io === "input" ? n.in._zod.def.type === "transform" ? n.out : n.in : n.out;
  T(r, t, o);
  let a = t.seen.get(e);
  a.ref = r;
}, vd = (e, t, i, o) => {
  let n = e._zod.def;
  T(n.innerType, t, o);
  let r = t.seen.get(e);
  r.ref = n.innerType, i.readOnly = !0;
}, $d = (e, t, i, o) => {
  let n = e._zod.def;
  T(n.innerType, t, o);
  let r = t.seen.get(e);
  r.ref = n.innerType;
}, Er = (e, t, i, o) => {
  let n = e._zod.def;
  T(n.innerType, t, o);
  let r = t.seen.get(e);
  r.ref = n.innerType;
}, _d = (e, t, i, o) => {
  let n = e._zod.innerType;
  T(n, t, o);
  let r = t.seen.get(e);
  r.ref = n;
}, $i = { string: Ac, number: Rc, boolean: Cc, bigint: Mc, symbol: Lc, null: Fc, undefined: Jc, void: qc, never: Wc, any: Kc, unknown: Vc, date: Gc, enum: Bc, literal: Hc, nan: Xc, template_literal: Yc, file: Qc, success: ed, custom: td, function: nd, transform: id, map: rd, set: od, array: ad, object: sd, union: Pr, intersection: ud, tuple: ld, record: cd, nullable: dd, nonoptional: md, default: pd, prefault: fd, catch: gd, pipe: hd, readonly: vd, promise: $d, optional: Er, lazy: _d };
function bd(e, t) {
  if ("_idmap" in e) {
    let o = e, n = Ke({ ...t, processors: $i }), r = {};
    for (let u of o._idmap.entries()) {
      let [l, d] = u;
      T(d, n);
    }
    let a = {}, s = { registry: o, uri: t?.uri, defs: r };
    n.external = s;
    for (let u of o._idmap.entries()) {
      let [l, d] = u;
      Ve(n, d), a[l] = Ge(n, d);
    }
    if (Object.keys(r).length > 0) {
      let u = n.target === "draft-2020-12" ? "$defs" : "definitions";
      a.__shared = { [u]: r };
    }
    return { schemas: a };
  }
  let i = Ke({ ...t, processors: $i });
  return T(e, i), Ve(i, e), Ge(i, e);
}
class ak {
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  get target() {
    return this.ctx.target;
  }
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  get override() {
    return this.ctx.override;
  }
  get io() {
    return this.ctx.io;
  }
  get counter() {
    return this.ctx.counter;
  }
  set counter(t) {
    this.ctx.counter = t;
  }
  get seen() {
    return this.ctx.seen;
  }
  constructor(t) {
    let i = t?.target ?? "draft-2020-12";
    i === "draft-4" && (i = "draft-04"), i === "draft-7" && (i = "draft-07"), this.ctx = Ke({ processors: $i, target: i, ...t?.metadata && { metadata: t.metadata }, ...t?.unrepresentable && { unrepresentable: t.unrepresentable }, ...t?.override && { override: t.override }, ...t?.io && { io: t.io } });
  }
  process(t, i = { path: [], schemaPath: [] }) {
    return T(t, this.ctx, i);
  }
  emit(t, i) {
    i && (i.cycles && (this.ctx.cycles = i.cycles), i.reused && (this.ctx.reused = i.reused), i.external && (this.ctx.external = i.external)), Ve(this.ctx, t);
    let o = Ge(this.ctx, t), { "~standard": n, ...r } = o;
    return r;
  }
}
var sk = {}, yd = {};
be(yd, { xor: () => Zm, xid: () => Qd, void: () => wm, uuidv7: () => Wd, uuidv6: () => qd, uuidv4: () => Jd, uuid: () => Fd, url: () => Kd, unknown: () => je, union: () => ti, undefined: () => km, ulid: () => Yd, uint64: () => bm, uint32: () => vm, tuple: () => to, transform: () => ii, templateLiteral: () => Jm, symbol: () => ym, superRefine: () => Oo, success: () => Mm, stringbool: () => Hm, stringFormat: () => cm, string: () => sn, strictObject: () => Um, set: () => jm, refine: () => Uo, record: () => no, readonly: () => ko, promise: () => qm, preprocess: () => Ym, prefault: () => go, pipe: () => lt, partialRecord: () => Em, optional: () => st, object: () => zm, number: () => Cr, nullish: () => Cm, nullable: () => ut, null: () => qr, nonoptional: () => ho, never: () => Qn, nativeEnum: () => Tm, nanoid: () => Bd, nan: () => Lm, meta: () => Gm, map: () => Dm, mac: () => nm, looseRecord: () => Nm, looseObject: () => Om, literal: () => Am, lazy: () => So, ksuid: () => em, keyof: () => xm, jwt: () => lm, json: () => Xm, ipv6: () => im, ipv4: () => tm, intersection: () => Qr, int64: () => _m, int32: () => hm, int: () => un, instanceof: () => Bm, httpUrl: () => Vd, hostname: () => dm, hex: () => mm, hash: () => pm, guid: () => Ld, function: () => ln, float64: () => gm, float32: () => fm, file: () => Rm, exactOptional: () => lo, enum: () => ni, emoji: () => Gd, email: () => Md, e164: () => um, discriminatedUnion: () => Pm, describe: () => Vm, date: () => Sm, custom: () => Km, cuid2: () => Xd, cuid: () => Hd, codec: () => Fm, cidrv6: () => om, cidrv4: () => rm, check: () => Wm, catch: () => _o, boolean: () => Mr, bigint: () => $m, base64url: () => sm, base64: () => am, array: () => Tt, any: () => Im, _function: () => ln, _default: () => po, _ZodString: () => jn, ZodXor: () => Hr, ZodXID: () => Fn, ZodVoid: () => Gr, ZodUnknown: () => Kr, ZodUnion: () => Rt, ZodUndefined: () => Fr, ZodUUID: () => ve, ZodURL: () => Et, ZodULID: () => Ln, ZodType: () => U, ZodTuple: () => eo, ZodTransform: () => so, ZodTemplateLiteral: () => Io, ZodSymbol: () => Lr, ZodSuccess: () => vo, ZodStringFormat: () => R, ZodString: () => Pt, ZodSet: () => ro, ZodRecord: () => Ct, ZodReadonly: () => yo, ZodPromise: () => xo, ZodPrefault: () => fo, ZodPipe: () => ai, ZodOptional: () => ri, ZodObject: () => At, ZodNumberFormat: () => Ce, ZodNumber: () => Nt, ZodNullable: () => co, ZodNull: () => Jr, ZodNonOptional: () => oi, ZodNever: () => Vr, ZodNanoID: () => Rn, ZodNaN: () => bo, ZodMap: () => io, ZodMAC: () => Rr, ZodLiteral: () => oo, ZodLazy: () => wo, ZodKSUID: () => Jn, ZodJWT: () => Xn, ZodIntersection: () => Yr, ZodIPv6: () => Wn, ZodIPv4: () => qn, ZodGUID: () => at, ZodFunction: () => zo, ZodFile: () => ao, ZodExactOptional: () => uo, ZodEnum: () => Be, ZodEmoji: () => An, ZodEmail: () => Tn, ZodE164: () => Hn, ZodDiscriminatedUnion: () => Xr, ZodDefault: () => mo, ZodDate: () => ei, ZodCustomStringFormat: () => Ye, ZodCustom: () => Mt, ZodCodec: () => si, ZodCatch: () => $o, ZodCUID2: () => Mn, ZodCUID: () => Cn, ZodCIDRv6: () => Vn, ZodCIDRv4: () => Kn, ZodBoolean: () => Dt, ZodBigIntFormat: () => Yn, ZodBigInt: () => jt, ZodBase64URL: () => Bn, ZodBase64: () => Gn, ZodArray: () => Br, ZodAny: () => Wr });
var kd = {};
be(kd, { uppercase: () => Sn, trim: () => Pn, toUpperCase: () => Nn, toLowerCase: () => En, startsWith: () => zn, slugify: () => Dn, size: () => zt, regex: () => In, property: () => Zr, positive: () => xr, overwrite: () => ke, normalize: () => Zn, nonpositive: () => Ur, nonnegative: () => Or, negative: () => zr, multipleOf: () => We, minSize: () => ze, minLength: () => De, mime: () => On, maxSize: () => Xe, maxLength: () => Ut, lte: () => de, lt: () => Se, lowercase: () => wn, length: () => Ot, includes: () => xn, gte: () => ie, gt: () => xe, endsWith: () => Un });
var Nr = {};
be(Nr, { time: () => Sd, duration: () => xd, datetime: () => Id, date: () => wd, ZodISOTime: () => Tr, ZodISODuration: () => Ar, ZodISODateTime: () => Dr, ZodISODate: () => jr });
var Dr = m("ZodISODateTime", (e, t) => {
  Fu.init(e, t), R.init(e, t);
});
function Id(e) {
  return ec(Dr, e);
}
var jr = m("ZodISODate", (e, t) => {
  Ju.init(e, t), R.init(e, t);
});
function wd(e) {
  return tc(jr, e);
}
var Tr = m("ZodISOTime", (e, t) => {
  qu.init(e, t), R.init(e, t);
});
function Sd(e) {
  return nc(Tr, e);
}
var Ar = m("ZodISODuration", (e, t) => {
  Wu.init(e, t), R.init(e, t);
});
function xd(e) {
  return ic(Ar, e);
}
var zd = (e, t) => {
  Ti.init(e, t), e.name = "ZodError", Object.defineProperties(e, { format: { value: (i) => Ri(e, i) }, flatten: { value: (i) => Ai(e, i) }, addIssue: { value: (i) => {
    e.issues.push(i), e.message = JSON.stringify(e.issues, tn, 2);
  } }, addIssues: { value: (i) => {
    e.issues.push(...i), e.message = JSON.stringify(e.issues, tn, 2);
  } }, isEmpty: { get() {
    return e.issues.length === 0;
  } } });
}, uk = m("ZodError", zd), le = m("ZodError", zd, { Parent: Error }), Ud = _t(le), Od = bt(le), Zd = yt(le), Pd = kt(le), Ed = Ci(le), Nd = Mi(le), Dd = Li(le), jd = Fi(le), Td = Ji(le), Ad = qi(le), Rd = Wi(le), Cd = Ki(le), U = m("ZodType", (e, t) => (z.init(e, t), Object.assign(e["~standard"], { jsonSchema: { input: ot(e, "input"), output: ot(e, "output") } }), e.toJSONSchema = Tc(e, {}), e.def = t, e.type = t.type, Object.defineProperty(e, "_def", { value: t }), e.check = (...i) => e.clone(P.mergeDefs(t, { checks: [...t.checks ?? [], ...i.map((o) => typeof o == "function" ? { _zod: { check: o, def: { check: "custom" }, onattach: [] } } : o)] }), { parent: !0 }), e.with = e.check, e.clone = (i, o) => ge(e, i, o), e.brand = () => e, e.register = (i, o) => (i.add(e, o), e), e.parse = (i, o) => Ud(e, i, o, { callee: e.parse }), e.safeParse = (i, o) => Zd(e, i, o), e.parseAsync = async (i, o) => Od(e, i, o, { callee: e.parseAsync }), e.safeParseAsync = async (i, o) => Pd(e, i, o), e.spa = e.safeParseAsync, e.encode = (i, o) => Ed(e, i, o), e.decode = (i, o) => Nd(e, i, o), e.encodeAsync = async (i, o) => Dd(e, i, o), e.decodeAsync = async (i, o) => jd(e, i, o), e.safeEncode = (i, o) => Td(e, i, o), e.safeDecode = (i, o) => Ad(e, i, o), e.safeEncodeAsync = async (i, o) => Rd(e, i, o), e.safeDecodeAsync = async (i, o) => Cd(e, i, o), e.refine = (i, o) => e.check(Uo(i, o)), e.superRefine = (i) => e.check(Oo(i)), e.overwrite = (i) => e.check(ke(i)), e.optional = () => st(e), e.exactOptional = () => lo(e), e.nullable = () => ut(e), e.nullish = () => st(ut(e)), e.nonoptional = (i) => ho(e, i), e.array = () => Tt(e), e.or = (i) => ti([e, i]), e.and = (i) => Qr(e, i), e.transform = (i) => lt(e, ii(i)), e.default = (i) => po(e, i), e.prefault = (i) => go(e, i), e.catch = (i) => _o(e, i), e.pipe = (i) => lt(e, i), e.readonly = () => ko(e), e.describe = (i) => {
  let o = e.clone();
  return ce.add(o, { description: i }), o;
}, Object.defineProperty(e, "description", { get() {
  return ce.get(e)?.description;
}, configurable: !0 }), e.meta = (...i) => {
  if (i.length === 0) return ce.get(e);
  let o = e.clone();
  return ce.add(o, i[0]), o;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e.apply = (i) => i(e), e)), jn = m("_ZodString", (e, t) => {
  xt.init(e, t), U.init(e, t), e._zod.processJSONSchema = (o, n, r) => Ac(e, o, n);
  let i = e._zod.bag;
  e.format = i.format ?? null, e.minLength = i.minimum ?? null, e.maxLength = i.maximum ?? null, e.regex = (...o) => e.check(In(...o)), e.includes = (...o) => e.check(xn(...o)), e.startsWith = (...o) => e.check(zn(...o)), e.endsWith = (...o) => e.check(Un(...o)), e.min = (...o) => e.check(De(...o)), e.max = (...o) => e.check(Ut(...o)), e.length = (...o) => e.check(Ot(...o)), e.nonempty = (...o) => e.check(De(1, ...o)), e.lowercase = (o) => e.check(wn(o)), e.uppercase = (o) => e.check(Sn(o)), e.trim = () => e.check(Pn()), e.normalize = (...o) => e.check(Zn(...o)), e.toLowerCase = () => e.check(En()), e.toUpperCase = () => e.check(Nn()), e.slugify = () => e.check(Dn());
}), Pt = m("ZodString", (e, t) => {
  xt.init(e, t), jn.init(e, t), e.email = (i) => e.check(ar(Tn, i)), e.url = (i) => e.check(kn(Et, i)), e.jwt = (i) => e.check(Sr(Xn, i)), e.emoji = (i) => e.check(dr(An, i)), e.guid = (i) => e.check(an(at, i)), e.uuid = (i) => e.check(sr(ve, i)), e.uuidv4 = (i) => e.check(ur(ve, i)), e.uuidv6 = (i) => e.check(lr(ve, i)), e.uuidv7 = (i) => e.check(cr(ve, i)), e.nanoid = (i) => e.check(mr(Rn, i)), e.guid = (i) => e.check(an(at, i)), e.cuid = (i) => e.check(pr(Cn, i)), e.cuid2 = (i) => e.check(fr(Mn, i)), e.ulid = (i) => e.check(gr(Ln, i)), e.base64 = (i) => e.check(kr(Gn, i)), e.base64url = (i) => e.check(Ir(Bn, i)), e.xid = (i) => e.check(hr(Fn, i)), e.ksuid = (i) => e.check(vr(Jn, i)), e.ipv4 = (i) => e.check($r(qn, i)), e.ipv6 = (i) => e.check(_r(Wn, i)), e.cidrv4 = (i) => e.check(br(Kn, i)), e.cidrv6 = (i) => e.check(yr(Vn, i)), e.e164 = (i) => e.check(wr(Hn, i)), e.datetime = (i) => e.check(Id(i)), e.date = (i) => e.check(wd(i)), e.time = (i) => e.check(Sd(i)), e.duration = (i) => e.check(xd(i));
});
function sn(e) {
  return Hl(Pt, e);
}
var R = m("ZodStringFormat", (e, t) => {
  A.init(e, t), jn.init(e, t);
}), Tn = m("ZodEmail", (e, t) => {
  Nu.init(e, t), R.init(e, t);
});
function Md(e) {
  return ar(Tn, e);
}
var at = m("ZodGUID", (e, t) => {
  Pu.init(e, t), R.init(e, t);
});
function Ld(e) {
  return an(at, e);
}
var ve = m("ZodUUID", (e, t) => {
  Eu.init(e, t), R.init(e, t);
});
function Fd(e) {
  return sr(ve, e);
}
function Jd(e) {
  return ur(ve, e);
}
function qd(e) {
  return lr(ve, e);
}
function Wd(e) {
  return cr(ve, e);
}
var Et = m("ZodURL", (e, t) => {
  Du.init(e, t), R.init(e, t);
});
function Kd(e) {
  return kn(Et, e);
}
function Vd(e) {
  return kn(Et, { protocol: /^https?$/, hostname: Re.domain, ...P.normalizeParams(e) });
}
var An = m("ZodEmoji", (e, t) => {
  ju.init(e, t), R.init(e, t);
});
function Gd(e) {
  return dr(An, e);
}
var Rn = m("ZodNanoID", (e, t) => {
  Tu.init(e, t), R.init(e, t);
});
function Bd(e) {
  return mr(Rn, e);
}
var Cn = m("ZodCUID", (e, t) => {
  Au.init(e, t), R.init(e, t);
});
function Hd(e) {
  return pr(Cn, e);
}
var Mn = m("ZodCUID2", (e, t) => {
  Ru.init(e, t), R.init(e, t);
});
function Xd(e) {
  return fr(Mn, e);
}
var Ln = m("ZodULID", (e, t) => {
  Cu.init(e, t), R.init(e, t);
});
function Yd(e) {
  return gr(Ln, e);
}
var Fn = m("ZodXID", (e, t) => {
  Mu.init(e, t), R.init(e, t);
});
function Qd(e) {
  return hr(Fn, e);
}
var Jn = m("ZodKSUID", (e, t) => {
  Lu.init(e, t), R.init(e, t);
});
function em(e) {
  return vr(Jn, e);
}
var qn = m("ZodIPv4", (e, t) => {
  Ku.init(e, t), R.init(e, t);
});
function tm(e) {
  return $r(qn, e);
}
var Rr = m("ZodMAC", (e, t) => {
  Gu.init(e, t), R.init(e, t);
});
function nm(e) {
  return Yl(Rr, e);
}
var Wn = m("ZodIPv6", (e, t) => {
  Vu.init(e, t), R.init(e, t);
});
function im(e) {
  return _r(Wn, e);
}
var Kn = m("ZodCIDRv4", (e, t) => {
  Bu.init(e, t), R.init(e, t);
});
function rm(e) {
  return br(Kn, e);
}
var Vn = m("ZodCIDRv6", (e, t) => {
  Hu.init(e, t), R.init(e, t);
});
function om(e) {
  return yr(Vn, e);
}
var Gn = m("ZodBase64", (e, t) => {
  Xu.init(e, t), R.init(e, t);
});
function am(e) {
  return kr(Gn, e);
}
var Bn = m("ZodBase64URL", (e, t) => {
  Qu.init(e, t), R.init(e, t);
});
function sm(e) {
  return Ir(Bn, e);
}
var Hn = m("ZodE164", (e, t) => {
  el.init(e, t), R.init(e, t);
});
function um(e) {
  return wr(Hn, e);
}
var Xn = m("ZodJWT", (e, t) => {
  nl.init(e, t), R.init(e, t);
});
function lm(e) {
  return Sr(Xn, e);
}
var Ye = m("ZodCustomStringFormat", (e, t) => {
  il.init(e, t), R.init(e, t);
});
function cm(e, t, i = {}) {
  return Zt(Ye, e, t, i);
}
function dm(e) {
  return Zt(Ye, "hostname", Re.hostname, e);
}
function mm(e) {
  return Zt(Ye, "hex", Re.hex, e);
}
function pm(e, t) {
  let i = t?.enc ?? "hex", o = `${e}_${i}`, n = Re[o];
  if (!n) throw Error(`Unrecognized hash format: ${o}`);
  return Zt(Ye, o, n, t);
}
var Nt = m("ZodNumber", (e, t) => {
  Yi.init(e, t), U.init(e, t), e._zod.processJSONSchema = (o, n, r) => Rc(e, o, n), e.gt = (o, n) => e.check(xe(o, n)), e.gte = (o, n) => e.check(ie(o, n)), e.min = (o, n) => e.check(ie(o, n)), e.lt = (o, n) => e.check(Se(o, n)), e.lte = (o, n) => e.check(de(o, n)), e.max = (o, n) => e.check(de(o, n)), e.int = (o) => e.check(un(o)), e.safe = (o) => e.check(un(o)), e.positive = (o) => e.check(xe(0, o)), e.nonnegative = (o) => e.check(ie(0, o)), e.negative = (o) => e.check(Se(0, o)), e.nonpositive = (o) => e.check(de(0, o)), e.multipleOf = (o, n) => e.check(We(o, n)), e.step = (o, n) => e.check(We(o, n)), e.finite = () => e;
  let i = e._zod.bag;
  e.minValue = Math.max(i.minimum ?? Number.NEGATIVE_INFINITY, i.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(i.maximum ?? Number.POSITIVE_INFINITY, i.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (i.format ?? "").includes("int") || Number.isSafeInteger(i.multipleOf ?? 0.5), e.isFinite = !0, e.format = i.format ?? null;
});
function Cr(e) {
  return rc(Nt, e);
}
var Ce = m("ZodNumberFormat", (e, t) => {
  rl.init(e, t), Nt.init(e, t);
});
function un(e) {
  return ac(Ce, e);
}
function fm(e) {
  return sc(Ce, e);
}
function gm(e) {
  return uc(Ce, e);
}
function hm(e) {
  return lc(Ce, e);
}
function vm(e) {
  return cc(Ce, e);
}
var Dt = m("ZodBoolean", (e, t) => {
  Qi.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => Cc(e, i, o);
});
function Mr(e) {
  return dc(Dt, e);
}
var jt = m("ZodBigInt", (e, t) => {
  er.init(e, t), U.init(e, t), e._zod.processJSONSchema = (o, n, r) => Mc(e, o), e.gte = (o, n) => e.check(ie(o, n)), e.min = (o, n) => e.check(ie(o, n)), e.gt = (o, n) => e.check(xe(o, n)), e.gte = (o, n) => e.check(ie(o, n)), e.min = (o, n) => e.check(ie(o, n)), e.lt = (o, n) => e.check(Se(o, n)), e.lte = (o, n) => e.check(de(o, n)), e.max = (o, n) => e.check(de(o, n)), e.positive = (o) => e.check(xe(BigInt(0), o)), e.negative = (o) => e.check(Se(BigInt(0), o)), e.nonpositive = (o) => e.check(de(BigInt(0), o)), e.nonnegative = (o) => e.check(ie(BigInt(0), o)), e.multipleOf = (o, n) => e.check(We(o, n));
  let i = e._zod.bag;
  e.minValue = i.minimum ?? null, e.maxValue = i.maximum ?? null, e.format = i.format ?? null;
});
function $m(e) {
  return pc(jt, e);
}
var Yn = m("ZodBigIntFormat", (e, t) => {
  ol.init(e, t), jt.init(e, t);
});
function _m(e) {
  return gc(Yn, e);
}
function bm(e) {
  return hc(Yn, e);
}
var Lr = m("ZodSymbol", (e, t) => {
  al.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => Lc(e, i);
});
function ym(e) {
  return vc(Lr, e);
}
var Fr = m("ZodUndefined", (e, t) => {
  sl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => Jc(e, i);
});
function km(e) {
  return $c(Fr, e);
}
var Jr = m("ZodNull", (e, t) => {
  ul.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => Fc(e, i, o);
});
function qr(e) {
  return _c(Jr, e);
}
var Wr = m("ZodAny", (e, t) => {
  ll.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => Kc();
});
function Im() {
  return bc(Wr);
}
var Kr = m("ZodUnknown", (e, t) => {
  cl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => Vc();
});
function je() {
  return yc(Kr);
}
var Vr = m("ZodNever", (e, t) => {
  dl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => Wc(e, i, o);
});
function Qn(e) {
  return kc(Vr, e);
}
var Gr = m("ZodVoid", (e, t) => {
  ml.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => qc(e, i);
});
function wm(e) {
  return Ic(Gr, e);
}
var ei = m("ZodDate", (e, t) => {
  pl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (o, n, r) => Gc(e, o), e.min = (o, n) => e.check(ie(o, n)), e.max = (o, n) => e.check(de(o, n));
  let i = e._zod.bag;
  e.minDate = i.minimum ? new Date(i.minimum) : null, e.maxDate = i.maximum ? new Date(i.maximum) : null;
});
function Sm(e) {
  return wc(ei, e);
}
var Br = m("ZodArray", (e, t) => {
  fl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => ad(e, i, o, n), e.element = t.element, e.min = (i, o) => e.check(De(i, o)), e.nonempty = (i) => e.check(De(1, i)), e.max = (i, o) => e.check(Ut(i, o)), e.length = (i, o) => e.check(Ot(i, o)), e.unwrap = () => e.element;
});
function Tt(e, t) {
  return zc(Br, e, t);
}
function xm(e) {
  let t = e._zod.def.shape;
  return ni(Object.keys(t));
}
var At = m("ZodObject", (e, t) => {
  $l.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => sd(e, i, o, n), P.defineLazy(e, "shape", () => t.shape), e.keyof = () => ni(Object.keys(e._zod.def.shape)), e.catchall = (i) => e.clone({ ...e._zod.def, catchall: i }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: je() }), e.loose = () => e.clone({ ...e._zod.def, catchall: je() }), e.strict = () => e.clone({ ...e._zod.def, catchall: Qn() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (i) => P.extend(e, i), e.safeExtend = (i) => P.safeExtend(e, i), e.merge = (i) => P.merge(e, i), e.pick = (i) => P.pick(e, i), e.omit = (i) => P.omit(e, i), e.partial = (...i) => P.partial(ri, e, i[0]), e.required = (...i) => P.required(oi, e, i[0]);
});
function zm(e, t) {
  let i = { type: "object", shape: e ?? {}, ...P.normalizeParams(t) };
  return new At(i);
}
function Um(e, t) {
  return new At({ type: "object", shape: e, catchall: Qn(), ...P.normalizeParams(t) });
}
function Om(e, t) {
  return new At({ type: "object", shape: e, catchall: je(), ...P.normalizeParams(t) });
}
var Rt = m("ZodUnion", (e, t) => {
  yn.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => Pr(e, i, o, n), e.options = t.options;
});
function ti(e, t) {
  return new Rt({ type: "union", options: e, ...P.normalizeParams(t) });
}
var Hr = m("ZodXor", (e, t) => {
  Rt.init(e, t), _l.init(e, t), e._zod.processJSONSchema = (i, o, n) => Pr(e, i, o, n), e.options = t.options;
});
function Zm(e, t) {
  return new Hr({ type: "union", options: e, inclusive: !1, ...P.normalizeParams(t) });
}
var Xr = m("ZodDiscriminatedUnion", (e, t) => {
  Rt.init(e, t), bl.init(e, t);
});
function Pm(e, t, i) {
  return new Xr({ type: "union", options: t, discriminator: e, ...P.normalizeParams(i) });
}
var Yr = m("ZodIntersection", (e, t) => {
  yl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => ud(e, i, o, n);
});
function Qr(e, t) {
  return new Yr({ type: "intersection", left: e, right: t });
}
var eo = m("ZodTuple", (e, t) => {
  tr.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => ld(e, i, o, n), e.rest = (i) => e.clone({ ...e._zod.def, rest: i });
});
function to(e, t, i) {
  let o = t instanceof z, n = o ? i : t;
  return new eo({ type: "tuple", items: e, rest: o ? t : null, ...P.normalizeParams(n) });
}
var Ct = m("ZodRecord", (e, t) => {
  kl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => cd(e, i, o, n), e.keyType = t.keyType, e.valueType = t.valueType;
});
function no(e, t, i) {
  return new Ct({ type: "record", keyType: e, valueType: t, ...P.normalizeParams(i) });
}
function Em(e, t, i) {
  let o = ge(e);
  return o._zod.values = void 0, new Ct({ type: "record", keyType: o, valueType: t, ...P.normalizeParams(i) });
}
function Nm(e, t, i) {
  return new Ct({ type: "record", keyType: e, valueType: t, mode: "loose", ...P.normalizeParams(i) });
}
var io = m("ZodMap", (e, t) => {
  Il.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => rd(e, i), e.keyType = t.keyType, e.valueType = t.valueType, e.min = (...i) => e.check(ze(...i)), e.nonempty = (i) => e.check(ze(1, i)), e.max = (...i) => e.check(Xe(...i)), e.size = (...i) => e.check(zt(...i));
});
function Dm(e, t, i) {
  return new io({ type: "map", keyType: e, valueType: t, ...P.normalizeParams(i) });
}
var ro = m("ZodSet", (e, t) => {
  wl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => od(e, i), e.min = (...i) => e.check(ze(...i)), e.nonempty = (i) => e.check(ze(1, i)), e.max = (...i) => e.check(Xe(...i)), e.size = (...i) => e.check(zt(...i));
});
function jm(e, t) {
  return new ro({ type: "set", valueType: e, ...P.normalizeParams(t) });
}
var Be = m("ZodEnum", (e, t) => {
  Sl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (o, n, r) => Bc(e, o, n), e.enum = t.entries, e.options = Object.values(t.entries);
  let i = new Set(Object.keys(t.entries));
  e.extract = (o, n) => {
    let r = {};
    for (let a of o) if (i.has(a)) r[a] = t.entries[a];
    else throw Error(`Key ${a} not found in enum`);
    return new Be({ ...t, checks: [], ...P.normalizeParams(n), entries: r });
  }, e.exclude = (o, n) => {
    let r = { ...t.entries };
    for (let a of o) if (i.has(a)) delete r[a];
    else throw Error(`Key ${a} not found in enum`);
    return new Be({ ...t, checks: [], ...P.normalizeParams(n), entries: r });
  };
});
function ni(e, t) {
  let i = Array.isArray(e) ? Object.fromEntries(e.map((o) => [o, o])) : e;
  return new Be({ type: "enum", entries: i, ...P.normalizeParams(t) });
}
function Tm(e, t) {
  return new Be({ type: "enum", entries: e, ...P.normalizeParams(t) });
}
var oo = m("ZodLiteral", (e, t) => {
  xl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => Hc(e, i, o), e.values = new Set(t.values), Object.defineProperty(e, "value", { get() {
    if (t.values.length > 1) throw Error("This schema contains multiple valid literal values. Use `.values` instead.");
    return t.values[0];
  } });
});
function Am(e, t) {
  return new oo({ type: "literal", values: Array.isArray(e) ? e : [e], ...P.normalizeParams(t) });
}
var ao = m("ZodFile", (e, t) => {
  zl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => Qc(e, i, o), e.min = (i, o) => e.check(ze(i, o)), e.max = (i, o) => e.check(Xe(i, o)), e.mime = (i, o) => e.check(On(Array.isArray(i) ? i : [i], o));
});
function Rm(e) {
  return Uc(ao, e);
}
var so = m("ZodTransform", (e, t) => {
  Ul.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => id(e, i), e._zod.parse = (i, o) => {
    if (o.direction === "backward") throw new vn(e.constructor.name);
    i.addIssue = (r) => {
      if (typeof r == "string") i.issues.push(P.issue(r, i.value, t));
      else {
        let a = r;
        a.fatal && (a.continue = !1), a.code ?? (a.code = "custom"), a.input ?? (a.input = i.value), a.inst ?? (a.inst = e), i.issues.push(P.issue(a));
      }
    };
    let n = t.transform(i.value, i);
    return n instanceof Promise ? n.then((r) => (i.value = r, i)) : (i.value = n, i);
  };
});
function ii(e) {
  return new so({ type: "transform", transform: e });
}
var ri = m("ZodOptional", (e, t) => {
  nr.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => Er(e, i, o, n), e.unwrap = () => e._zod.def.innerType;
});
function st(e) {
  return new ri({ type: "optional", innerType: e });
}
var uo = m("ZodExactOptional", (e, t) => {
  Ol.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => Er(e, i, o, n), e.unwrap = () => e._zod.def.innerType;
});
function lo(e) {
  return new uo({ type: "optional", innerType: e });
}
var co = m("ZodNullable", (e, t) => {
  Zl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => dd(e, i, o, n), e.unwrap = () => e._zod.def.innerType;
});
function ut(e) {
  return new co({ type: "nullable", innerType: e });
}
function Cm(e) {
  return st(ut(e));
}
var mo = m("ZodDefault", (e, t) => {
  Pl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => pd(e, i, o, n), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function po(e, t) {
  return new mo({ type: "default", innerType: e, get defaultValue() {
    return typeof t == "function" ? t() : P.shallowClone(t);
  } });
}
var fo = m("ZodPrefault", (e, t) => {
  El.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => fd(e, i, o, n), e.unwrap = () => e._zod.def.innerType;
});
function go(e, t) {
  return new fo({ type: "prefault", innerType: e, get defaultValue() {
    return typeof t == "function" ? t() : P.shallowClone(t);
  } });
}
var oi = m("ZodNonOptional", (e, t) => {
  Nl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => md(e, i, o, n), e.unwrap = () => e._zod.def.innerType;
});
function ho(e, t) {
  return new oi({ type: "nonoptional", innerType: e, ...P.normalizeParams(t) });
}
var vo = m("ZodSuccess", (e, t) => {
  Dl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => ed(e, i, o), e.unwrap = () => e._zod.def.innerType;
});
function Mm(e) {
  return new vo({ type: "success", innerType: e });
}
var $o = m("ZodCatch", (e, t) => {
  jl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => gd(e, i, o, n), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function _o(e, t) {
  return new $o({ type: "catch", innerType: e, catchValue: typeof t == "function" ? t : () => t });
}
var bo = m("ZodNaN", (e, t) => {
  Tl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => Xc(e, i);
});
function Lm(e) {
  return xc(bo, e);
}
var ai = m("ZodPipe", (e, t) => {
  Al.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => hd(e, i, o, n), e.in = t.in, e.out = t.out;
});
function lt(e, t) {
  return new ai({ type: "pipe", in: e, out: t });
}
var si = m("ZodCodec", (e, t) => {
  ai.init(e, t), ir.init(e, t);
});
function Fm(e, t, i) {
  return new si({ type: "pipe", in: e, out: t, transform: i.decode, reverseTransform: i.encode });
}
var yo = m("ZodReadonly", (e, t) => {
  Rl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => vd(e, i, o, n), e.unwrap = () => e._zod.def.innerType;
});
function ko(e) {
  return new yo({ type: "readonly", innerType: e });
}
var Io = m("ZodTemplateLiteral", (e, t) => {
  Cl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => Yc(e, i, o);
});
function Jm(e, t) {
  return new Io({ type: "template_literal", parts: e, ...P.normalizeParams(t) });
}
var wo = m("ZodLazy", (e, t) => {
  Fl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => _d(e, i, o, n), e.unwrap = () => e._zod.def.getter();
});
function So(e) {
  return new wo({ type: "lazy", getter: e });
}
var xo = m("ZodPromise", (e, t) => {
  Ll.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => $d(e, i, o, n), e.unwrap = () => e._zod.def.innerType;
});
function qm(e) {
  return new xo({ type: "promise", innerType: e });
}
var zo = m("ZodFunction", (e, t) => {
  Ml.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => nd(e, i);
});
function ln(e) {
  return new zo({ type: "function", input: Array.isArray(e?.input) ? to(e?.input) : e?.input ?? Tt(je()), output: e?.output ?? je() });
}
var Mt = m("ZodCustom", (e, t) => {
  Jl.init(e, t), U.init(e, t), e._zod.processJSONSchema = (i, o, n) => td(e, i);
});
function Wm(e) {
  let t = new J({ check: "custom" });
  return t._zod.check = e, t;
}
function Km(e, t) {
  return Oc(Mt, e ?? (() => !0), t);
}
function Uo(e, t = {}) {
  return Zc(Mt, e, t);
}
function Oo(e) {
  return Pc(e);
}
var Vm = Nc, Gm = Dc;
function Bm(e, t = {}) {
  let i = new Mt({ type: "custom", check: "custom", fn: (o) => o instanceof e, abort: !0, ...P.normalizeParams(t) });
  return i._zod.bag.Class = e, i._zod.check = (o) => {
    o.value instanceof e || o.issues.push({ code: "invalid_type", expected: e.name, input: o.value, inst: i, path: [...i._zod.def.path ?? []] });
  }, i;
}
var Hm = (...e) => jc({ Codec: si, Boolean: Dt, String: Pt }, ...e);
function Xm(e) {
  let t = So(() => ti([sn(e), Cr(), Mr(), qr(), Tt(t), no(sn(), t)]));
  return t;
}
function Ym(e, t) {
  return lt(ii(e), t);
}
var lk = { invalid_type: "invalid_type", too_big: "too_big", too_small: "too_small", invalid_format: "invalid_format", not_multiple_of: "not_multiple_of", unrecognized_keys: "unrecognized_keys", invalid_union: "invalid_union", invalid_key: "invalid_key", invalid_element: "invalid_element", invalid_value: "invalid_value", custom: "custom" };
function ck(e) {
  te({ customError: e });
}
function dk() {
  return te().customError;
}
var _i;
_i || (_i = {});
var b = { ...yd, ...kd, iso: Nr }, mk = /* @__PURE__ */ new Set(["$schema", "$ref", "$defs", "definitions", "$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor", "type", "enum", "const", "anyOf", "oneOf", "allOf", "not", "properties", "required", "additionalProperties", "patternProperties", "propertyNames", "minProperties", "maxProperties", "items", "prefixItems", "additionalItems", "minItems", "maxItems", "uniqueItems", "contains", "minContains", "maxContains", "minLength", "maxLength", "pattern", "format", "minimum", "maximum", "exclusiveMinimum", "exclusiveMaximum", "multipleOf", "description", "default", "contentEncoding", "contentMediaType", "contentSchema", "unevaluatedItems", "unevaluatedProperties", "if", "then", "else", "dependentSchemas", "dependentRequired", "nullable", "readOnly"]);
function pk(e, t) {
  let i = e.$schema;
  return i === "https://json-schema.org/draft/2020-12/schema" ? "draft-2020-12" : i === "http://json-schema.org/draft-07/schema#" ? "draft-7" : i === "http://json-schema.org/draft-04/schema#" ? "draft-4" : t ?? "draft-2020-12";
}
function fk(e, t) {
  if (!e.startsWith("#")) throw Error("External $ref is not supported, only local refs (#/...) are allowed");
  let i = e.slice(1).split("/").filter(Boolean);
  if (i.length === 0) return t.rootSchema;
  let o = t.version === "draft-2020-12" ? "$defs" : "definitions";
  if (i[0] === o) {
    let n = i[1];
    if (!n || !t.defs[n]) throw Error(`Reference not found: ${e}`);
    return t.defs[n];
  }
  throw Error(`Reference not found: ${e}`);
}
function Qm(e, t) {
  if (e.not !== void 0) {
    if (typeof e.not == "object" && Object.keys(e.not).length === 0) return b.never();
    throw Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (e.unevaluatedItems !== void 0) throw Error("unevaluatedItems is not supported");
  if (e.unevaluatedProperties !== void 0) throw Error("unevaluatedProperties is not supported");
  if (e.if !== void 0 || e.then !== void 0 || e.else !== void 0) throw Error("Conditional schemas (if/then/else) are not supported");
  if (e.dependentSchemas !== void 0 || e.dependentRequired !== void 0) throw Error("dependentSchemas and dependentRequired are not supported");
  if (e.$ref) {
    let n = e.$ref;
    if (t.refs.has(n)) return t.refs.get(n);
    if (t.processing.has(n)) return b.lazy(() => {
      if (!t.refs.has(n)) throw Error(`Circular reference not resolved: ${n}`);
      return t.refs.get(n);
    });
    t.processing.add(n);
    let r = fk(n, t), a = ee(r, t);
    return t.refs.set(n, a), t.processing.delete(n), a;
  }
  if (e.enum !== void 0) {
    let n = e.enum;
    if (t.version === "openapi-3.0" && e.nullable === !0 && n.length === 1 && n[0] === null) return b.null();
    if (n.length === 0) return b.never();
    if (n.length === 1) return b.literal(n[0]);
    if (n.every((a) => typeof a == "string")) return b.enum(n);
    let r = n.map((a) => b.literal(a));
    return r.length < 2 ? r[0] : b.union([r[0], r[1], ...r.slice(2)]);
  }
  if (e.const !== void 0) return b.literal(e.const);
  let i = e.type;
  if (Array.isArray(i)) {
    let n = i.map((r) => {
      let a = { ...e, type: r };
      return Qm(a, t);
    });
    return n.length === 0 ? b.never() : n.length === 1 ? n[0] : b.union(n);
  }
  if (!i) return b.any();
  let o;
  switch (i) {
    case "string": {
      let n = b.string();
      if (e.format) {
        let r = e.format;
        r === "email" ? n = n.check(b.email()) : r === "uri" || r === "uri-reference" ? n = n.check(b.url()) : r === "uuid" || r === "guid" ? n = n.check(b.uuid()) : r === "date-time" ? n = n.check(b.iso.datetime()) : r === "date" ? n = n.check(b.iso.date()) : r === "time" ? n = n.check(b.iso.time()) : r === "duration" ? n = n.check(b.iso.duration()) : r === "ipv4" ? n = n.check(b.ipv4()) : r === "ipv6" ? n = n.check(b.ipv6()) : r === "mac" ? n = n.check(b.mac()) : r === "cidr" ? n = n.check(b.cidrv4()) : r === "cidr-v6" ? n = n.check(b.cidrv6()) : r === "base64" ? n = n.check(b.base64()) : r === "base64url" ? n = n.check(b.base64url()) : r === "e164" ? n = n.check(b.e164()) : r === "jwt" ? n = n.check(b.jwt()) : r === "emoji" ? n = n.check(b.emoji()) : r === "nanoid" ? n = n.check(b.nanoid()) : r === "cuid" ? n = n.check(b.cuid()) : r === "cuid2" ? n = n.check(b.cuid2()) : r === "ulid" ? n = n.check(b.ulid()) : r === "xid" ? n = n.check(b.xid()) : r === "ksuid" && (n = n.check(b.ksuid()));
      }
      typeof e.minLength == "number" && (n = n.min(e.minLength)), typeof e.maxLength == "number" && (n = n.max(e.maxLength)), e.pattern && (n = n.regex(new RegExp(e.pattern))), o = n;
      break;
    }
    case "number":
    case "integer": {
      let n = i === "integer" ? b.number().int() : b.number();
      typeof e.minimum == "number" && (n = n.min(e.minimum)), typeof e.maximum == "number" && (n = n.max(e.maximum)), typeof e.exclusiveMinimum == "number" ? n = n.gt(e.exclusiveMinimum) : e.exclusiveMinimum === !0 && typeof e.minimum == "number" && (n = n.gt(e.minimum)), typeof e.exclusiveMaximum == "number" ? n = n.lt(e.exclusiveMaximum) : e.exclusiveMaximum === !0 && typeof e.maximum == "number" && (n = n.lt(e.maximum)), typeof e.multipleOf == "number" && (n = n.multipleOf(e.multipleOf)), o = n;
      break;
    }
    case "boolean": {
      o = b.boolean();
      break;
    }
    case "null": {
      o = b.null();
      break;
    }
    case "object": {
      let n = {}, r = e.properties || {}, a = new Set(e.required || []);
      for (let [u, l] of Object.entries(r)) {
        let d = ee(l, t);
        n[u] = a.has(u) ? d : d.optional();
      }
      if (e.propertyNames) {
        let u = ee(e.propertyNames, t), l = e.additionalProperties && typeof e.additionalProperties == "object" ? ee(e.additionalProperties, t) : b.any();
        if (Object.keys(n).length === 0) {
          o = b.record(u, l);
          break;
        }
        let d = b.object(n).passthrough(), p = b.looseRecord(u, l);
        o = b.intersection(d, p);
        break;
      }
      if (e.patternProperties) {
        let u = e.patternProperties, l = Object.keys(u), d = [];
        for (let g of l) {
          let _ = ee(u[g], t), x = b.string().regex(new RegExp(g));
          d.push(b.looseRecord(x, _));
        }
        let p = [];
        if (Object.keys(n).length > 0 && p.push(b.object(n).passthrough()), p.push(...d), p.length === 0) o = b.object({}).passthrough();
        else if (p.length === 1) o = p[0];
        else {
          let g = b.intersection(p[0], p[1]);
          for (let _ = 2; _ < p.length; _++) g = b.intersection(g, p[_]);
          o = g;
        }
        break;
      }
      let s = b.object(n);
      e.additionalProperties === !1 ? o = s.strict() : typeof e.additionalProperties == "object" ? o = s.catchall(ee(e.additionalProperties, t)) : o = s.passthrough();
      break;
    }
    case "array": {
      let { prefixItems: n, items: r } = e;
      if (n && Array.isArray(n)) {
        let a = n.map((u) => ee(u, t)), s = r && typeof r == "object" && !Array.isArray(r) ? ee(r, t) : void 0;
        s ? o = b.tuple(a).rest(s) : o = b.tuple(a), typeof e.minItems == "number" && (o = o.check(b.minLength(e.minItems))), typeof e.maxItems == "number" && (o = o.check(b.maxLength(e.maxItems)));
      } else if (Array.isArray(r)) {
        let a = r.map((u) => ee(u, t)), s = e.additionalItems && typeof e.additionalItems == "object" ? ee(e.additionalItems, t) : void 0;
        s ? o = b.tuple(a).rest(s) : o = b.tuple(a), typeof e.minItems == "number" && (o = o.check(b.minLength(e.minItems))), typeof e.maxItems == "number" && (o = o.check(b.maxLength(e.maxItems)));
      } else if (r !== void 0) {
        let a = ee(r, t), s = b.array(a);
        typeof e.minItems == "number" && (s = s.min(e.minItems)), typeof e.maxItems == "number" && (s = s.max(e.maxItems)), o = s;
      } else o = b.array(b.any());
      break;
    }
    default:
      throw Error(`Unsupported type: ${i}`);
  }
  return e.description && (o = o.describe(e.description)), e.default !== void 0 && (o = o.default(e.default)), o;
}
function ee(e, t) {
  if (typeof e == "boolean") return e ? b.any() : b.never();
  let i = Qm(e, t), o = e.type || e.enum !== void 0 || e.const !== void 0;
  if (e.anyOf && Array.isArray(e.anyOf)) {
    let s = e.anyOf.map((l) => ee(l, t)), u = b.union(s);
    i = o ? b.intersection(i, u) : u;
  }
  if (e.oneOf && Array.isArray(e.oneOf)) {
    let s = e.oneOf.map((l) => ee(l, t)), u = b.xor(s);
    i = o ? b.intersection(i, u) : u;
  }
  if (e.allOf && Array.isArray(e.allOf)) if (e.allOf.length === 0) i = o ? i : b.any();
  else {
    let s = o ? i : ee(e.allOf[0], t), u = o ? 0 : 1;
    for (let l = u; l < e.allOf.length; l++) s = b.intersection(s, ee(e.allOf[l], t));
    i = s;
  }
  e.nullable === !0 && t.version === "openapi-3.0" && (i = b.nullable(i)), e.readOnly === !0 && (i = b.readonly(i));
  let n = {}, r = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (let s of r) s in e && (n[s] = e[s]);
  let a = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (let s of a) s in e && (n[s] = e[s]);
  for (let s of Object.keys(e)) mk.has(s) || (n[s] = e[s]);
  return Object.keys(n).length > 0 && t.registry.add(i, n), i;
}
function gk(e, t) {
  if (typeof e == "boolean") return e ? b.any() : b.never();
  let i = pk(e, t?.defaultTarget), o = e.$defs || e.definitions || {}, n = { version: i, defs: o, refs: /* @__PURE__ */ new Map(), processing: /* @__PURE__ */ new Set(), rootSchema: e, registry: t?.registry ?? ce };
  return ee(e, n);
}
var ep = {};
be(ep, { string: () => hk, number: () => vk, date: () => bk, boolean: () => $k, bigint: () => _k });
function hk(e) {
  return Xl(Pt, e);
}
function vk(e) {
  return oc(Nt, e);
}
function $k(e) {
  return mc(Dt, e);
}
function _k(e) {
  return fc(jt, e);
}
function bk(e) {
  return Sc(ei, e);
}
te(ql());
var yk = c.union([c.literal("light"), c.literal("dark")]).describe("Color theme preference for the host environment."), Zo = c.union([c.literal("inline"), c.literal("fullscreen"), c.literal("pip")]).describe("Display mode for UI presentation."), kk = c.union([c.literal("--color-background-primary"), c.literal("--color-background-secondary"), c.literal("--color-background-tertiary"), c.literal("--color-background-inverse"), c.literal("--color-background-ghost"), c.literal("--color-background-info"), c.literal("--color-background-danger"), c.literal("--color-background-success"), c.literal("--color-background-warning"), c.literal("--color-background-disabled"), c.literal("--color-text-primary"), c.literal("--color-text-secondary"), c.literal("--color-text-tertiary"), c.literal("--color-text-inverse"), c.literal("--color-text-ghost"), c.literal("--color-text-info"), c.literal("--color-text-danger"), c.literal("--color-text-success"), c.literal("--color-text-warning"), c.literal("--color-text-disabled"), c.literal("--color-text-ghost"), c.literal("--color-border-primary"), c.literal("--color-border-secondary"), c.literal("--color-border-tertiary"), c.literal("--color-border-inverse"), c.literal("--color-border-ghost"), c.literal("--color-border-info"), c.literal("--color-border-danger"), c.literal("--color-border-success"), c.literal("--color-border-warning"), c.literal("--color-border-disabled"), c.literal("--color-ring-primary"), c.literal("--color-ring-secondary"), c.literal("--color-ring-inverse"), c.literal("--color-ring-info"), c.literal("--color-ring-danger"), c.literal("--color-ring-success"), c.literal("--color-ring-warning"), c.literal("--font-sans"), c.literal("--font-mono"), c.literal("--font-weight-normal"), c.literal("--font-weight-medium"), c.literal("--font-weight-semibold"), c.literal("--font-weight-bold"), c.literal("--font-text-xs-size"), c.literal("--font-text-sm-size"), c.literal("--font-text-md-size"), c.literal("--font-text-lg-size"), c.literal("--font-heading-xs-size"), c.literal("--font-heading-sm-size"), c.literal("--font-heading-md-size"), c.literal("--font-heading-lg-size"), c.literal("--font-heading-xl-size"), c.literal("--font-heading-2xl-size"), c.literal("--font-heading-3xl-size"), c.literal("--font-text-xs-line-height"), c.literal("--font-text-sm-line-height"), c.literal("--font-text-md-line-height"), c.literal("--font-text-lg-line-height"), c.literal("--font-heading-xs-line-height"), c.literal("--font-heading-sm-line-height"), c.literal("--font-heading-md-line-height"), c.literal("--font-heading-lg-line-height"), c.literal("--font-heading-xl-line-height"), c.literal("--font-heading-2xl-line-height"), c.literal("--font-heading-3xl-line-height"), c.literal("--border-radius-xs"), c.literal("--border-radius-sm"), c.literal("--border-radius-md"), c.literal("--border-radius-lg"), c.literal("--border-radius-xl"), c.literal("--border-radius-full"), c.literal("--border-width-regular"), c.literal("--shadow-hairline"), c.literal("--shadow-sm"), c.literal("--shadow-md"), c.literal("--shadow-lg")]).describe("CSS variable keys available to MCP apps for theming."), Ik = c.record(kk.describe(`Style variables for theming MCP apps.

Individual style keys are optional - hosts may provide any subset of these values.
Values are strings containing CSS values (colors, sizes, font stacks, etc.).

Note: This type uses \`Record<K, string | undefined>\` rather than \`Partial<Record<K, string>>\`
for compatibility with Zod schema generation. Both are functionally equivalent for validation.`), c.union([c.string(), c.undefined()]).describe(`Style variables for theming MCP apps.

Individual style keys are optional - hosts may provide any subset of these values.
Values are strings containing CSS values (colors, sizes, font stacks, etc.).

Note: This type uses \`Record<K, string | undefined>\` rather than \`Partial<Record<K, string>>\`
for compatibility with Zod schema generation. Both are functionally equivalent for validation.`)).describe(`Style variables for theming MCP apps.

Individual style keys are optional - hosts may provide any subset of these values.
Values are strings containing CSS values (colors, sizes, font stacks, etc.).

Note: This type uses \`Record<K, string | undefined>\` rather than \`Partial<Record<K, string>>\`
for compatibility with Zod schema generation. Both are functionally equivalent for validation.`);
c.object({ method: c.literal("ui/open-link"), params: c.object({ url: c.string().describe("URL to open in the host's browser") }) });
c.object({ isError: c.boolean().optional().describe("True if the host failed to open the URL (e.g., due to security policy).") }).passthrough();
c.object({ isError: c.boolean().optional().describe("True if the host rejected or failed to deliver the message.") }).passthrough();
c.object({ method: c.literal("ui/notifications/sandbox-proxy-ready"), params: c.object({}) });
c.object({ method: c.literal("ui/notifications/sandbox-resource-ready"), params: c.object({ html: c.string().describe("HTML content to load into the inner iframe."), sandbox: c.string().optional().describe("Optional override for the inner iframe's sandbox attribute."), csp: c.object({ connectDomains: c.array(c.string()).optional().describe("Origins for network requests (fetch/XHR/WebSocket)."), resourceDomains: c.array(c.string()).optional().describe("Origins for static resources (scripts, images, styles, fonts).") }).optional().describe("CSP configuration from resource metadata.") }) });
c.object({ method: c.literal("ui/notifications/size-changed"), params: c.object({ width: c.number().optional().describe("New width in pixels."), height: c.number().optional().describe("New height in pixels.") }) });
c.object({ method: c.literal("ui/notifications/tool-input"), params: c.object({ arguments: c.record(c.string(), c.unknown().describe("Complete tool call arguments as key-value pairs.")).optional().describe("Complete tool call arguments as key-value pairs.") }) });
c.object({ method: c.literal("ui/notifications/tool-input-partial"), params: c.object({ arguments: c.record(c.string(), c.unknown().describe("Partial tool call arguments (incomplete, may change).")).optional().describe("Partial tool call arguments (incomplete, may change).") }) });
c.object({ method: c.literal("ui/notifications/tool-cancelled"), params: c.object({ reason: c.string().optional().describe('Optional reason for the cancellation (e.g., "user action", "timeout").') }) });
var wk = c.object({ fonts: c.string().optional().describe("CSS for font loading (@font-face rules or") }), Sk = c.object({ variables: Ik.optional().describe("CSS variables for theming the app."), css: wk.optional().describe("CSS blocks that apps can inject.") });
c.object({ method: c.literal("ui/resource-teardown"), params: c.object({}) });
c.record(c.string(), c.unknown());
var xk = c.object({ experimental: c.object({}).optional().describe("Experimental features (structure TBD)."), openLinks: c.object({}).optional().describe("Host supports opening external URLs."), serverTools: c.object({ listChanged: c.boolean().optional().describe("Host supports tools/list_changed notifications.") }).optional().describe("Host can proxy tool calls to the MCP server."), serverResources: c.object({ listChanged: c.boolean().optional().describe("Host supports resources/list_changed notifications.") }).optional().describe("Host can proxy resource reads to the MCP server."), logging: c.object({}).optional().describe("Host accepts log messages.") }), zk = c.object({ experimental: c.object({}).optional().describe("Experimental features (structure TBD)."), tools: c.object({ listChanged: c.boolean().optional().describe("App supports tools/list_changed notifications.") }).optional().describe("App exposes MCP-style tools that the host can call.") });
c.object({ method: c.literal("ui/notifications/initialized"), params: c.object({}).optional() });
var Uk = c.object({ connectDomains: c.array(c.string()).optional().describe("Origins for network requests (fetch/XHR/WebSocket)."), resourceDomains: c.array(c.string()).optional().describe("Origins for static resources (scripts, images, styles, fonts).") });
c.object({ csp: Uk.optional().describe("Content Security Policy configuration."), domain: c.string().optional().describe("Dedicated origin for widget sandbox."), prefersBorder: c.boolean().optional().describe("Visual boundary preference - true if UI prefers a visible border.") });
c.object({ method: c.literal("ui/request-display-mode"), params: c.object({ mode: Zo.describe("The display mode being requested.") }) });
c.object({ mode: Zo.describe("The display mode that was actually set. May differ from requested if not supported.") }).passthrough();
var Ok = c.union([c.literal("model"), c.literal("app")]).describe("Tool visibility scope - who can access the tool.");
c.object({ resourceUri: c.string().optional(), visibility: c.array(Ok).optional().describe(`Who can access this tool. Default: ["model", "app"]
- "model": Tool visible to and callable by the agent
- "app": Tool callable by the app from this server only`) });
c.object({ method: c.literal("ui/message"), params: c.object({ role: c.literal("user").describe('Message role, currently only "user" is supported.'), content: c.array(hn).describe("Message content blocks (text, image, etc.).") }) });
c.object({ method: c.literal("ui/notifications/tool-result"), params: Ni.describe("Standard MCP tool execution result.") });
var tp = c.object({ toolInfo: c.object({ id: mt.optional().describe("JSON-RPC id of the tools/call request."), tool: Ei.describe("Tool definition including name, inputSchema, etc.") }).optional().describe("Metadata of the tool call that instantiated this App."), theme: yk.optional().describe("Current color theme preference."), styles: Sk.optional().describe("Style configuration for theming the app."), displayMode: Zo.optional().describe("How the UI is currently displayed."), availableDisplayModes: c.array(c.string()).optional().describe("Display modes the host supports."), containerDimensions: c.union([c.object({ height: c.number().describe("Fixed container height in pixels.") }), c.object({ maxHeight: c.union([c.number(), c.undefined()]).optional().describe("Maximum container height in pixels.") })]).and(c.union([c.object({ width: c.number().describe("Fixed container width in pixels.") }), c.object({ maxWidth: c.union([c.number(), c.undefined()]).optional().describe("Maximum container width in pixels.") })])).optional().describe(`Container dimensions. Represents the dimensions of the iframe or other
container holding the app. Specify either width or maxWidth, and either height or maxHeight.`), locale: c.string().optional().describe("User's language and region preference in BCP 47 format."), timeZone: c.string().optional().describe("User's timezone in IANA format."), userAgent: c.string().optional().describe("Host application identifier."), platform: c.union([c.literal("web"), c.literal("desktop"), c.literal("mobile")]).optional().describe("Platform type for responsive design decisions."), deviceCapabilities: c.object({ touch: c.boolean().optional().describe("Whether the device supports touch input."), hover: c.boolean().optional().describe("Whether the device supports hover interactions.") }).optional().describe("Device input capabilities."), safeAreaInsets: c.object({ top: c.number().describe("Top safe area inset in pixels."), right: c.number().describe("Right safe area inset in pixels."), bottom: c.number().describe("Bottom safe area inset in pixels."), left: c.number().describe("Left safe area inset in pixels.") }).optional().describe("Mobile safe area boundaries in pixels.") }).passthrough();
c.object({ method: c.literal("ui/notifications/host-context-changed"), params: tp.describe("Partial context update containing only changed fields.") });
c.object({ method: c.literal("ui/initialize"), params: c.object({ appInfo: gn.describe("App identification (name and version)."), appCapabilities: zk.describe("Features and capabilities this app provides."), protocolVersion: c.string().describe("Protocol version this app supports.") }) });
c.object({ protocolVersion: c.string().describe('Negotiated protocol version string (e.g., "2025-11-21").'), hostInfo: gn.describe("Host application identification and version."), hostCapabilities: xk.describe("Features and capabilities provided by the host."), hostContext: tp.describe("Rich context about the host environment.") }).passthrough();
var Mk = "ui/resourceUri", Ht = "text/html;profile=mcp-app";
const Zk = "mcpui.dev/ui-", Pk = `var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class MCPUIAppsSdkAdapter {
  constructor(config = {}) {
    __publicField(this, "config");
    __publicField(this, "pendingRequests", /* @__PURE__ */ new Map());
    __publicField(this, "messageIdCounter", 0);
    __publicField(this, "originalPostMessage", null);
    this.config = {
      logger: config.logger || console,
      hostOrigin: config.hostOrigin || window.location.origin,
      timeout: config.timeout || 3e4,
      intentHandling: config.intentHandling || "prompt"
    };
  }
  /**
   * Initialize the adapter and monkey-patch postMessage if Apps SDK is present
   */
  install() {
    if (!window.openai) {
      this.config.logger.warn(
        "[MCPUI-Apps SDK Adapter] window.openai not detected. Adapter will not activate."
      );
      return false;
    }
    this.config.logger.log("[MCPUI-Apps SDK Adapter] Initializing adapter...");
    this.patchPostMessage();
    this.setupAppsSdkEventListeners();
    this.sendRenderData();
    this.config.logger.log("[MCPUI-Apps SDK Adapter] Adapter initialized successfully");
    return true;
  }
  /**
   * Clean up pending requests and restore original postMessage
   */
  uninstall() {
    for (const request of this.pendingRequests.values()) {
      clearTimeout(request.timeoutId);
      request.reject(new Error("Adapter uninstalled"));
    }
    this.pendingRequests.clear();
    if (this.originalPostMessage) {
      try {
        const parentWindow = window.parent ?? null;
        if (parentWindow) {
          parentWindow.postMessage = this.originalPostMessage;
        }
        this.config.logger.log("[MCPUI-Apps SDK Adapter] Restored original parent.postMessage");
      } catch (error) {
        this.config.logger.error(
          "[MCPUI-Apps SDK Adapter] Failed to restore original postMessage:",
          error
        );
      }
    }
    this.config.logger.log("[MCPUI-Apps SDK Adapter] Adapter uninstalled");
  }
  /**
   * Monkey-patch parent.postMessage to intercept MCP-UI messages
   * and forward non-MCP-UI messages to the original postMessage
   */
  patchPostMessage() {
    const parentWindow = window.parent ?? null;
    this.originalPostMessage = parentWindow?.postMessage?.bind(parentWindow) ?? null;
    if (!this.originalPostMessage) {
      this.config.logger.debug(
        "[MCPUI-Apps SDK Adapter] parent.postMessage does not exist, installing shim only"
      );
    } else {
      this.config.logger.debug(
        "[MCPUI-Apps SDK Adapter] Monkey-patching parent.postMessage to intercept MCP-UI messages"
      );
    }
    const postMessageInterceptor = (message, targetOriginOrOptions, transfer) => {
      if (this.isMCPUIMessage(message)) {
        const mcpMessage = message;
        this.config.logger.debug(
          "[MCPUI-Apps SDK Adapter] Intercepted MCP-UI message:",
          mcpMessage.type
        );
        this.handleMCPUIMessage(mcpMessage);
      } else {
        if (this.originalPostMessage) {
          this.config.logger.debug(
            "[MCPUI-Apps SDK Adapter] Forwarding non-MCP-UI message to original postMessage"
          );
          if (typeof targetOriginOrOptions === "string" || targetOriginOrOptions === void 0) {
            const targetOrigin = targetOriginOrOptions ?? "*";
            this.originalPostMessage(message, targetOrigin, transfer);
          } else {
            this.originalPostMessage(message, targetOriginOrOptions);
          }
        } else {
          this.config.logger.warn(
            "[MCPUI-Apps SDK Adapter] No original postMessage to forward to, ignoring message:",
            message
          );
        }
      }
    };
    try {
      if (parentWindow) {
        parentWindow.postMessage = postMessageInterceptor;
      }
    } catch (error) {
      this.config.logger.error(
        "[MCPUI-Apps SDK Adapter] Failed to monkey-patch parent.postMessage:",
        error
      );
    }
  }
  /**
   * Check if a message is an MCP-UI protocol message
   */
  isMCPUIMessage(message) {
    if (!message || typeof message !== "object") {
      return false;
    }
    const msg = message;
    return typeof msg.type === "string" && (msg.type.startsWith("ui-") || ["tool", "prompt", "intent", "notify", "link"].includes(msg.type));
  }
  /**
   * Handle incoming MCP-UI messages and translate to Apps SDK actions
   */
  async handleMCPUIMessage(message) {
    this.config.logger.debug("[MCPUI-Apps SDK Adapter] Received MCPUI message:", message.type);
    try {
      switch (message.type) {
        case "tool":
          await this.handleToolMessage(message);
          break;
        case "prompt":
          await this.handlePromptMessage(message);
          break;
        case "intent":
          await this.handleIntentMessage(message);
          break;
        case "notify":
          await this.handleNotifyMessage(message);
          break;
        case "link":
          await this.handleLinkMessage(message);
          break;
        case "ui-lifecycle-iframe-ready":
          this.sendRenderData();
          break;
        case "ui-request-render-data":
          this.sendRenderData(message.messageId);
          break;
        case "ui-size-change":
          this.handleSizeChange(message);
          break;
        case "ui-request-data":
          this.handleRequestData(message);
          break;
        default:
          this.config.logger.warn("[MCPUI-Apps SDK Adapter] Unknown message type:", message.type);
      }
    } catch (error) {
      this.config.logger.error("[MCPUI-Apps SDK Adapter] Error handling message:", error);
      if (message.messageId) {
        this.sendErrorResponse(message.messageId, error);
      }
    }
  }
  /**
   * Handle 'tool' message - call Apps SDK tool
   */
  async handleToolMessage(message) {
    if (message.type !== "tool")
      return;
    const { toolName, params } = message.payload;
    const messageId = message.messageId || this.generateMessageId();
    this.sendAcknowledgment(messageId);
    try {
      if (!window.openai?.callTool) {
        throw new Error("Tool calling is not supported in this environment");
      }
      const result = await this.withTimeout(window.openai.callTool(toolName, params), messageId);
      this.sendSuccessResponse(messageId, result);
    } catch (error) {
      this.sendErrorResponse(messageId, error);
    }
  }
  /**
   * Handle 'prompt' message - send followup turn
   */
  async handlePromptMessage(message) {
    if (message.type !== "prompt")
      return;
    const prompt = message.payload.prompt;
    const messageId = message.messageId || this.generateMessageId();
    this.sendAcknowledgment(messageId);
    try {
      if (!window.openai?.sendFollowUpMessage) {
        throw new Error("Followup turns are not supported in this environment");
      }
      await this.withTimeout(window.openai.sendFollowUpMessage({ prompt }), messageId);
      this.sendSuccessResponse(messageId, { success: true });
    } catch (error) {
      this.sendErrorResponse(messageId, error);
    }
  }
  /**
   * Handle 'intent' message - convert to prompt or ignore based on config
   */
  async handleIntentMessage(message) {
    if (message.type !== "intent")
      return;
    const messageId = message.messageId || this.generateMessageId();
    this.sendAcknowledgment(messageId);
    if (this.config.intentHandling === "ignore") {
      this.config.logger.log("[MCPUI-Apps SDK Adapter] Intent ignored:", message.payload.intent);
      this.sendSuccessResponse(messageId, { ignored: true });
      return;
    }
    const { intent, params } = message.payload;
    const prompt = \`\${intent}\${params ? \`: \${JSON.stringify(params)}\` : ""}\`;
    try {
      if (!window.openai?.sendFollowUpMessage) {
        throw new Error("Followup turns are not supported in this environment");
      }
      await this.withTimeout(window.openai.sendFollowUpMessage({ prompt }), messageId);
      this.sendSuccessResponse(messageId, { success: true });
    } catch (error) {
      this.sendErrorResponse(messageId, error);
    }
  }
  /**
   * Handle 'notify' message - log only
   */
  async handleNotifyMessage(message) {
    if (message.type !== "notify")
      return;
    const messageId = message.messageId || this.generateMessageId();
    this.config.logger.log("[MCPUI-Apps SDK Adapter] Notification:", message.payload.message);
    this.sendAcknowledgment(messageId);
    this.sendSuccessResponse(messageId, { acknowledged: true });
  }
  /**
   * Handle 'link' message - not supported in Apps SDK environments
   */
  async handleLinkMessage(message) {
    if (message.type !== "link")
      return;
    const messageId = message.messageId || this.generateMessageId();
    this.sendAcknowledgment(messageId);
    this.sendErrorResponse(
      messageId,
      new Error("Navigation is not supported in Apps SDK environment")
    );
  }
  /**
   * Handle size change - no-op in Apps SDK environment
   */
  handleSizeChange(message) {
    this.config.logger.debug(
      "[MCPUI-Apps SDK Adapter] Size change requested (no-op in Apps SDK):",
      message.payload
    );
  }
  /**
   * Handle generic data request
   */
  handleRequestData(message) {
    const messageId = message.messageId || this.generateMessageId();
    this.sendAcknowledgment(messageId);
    this.sendErrorResponse(messageId, new Error("Generic data requests not yet implemented"));
  }
  /**
   * Setup listeners for Apps SDK events
   */
  setupAppsSdkEventListeners() {
    window.addEventListener("openai:set_globals", () => {
      this.config.logger.debug("[MCPUI-Apps SDK Adapter] Globals updated");
      this.sendRenderData();
    });
  }
  /**
   * Gather render data from Apps SDK and send to widget
   */
  sendRenderData(requestMessageId) {
    if (!window.openai)
      return;
    const renderData = {
      toolInput: window.openai.toolInput,
      toolOutput: window.openai.toolOutput,
      widgetState: window.openai.widgetState,
      locale: window.openai.locale || "en-US",
      theme: window.openai.theme || "light",
      displayMode: window.openai.displayMode || "inline",
      maxHeight: window.openai.maxHeight
    };
    this.dispatchMessageToIframe({
      type: "ui-lifecycle-iframe-render-data",
      messageId: requestMessageId,
      payload: { renderData }
    });
  }
  /**
   * Send acknowledgment for a message
   */
  sendAcknowledgment(messageId) {
    this.dispatchMessageToIframe({
      type: "ui-message-received",
      payload: { messageId }
    });
  }
  /**
   * Send success response
   */
  sendSuccessResponse(messageId, response) {
    this.dispatchMessageToIframe({
      type: "ui-message-response",
      payload: { messageId, response }
    });
  }
  /**
   * Send error response
   */
  sendErrorResponse(messageId, error) {
    const errorObj = error instanceof Error ? { message: error.message, name: error.name } : { message: String(error) };
    this.dispatchMessageToIframe({
      type: "ui-message-response",
      payload: { messageId, error: errorObj }
    });
  }
  /**
   * Dispatch a MessageEvent to the iframe (widget)
   * Simulates messages that would normally come from the parent/host
   */
  dispatchMessageToIframe(data) {
    const event = new MessageEvent("message", {
      data,
      origin: this.config.hostOrigin,
      source: null
    });
    window.dispatchEvent(event);
  }
  /**
   * Wrap a promise with timeout
   */
  async withTimeout(promise, requestId) {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        this.pendingRequests.delete(requestId);
        reject(new Error(\`Request timed out after \${this.config.timeout}ms\`));
      }, this.config.timeout);
      this.pendingRequests.set(requestId, {
        messageId: requestId,
        type: "generic",
        resolve,
        reject,
        timeoutId
      });
      promise.then((result) => {
        clearTimeout(timeoutId);
        this.pendingRequests.delete(requestId);
        resolve(result);
      }).catch((error) => {
        clearTimeout(timeoutId);
        this.pendingRequests.delete(requestId);
        reject(error);
      });
    });
  }
  /**
   * Generate a unique message ID
   */
  generateMessageId() {
    return \`adapter-\${Date.now()}-\${++this.messageIdCounter}\`;
  }
}
let adapterInstance = null;
function initAdapter(config) {
  if (adapterInstance) {
    console.warn("[MCPUI-Apps SDK Adapter] Adapter already initialized");
    return true;
  }
  adapterInstance = new MCPUIAppsSdkAdapter(config);
  return adapterInstance.install();
}
function uninstallAdapter() {
  if (adapterInstance) {
    adapterInstance.uninstall();
    adapterInstance = null;
  }
}
`;
function Ek(e) {
  const t = e ? JSON.stringify(e) : "{}";
  return `
<script>
(function() {
  'use strict';
  
  ${Pk}
  
  // Override auto-init from runtime and initialize with provided config
  if (typeof window !== 'undefined') {
    // If the functions are not defined, just return, we can't do anything.
    if (typeof initAdapter !== 'function' || typeof uninstallAdapter !== 'function') {
      console.warn('[MCPUI-Apps SDK Adapter] Adapter runtime not found with the correct methods. Adapter will not activate.')    
      return;
    }
    
    // If auto-init is enabled, initialize with config from server 
    if (!window.MCP_APPSSDK_ADAPTER_NO_AUTO_INSTALL) {
      initAdapter(${t});
    }
    
    // Expose functions globally
    if (typeof window.MCPUIAppsSdkAdapter === 'undefined') {
      window.MCPUIAppsSdkAdapter = {
        init: initAdapter,
        initWithConfig: () => initAdapter(${t}),
        uninstall: uninstallAdapter,
      };
    }
  }
})();
<\/script>
`.trim();
}
const Nk = `var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const LATEST_PROTOCOL_VERSION = "2025-11-21";
const METHODS = {
  // Lifecycle
  INITIALIZE: "ui/initialize",
  INITIALIZED: "ui/notifications/initialized",
  // Tool data (Host -> Guest)
  TOOL_INPUT: "ui/notifications/tool-input",
  TOOL_INPUT_PARTIAL: "ui/notifications/tool-input-partial",
  TOOL_RESULT: "ui/notifications/tool-result",
  TOOL_CANCELLED: "ui/notifications/tool-cancelled",
  // Context & UI
  HOST_CONTEXT_CHANGED: "ui/notifications/host-context-changed",
  SIZE_CHANGED: "ui/notifications/size-changed",
  RESOURCE_TEARDOWN: "ui/resource-teardown",
  // Standard MCP methods
  TOOLS_CALL: "tools/call",
  NOTIFICATIONS_MESSAGE: "notifications/message",
  OPEN_LINK: "ui/open-link",
  MESSAGE: "ui/message"
};
class McpAppsAdapter {
  constructor(config = {}) {
    __publicField(this, "config");
    __publicField(this, "pendingRequests", /* @__PURE__ */ new Map());
    __publicField(this, "messageIdCounter", 0);
    __publicField(this, "originalPostMessage", null);
    __publicField(this, "parentWindow", null);
    __publicField(this, "hostCapabilities", null);
    __publicField(this, "hostContext", null);
    __publicField(this, "initialized", false);
    // Current render data state (similar to window.openai in Apps SDK)
    __publicField(this, "currentRenderData", {});
    this.config = {
      logger: config.logger || console,
      timeout: config.timeout || 3e4
    };
  }
  install() {
    this.parentWindow = window.parent;
    this.config.logger.log("[MCP Apps Adapter] Checking parent window...");
    this.config.logger.log("[MCP Apps Adapter] window.parent exists:", !!this.parentWindow);
    this.config.logger.log(
      "[MCP Apps Adapter] window.parent === window:",
      this.parentWindow === window
    );
    if (!this.parentWindow || this.parentWindow === window) {
      this.config.logger.warn(
        "[MCP Apps Adapter] No parent window detected. Adapter will not activate."
      );
      return false;
    }
    this.config.logger.log("[MCP Apps Adapter] Initializing adapter...");
    this.patchPostMessage();
    window.addEventListener("message", this.handleHostMessage.bind(this));
    this.performInitialization();
    this.config.logger.log("[MCP Apps Adapter] Adapter initialized successfully");
    return true;
  }
  /**
   * Performs the MCP Apps SEP initialization handshake:
   * 1. Send ui/initialize request with adapter info
   * 2. Receive host capabilities and context
   * 3. Send ui/notifications/initialized notification
   * 4. Dispatch ready event to MCP-UI app
   */
  async performInitialization() {
    const jsonRpcId = this.generateJsonRpcId();
    const initPromise = new Promise((resolve, reject) => {
      this.pendingRequests.set(String(jsonRpcId), {
        messageId: "init",
        type: "init",
        resolve: (result) => {
          const res = result;
          this.hostCapabilities = res?.hostCapabilities ?? null;
          this.hostContext = res?.hostContext ?? null;
          this.initialized = true;
          this.sendJsonRpcNotification(METHODS.INITIALIZED, {});
          if (this.hostContext) {
            if (this.hostContext.theme)
              this.currentRenderData.theme = this.hostContext.theme;
            if (this.hostContext.displayMode)
              this.currentRenderData.displayMode = this.hostContext.displayMode;
            if (this.hostContext.locale)
              this.currentRenderData.locale = this.hostContext.locale;
            const dims = this.hostContext.containerDimensions;
            if (dims && "maxHeight" in dims && dims.maxHeight !== void 0)
              this.currentRenderData.maxHeight = dims.maxHeight;
          }
          this.sendRenderData();
          this.dispatchMessageToIframe({
            type: "ui-lifecycle-iframe-ready"
          });
          resolve();
        },
        reject: (error) => {
          this.config.logger.error("[MCP Apps Adapter] Initialization failed:", error);
          reject(error);
        },
        timeoutId: setTimeout(() => {
          this.pendingRequests.delete(String(jsonRpcId));
          this.config.logger.warn("[MCP Apps Adapter] Initialization timed out, proceeding anyway");
          this.dispatchMessageToIframe({
            type: "ui-lifecycle-iframe-ready"
          });
          resolve();
        }, this.config.timeout)
      });
    });
    this.config.logger.log("[MCP Apps Adapter] Sending ui/initialize request with id:", jsonRpcId);
    this.sendJsonRpcRequest(jsonRpcId, METHODS.INITIALIZE, {
      appInfo: {
        name: "mcp-ui-adapter",
        version: "1.0.0"
      },
      appCapabilities: {},
      protocolVersion: LATEST_PROTOCOL_VERSION
    });
    this.config.logger.log("[MCP Apps Adapter] ui/initialize request sent");
    try {
      await initPromise;
    } catch (_error) {
      this.config.logger.warn("[MCP Apps Adapter] Continuing despite initialization error");
    }
  }
  uninstall() {
    for (const request of this.pendingRequests.values()) {
      clearTimeout(request.timeoutId);
      request.reject(new Error("Adapter uninstalled"));
    }
    this.pendingRequests.clear();
    if (this.originalPostMessage && this.parentWindow) {
      try {
        this.parentWindow.postMessage = this.originalPostMessage;
        this.config.logger.log("[MCP Apps Adapter] Restored original parent.postMessage");
      } catch (error) {
        this.config.logger.error(
          "[MCP Apps Adapter] Failed to restore original postMessage:",
          error
        );
      }
    }
    window.removeEventListener("message", this.handleHostMessage.bind(this));
    this.config.logger.log("[MCP Apps Adapter] Adapter uninstalled");
  }
  patchPostMessage() {
    this.originalPostMessage = this.parentWindow?.postMessage.bind(this.parentWindow) ?? null;
    const postMessageInterceptor = (message, targetOriginOrOptions, transfer) => {
      if (this.isMCPUIMessage(message)) {
        const mcpMessage = message;
        this.config.logger.debug("[MCP Apps Adapter] Intercepted MCP-UI message:", mcpMessage.type);
        this.handleMCPUIMessage(mcpMessage);
      } else {
        if (this.originalPostMessage) {
          if (typeof targetOriginOrOptions === "string" || targetOriginOrOptions === void 0) {
            const targetOrigin = targetOriginOrOptions ?? "*";
            this.originalPostMessage(message, targetOrigin, transfer);
          } else {
            this.originalPostMessage(message, targetOriginOrOptions);
          }
        }
      }
    };
    try {
      if (this.parentWindow) {
        this.parentWindow.postMessage = postMessageInterceptor;
      }
    } catch (error) {
      this.config.logger.error(
        "[MCP Apps Adapter] Failed to monkey-patch parent.postMessage:",
        error
      );
    }
  }
  isMCPUIMessage(message) {
    if (!message || typeof message !== "object") {
      return false;
    }
    const msg = message;
    return typeof msg.type === "string" && (msg.type.startsWith("ui-") || ["tool", "prompt", "intent", "notify", "link"].includes(msg.type));
  }
  /**
   * Handles messages coming from the Host (JSON-RPC) and translates them to MCP-UI messages
   *
   * MCP Apps SEP protocol methods (from @modelcontextprotocol/ext-apps):
   * - ui/notifications/tool-input: Complete tool arguments
   * - ui/notifications/tool-input-partial: Streaming partial tool arguments
   * - ui/notifications/tool-result: Tool execution results
   * - ui/notifications/host-context-changed: Theme, viewport, locale changes
   * - ui/notifications/size-changed: Size change notifications (bidirectional)
   * - ui/notifications/tool-cancelled: Tool execution was cancelled
   * - ui/resource-teardown: Host notifies UI before teardown (request)
   */
  handleHostMessage(event) {
    const data = event.data;
    if (!data || typeof data !== "object" || !data.jsonrpc) {
      return;
    }
    this.config.logger.debug("[MCP Apps Adapter] Received JSON-RPC message:", data);
    if (data.method) {
      switch (data.method) {
        case METHODS.TOOL_INPUT:
          this.currentRenderData.toolInput = data.params?.arguments;
          this.sendRenderData();
          break;
        case METHODS.TOOL_INPUT_PARTIAL:
          this.currentRenderData.toolInput = data.params?.arguments;
          this.sendRenderData();
          break;
        case METHODS.TOOL_RESULT:
          this.currentRenderData.toolOutput = data.params;
          this.sendRenderData();
          break;
        case METHODS.HOST_CONTEXT_CHANGED: {
          if (data.params?.theme)
            this.currentRenderData.theme = data.params.theme;
          if (data.params?.displayMode)
            this.currentRenderData.displayMode = data.params.displayMode;
          if (data.params?.locale)
            this.currentRenderData.locale = data.params.locale;
          const contextDims = data.params?.containerDimensions;
          if (contextDims && "maxHeight" in contextDims && contextDims.maxHeight !== void 0)
            this.currentRenderData.maxHeight = contextDims.maxHeight;
          this.sendRenderData();
          break;
        }
        case METHODS.SIZE_CHANGED:
          if (data.params?.height)
            this.currentRenderData.maxHeight = data.params.height;
          this.sendRenderData();
          break;
        case METHODS.TOOL_CANCELLED:
          this.dispatchMessageToIframe({
            type: "ui-lifecycle-tool-cancelled",
            payload: {
              reason: data.params?.reason
            }
          });
          break;
        case METHODS.RESOURCE_TEARDOWN:
          this.dispatchMessageToIframe({
            type: "ui-lifecycle-teardown",
            payload: {
              reason: data.params?.reason
            }
          });
          if (data.id) {
            this.sendJsonRpcResponse(data.id, {});
          }
          break;
      }
    } else if (data.id) {
      const pendingRequest = this.pendingRequests.get(String(data.id));
      if (pendingRequest) {
        if (data.error) {
          pendingRequest.reject(new Error(data.error.message));
        } else {
          pendingRequest.resolve(data.result);
        }
        this.pendingRequests.delete(String(data.id));
        clearTimeout(pendingRequest.timeoutId);
        this.dispatchMessageToIframe({
          type: "ui-message-response",
          messageId: pendingRequest.messageId,
          // The original message ID from the App
          payload: {
            messageId: pendingRequest.messageId,
            response: data.result,
            error: data.error
          }
        });
      }
    }
  }
  /**
   * Handles messages coming from the App (MCP-UI) and translates them to Host (JSON-RPC)
   *
   * MCP-UI message types translated to MCP Apps SEP:
   * - 'tool' -> tools/call request
   * - 'ui-size-change' -> ui/notifications/size-changed notification
   * - 'notify' -> notifications/message notification (logging)
   * - 'link' -> ui/open-link request
   * - 'prompt' -> ui/message request
   * - 'ui-lifecycle-iframe-ready' -> ui/notifications/initialized notification
   */
  async handleMCPUIMessage(message) {
    const messageId = message.messageId || this.generateMessageId();
    this.dispatchMessageToIframe({
      type: "ui-message-received",
      payload: { messageId }
    });
    try {
      switch (message.type) {
        case "tool": {
          const { toolName, params } = message.payload;
          const jsonRpcId = this.generateJsonRpcId();
          this.pendingRequests.set(String(jsonRpcId), {
            messageId,
            type: "tool",
            resolve: () => {
            },
            // Handled in handleHostMessage
            reject: () => {
            },
            timeoutId: setTimeout(() => {
              this.pendingRequests.delete(String(jsonRpcId));
              this.dispatchMessageToIframe({
                type: "ui-message-response",
                messageId,
                payload: { messageId, error: "Timeout" }
              });
            }, this.config.timeout)
          });
          this.sendJsonRpcRequest(jsonRpcId, METHODS.TOOLS_CALL, {
            name: toolName,
            arguments: params
          });
          break;
        }
        case "ui-size-change": {
          const { width, height } = message.payload;
          this.sendJsonRpcNotification(METHODS.SIZE_CHANGED, { width, height });
          break;
        }
        case "notify": {
          const { message: msg } = message.payload;
          this.sendJsonRpcNotification(METHODS.NOTIFICATIONS_MESSAGE, {
            level: "info",
            data: msg
          });
          break;
        }
        case "link": {
          const { url } = message.payload;
          const jsonRpcId = this.generateJsonRpcId();
          this.pendingRequests.set(String(jsonRpcId), {
            messageId,
            type: "link",
            resolve: () => {
            },
            reject: () => {
            },
            timeoutId: setTimeout(() => {
              this.pendingRequests.delete(String(jsonRpcId));
              this.dispatchMessageToIframe({
                type: "ui-message-response",
                messageId,
                payload: { messageId, error: "Timeout" }
              });
            }, this.config.timeout)
          });
          this.sendJsonRpcRequest(jsonRpcId, METHODS.OPEN_LINK, { url });
          break;
        }
        case "prompt": {
          const { prompt } = message.payload;
          const jsonRpcId = this.generateJsonRpcId();
          this.pendingRequests.set(String(jsonRpcId), {
            messageId,
            type: "prompt",
            resolve: () => {
            },
            reject: () => {
            },
            timeoutId: setTimeout(() => {
              this.pendingRequests.delete(String(jsonRpcId));
              this.dispatchMessageToIframe({
                type: "ui-message-response",
                messageId,
                payload: { messageId, error: "Timeout" }
              });
            }, this.config.timeout)
          });
          this.sendJsonRpcRequest(jsonRpcId, METHODS.MESSAGE, {
            role: "user",
            content: [{ type: "text", text: prompt }]
          });
          break;
        }
        case "ui-lifecycle-iframe-ready": {
          this.sendJsonRpcNotification(METHODS.INITIALIZED, {});
          this.sendRenderData();
          break;
        }
        case "ui-request-render-data": {
          this.sendRenderData(messageId);
          break;
        }
        case "intent": {
          const { intent, params } = message.payload;
          const jsonRpcId = this.generateJsonRpcId();
          this.pendingRequests.set(String(jsonRpcId), {
            messageId,
            type: "intent",
            resolve: () => {
            },
            reject: () => {
            },
            timeoutId: setTimeout(() => {
              this.pendingRequests.delete(String(jsonRpcId));
              this.dispatchMessageToIframe({
                type: "ui-message-response",
                messageId,
                payload: { messageId, error: "Timeout" }
              });
            }, this.config.timeout)
          });
          this.sendJsonRpcRequest(jsonRpcId, METHODS.MESSAGE, {
            role: "user",
            content: [
              { type: "text", text: \`Intent: \${intent}. Parameters: \${JSON.stringify(params)}\` }
            ]
          });
          break;
        }
      }
    } catch (error) {
      this.config.logger.error("[MCP Apps Adapter] Error handling message:", error);
      this.dispatchMessageToIframe({
        type: "ui-message-response",
        messageId,
        payload: { messageId, error }
      });
    }
  }
  /**
   * Send current render data to the MCP-UI app
   * This mirrors the Apps SDK adapter's sendRenderData method
   */
  sendRenderData(requestMessageId) {
    this.dispatchMessageToIframe({
      type: "ui-lifecycle-iframe-render-data",
      messageId: requestMessageId,
      payload: {
        renderData: {
          toolInput: this.currentRenderData.toolInput,
          toolOutput: this.currentRenderData.toolOutput,
          widgetState: this.currentRenderData.widgetState,
          locale: this.currentRenderData.locale,
          theme: this.currentRenderData.theme,
          displayMode: this.currentRenderData.displayMode,
          maxHeight: this.currentRenderData.maxHeight
        }
      }
    });
  }
  sendJsonRpcRequest(id, method, params) {
    this.originalPostMessage?.(
      {
        jsonrpc: "2.0",
        id,
        method,
        params
      },
      "*"
    );
  }
  sendJsonRpcResponse(id, result) {
    this.originalPostMessage?.(
      {
        jsonrpc: "2.0",
        id,
        result
      },
      "*"
    );
  }
  sendJsonRpcNotification(method, params) {
    this.originalPostMessage?.(
      {
        jsonrpc: "2.0",
        method,
        params
      },
      "*"
    );
  }
  dispatchMessageToIframe(data) {
    const event = new MessageEvent("message", {
      data,
      origin: window.location.origin,
      // Same origin since we are inside the iframe
      source: window
    });
    window.dispatchEvent(event);
  }
  generateMessageId() {
    return \`adapter-\${Date.now()}-\${++this.messageIdCounter}\`;
  }
  generateJsonRpcId() {
    return ++this.messageIdCounter;
  }
}
let adapterInstance = null;
function initAdapter(config) {
  if (adapterInstance) {
    console.warn("[MCP Apps Adapter] Adapter already initialized");
    return true;
  }
  adapterInstance = new McpAppsAdapter(config);
  return adapterInstance.install();
}
function uninstallAdapter() {
  if (adapterInstance) {
    adapterInstance.uninstall();
    adapterInstance = null;
  }
}
`;
function Dk(e) {
  const t = e ? {
    timeout: e.timeout
  } : {}, i = JSON.stringify(t);
  return `
<script>
(function() {
  'use strict';
  
  ${Nk}
  
  if (typeof window !== 'undefined') {
    if (typeof initAdapter !== 'function' || typeof uninstallAdapter !== 'function') {
      console.warn('[MCP Apps Adapter] Adapter runtime not found. Adapter will not activate.');
      return;
    }
    
    if (!window.MCP_APPS_ADAPTER_NO_AUTO_INSTALL) {
      initAdapter(${i});
    }
    
    window.McpAppsAdapter = {
      init: initAdapter,
      initWithConfig: () => initAdapter(${i}),
      uninstall: uninstallAdapter,
    };
  }
})();
<\/script>
`.trim();
}
function ga(e) {
  const t = { ...e.resourceProps ?? {} };
  if (e.uiMetadata || e.metadata) {
    const i = Object.fromEntries(
      Object.entries(e.uiMetadata ?? {}).map(([o, n]) => [
        `${Zk}${o}`,
        n
      ])
    );
    t._meta = {
      ...i,
      ...e.metadata ?? {},
      ...t._meta ?? {}
    };
  }
  return t;
}
function jk(e) {
  if (typeof Buffer < "u")
    return Buffer.from(e, "utf-8").toString("base64");
  if (typeof TextEncoder < "u" && typeof btoa < "u") {
    const i = new TextEncoder().encode(e);
    let o = "";
    const n = 8192;
    for (let r = 0; r < i.length; r += n)
      o += String.fromCharCode(...i.slice(r, r + n));
    return btoa(o);
  } else {
    console.warn(
      "MCP-UI SDK: Buffer API and TextEncoder/btoa not available. Base64 encoding might not be UTF-8 safe."
    );
    try {
      return btoa(e);
    } catch {
      throw new Error(
        "MCP-UI SDK: Suitable UTF-8 to Base64 encoding method not found, and fallback btoa failed."
      );
    }
  }
}
function Tk(e) {
  if (e) {
    if (e.appsSdk?.enabled)
      return e.appsSdk.mimeType ?? "text/html+skybridge";
    if (e.mcpApps?.enabled)
      return Ht;
  }
}
function Ak(e, t) {
  if (!t)
    return e;
  const i = [];
  if (t.appsSdk?.enabled) {
    const r = Ek(t.appsSdk.config);
    i.push(r);
  }
  if (t.mcpApps?.enabled) {
    const r = Dk(t.mcpApps.config);
    i.push(r);
  }
  if (i.length === 0)
    return e;
  const o = i.join(`
`);
  let n;
  return e.includes("<head>") ? n = e.replace("<head>", `<head>
${o}`) : e.includes("<html>") ? n = e.replace("<html>", `<html>
<head>
${o}
</head>`) : n = `${o}
${e}`, n;
}
function Lk(e) {
  let t, i;
  if (e.content.type === "rawHtml") {
    if (!e.uri.startsWith("ui://"))
      throw new Error("MCP-UI SDK: URI must start with 'ui://' when content.type is 'rawHtml'.");
    if (t = e.content.htmlString, typeof t != "string")
      throw new Error(
        "MCP-UI SDK: content.htmlString must be provided as a string when content.type is 'rawHtml'."
      );
    e.adapters ? (t = Ak(t, e.adapters), i = Tk(e.adapters) ?? Ht) : i = Ht;
  } else if (e.content.type === "externalUrl") {
    if (!e.uri.startsWith("ui://"))
      throw new Error(
        "MCP-UI SDK: URI must start with 'ui://' when content.type is 'externalUrl'."
      );
    const n = e.content.iframeUrl;
    if (typeof n != "string")
      throw new Error(
        "MCP-UI SDK: content.iframeUrl must be provided as a string when content.type is 'externalUrl'."
      );
    t = n, i = Ht;
  } else {
    const n = e.content;
    throw new Error(`MCP-UI SDK: Invalid content.type specified: ${n}`);
  }
  let o;
  switch (e.encoding) {
    case "text":
      o = {
        uri: e.uri,
        mimeType: i,
        text: t,
        ...ga(e)
      };
      break;
    case "blob":
      o = {
        uri: e.uri,
        mimeType: i,
        blob: jk(t),
        ...ga(e)
      };
      break;
    default: {
      const n = e.encoding;
      throw new Error(`MCP-UI SDK: Invalid encoding type: ${n}`);
    }
  }
  return {
    type: "resource",
    resource: o,
    ...e.embeddedResourceProps ?? {}
  };
}
function Fk(e) {
  window.parent && window.parent.postMessage(e, "*");
}
const Jk = {
  UI_MESSAGE_RECEIVED: "ui-message-received",
  UI_MESSAGE_RESPONSE: "ui-message-response",
  UI_SIZE_CHANGE: "ui-size-change",
  UI_LIFECYCLE_IFRAME_READY: "ui-lifecycle-iframe-ready",
  UI_LIFECYCLE_IFRAME_RENDER_DATA: "ui-lifecycle-iframe-render-data",
  UI_RAWHTML_CONTENT: "ui-html-content"
}, qk = {
  WAIT_FOR_RENDER_DATA: "waitForRenderData"
};
function Wk(e, t) {
  return {
    type: "tool",
    payload: {
      toolName: e,
      params: t
    }
  };
}
function Kk(e) {
  return {
    type: "prompt",
    payload: {
      prompt: e
    }
  };
}
function Vk(e) {
  return {
    type: "link",
    payload: {
      url: e
    }
  };
}
function Gk(e, t) {
  return {
    type: "intent",
    payload: {
      intent: e,
      params: t
    }
  };
}
function Bk(e) {
  return {
    type: "notify",
    payload: {
      message: e
    }
  };
}
let Rk = 0;
const Ck = 3e4;
function Hk(e, t, i) {
  if (window.parent === window)
    return Promise.reject(
      new Error("sendExperimentalRequest must be called from within an iframe")
    );
  const o = ++Rk, n = i?.timeoutMs ?? Ck;
  return new Promise((r, a) => {
    let s;
    const u = () => {
      window.removeEventListener("message", l), s !== void 0 && clearTimeout(s), i?.signal?.removeEventListener("abort", d);
    }, l = (p) => {
      if (p.source !== window.parent) return;
      const g = p.data;
      g?.jsonrpc === "2.0" && g?.id === o && (u(), g.error ? a(g.error) : r(g.result));
    }, d = () => {
      u(), a(new Error(`Experimental request "${e}" was aborted`));
    };
    if (i?.signal?.aborted) {
      a(new Error(`Experimental request "${e}" was aborted`));
      return;
    }
    i?.signal?.addEventListener("abort", d), window.addEventListener("message", l), n > 0 && (s = setTimeout(() => {
      u(), a(new Error(`Experimental request "${e}" timed out after ${n}ms`));
    }, n)), window.parent.postMessage(
      {
        jsonrpc: "2.0",
        id: o,
        method: e,
        ...t !== void 0 && { params: t }
      },
      "*"
    );
  });
}
export {
  Jk as InternalMessageType,
  Ht as RESOURCE_MIME_TYPE,
  Mk as RESOURCE_URI_META_KEY,
  qk as ReservedUrlParams,
  Lk as createUIResource,
  Tk as getAdapterMimeType,
  Ek as getAppsSdkAdapterScript,
  Dk as getMcpAppsAdapterScript,
  Fk as postUIActionResult,
  Hk as sendExperimentalRequest,
  Gk as uiActionResultIntent,
  Vk as uiActionResultLink,
  Bk as uiActionResultNotification,
  Kk as uiActionResultPrompt,
  Wk as uiActionResultToolCall,
  Ak as wrapHtmlWithAdapters
};
//# sourceMappingURL=index.mjs.map
