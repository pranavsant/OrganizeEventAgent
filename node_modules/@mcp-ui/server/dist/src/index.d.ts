import { Base64BlobContent, CreateUIResourceOptions, HTMLTextContent, UIActionResult, UIActionResultLink, UIActionResultNotification, UIActionResultPrompt, UIActionResultIntent, UIActionResultToolCall } from './types.js';

export type UIResource = {
    type: 'resource';
    resource: HTMLTextContent | Base64BlobContent;
    annotations?: Record<string, unknown>;
    _meta?: Record<string, unknown>;
};
/**
 * Creates a UIResource.
 * This is the object that should be included in the 'content' array of a toolResult.
 *
 * @param options Configuration for the interactive resource.
 * @returns a UIResource
 */
export declare function createUIResource(options: CreateUIResourceOptions): UIResource;
export type { CreateUIResourceOptions, ResourceContentPayload, UIActionResult, AdaptersConfig, AppsSdkAdapterOptions, } from './types.js';
export { RESOURCE_URI_META_KEY, RESOURCE_MIME_TYPE } from './types.js';
export { wrapHtmlWithAdapters, getAdapterMimeType } from './utils.js';
export * from './adapters/index.js';
export declare function postUIActionResult(result: UIActionResult): void;
export declare const InternalMessageType: {
    UI_MESSAGE_RECEIVED: string;
    UI_MESSAGE_RESPONSE: string;
    UI_SIZE_CHANGE: string;
    UI_LIFECYCLE_IFRAME_READY: string;
    UI_LIFECYCLE_IFRAME_RENDER_DATA: string;
    UI_RAWHTML_CONTENT: string;
};
export declare const ReservedUrlParams: {
    readonly WAIT_FOR_RENDER_DATA: "waitForRenderData";
};
export declare function uiActionResultToolCall(toolName: string, params: Record<string, unknown>): UIActionResultToolCall;
export declare function uiActionResultPrompt(prompt: string): UIActionResultPrompt;
export declare function uiActionResultLink(url: string): UIActionResultLink;
export declare function uiActionResultIntent(intent: string, params: Record<string, unknown>): UIActionResultIntent;
export declare function uiActionResultNotification(message: string): UIActionResultNotification;
/**
 * Send an experimental JSON-RPC request to the host from inside a guest UI iframe.
 *
 * The host must have an `onFallbackRequest` handler registered on AppRenderer.
 * The request flows through PostMessageTransport and AppBridge's fallbackRequestHandler.
 *
 * @param method - JSON-RPC method name. Convention: use "x/<namespace>/<action>" for
 *   experimental methods (e.g., "x/clipboard/write"). Standard MCP methods not yet
 *   in the Apps spec (e.g., "sampling/createMessage") can use their canonical names.
 * @param params - Request parameters
 * @param options - Optional configuration
 * @param options.signal - AbortSignal to cancel the request
 * @param options.timeoutMs - Timeout in milliseconds (default: 30000). Set to 0 to disable.
 * @returns Promise that resolves with the host's JSON-RPC response result, or rejects
 *   with the JSON-RPC error
 *
 * @example
 * ```ts
 * const result = await sendExperimentalRequest('x/clipboard/write', { text: 'hello' });
 * ```
 */
export declare function sendExperimentalRequest(method: string, params?: Record<string, unknown>, options?: {
    signal?: AbortSignal;
    timeoutMs?: number;
}): Promise<unknown>;
//# sourceMappingURL=index.d.ts.map